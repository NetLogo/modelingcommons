name,path,source,information
Fireworks,/models/Sample Models/Art,"turtles-own [col               ;sets color of an explosion particle
             x-vel             ;x-velocity
             y-vel             ;y-velocity
            ]
breed [ rockets rocket ]
breed [ frags frag ]
rockets-own [ terminal-y-vel ] ;velocity at which rocket will explode
frags-own [ dim ]              ;used for fading particles

;SETUP
;-----
;This function clears all patches and turtles.

to setup
  clear-all
  set-default-shape turtles ""circle""
end


;GO
;--
;This function executes the model.  If there are no turtles, then it creates a random number
;according to the slider FIREWORKS and sets all the initial values for each firework.
;It then calls PROJECTILE-MOTION, which launches and explodes the fireworks.

to go
  if not any? turtles
  [
    ifelse trails?      ;;used so that the trails don't immediately disappear
      [wait 1]
      [wait .3]
    clear-drawing

    create-rockets (random fireworks)
    [
      setxy random-xcor min-pycor
      set x-vel ((random-float (2 * initial-x-vel)) - (initial-x-vel))
      set y-vel ((random-float initial-y-vel) + initial-y-vel * 2 )
      set col ((random 14) + 1) * 10 - 5    ;; reports a random 'primary' color   i.e. 5, 15, 25, etc.
      set color (col + 2)
      set size 2
      set terminal-y-vel (random-float 4.0)     ;; at what speed does the rocket explode?
    ]
  ]
  ;we don't want the model to run too quickly because otherwise, you wouldn't be able to see the fireworks
  every 0.03
  [
    ask turtles
      [ projectile-motion ]
    display
  ]
  if not any? turtles
    [ tick ]
end


;PROJECTILE-MOTION
;-----------------
;This function simulates the actual free-fall motion of the turtles.
;If a turtle is a rocket it checks if it has slowed down enough to explode.

to projectile-motion               ;; turtle procedure
  set y-vel (y-vel - (gravity / 5))
  set heading (atan x-vel y-vel)
  let move-amount (sqrt ((x-vel ^ 2) + (y-vel ^ 2)))
  if not can-move? move-amount
    [ die ]
  fd (sqrt ((x-vel ^ 2) + (y-vel ^ 2)))

  ifelse (breed = rockets)
    [if (y-vel < terminal-y-vel)
       [explode
        die
       ]
    ]
    [fade]
end


;EXPLODE
;-------
;This is where the explosion is created.
;EXPLODE calls hatch a number of times indicated by the slider FRAGMENTS.

to explode                 ;; turtle procedure
  hatch-frags fragments
    [ set dim 0
      rt random 360
      set size 1
      set x-vel (x-vel * .5 + (sin heading) + (random-float 2.0) - 1)
      set y-vel (y-vel * .3 + (cos heading) + (random-float 2.0) - 1)
      ifelse trails?
        [ pd ]
        [ pu ]
     ]
end


;FADE
;----
;This function changes the color of a frag.
;Each frag fades its color by an amount proportional to FADE-AMOUNT.

to fade                    ;; frag procedure
  set dim dim - (fade-amount / 10)
  set color scale-color col dim -5 .5
  if ( color < (col - 3.5) )
    [die]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Fireworks model.
; http://ccl.northwestern.edu/netlogo/models/Fireworks.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Fireworks
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This program models the action of fireworks.  Rockets begin at the bottom of the view, shoot upwards into the sky and then explode, emitting showers of falling sparks.


HOW IT WORKS
------------
Each rocket, represented by a turtle, is launched upward with an initial x and y velocity.  At a certain point in the sky, an explosion occurs, which is represented by a series of turtle hatches.  Each hatched turtle inherits the velocity from the original rocket in addition to velocity from the explosion itself.  The result is a simulation of a fireworks display.


HOW TO USE IT
-------------
SETUP sets up the model according to the values indicated by all the sliders and the switch. GO is a forever button that executes the model continually.
FIREWORKS creates a random number of fireworks between 0 and the number indicated on the slider.
FRAGMENTS determines how many particle fragments will emerge after the explosion of a single firework.
GRAVITY determines the gravitational strength in the environment.  A larger value will give a greater gravitational acceleration, meaning that particles will be forced to the ground at a faster rate.  The inverse is true for smaller values.
INIT-X-VEL sets the initial x-velocity of each rocket to a random number between the negative and positive value of the number indicated on the slider.
INIT-Y-VEL sets the initial y-velocity of each rocket to a random number between 0 and the number indicated on the slider plus ten.  This is to ensure that there is a range of difference in the initial y-velocities of the fireworks.
FADE-AMOUNT determines the rate at which the explosion particles fade after the explosion.

TRAILS allows the user to turn the trails left by the explosion particles on or off.  In other words, if the TRAILS switch is ON, then the turtles will leave trails.  If it is OFF, then they will not leave trails.

This model has been constructed so that all changes in the sliders and switches will take effect in the model during execution.  So, while the GO button is still down, you can change the values of the sliders and the switch, and you can see these changes immediately in the view.


THINGS TO NOTICE
----------------
Experiment with the INIT-X-VEL and INIT-Y-VEL sliders.  Observe that at an initial x-velocity of zero, the rockets launch straight upwards.  When the initial x-velocity is increased, notice that some rockets make an arc to the left or right in the sky depending on whether the initial x-velocity is negative or positive.

With the initial y-velocity, observe that, on a fixed GRAVITY value, the heights of the fireworks are lower on smaller initial y-velocities and higher on larger ones.  Also observe that each rocket explodes at a height equal to or a little less than its apex.


THINGS TO TRY
-------------
Observe what happens to the model when the GRAVITY slider is set to different values.  Watch what happens to the model when GRAVITY is set to zero.  Can you explain what happens to the fireworks in the model?  Can you explain why this phenomenon occurs?  What does this say about the importance of gravity?  Now set the GRAVITY slider to its highest value.  What is different about the behavior of the fireworks at this setting?  What can you conclude about the relationship between gravity and how objects move in space?


EXTENDING THE MODEL
-------------------
The fireworks represented in this model are only of one basic type.  A good way of extending this model would be to create other more complex kinds of fireworks.  Some could have multiple explosions, multiple colors, or a specific shape engineered into their design.

Notice that this model portrays fireworks in a two-dimensional viewpoint.  When we see real fireworks, however, they appear to take a three-dimensional form.  Try extending this model by converting its viewpoint from 2D to 3D.


NETLOGO FEATURES
----------------
An important aspect of this model is the fact that each particle from an explosion inherits the properties of the original firework.  This informational inheritance allows the model to adequately represent the projectile motion of the firework particles since their initial x and y velocities are relative to their parent firework.

To visually represent the fading property of the firework particles, this model made use of the reporter 'scale-color'.  As the turtle particles fall to the ground, they hold their pens down and gradually scale their color to black.  As mentioned above, the rate of fade can be controlled using the FADE-AMOUNT slider.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Fireworks model.  http://ccl.northwestern.edu/netlogo/models/Fireworks.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Fireworks for terms of use.
"
Sound Machines,/models/Sample Models/Art,"extensions [sound]

globals [
  selected    ;; lever that is currently selected
  dragged     ;; lever that is currently being dragged
]

breed [levers lever]
levers-own [
  neighbor1 neighbor2  ;; each holds an adjacent lever (or nobody)
  fixed?               ;; if true, lever only turns, never changes position
  spin                 ;; -1, 0, or 1
  len                  ;; this times SCALE slider equals size
  new-xcor new-ycor    ;; next values for xcor and ycor
  new-heading          ;; next value for heading
  xvel yvel            ;; x and y velocities
]

;;;
;;; SETUP PROCEDURES
;;;

to setup-begin
  clear-all
  set-default-shape levers ""lever""
  create-ordered-levers num-levers [
    set heading 180
    set new-xcor 0
    set ycor ((who / num-levers) * world-height + min-pycor ) * -0.8
    set new-ycor ycor
    set fixed? false
    set len 0.5
    set neighbor1 turtle (who - 1)
    set neighbor2 turtle (who + 1)
  ]
  ask lever 0 [ set fixed? true ]
end

to setup-dangle
  setup-begin
  ask turtle (num-levers - 4) [
    set len len * 2
    set spin 1
  ]
  setup-finish
end

to setup-finish
  set selected last sort levers  ;; select last lever
  ask levers [ lever-display ]
end

to setup-chaos-tentacle
  setup-begin
  ask levers
    [ set len (num-levers - who) * 0.1
      set spin (who mod 2) * 2 - 1
    ]
  ask first sort levers
    [ set new-xcor 0
      set new-ycor 0
      setxy 0 0
      set fixed? true
    ]
  setup-finish
end

to setup-crazy-machine
  setup-begin
  ask levers
    [ ; choose random location, in the inner area of the world
      set new-xcor (random-float 1.6 - 0.8) * max-pxcor
      set new-ycor (random-float 1.6 - 0.8) * max-pycor
      setxy new-xcor new-ycor
      set fixed? (random 5 = 0)
      set spin one-of [-1 0 1]
      set len precision (0.5 + 0.5 * random 4) 1
      lever-display
    ]
  setup-finish
end

;;;
;;; RUNTIME PROCEDURES
;;;

to go
  ask levers [ monitor-mouse ]
  ask levers [ lever! ]
  ask levers [ lever-display ]
  tick
end

to lever!
  ifelse self = dragged
  [ ; if being dragged, then go there the mouse tells you
    set new-xcor mouse-xcor
    set new-ycor mouse-ycor
  ]
  [
    if not fixed?
    [ set xvel (xvel * f) + ((n1x2 - x1) + (n2x1 - x2)) * 0.5
      set yvel (yvel * f) + ((n1y2 - y1) + (n2y1 - y2)) * 0.5
      set yvel yvel - g * len
      set new-xcor xcor + xvel
      set new-ycor ycor + yvel
      if abs new-xcor > max-pxcor [ set xvel xvel * -0.99
                                    set new-xcor max-pxcor * sign new-xcor + xvel
                                    bonk! ycor ]
      if abs new-ycor > max-pycor [ set yvel yvel * -0.99
                                    set new-ycor max-pycor * sign new-ycor + yvel
                                    bonk! xcor ]
    ]
  ]
  ; calculate new heading of lever
  ; if node2 of neighbor1 is overlapping center, keep same heading
  ; otherwise, find heading to hook 2 of neighbor1
  let a 180 + heading
  let b heading
  if distancexy n1x2 n1y2 > 0
    [ set a 180 + towardsxy n1x2 n1y2 ]
  ; likewise hook 1 of neighbor2
  if distancexy n2x1 n2y1 > 0
    [ set b towardsxy n2x1 n2y1 ]
  ; use trig to take mean of a and b
  set new-heading atan (sin a + sin b)
                       (cos a + cos b)
                  + spin * spin-speed
end

to lever-display
  setxy new-xcor new-ycor
  set heading new-heading
  set size 2 * scale * len
  let -s """"
  ifelse self = selected
  [ set -s ""-s""
    let new-label (word ""selected: "" who "" - "" (precision len 2) "" "")
    ask patch max-pxcor max-pycor [ set plabel new-label ]
    set label (word who "" - "" (precision len 2) "" ""  "" ---->     "")
  ]
  [ set label """" ]
  set shape (word ""lever""
                  ifelse-value fixed? [""-f""] [""""]
                  item (spin + 1) [""-ws"" """" ""-cw""]
                  -s)
end

;; lever procedures; these report the x and y coordinates
;; of this lever's hooks
to-report x1 report xcor - dx * scale * len end
to-report y1 report ycor - dy * scale * len end
to-report x2 report xcor + dx * scale * len end
to-report y2 report ycor + dy * scale * len end

;; lever procedures; these report the x and y coordinates
;; of our neighbor's hooks. if no neighbor, use own hook.
to-report n1x1 ifelse neighbor1 = nobody [ report x2 ] [ report [x1] of neighbor1 ] end
to-report n1y1 ifelse neighbor1 = nobody [ report y2 ] [ report [y1] of neighbor1 ] end
to-report n1x2 ifelse neighbor1 = nobody [ report x1 ] [ report [x2] of neighbor1 ] end
to-report n1y2 ifelse neighbor1 = nobody [ report y1 ] [ report [y2] of neighbor1 ] end    
to-report n2x1 ifelse neighbor2 = nobody [ report x2 ] [ report [x1] of neighbor2 ] end
to-report n2y1 ifelse neighbor2 = nobody [ report y2 ] [ report [y1] of neighbor2 ] end
to-report n2x2 ifelse neighbor2 = nobody [ report x1 ] [ report [x2] of neighbor2 ] end
to-report n2y2 ifelse neighbor2 = nobody [ report y1 ] [ report [y2] of neighbor2 ] end    

to-report sign [a]
  ifelse a = 0
    [ report 0 ]
    [ ifelse a < 0 [ report -1 ]
                   [ report 1 ] ]
end

;;;
;;; SELECTION & DRAGGING PROCEDURES
;;;

to monitor-mouse
  let mouse-here? abs (mouse-xcor - xcor) < scale / 2 and
                  abs (mouse-ycor - ycor) < scale / 2
  ifelse mouse-here?
  [ if color != white [ set color white ] ]
  [ if color = white  [ set color item (who mod 14) base-colors ] ]
  ifelse mouse-down?
  [ if dragged = nobody and mouse-here?
    [ set dragged self
      set selected self
    ]
  ]
  [ set dragged nobody ]
end

to select-lever [which-lever]
  let new lever (which-lever + [who] of selected)
  if new != nobody [ set selected new ]
end

;;;
;;; SOUND PROCEDURES
;;;

to bonk! [coordinate]
  sound:play-note my-instrument (pitch coordinate) 90 0.05
end

to-report pitch [coordinate]  ;; lever procedure
  report 16 + round (96 * (coordinate + max-pxcor) / world-width)
end

to-report my-instrument  ;; lever procedure
  report item ((who + instrument) mod length sound:instruments)
              sound:instruments
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2005 by Uri Wilensky.
; Includes code by James P. Steiner.
;
; This work is licensed under the Creative Commons
; Attribution-NonCommercial-ShareAlike 2.5 License.  To view a copy of
; this license, visit http://creativecommons.org/licenses/by-nc-sa/2.5/
; or send a letter to Creative Commons, 559 Nathan Abbott Way,
; Stanford, California 94305, USA.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2005).  NetLogo Sound Machines model.
; http://ccl.northwestern.edu/netlogo/models/SoundMachines.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2005 Uri Wilensky.  Some rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/SoundMachines
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model shows one way turtles can make interesting and varied sounds, or if you like, music.  It uses some simple physics to make ""machines"" that twist, spin, turn, twitch, and bounce.  When a part of the machine touches a wall, ceiling, or floor, it makes a sound.  The pitch of the sound depends on the location of the touch.

You can start with a standard machine, or generate a random one.  You can change and build machines yourself, by changing the characteristics of each part.  You can sit back and let the machines play themselves, or you can use the mouse to move them around to control the sound yourself.


HOW IT WORKS
------------
The machines are made up of levers.  Levers can be different sizes and are pulled down by gravity (in proportion to their size) and subject to friction.

Each lever has one or two ""hooks"" to connect it to adjacent levers.  Each lever rather simple-mindedly tries to move and rotate to keep its hooks attached (or at least pointing towards) its neighbors' hooks.

Some levers have additional constraints.  A lever can be fixed in position so it can't move.  It can also rotate, as if powered by a motor.

The rules aren't perfect; for example, sometimes the levers separate.  Nonetheless, the behavior is often surprisingly realistic, and is rich enough to generate interesting motion which generates interesting sounds.


HOW TO USE IT
-------------
Press one of the SETUP... buttons to create a machine.  If you want, change NUM-LEVERS first to get more or fewer levers.

Press GO to start the machine going.  You should start hearing sounds, although if your machine never touches the wall (or ceiling or floor), you won't hear anything.

You can use the mouse to select a lever by clicking on it, or to move a lever by dragging it.  The selected lever has a circle around it.

Once you have selected a lever, a variety of controls on the left let you change that lever's properties.  They are not described in detail here; play with him and see for yourself what they do.

Some parameters affecting the entire system are on the bottom left and the right.  f is friction, g is gravity.  There are also controls for spin.

You can use the INSTRUMENT slider to pick a different musical instrument for the levers to play.

If you make a machine you especially like, you can use Export World and Import World on the File menu to save it out and load it back in again.


THINGS TO NOTICE
----------------
The simple rules followed by the levers produce some quite realistic-looking behavior.

Some machines don't do anything.  Other machines make simple, repetitive motions.  And others are wildly chaotic.


THINGS TO TRY
-------------
Try all of the different SETUP buttons.

Try all of the lever controls on the left.

Explore the effect of the parameters on the right.

See if you can make machines which are somewhat repetitive, but also somewhat unpredictable and chaotic.  Sometimes these make the most pleasing ""music"".

Using the command center, tell the turtles to put their pens down (using the PEN-DOWN command, abbreviated PD).  This generates some pleasing patterns.  Use CLEAR-DRAWING (abbreviated CD) to start a new drawing.


EXTENDING THE MODEL
-------------------
There are endless possibilities for how the same basic physics engine could be used to generate sound.  The levers could:
- Play different instruments, instead of all the same one.
- Make percussion sounds in addition pitched sounds.
- Make sounds even when they don't hit the wall
- Make sounds that depend on their characteristics
And so on.

How ""normal"" and ""musical"" can you make the model sound?  Currently the rules of the model aren't based on scales or tonality; by choosing pitches more carefully, you might be able to produce music which is less strange, more like music composed by humans.  You could also try to produce more regular rhythms by timing sounds to coincide with a regular beat.

Or, you could take the opposite approach, and see how wild, different, and unusual can you make the sounds.  Make something that doesn't sound like anything you've ever heard before!


NETLOGO FEATURES
----------------
The model uses NetLogo's sound extension.  The sound extension is described in the Sound section of the NetLogo User Manual.


RELATED MODELS
--------------
Beatbox
Composer
GasLab With Sound
Sound Workbench
Percussion Workbench


CREDITS AND REFERENCES
----------------------
This model is a streamlined variant of the Machines 2005 model created and submitted to the NetLogo User Community Models repository by James Steiner.  Machines 2005 is available from http://ccl.northwestern.edu/netlogo/models/community/machines-2005.

Thanks to James for creating an earlier version which was silent; Seth Tisue for first adding sound to it; and James again for his further improvements, and for releasing the model under a Creative Commons License.

This variant is copyright 2005 Uri Wilensky.  Includes code by James P. Steiner.  This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 2.5 License.  To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/2.5/ or send a letter to Creative Commons, 559 Nathan Abbott Way, Stanford, California 94305, USA.

To refer to this model in academic publications, please use:  Wilensky, U. (2005).  NetLogo Sound Machines model.  http://ccl.northwestern.edu/netlogo/models/SoundMachines.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2005 Uri Wilensky.  Some rights reserved.  See http://ccl.northwestern.edu/netlogo/models/SoundMachines for terms of use.
"
Diffusion Graphics,/models/Sample Models/Art,"patches-own [ heat ]

to setup
  clear-all
  set-default-shape turtles ""circle""
  create-turtles num-turtles   ; each turtle is like a heat source
  [ setxy random-xcor random-ycor     ; position the turtles randomly
    hide-turtle   ; so we don't see the turtles themselves, just the heat they produce
    set heat turtle-heat ] ; turtles set the patch variable
  recolor-patches                       ; color patches according to heat
end

to go
  ask turtles [ set heat turtle-heat ]   ; turtles set the patch variable
  if wander? [ ask turtles [ wander ] ]  ; movement of turtles is controlled by WANDER? switch
  diffuse heat diffusion-rate            ; this causes the ""spreading"" of heat
  recolor-patches                        ; color patches according to heat
  tick
end

to wander ; turtle procedure
  rt random 50 - random 50
  fd turtle-speed
end

to recolor-patches  ;; color patches according to heat
  ask patches [ set pcolor heat ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1997 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1997).  NetLogo Diffusion Graphics model.
; http://ccl.northwestern.edu/netlogo/models/DiffusionGraphics.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1997 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/DiffusionGraphics
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
Diffusion Graphics is unlike most other NetLogo models, in that it really doesn't 'model' anything. It simply explores the power behind an interesting patch primitive: 'diffuse'.

In this model, the turtles are ""hot spots"" -- they set a certain value (a patch variable called 'heat') to the maximum level every time step. Each patch (through the 'diffuse' primitive) then shares its value of 'heat' with its surrounding patches. It's not intended to closely model real heat, it's just a number that behaves something like heat -- it slowly spreads itself evenly across a plane. (See the 'Diffusion' model for a model that models real heat more closely.)

Here you can watch what happens as hot-spots interact with each other, as they move around, as their values become negative, or as the 'heat' slowly decays down to nothing. The whole point of the project is to give you an idea how patches interact via the 'diffuse' primitive. (Or maybe just to give you something nice to stare at if you're bored.)


HOW TO USE IT
-------------
Two buttons, SETUP and GO, control execution of the model. As in most NetLogo models, the SETUP button will initialize the 'hot-spots' and other variables, preparing the model to be run. The GO button, a forever button, will then run the model.

Four sliders and two switches determine the various properties of the model. Each of them can be set prior to initialization; most can be used mid-run to affect what will happen.

NUM-TURTLES determines how many turtles there are. TURTLE-SPEED determines how fast they move. Each turtle sets the 'heat' of the patch it is over to TURTLE-HEAT.  Then that patch diffuses it into the nearby patches.

The DIFFUSION-RATE slider is the rate at which the colors diffuse out from each patch. All patches diffuse their color value to their neighbors each time step. DIFFUSION-RATE is simply the fraction of this color leaked out.

The WANDER? switch, if on, allows the turtles to move around the view. If the switch is off, the turtles will stay rooted in place.


THINGS TO NOTICE
----------------
Mainly what Diffusion Graphics will show you is how patch-color is diffused in NetLogo.  The graphical display may evoke fractal imagery, or a topographical landscape.  Diffusion Graphics really does bring about a topography of sorts, with the turtles being peaks, and the darkest colors being valleys. The model essentially tries to then smooth out these differences.

Let the model run for a while with WANDER all off (all set to 0). Watch what happens to the 'terrain'. What do you predict will eventually happen?

This model was built to please. Just play around with the sliders and switches. Later, try altering the code and see what works (and what doesn't work, too).


THINGS TO TRY
-------------
Try setting TURTLE-HEAT to a very large number.  What happens?  What does this show you about NetLogo's color model?

Try setting TURTLE-HEAT to a negative number.  What happens?  What does this show you about NetLogo's color model?

Try setting the patch size to a small number for a richer display. Or make the patch size large, for a 'zoomed-in' perspective.


EXTENDING THE MODEL
-------------------
Change it so that the NUM-TURTLES slider will the change the number of turtles on the fly, instead of requiring you to hit SETUP.

In 'diffusion-graphics', the position of each turtle is determined randomly at setup. Change the model so that the user may position turtles with the mouse.

Color the patches a different way, perhaps along the traditional ROY-G-BIV (red, orange, yellow, green, blue, indigo, violet) spectrum.


NETLOGO FEATURES
----------------
The Diffusion Graphics model was designed around the 'diffuse' primitive.   'diffuse' is an observer primitive that takes two inputs, a patch variable and a number.  'diffuse' makes all the patches share that patch variable with their eight neighbors.  The second input is a number between 0 and 1.0 determines what fraction of the patch variable is shared.  (In this model, the amount shared is controlled by the CHANGE-RATE slider.)  So for example, if I ask the observer to 'diffuse heat 0.5', the observer tells each patch to give half of 'heat' to the eight other patches.  If a patch had 80 to begin with, then it keeps 40 and gives 5 away to each neighbor.  The total value of 'heat' for all the patches remains constant.

There is also a 'diffuse4' primitive where the patches only share with their neighbors in the north, south, east, and west directions, not with their diagonal neighbors.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1997).  NetLogo Diffusion Graphics model.  http://ccl.northwestern.edu/netlogo/models/DiffusionGraphics.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1997 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/DiffusionGraphics for terms of use.
"
Kaleidoscope,/models/Sample Models/Art/Unverified,"globals [curr-color-sep]   ;; spread of the colors in the kaleidoscope

;; INITIALIZATION PROCEDURES
to setup
  clear-all
  set-default-shape turtles ""circle""
  ;; the patterns assume evenly spaced turtles
  create-ordered-turtles nturtles [ pd ]
  set curr-color-sep color-sep
end


;; RUN-TIME PROCEDURES
;; First Pattern
;; -turn a bit right, hatch a turtle which draws a circle then dies
to pattern-1
  ask turtles [
    rt 1
    hatch 1 [
      set color 5.375 * ((count turtles - 1) / curr-color-sep) + 10
      right-circle
      die
    ]
  ]
  every 1
  [
    if color-shift?
      [ color-shift ]
  ]
  tick
end

;; Second Pattern
;; -half our turtles do Pattern 1; the other half do the same,
;;  except mirrored (they turn left circles)
to pattern-2
  ask turtles [
    ifelse (who mod 2) = 0 [
      rt 1
      hatch 1 [
        set color 5.375 * ((count turtles - 1) / curr-color-sep) + 10
        right-circle
        die
      ]
    ]
    [
      lt 1
      hatch 1 [
        set color 5.375 * ((count turtles - 1) / curr-color-sep) + 10
        left-circle
        die
      ]
    ]
  ]
  every 1
  [
    if color-shift?
      [ color-shift ]
  ]
  tick
end

;; Spin a circle, clockwise
to right-circle
  repeat 36 [
    fd 4
    rt 10
  ]
end

;; Spin a circle, counterclockwise
to left-circle
  repeat 36[
    fd 4
    lt 10
  ]
end

;; Change curr-olor-sep, to increase colors or decrease colors
to color-shift
  ifelse increase-color?
  [
    set curr-color-sep curr-color-sep + random 3
    if curr-color-sep > 60
      [ set curr-color-sep 60 ]
  ]
  [
    set curr-color-sep curr-color-sep - random 3
    if curr-color-sep < 1
      [ set curr-color-sep 1 ]
  ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Kaleidoscope model.
; http://ccl.northwestern.edu/netlogo/models/Kaleidoscope.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Kaleidoscope
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model uses NetLogo turtles to repeatedly draw circles, turning periodically so that the display gives the impression of a kaleidoscope or pinwheel.


HOW TO USE IT
-------------
The NTURTLES slider really determines the number of ""arms"" or ""petals"" that the kaleidoscope will have. Begin by setting this slider to the desired value (10 is fine).

Next, set COLOR-SEP to some value. COLOR-SEP basically determines the range of colors that the turtles (and hence
the kaleidoscope) will take on. The higher the value, the smaller the range. (For a nice, three-colored kaleidoscope, set COLOR-SEP to 25.) This inverse relation between COLOR-SEP and the color range is due to the fact that COLOR-SEP acts as a constant to divide a turtle's color by.

When you have set both NTURTLES and COLOR-SEP, press the SETUP button to set your kaleidoscope in motion.

Next, choose which pattern you want. Each pattern has its own forever-button that controls it. PATTERN-1 has the arms of the kaleidoscope all spiraling clockwise, while PATTERN-2 has the arms of the kaleidoscope spiral in both clockwise and counterclockwise directions, giving a slightly more complicated design.

Finally, you have the power to change the color distribution exhibited by this model. The COLOR-SHIFT button will either increment or decrement the value of COLOR-SEP used by the turtles -- saved internally as CURR-COLOR-SEP. (Thus the slider value itself isn't changed, but the number the turtles look at is.) This number is changed by a small random amount. The INCREASE-C? switch determines if CURR-COLOR-SEP is increased (true) or decreased (false).

You also have two monitors at the bottom of the Interface Window. COUNT-TURTLES will simply display the current number of turtles. Likewise, CURR-COLOR-SEP will display that variable's value, so that you know when it has been altered, and by how much.


THINGS TO NOTICE
----------------
First, just try playing around and observe what happens. This is meant to be a visually pleasing model just to watch. See what different values of NTURTLES and COLOR-SEP produce, and explore how COLOR-SHIFT changes the appearance of the kaleidoscope. What seems the best to you?

An important thing to notice here is the number given in COUNT-TURTLES. Right away, it becomes much larger than NTURTLES, but quickly settles on some nice big number. Take a look at the Procedures Window. There are really two levels of turtle commands going on here. Initially, upon setup, there are NTURTLES number of turtles. Once one of the pattern buttons is pressed, each of these turtles (who compose the ""arms"" of the kaleidoscope) repeatedly hatches a new turtle and turns by a single degree. The newly-hatched turtles begin to draw circles, self-destructing upon completion. As the ""arm"" turtles execute their commands much quicker than the hatched turtles, they produce many turtles during one loop of a circle; eventually, though, turtles start to die off. At this point, the number of turtles who are born is roughly equal to the number who die at any given step.

You also should notice how COLOR-SEP (or really CURR-COLOR-SEP) alters the appearance of the kaleidoscope. Turn COLOR-SHIFT on, and let CURR-COLOR-SEP become very large. Then watch what happens when it is small, maybe zero or some negative number.


THINGS TO TRY
-------------
Try changing the code in the Procedures Tab. Increase the size of the circles drawn by each of the turtles, or try changing the size of the angle each of the turtles turns through.

Instead of each turtle moving or turning a given amount, what about having it move a small random amount (as in the changes to curr-color-sep from COLOR-SHIFT). How much randomness can you add and still maintain some kind of overall structure?


EXTENDING THE MODEL
-------------------
Whenever a turtle is hatched by one of the ""arm"" turtles, it proceeds to draw a circle. Change the HATCH command list so that it draws some other shape or pattern. Try to predict what overall shape will emerge.

Currently, the only difference between the two patterns is that PATTERN-2 has half of the ""arm"" turtles circle to the left, the other half to the right. Write your own pattern -- i.e., come up with a new command or set of commands for these turtles to execute.

Try to write an entirely new kind of model along similar lines.  In the current model, turtles spin off from a center core of NTURTLES turtles. In your new model, maybe the drawing turtles could orbit around some fixed (or moving) point, like in the StarLogoT models N Bodies and Gravitation.


NETLOGO FEATURES
-----------------
This makes nice use of the turtle primitive HATCH. Whenever a turtle is hatched, it executes the command list that follows the HATCH command. In most context this is used just to change the new turtle's color or alter some variable.  But there's no reason it can't run some other, possibly lengthy, procedure, and that's exactly what happens here.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Kaleidoscope model.  http://ccl.northwestern.edu/netlogo/models/Kaleidoscope.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Kaleidoscope for terms of use.
"
Geometron Top-Down,/models/Sample Models/Art/Unverified,"globals [
  curr-color-sep        ;; spread of the colors in the kaleidoscope
  counter
]

turtles-own [
  new?                 ;; was the turtle just created?
  type-a?              ;; used when turtles with different behaviors are hatched
]

to setup
  clear-all
  ;; some of the patterns assume
  ;; evenly spaced turtles
  create-ordered-turtles nturtles
  ask turtles
    [pen-down
     set new? false
    ]
  set curr-color-sep color-sep
  set counter 0
end

to lift-pen
  ask turtles
    [if (who >= nturtles)
       [die]
     pen-up
    ]
  clear-patches
end


to restore
  ask turtles
    [if (who >= nturtles)
       [die]
     pen-down
    ]
  clear-patches
end

to color-shift
  ifelse shift-direction = ""increment""
    [set curr-color-sep (curr-color-sep + (random-float 1.0))]
    [set curr-color-sep (curr-color-sep - (random-float 1.0))]
  wait 1
end


;;PATTERN-1
;;---------
;;Turtles draw circles creating an overall circular design.

to pattern-1    ;;turtle procedure
  if (new?)
    [set color (who / curr-color-sep)
     if (follow-turtle)
       [if (who = (50 + nturtles))
          [pen-down]
       ]
     right-circle
     left-circle
     die
    ]
  if (( who mod 10 ) = 0)
    [rt direction
     fd 0.5
     if (count turtles + 1 <= max-num)
       [hatch 1
          [set new? true]
       ]
    ]
end


;;PATTERN-2
;;---------
;;Turtles draw a combination of hexagons and octagons, Overall shape determined by NTURTLES.

to pattern-2    ;;turtle procedure
  if (new?)
    [ifelse (type-a?)
       [set color (who / curr-color-sep)
        if (follow-turtle)
          [if (who = (60 + nturtles))
             [pen-down]
          ]
        hexagon
        die
       ]
       [set color (who / curr-color-sep)
        if (follow-turtle)
          [if (who = (50 + nturtles))
             [pen-down]
          ]
        octagon
        die
       ]
    ]
  ifelse ((who mod 2) = 0)
    [rt 1
     fd 1
     if (count turtles + 1 <= max-num)
       [hatch 1
          [set new? true
           set type-a? true
          ]
       ]
    ]
    [lt 1
     fd 1
     if (count turtles + 1 <= max-num)
       [hatch 1
          [set new? true
           set type-a? false
          ]
       ]
    ]
end


;;PATTERN-3
;;---------
;;Turtles create only pentagons, slight variations in their origin create the overall effect.

to pattern-3    ;;turtle procedure
  if (new?)
    [set color (who / curr-color-sep)
     if (follow-turtle)
       [if (who = (60 + nturtles))
          [pen-down]
       ]
     pentagon
     die
    ]
  if (who mod 5) = 0
    [rt direction
     fd 0.5
     if (count turtles + 1 <= max-num)
       [hatch 1
          [set new? true]
       ]
    ]
end


;;PATTERN-4
;;---------
;;Turtles draw ninegons and left circles creating an overall circular pattern.

to pattern-4    ;;turtle procedure
  if (new?)
    [ifelse (type-a?)
       [set color (who / curr-color-sep)
        if (follow-turtle)
          [if (who = (1583 + nturtles))
             [pen-down]
           if (who = (1087 + nturtles))
             [pen-down]
          ]
        nine-gon
        die
       ]
       [set color (who / curr-color-sep)
        if (follow-turtle)
          [if (who = (214 + nturtles))
             [pen-down]
          ]
        left-circle
        die
       ]
    ]
  ifelse ((who mod 3) = 0)
    [rt 1
     if (count turtles + 1 <= max-num)
       [hatch 1
          [set new? true
           set type-a? true
          ]
       ]
    ]
    [lt 1
     if (count turtles + 1 <= max-num)
       [hatch 1
          [set new? true
           set type-a? false
          ]
       ]
    ]
end


;;PATTERN-5
;;---------
;;Turtles draw a left square and then die.

to pattern-5    ;;turtle procedure
  if (new?)
    [set color (who / curr-color-sep)
     if (follow-turtle)
       [if (who = (80 + nturtles))
          [pen-down]
       ]
     left-square
     die
    ]
  if (count turtles + 1 <= max-num)
    [hatch 1
       [set new? true]
    ]
end


;;PATTERN-6
;;---------
;;Turtles draw several shapes, however overall design remains circular.

to pattern-6    ;;turtle procedure
  if count turtles > max-num
    [if (who > max-num)
       [die]
     stop
    ]
  if (new?)
    [ifelse (type-a?)
       [set color (who / curr-color-sep)
        if (follow-turtle)
          [if (who = (60 + nturtles))
             [pen-down]
          ]
        pentagon
        hexagon
        left-circle
        die
       ]
       [set color (who / curr-color-sep)
        if (follow-turtle)
          [if (who = (60 + nturtles))
             [pen-down]
          ]
        nine-gon
        octagon
        right-circle
        die
       ]
    ]
  if (count turtles + 1 <= max-num)
    [hatch 1
       [set new? true
        set type-a? true
       ]
    ]
  if (count turtles + 1 <= max-num)
    [hatch 1
       [set new? true
        set type-a? false
       ]
    ]
end


;;RIGHT-CIRCLE
;;------------
;;Performs the following procedure 180 times:
;;Move forward 1.5 steps and turn right by 2 degrees.
;;To see the shape that this function creates,
;;try calling it in the command center with one turtle with the pen down.
;;A turtle will create a circle heading in the right direction.

to right-circle    ;;turtle procedure
  repeat 180
    [fd 1.5
     rt 2
    ]
end


;;LEFT-CIRCLE
;;-----------
;;Performs the following procedure 180 times:
;;Move forward 1.5 steps and turn left by 2 degrees.
;;To see the shape that this function creates,
;;try calling it in the command center with 0one turtle with the pen down.
;;A turtle will create a circle heading in the left direction.

to left-circle    ;;turtle procedure
  repeat 180
    [fd 1.5
     lt 2
    ]
end


;;LEFT-SQUARE
;;-----------
;;Performs the following procedure 4 times:
;;Move forward EXPANDER steps and turn left by 90 degrees.
;;To see the shape that this function creates,
;;try calling it in the command center with one turtle with the pen down.
;;A turtle will create a square heading in the left direction.

to left-square    ;;turtle procedure
  repeat 4
    [fd expander
     lt 90
    ]
end


;;RIGHT-TRIANGLE
;;--------------
;;Performs the following procedure 3 times:
;;Move forward 35 steps and turn right by 120 degrees.
;;To see the shape that this function creates,
;;try calling it in the command center with one turtle with the pen down.
;;A turtle will create a triangle heading in the right direction.

to right-triangle    ;;turtle procedure
  repeat 3
    [fd expander
     rt 120
    ]
end


;;OCTAGON
;;-------
;;Performs the following procedure 8 times:
;;Move forward 30 steps and turn right by 45 degrees.
;;To see the shape that this function creates,
;;try calling it in the command center with one turtle with the pen down.
;;A turtle will create an octagon heading in the right direction.

to octagon    ;;turtle procedure
  repeat 8
    [fd 30
     lt 45
    ]
end


;;PENTAGON
;;--------
;;Performs the following procedure 5 times:
;;Move forward 35 steps and turn right by 72 degrees.
;;To see the shape that this function creates,
;;try calling it in the command center with one turtle with the pen down.
;;A turtle will create a pentagon heading in the right direction.

to pentagon    ;;turtle procedure
  repeat 5
    [fd 35
     rt 72
    ]
end


;;HEXAGON
;;-------
;;Performs the following procedure 6 times:
;;Move forward 30 steps and turn right by 60 degrees.
;;To see the shape that this function creates,
;;try calling it in the command center with one turtle with the pen down.
;;A turtle will create a hexagon heading in the right direction.

to hexagon    ;;turtle procedure
  repeat 6
    [fd 30
     rt 60
    ]
end


;;NINE-GON
;;--------
;;Performs the following procedure 9 times:
;;Move forward 35 steps and turn right by 40 degrees.
;;To see the shape that this function creates,
;;try calling it in the command center with one turtle with the pen down.
;;A turtle will create a nine-gon heading in the right direction.

to nine-gon    ;;turtle procedure
  repeat 9
  [fd 35
   lt 40
  ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Geometron Top-Down model.
; http://ccl.northwestern.edu/netlogo/models/GeometronTop-Down.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/GeometronTop-Down
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model uses NetLogo turtles to repeatedly draw circles and other geometric shapes, turning periodically so that the display gives the impression of a kaleidoscope or a pinwheel.


HOW TO USE IT
-------------
Set NTURTLES to a desired value between 0 and 36 (default value is 10).  NTURTLES determines how many initial turtles you want to start out with. These initial turtles will spawn other shape-making turtles.

Set COLOR-SEP to a desired value between 0 and 30 (default value is 2).  COLOR-SEP determines the range of colors that the turtles (and hence the kaleidoscope) will take on. The higher the value, the smaller the range.

Set MAX-NUM to a desired value between 1024 and 8192 (default value is 4096).  MAX-NUM determines the maximum number of turtles that can be in the world at any time.  Note however, a higher value will make the model run slower.

When you have set COLOR-SEP and NTURTLES, press the SETUP button to set-up the model.

Next, choose a pattern. In each pattern, the initial turtles hatch other turtles and those hatched turtles draw different geometric shapes.  Each pattern is represented by a forever button. The user cannot change PATTERN-2, PATTERN-4 or PATTERN-6.  PATTERN-1, PATTERN-3, and PATTERN-5, however, allow for user control using the DIRECTION and EXPANDER sliders.  For detailed descriptions of the instructions in each pattern, go to the end of the info-window.

The slider DIRECTION (default value is 2) is designed for PATTERN-1 and PATTERN-3.  At each cycle, DIRECTION determines the amount that the pattern-making turtles turn to the right.  In other words, if DIRECTION is set to 12, each turtle will turn 12 degrees to the right before moving forward.

The slider EXPANDER is designed specifically for pattern 5 (default value is 80).  At each cycle of PATTERN-5, EXPANDER determines how large each leg of the polygon will be.

The user also has control over the color distribution exhibited by each pattern. The COLOR-SHIFT button will continuously increase or decrease the value of 'curr-color-sep' by a small random amount. (Thus the slider value itself isn't changed, but the color value of the turtle is.)  The SHIFT-DIRECTION chooser determines if 'curr-color-sep' is increased or decreased.

Other features of the model are the LIFT-PEN and RESTORE buttons.  LIFT-PEN lifts the pen on all turtles and kills all turtles greater than NTURTLES.  RESTORE kills all turtles greater than NTURTLES and tells all turtles to put their pen down. Killing all turtles greater than NTURTLES restores the original number of turtles in the world.

A useful tool that can be used in conjunction with the LIFT-PEN and RESTORE buttons is a switch called FOLLOW-TURTLE. When you press LIFT-PEN without FOLLOW-TURTLE being on, you see the skeleton of the pattern since the turtles are moving without their pen down. But when the switch is turned on, one hatched turtle will put its pen down.  However, since turtles are constantly being born and dying it may take time for this particular turtle to appear.  It should also be understood that because some of the patterns divide the turtles into different groups and assign them different shapes to create, more than one turtle may be told to put its pen down in order to represent what all the turtles in the pattern are doing.

Two monitors are provided at the bottom of the Interface Window. COUNT-TURTLES displays the current number of turtles in the world. Likewise, CURR-COLOR-SEP displays that variable's value, so that you know when it has been altered, and by how much.


THINGS TO NOTICE
----------------
An important thing to notice here is the number given in COUNT-TURTLES. Right away, it becomes much larger than NTURTLES, but quickly settles on some nice big number. Take a look at the Procedures Window. Initially, upon setup, there are NTURTLES turtles. Once one of the pattern buttons is pressed, each of these turtles repeatedly hatches a new turtle and turns by a specified degree.

It is important to understand that this phenomenon, the fact that initial NTURTLES is exploding into a number much larger than NTURTLES is because other turtles are being hatched in between the time a single turtle is hatched and the time it finishes drawing its given shape.  Thus, if we were to add a wait statement into one of the patterns, not as many turtles could be hatched.  In other words, the number of turtles greater than NTURTLES would decrease. As turtles execute their commands much quicker than the hatched turtles, they produce many turtles during one loop of a pattern; eventually, though, turtles start to die off. At this point, the number of turtles who are born is roughly equal to the number who die at any given step.

You also should notice how COLOR-SEP (known in the code as 'curr-color-sep') alters the appearance of the pattern. Turn COLOR-SHIFT on, and let 'curr-color-sep' become very large. Then watch what happens when it is small, maybe zero or some negative number.


THINGS TO TRY
-------------
Try playing around with the DIRECTION slider on PATTERN-1 AND PATTERN-3 and the EXPANDER slider on PATTERN-5.  Observe what happens to the pattern as you change the values of each. GEOMETRON-TOP-DOWN is meant to be a visually pleasing model just to watch. See what different values of COLOR-SEP produce, and explore how COLOR-SHIFT changes the appearance of the kaleidoscope. What seems the best to you?

Try changing the code in the Procedures Tab. Increase the size of the shapes drawn by each of the turtles, or try changing the size of the angle each of the turtles turns through.

Instead of each turtle moving or turning a given amount, what about having it move a small random amount (as in the changes to curr-color-sep from COLOR-SHIFT). How much randomness can you add to 'kaleidoscope' and still maintain some kind of overall structure?

After running one of the patterns, try changing the number of NTURTLES and then stop the pattern and push CLEAR-PATCHES-LIFT-PEN.  Then start the pattern again.  What happens?  Can you explain why this happens?

Try changing the MAX-NUM slider during a run, what happens?  Can you explain why this occurs?


EXTENDING THE MODEL
-------------------
Whenever a turtle is hatched by one of NTURTLES, it proceeds to draw a certain pattern. Change the 'hatch' command list so that it draws some other shape or pattern. Try to predict what overall shape will emerge.

Try to write an entirely new kind of GEOMETRON-TOP-DOWN project. In the current project, turtles spin off from a center core of NTURTLES turtles. In your new project, maybe the drawing turtles could orbit around some fixed (or moving) point-look at the NetLogo projects 'n-bodies' and 'gravitation'.


NETLOGO FEATURES
-----------------
GEOMETRON-TOP-DOWN makes nice use of the turtle primitive 'hatch'. Whenever a turtle is hatched, it executes the command list that follows the 'hatch' command. Generally all it does is change its color or alter some variable- there's no reason it can't run some other, possibly lengthy, procedure. (Which is exactly what happens here.)


NOTES ON THE SHAPES
-------------------
The following is a list of all the basic shape functions that are used in this model to create the six patterns.  It is important to understand that the complexity of the patterns are actually nothing more than different combinations of these shape functions.  For example, pattern-1 utilizes the right-shape and left-shape functions.  Both these functions simply draw circles.  However, by adding slight variations to what the turtle does and which ones do it, it is possible to create the pattern that is represented by pattern-1.  This, in fact, is the basic algorithm that the model uses in order to create all the patterns.  Take the basic shape functions, add slight variations to what the turtles do and choose which turtles do it.

about RIGHT-CIRCLE:
Performs the following procedure 180 times:
Move forward 1.5 steps and turn right by 2 degrees.
To see the shape that this function creates, try calling it in the command center with one turtle with the pen down.
A turtle will create a circle heading in the right direction.

about LEFT-CIRCLE:
Performs the following procedure 180 times:
Move forward 1.5 steps and turn left by 2 degrees.
To see the shape that this function creates, try calling it in the command center with one turtle with the pen down.
A turtle will create a circle heading in the left direction.

about LEFT-SQUARE:
Performs the following procedure 4 times:
Move forward EXPANDER steps and turn right by 90 degrees.
To see the shape that this function creates, try calling it in the command center with one turtle with the pen down.
A turtle will create a square heading in the left direction.

about RIGHT-TRIANGLE:
Performs the following procedure 3 times:
Move forward 35 steps and turn right by 120 degrees.
To see the shape that this function creates, try calling it in the command center with one turtle with the pen down.
A turtle will create a triangle heading in the right direction.

about OCTAGON:
Performs the following procedure 8 times:
Move forward 30 steps and turn right by 45 degrees.
To see the shape that this function creates, try calling it in the command center with one turtle with the pen down.
A turtle will create an octagon heading in the right direction.

about PENTAGON:
Performs the following procedure 5 times:
Move forward 35 steps and turn right by 72 degrees.
To see the shape that this function creates, try calling it in the command center with one turtle with the pen down.
A turtle will create a pentagon heading in the right direction.

about HEXAGON:
Performs the following procedure 6 times:
Move forward 30 steps and turn right by 60 degrees.
To see the shape that this function creates, try calling it in the command center with one turtle with the pen down.
A turtle will create a hexagon heading in the right direction.

about NINE-GON:
Performs the following procedure 9 times:
Move forward 35 steps and turn right by 40 degrees.
To see the shape that this function creates, try calling it in the command center with one turtle with the pen down.
A turtle will create a nine-gon heading in the right direction.


SLIDER DESCRIPTIONS
-------------------
EXPANDER: Numbered from 0 to 90 and increments by 1.  Expands and contracts the square created by LEFT-SQUARE.  Associated with PATTERN-5.

DIRECTION: Numbered from 0 to 10 and increments by 0.1 or (1/10).  Turns a turtle to the right by the number of degrees specified by the slider.  Associated with PATTERN-3 and PATTERN-1.


WHAT THE PATTERNS DO
----------------------------

about PATTERN-1:
In this pattern, every 10th turtle moves forward 0.5 steps and to the right by DIRECTION degrees.  Each call to the pattern hatches a turtle who performs the RIGHT-CIRCLE function, then the LEFT-CIRCLE function and then dies.  By increasing the DIRECTION, the turtles increase the degrees by which they turn to the right.  This means that at each forward movement the turtle turns tighter around a center point.  Thus, when DIRECTION  is set to 0, the turtle simply moves forward.  The more it is increased, say from 0 to 1 to 2 to 10, the more circular the turtles movement becomes.  Although the pattern changes, it must be understood that the underlying shape that is being created is a circle.

about PATTERN-2:
Every even numbered turtle moves forward 1 step and turns right by 1 degree.  It then hatches a turtle that performs the HEXAGON function and then dies.  Every odd numbered turtle moves forward 1 step and turns left by 1 degree. It then hatches a turtle that performs the OCTAGON  function and then dies.  It is interesting to note that when the nturtles slider is raised to a high number ,i.e., greater than or equal to 20, the pattern in the lower numbers becomes unrecognizable.  However, it must be understood that although the new pattern may appear to be different, still, the underlying shapes that are being made are the hexagon and octagon.

about PATTERN-3:
Every 5th turtle moves forward 0.5 steps and turns right by DIRECTION degrees.  It then hatches a turtle which performs the PENTAGON function and then dies.  PATTERN-3 and PATTERN-5 are probably the simplest patterns in this model in terms of explaining their behavior.  Basically, PATTERN-3 creates pentagons, but because the turtles move forward 0.5 and move to the right DIRECTION  number of degrees, this is what causes the pattern to drastically change.  The illusion is that the hatched turtles are somehow creating different shapes but the truth of the matter is that they are making pentagons and always will be making pentagons.  It is only the slight variations in outside influences that brings about a change in the pattern.

about PATTERN-4:
Every 3rd turtle turns right by 1 degree and then hatches a turtle that performs the NINE-GON function and then dies.  All the other turtles turn left by 1 degree and then hatch a turtle that performs the LEFT-CIRCLE function and then dies.

about PATTERN-5:
Every turtle hatches another turtle that performs the LEFT-SQUARE function and then dies.

about PATTERN-6:
Every turtle moves forward DIRECTION steps and then hatches a turtle which performs the following functions in the following order: NINE-GON, OCTAGON, RIGHT-CIRCLE, PENTAGON, HEXAGON, and LEFT-CIRCLE.  After performing these functions, each hatched turtle then dies.


NOTES ON THE CODE
-----------------
Notice that in each of these functions, the number of times the procedure is repeated multiplied by the number of degrees the turtle turns either to the right or to the left is equal to 360 degrees.  Which means that each of the turtles is creating a polygon.

I discovered that in the patterns where the turtle moves a number of steps forward and then turns right or left in some direction, this action significantly changes the pattern.  For example, in pattern-1, the fact that each hatching turtle moves 0.5 steps forward means that the resulting shape from the RIGHT-CIRCLE OR LEFT-CIRCLE function will resemble a kidney bean rather than a circle, which is what the RIGHT-CIRCLE  and LEFT-CIRCLE function are designed to produce.

It is important to understand that these patterns are able to be created because they obey certain basic rules about geometry.  For example, I mentioned above that all the functions create polygons. This is due to the fact that every polygon must have the interior sum of its angles equal to 360 degrees.  However, certain slight alterations like those mentioned above, are enough to change the shape and create a new one.  For example, if the DIRECTION slider started off at 0 in pattern-1, every hatching turtle would simply be moving forward by 0.5 steps as it was creating its pattern.  However, if we increase the slider by increments of 0.1, we notice that its movements seem to be getting tighter and tighter until it remains fixed in one place and keeps revolving around a point.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Geometron Top-Down model.  http://ccl.northwestern.edu/netlogo/models/GeometronTop-Down.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/GeometronTop-Down for terms of use.
"
Optical Illusions,/models/Sample Models/Art,"globals [caption]

;; runs automatically when model is opened
to startup
  set caption """"  ;; otherwise it would start out as 0
end

to illusion-1
  ca
  set caption ""What color are the circles?""
  set-default-shape turtles ""circle""
  ;; make the gray lines
  ask patches with [pxcor mod 5 = 0 or
                    pycor mod 5 = 0]
    [ set pcolor gray ]
  ;; make the circles
  ask patches with [pxcor mod 5 = 0 and
                    pycor mod 5 = 0]
    [ sprout 1
        [ set color white
          set size 1.7 ] ]
end

to illusion-2
  ca
  set caption ""Are the thick lines parallel?""
  ask patches
    [ set pcolor white ]
  ;; make 2 parallel lines
  ask patches with [abs pycor = 4]
    [ set pcolor black ]
  ;; make diagonal lines that start at the center
  ;; and go to different parts of the world
  crt 60
    [ set heading who * 6
      set color black
      set shape ""line""
      set size 100 ]
  ;; make a circle in the center
  crt 1
    [ set color black
      set shape ""circle""
      set size 5 ]
end

to illusion-3
  ca
  set caption ""Are the lines parallel?""
  set-default-shape turtles ""square""
  ask patches
    [ set pcolor gray ]
  ;; every fourth patch creates a square, either black or white
  ask patches with [pxcor mod 4 = 0 and
                    pycor mod 4 = 0]
    [ sprout 1
        [ set heading 0
          set size 4.8
          ifelse pxcor mod 8 = 0
            [ set color white ]
            [ set color black ] ] ]
  ;; move every other row over 1 to the right
  ask turtles with [pycor mod 16 = 4]
    [ set xcor xcor + 1 ]
  ;; move every other row over 1 to the left
  ask turtles with [pycor mod 16 = 12 ]
    [ set xcor xcor - 1 ]
end

to illusion-4
  ca
  set caption ""Which inner circle is bigger?""
  set-default-shape turtles ""circle""

  ;; make right figure
  let counter 0
  ask patch -12 0
    [ ;; middle circle
      sprout 1
        [ set color white
          set size 5
          ;; 6 smaller circles around the middle circle
          hatch 6
            [ set size 2.5
              set heading 60 * counter
              fd 4
              set counter counter + 1 ] ] ]
  ;; make left figure
  set counter 0
  ask patch 6 0
    [ ;; middle circle
      sprout 1
        [ set color white
          set size 5
          ;; 6 larger circles around the middle circle
          hatch 6
            [ set size 8
              set heading 60 * counter
              fd 8
              set counter counter + 1 ] ] ]
end

to illusion-5
  ca
  set caption ""Stare at the dot, then lean forward and back.""
  ask patches
    [ set pcolor gray ]
  ;; make the inside circle of diamonds
  ;; use ordered turtles so the circle is evenly spaced
  create-ordered-turtles 32
    [ set size 2
      set shape ""diamond1""
      fd 12 ]
  ;; make the outside circle of diamonds
  ;; use ordered turtles so the circle is evenly spaced
  create-ordered-turtles 40
    [ set size 2
      set shape ""diamond2""
      fd 15 ]
  ;; make the dot in the middle
  crt 1
    [ set shape ""circle""
      set color black ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2005 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2005).  NetLogo Optical Illusions model.
; http://ccl.northwestern.edu/netlogo/models/OpticalIllusions.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2005 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/OpticalIllusions
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model presents five classic optical illusions.


HOW IT WORKS
------------
The optical illusions are constructed using a combination of NetLogo turtles and patches.

ILLUSION #1 -- White circles on a gray background produce an illusion of the circles changing colors between black and white, depending on where you focus your eyes.

ILLUSION #2 -- Diagonals moving away from the center create an illusion of depth, which makes the parallel horizontal lines seem to bend in the center.

ILLUSION #3 -- The perpendicular lines that do not match row to row create an illusion of the lines between them being not parallel.

ILLUSION #4 -- Relative sizes of other circles skew the perception of the middle circles, creating an illusion of difference in size.

ILLUSION #5 -- Circles of diamonds seem to rotate you focus your eyes on their center.


HOW TO USE IT
-------------
Press a button to choose an illusion, and it will be presented in the NetLogo view.

Some explanatory text will appear in the monitor below the view.


EXTENDING THE MODEL
-------------------
Add more illusions.


NETLOGO FEATURES
----------------
Many of the illusions in the model, such as illusions 2, 4 and 5, involve turtles positioned in a circle around a middle point.  Optical Illusions is a great example of the use of FORWARD and HEADING to position objects in a pattern.


RELATED MODELS
--------------
Other models that were created ""for fun"" include Frogger, Lunar Lander and other games included in the Games section of the Models Library.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (2005).  NetLogo Optical Illusions model.  http://ccl.northwestern.edu/netlogo/models/OpticalIllusions.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2005 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/OpticalIllusions for terms of use.
"
Follower,/models/Sample Models/Art,"turtles-own [
  leader    ;; the turtle this turtle is following,
            ;; or nobody if not following
  follower  ;; the turtle that is following this turtle,
            ;; or nobody if not being followed
]

to setup
  clear-all
  crt population
  [ set color magenta
    setxy random-xcor random-ycor
    set leader nobody
    set follower nobody ]
  setup-plot
  update-plot
end

to go
  ask turtles
  [ if leader = nobody
    [ attach-turtle ] ]
  ask turtles [ turn-turtle ]
  ask turtles [ fd 1 ]
  tick
  update-plot
end

to attach-turtle  ;; turtle procedure
  ;; find a random patch to test inside the donut
  let xd near-radius + random (far-radius - near-radius)
  let yd near-radius + random (far-radius - near-radius)
  if random 2 = 0 [ set xd (- xd) ]
  if random 2 = 0 [ set yd (- yd) ]
  ;; check for free turtles on that patch
  let candidate one-of (turtles-at xd yd) with [follower = nobody]
  ;; if we didn't find a suitable turtle, stop
  if candidate = nobody [ stop ]
  ;; we're all set, so latch on!
  ask candidate [ set follower myself ]
  set leader candidate
  ;; change our color
  ifelse follower = nobody
  [ set color lime ]
  [ set color sky
    set shape ""line"" ]
  ;; change our leader's color
  ask candidate
  [ ifelse leader = nobody
    [ set color yellow ]
    [ set color sky
      set shape ""line"" ] ]
end

to turn-turtle  ;; turtle procedure
  ;; if we are still unattached...
  ifelse leader = nobody
  ;; do a somewhat random glide
  [ rt random-float waver - random-float waver ]
  ;; otherwise follow the leader
  [ face leader ]
end

to setup-plot
  set-current-plot ""Turtle Count""
  set-plot-y-range 0 population
end

to update-plot
  set-current-plot-pen ""unattached""
  plot count turtles with [color = magenta]
  set-current-plot-pen ""heads""
  plot count turtles with [color = yellow]
  set-current-plot-pen ""bodies""
  plot count turtles with [color = sky]
  set-current-plot-pen ""tails""
  plot count turtles with [color = lime]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Follower model.
; http://ccl.northwestern.edu/netlogo/models/Follower.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Follower
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
In Follower, turtles attempt to ""connect"" with other turtles, forming long chains according to a small set of simple rules.

In the model, a turtle can follow only ONE other turtle, and similarly it can only be followed by ONE other turtle. This means there are four turtle states, each represented by a different color:
- Magenta: Unattached
- Green: Following another turtle (a ""tail"")
- Yellow: Being followed by another turtle (a ""head"")
- Blue: Following and being followed by other turtles (a ""body"" segment)

Turtles are created in the magenta (unattached) state. At each turn, each turtle checks a random patch in a square donut shape around itself. If it finds a turtle there who is not already being followed, it will ""latch on"" and start following the movements of that turtle. An unattached turtle (one that has not yet ""latched on"" to another turtle) will move randomly.


HOW TO USE IT
--------------
SETUP: Clears the world and creates the number of turtles specified in the POPULATION slider. All the turtles are created in an unattached state (magenta).

GO: Runs the simulation.

POPULATION: Specifies the number of turtles created in SETUP.

NEAR-RADIUS: The inner radius of the square donut turtles search in.

FAR-RADIUS: The outer radius of the square donut turtles search in.

WAVER: The amount of randomness in the movement of non-following turtles.

There is also a plot called ""Turtle Count"" that displays, over time, the number of turtles in each state.


THINGS TO NOTICE
----------------
Each of the sliders has a different effect on the simulation.

Notice that the when the number of turtles is high, chains tend to form very quickly. This is because there are more turtles and therefore more chances for each turtle to attach on each turn.

Varying the size of the donut tends to affect how the turtles start to attach, but in the long run doesn't have a big effect on the simulation outcome. Donut size is most interesting at very small values, which causes the turtles to attach into very small loops. Also, very large thick donuts (big FAR-RADIUS, small NEAR-RADIUS) looks interesting with a large number of turtles.

The amount of movement randomness (set by WAVER) can also change the simulation outcome. Very high values for WAVER result in small loops being formed because the turtles are continuously moving over themselves, increasing the chances of connecting the head of the chain to its tail.

The simulation, under any parameters, moves towards forming loops. Loops may be formed by wrapping around the world, but in almost all cases if the simulation is left running long enough you will get many small loops or one big loop. It is possible that a chain will never connect to itself if the WAVER slider is set to zero, but otherwise the simulation should proceed towards loops.


THINGS TO TRY
-------------
Try making the waver setting very high. Notice how the turtles clump up into little clusters. This is because they are moving over themselves frequently, which increases the chances of attaching to their tail. This makes sense if the donut allows the turtles to check close to themselves, but if it does not (NEAR-RADIUS is big) then the same thing still happens. Why is this the case?

Notice that we are plotting all four possible turtle states, but only three appear on the plot. Do you know why?


EXTENDING THE MODEL
-------------------
Try implementing different rules for how turtles follow each other. For instance, interesting results can be seen if you turn off world wrapping. Or, what if two turtles are allowed to have the same leader?

You might also try giving the turtles a certain probability of breaking apart again. See how this affects the patterns they make.


NETLOGO FEATURES
----------------
Note the use of the TOWARDS primitive to make the turtles follow each other.

Note also that we are careful to ensure that we never have two turtles following the same leader.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Follower model.  http://ccl.northwestern.edu/netlogo/models/Follower.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Follower for terms of use.
"
Vants,/models/Sample Models/Computer Science,"to setup
  clear-all
  ask patches
    [ set pcolor white ]
  crt num-vants
    [ face one-of neighbors4
      set color red
      set size 6 ]    ;; much easier to see this way
end

;; We can't use ""ask turtles"", because then the vants would
;; execute in a different random order each time.  So instead
;; we use SORT to get the turtles in order by who number.

to go-forward
  foreach sort turtles [
    ask ? [
      fd 1
      turn
    ] ]
  tick
end

to go-reverse
  foreach reverse sort turtles [
    ask ? [
      turn
      bk 1
    ] ]
  tick
end

to turn
  ifelse pcolor = white
    [ set pcolor black
      rt 90 ]
    [ set pcolor white
      lt 90 ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2005 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2005).  NetLogo Vants model.
; http://ccl.northwestern.edu/netlogo/models/Vants.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2005 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Vants
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This is a basic virtual ant (""vant"") model.  It shows how extremely simple deterministic rule can result in very complex-seeming behavior.  It also demonstrates the concept of time reversibility and shows that time reversibility is not incompatible with complex behavior.


HOW IT WORKS
------------
The world is a grid of patches.  Each patch can be either black or white.  Initially, they are all white.

The rules the ""vants"" (virtual ants) follow are very simple.  Each vant faces north, south, east, or west.  At each time step, a vant moves to the next patch.  Then it looks at the new patch:

- If the new patch is white, the vant colors the patch black and turns right 90 degrees.

- If the new patch is black, the vant colors the patch white and turns left 90 degrees.

That's it!

The world wraps, so when a vant moves off one side of the view it reappears at the other side.


HOW TO USE IT
-------------
The SETUP button colors all the patches white and creates a number of vants determined by the the NUM-VANTS slider.

Pressing the FORWARD button makes the vants start to move according to the normal rules.

You can stop the FORWARD button and then press the REVERSE button instead to make the vants move backwards instead of forwards, while still following the same turning rule.

The model runs fairly slowly by default, so you can see every step the vants take.  You may want to use the speed slider to speed the model up so you can see what happens when a lot of time passes.


THINGS TO NOTICE
----------------
To make it easier to see, the vant is shown as larger than a patch.

The resulting patterns sometimes have obvious structure, but sometimes appear random, even though the rules are deterministic.

Call the diagonal paths that form ""highways"".  Are there different kinds of highways?


THINGS TO TRY
-------------
Compare the results with one vant to those with multiple vants.  Are there any behaviors you get with multiple vants that don't occur with just one?

When there are multiple vants, they are initially given random headings.  That means that you may get different looking behavior even with the same number of vants, depending on the directions they start out facing.

If you press the REVERSE button, the vants turn then move backwards, instead of moving forwards then turning.  The turn rule is the same.  What effect does this have?  Press SETUP, run the model forwards a little, then stop the GO button and press REVERSE instead.


EXTENDING THE MODEL
-------------------
Without changing the rules, you could change the visualization by making different vants different colors and color-coding the patches to show which vant touched a patch last.  This should make some additional structure apparent to the eye.


NETLOGO FEATURES
----------------
You can use the SORT primitive to created a list of turtles sorted by who number.  That is necessary in this model because we need the turtles to execute in the same order at every tick, rather than a different random order every tick as would happen if we just said ""ask turtles"".


RELATED MODELS
--------------
Turing Machine 2D -- similar to Vants, but much more general.  This model can be easily configured to use Vants rules, or to use other rules.


CREDITS AND REFERENCES
----------------------
The rules for Vants were originally invented by the artificial life researcher Chris Langton.

To refer to this model in academic publications, please use:  Wilensky, U. (2005).  NetLogo Vants model.  http://ccl.northwestern.edu/netlogo/models/Vants.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2005 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Vants for terms of use.
"
Turing Machine 2D,/models/Sample Models/Computer Science,"turtles-own [rule-set bg fg state]
patches-own [on?]

to setup
  clear-all
  crt heads
  [
    set size 5
    set state 0    ;; initialize all head states to 0
    set heading 0
    fd who    ;; have all the turtles line up vertically
    set bg black
    ifelse color-paths?  ;; if show-path? is enabled, color the turtles
      [ set fg color ]
      [ set fg white ]
  ]
  ask patches [ set on? false ] ;; clear cell values
end

to setup-example
  if example = 1
    [ apply-rules [[1 180 true] [1 90 true] [0 180 true] [1 270 true]] ]
  if example = 2
    [ apply-rules [[0 270 true] [1 180 false] [1 90 true] [0 0 true]] ]
  if example = 3
    [ apply-rules [[1 90 false] [0 90 true] [0 0 false] [0 180 false]] ]
  if example = 4
    [ apply-rules [[0 90 true] [0 0 false] [0 270 false] [0 0 false]] ]
  if example = 5
    [ apply-rules [[1 180 true] [1 270 true] [0 270 true] [1 90 false]] ]
  setup
end

to go
  ask turtles [ set rule-set find-rule ]
  ask turtles [
    set on? last rule-set
    ifelse on?
      [ set pcolor fg ]
      [ set pcolor bg ]
  ]
  ask turtles [
    rt item 1 rule-set
    fd 1
    set state first rule-set
  ]
  tick
end

;; find the rule to use for current head state and cell state
to-report find-rule  ;; turtle procedure
  ifelse on?  ;; check state of this patch
  [
    if state = 0 [ report fput on-0-state list (direction-to-number on-0-turn) on-0-on? ]
    if state = 1 [ report fput on-1-state list (direction-to-number on-1-turn) on-1-on? ]
  ]
  [
    if state = 0 [ report fput off-0-state list (direction-to-number off-0-turn) off-0-on? ]
    if state = 1 [ report fput off-1-state list (direction-to-number off-1-turn) off-1-on? ]
  ]
end

;; change the current configuration to the given list of rules
to apply-rules [l]
  set off-0-state  item 0 item 0 l
  set off-0-turn   number-to-direction (item 1 item 0 l)
  set off-0-on?    item 2 item 0 l
  set off-1-state  item 0 item 1 l
  set off-1-turn   number-to-direction (item 1 item 1 l)
  set off-1-on?    item 2 item 1 l
  set on-0-state   item 0 item 2 l
  set on-0-turn    number-to-direction (item 1 item 2 l)
  set on-0-on?     item 2 item 2 l
  set on-1-state   item 0 item 3 l
  set on-1-turn    number-to-direction (item 1 item 3 l)
  set on-1-on?     item 2 item 3 l
end

to-report direction-to-number [direction]
  if direction = ""--""
    [ report 0 ]
  if direction = ""Right""
    [ report 90 ]
  if direction = ""Backwards""
    [ report 180 ]
  if direction = ""Left""
    [ report 270 ]
end

to-report number-to-direction [number]
  if number = 0
    [ report ""--"" ]
  if number = 90
    [ report ""Right"" ]
  if number = 180
    [ report ""Backwards"" ]
  if number = 270
    [ report ""Left"" ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2002 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2002).  NetLogo Turing Machine 2D model.
; http://ccl.northwestern.edu/netlogo/models/TuringMachine2D.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2002 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/TuringMachine2D
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
A Turing machine, first proposed by Alan Turing in 1936, is a simple computing machine capable of doing anything a modern computer can do.  A traditional Turing machine has a single processor, or ""head,"" with a limited number of internal states that change depending on the data that is read by the head.  As the Turing machine computes, the head moves back and forth across the tape, changing its internal state and the value of the current cell.

This is a model of a multi-headed Turing machine on a 2 dimensional tape (2D MTM), which is an extension of the original machine proposed by Turing in 1936. 2D MTMs can be emulated on a single headed one dimensional Turing machine (TM), but the rules of a 2D MTM may be significantly simpler than those of a traditional TM emulating a 2D MTM.  In the model, there can be up to 256 ""heads"" which all follow the same set of basic rules.  In this 2-state 2D MTM, the head may change its state, the value of its current cell, and move either north, east, west, or south, depending on whether or not the current cell is on or off and its current state.

This model demonstrates how multiple processors may interact with each other to complete complex processing tasks. It also shows that these machines can be heavily dependent on the number of processing agents. In addition to exploring the complexity of parallel computation, this model also demonstrates some of the caveats of parallel algorithms.


HOW IT WORKS
-------------
On each turn, each head moves forward. Depending on whether the patch (""cell"") it's over is ""on"" (showing color) or ""off"" (invisible), the head will use the rule which transitions from its current state to the new state. In other words, if head A (which is in state 1, with position 2) is over cell B (which is on), then the on-1-state will show what the next state will be, the on-1-position slider will show what the next position will be for that head (0: North, 1: East, 2: South, 3: West), and if on-1-on? is true, then it will remain on. If on-1-on? is false, then it will turn off, becoming invisible.


HOW TO USE IT
-------------
HEADS: the number of heads used by the Turing machine

COLOR-PATHS?: Tells the heads to write color information onto the cell. This feature allows the user to analyze both the information written and the process in which it was written. It is only a device to keep track of which cell had been most recently turned on by a particular head; it does not affect on/off data written on the tape: colored cells are on, black cells are off.

HEAD-SIZE: How large the head, or turtle appears.

The rules of all heads are given by three parameters:
[cell state]-[head state]-state [cell state]-[head state]-position [cell state]-[head state]-on?

The prefix of each slider/toggle refers to the current state of the machine and the cell it is on.

First prefix  - current cell state: on/off
Second prefix - current state of head, which may be either 0 or 1


These prefixes specify the initial state which the following rules are applied to:

Turn- specifies what direction the head will turn before moving forward 1 cell
New Head State- specifies the new head state
New Cell State- specifies the state to apply to the current cell


THINGS TO NOTICE
----------------
Here are some interesting phenomena that occur with the example setups:

Example 1: In the first example, the machine does nothing with only one head. With two or more heads, the heads cooperate with each other to fill the tape with data in a repetitive fashion forming a shape similar to a square rotated by 45 degrees.  When the heads wrap around and converge with the written data, they get stuck in a loop and do not write any more data. If the tape was infinite, the growth of the square would be unbounded.

Example 2: Like the first example, the processors also aid each other in filling up the tape with data.  The pattern they form is less symmetric, and two processors may get stuck in a small loop with each other as the tape gets filled with data, potentially stunting the growth of the data.  This is an example where multiprocessing fails to work effectively.  This is analogous common problems faced by parallel algorithms. The processing of shared resources between multiple processors may conflict with proper functioning.

Example 3: This example demonstrates the codependency of processors to perform complex computational tasks.  If a head does not have a pair, it will get stuck in a tight loop and not be able to process data.  The minimum number of heads required to produce chaotic behavior is 3 heads.  Greater numbers of heads will produce chaotic behavior that will most likely produce complex patterns.  Often times, the movement of heads is short lived and the entire machine will get stuck in a loop.

Example 4: This particular type of Turing machine is commonly known as Langton's vants (see references for more information).  In this example, the head evaluates only the state of the current cell. If it is black, it changes the cell to white, turns white, and moves forward. If the cell is white, it turns off the cell, and turns left. With a single head, the van"" moves chaotically on the tape, eventually creating ""highways"" of repetitive patterns that diverge from the main cluster.  The behavior of this machine is highly dependent on its initial configuration.  When small odd numbers of heads are created, they behave like the classic vants, moving randomly, building highways which other heads may follow and possibly deconstruct. When the machine is initially setup with an even number of heads arranged vertically, the heads will follow each other forming a shape similar to a rotated square which is constantly expanding. Once the square wraps around the horizontal edges, the system becomes chaotic.  This is an example where pairs of ""chaotic"" computational machines may combine to produce a somewhat stable behavior.

Example 5: The rules of this machine is very similar to that of Langton's vants, and its behavior is similar but has more stable properties. With two processors, there is a tight loop that doesn't seem to go anywhere.  Larger even numbers of heads create a 1-bit path which stably oscillates back and forth.  The processing of data remains constrained.  Odd numbers of heads start off similarly to even numbers of heads, but unwind as they oscillate.  Their growth is unconstrained and chaotic, with behavior very similar to vants.  When the number of heads is even and exceeds 128 processors (the tape has 256x256 cells), the end of the path being drawn hits the point of origin of the path and behaves similarly to configurations with larger odd numbers of heads.  This model demonstrates that pairs of ""chaotic"" heads can produce very stable behavior given the proper initial conditions.


THINGS TO TRY
-------------
Start by tinkering around with the number of heads in the example models, and consider the following:

How do the heads interact with each other?

What can you conclude about the number of heads in relation to the complexity of their execution?

Can you find any other configurations that will yield interesting results?


EXTENDING THE MODEL
-------------------
Change the starting position of the heads.  How does this affect the execution of the 2D MTM?

What happens to the execution of configurations when they start with random bits of data on the tape?

Try adding more states to the cells and/or heads to the model.  Do different types of complexities emerge?  Are there more states that yield complex behavior?


CREDITS AND REFERENCES
-----------------------
Langton, C. 1984. Self-reproduction in cellular automata. Physica D 10, 134-144
Langton, C. 1986. Studying artificial life with cellular automata. Physica D 22, 120-149
Sipser, M. 1997. Introduction to the Theory of Computation. PWS Publishing 125-147.
Wolfram, S. 2002. A New Kind of Science. Wolfram Media Inc.  Champaign, IL.
Pegg, E. 2002. Turmite. http://mathworld.wolfram.com/Turmite.html.

Thanks to Ethan Bakshy for his work on this model.

To refer to this model in academic publications, please use:  Wilensky, U. (2002).  NetLogo Turing Machine 2D model.  http://ccl.northwestern.edu/netlogo/models/TuringMachine2D.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2002 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/TuringMachine2D for terms of use.
"
CA Continuous,/models/Sample Models/Computer Science/Cellular Automata,"globals
[
  row             ;; current row we are now calculating
  done?           ;; flag used to allow you to press the go button multiple times
]

patches-own
[
  value           ;; some real number between 0 and 1
]

;; Setup general working environment.  The other setup procedures call this.
to setup-general
  set row max-pycor   ;; Set the current row to be the top
  set done? false
  cp ct
end

;; Setup for a single point
to setup-single
  setup-general
  reset-ticks
  ;; Set only the middle patch to be 1 on the top row
  ask patches with [pycor = row]
  [
    ifelse pxcor = 0
      [ set value 1 ]
      [ set value 0 ]
    color-patch
  ]
end

;; Setup for a random top row
to setup-random
  setup-general
  reset-ticks
  ;; Randomize the values of the top row
  ask patches with [pycor = row]
  [
    set value random-float max-value
    color-patch
  ]
end

;; This is called when auto-continue? is enabled or go is clicked after a run.
;; Setup the patches to continue a particular model run.  This will copy the i
;; bottom row of patches to the top row.
to setup-continue
  let value-list []
  if not done?  ;; make sure go has already been called
    [ stop ]

  set value-list map [[value] of ?] sort patches with [pycor = row]  ;; copy cell states from bottom row to a list
  setup-general
  ask patches with [pycor = row]  ;; copy states from list to top row
  [
    set value item (pxcor + max-pxcor) value-list
    color-patch
  ]
  set done? false
end

;; Run the model.
to go
  ;; Did we reach the bottom row?
  if row = min-pycor
  [
    ;; If auto-continue? is enabled or we are clicking go again,
    ;; we continue from the top, otherwise we stop
    ifelse auto-continue? or done?
    [
       set done? true
       display    ;; ensure all the patches get drawn before we clear
       setup-continue
    ]
    [
       set done? true
       stop
    ]
  ]

  ;; Go down a row
  set row (row - 1)

  ;; Calculate the values for the current row
  ask patches with [pycor = row]
  [
    calculate-value
    color-patch
  ]
  tick
end

to calculate-value  ;; patch procedure
  ;; Retrieve the three patches that touch this patch one row above it
  let top-neighbors neighbors with [pycor = [pycor] of myself + 1]

  ;; Calculate the average of their values
  let mean-value mean [value] of top-neighbors

  ;; Perform a function to the average and set it as our value
  set value iterated-map mean-value
end

;; This is a simple function that takes in a number, adds a constant to it and
;; only reports the decimal portion rounded to a given number of decimal places.
to-report iterated-map [x]
  report precision (fractional-part (add-constant + x))
                   precision-level
end

;; Scales the patch's color according to its value
to color-patch  ;; patch procedure
  set pcolor scale-color green value 0 2
end

;; Reports only the decimal part of the number
to-report fractional-part [x]
  report x - (int x)
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2003 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2003).  NetLogo CA Continuous model.
; http://ccl.northwestern.edu/netlogo/models/CAContinuous.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2003 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/CAContinuous
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This is a continuous cellular automaton, otherwise known as a ""coupled map lattice.""  (See CA 1D Elementary and CA 1D Totalistic if you are unfamiliar with cellular automata.)  It operates just like a standard cellular automaton, except for the fact that its states are not discrete, but continuous values.

In this particular continuous cellular automaton, the cell's values range from 0.0 to 1.0, 0.0 being black and 1.0 being green.

Unlike two- or three-state cellular automata, each cell in a continuous cellular automaton can ideally have infinite states, but is limited by the precision of the computer (in this case the maximum is 16 decimal places, which is the most NetLogo can handle). The continuous nature of the CA and its particular rules allow this model to generate a great deal of complex behavior under almost any settings.


HOW IT WORKS
------------
The rules are a cross between a totalistic cellular automaton and an iterated map.

An iterated map is a fixed map, or function, that is applied to a number repeatedly.  The iterated map that is used in this model takes in a number, adds a constant (ADD-CONSTANT) between 0 and 1, and then the fractional part of that number is taken.  For example, if the given number is 0.8 and the add-constant is 0.6, the sum would be 1.4, and the fractional part would be 0.4.

The cellular automaton is totalistic, which means that at every time step, each cell's new state is determined by taking the average of itself and its nearest neighbors, and then passing it through the iterated map.

The precision of the values in the cells is determined by the PRECISION slider.


HOW TO USE IT
-------------
Set up:
- SETUP SINGLE initializes the model with a single cell set to 1 in the center.
- SETUP RANDOM initializes the model with each initial cell being a random value ranging from 0 to MAX-VALUE

Parameters:
- ADD-CONSTANT is the constant added to the average value of the nearest cells before the fractional part is taken.
- PRECISION-LEVEL is the precision of the value of each cell, with a slider value of 1 being an accuracy of 1 decimal place, and 16 being an accuracy of 16 decimal places.

Running the model:
- GO begins running the model with the currently set parameters. It continues until it reaches the last row of patches.  If it is clicked again, GO will continue the run from the top.
- AUTO-CONTINUE? automatically wraps to the top once it reaches the last row when the switch is on


THINGS TO NOTICE
----------------
Like their discrete counterparts, continuous cellular automata exhibit certain classes of behavior:
Class I - cellular automaton is ordered and always ends up in a uniform state.
Class II - cellular automaton is ordered and produces repetitive patterns.
Class III - cellular automaton is ""chaotic,"" or almost completely random.
Class IV - cellular automaton is neither in class I, II, or III.  It exhibits ""complex"" behavior, which often lies between order and chaos.

Can you find any cellular automaton configurations that exhibit these properties?  What does this tell you about the nature of cellular automata?

Unlike elementary two-state cellular automata, certain configurations grow outwards at a rate that may be faster or slower than others, and less linear than the permitted one-cell per step growth in two-state cellular automata.  Why do you think this is?  What might this tell you about the relationship between the number of states and the growth of cellular automata?

The growth of continuous cellular automata is closely related to the continuity of space that it can produce.  With certain ADD-VALUES, this model is able to produce very smooth curves.  This is a sharp contrast to the jagged triangular patterns often found in two or three state cellular automata.  Why do you think this happens?  What might this tell you about the relationship between the number of states and spatial continuity in cellular automata?

Structures might seem to spontaneously occur from parts that seem very regular, especially when the model is run with initial random conditions with a with a very small MAX-VALUE.  It is important to note that this is generally caused by small changes in cell values that cannot be seen due to the color limitations of NetLogo, and ultimately the human eye.


THINGS TO TRY
-------------
Try these with single point initial conditions:

Run the model with ADD-CONSTANT set to 0.0 and 1.0. Why do they produce the same pattern?

Why does it make sense that an ADD-CONSTANT of 0.5 produces relatively solid alternating green and black patterns?  Why does the line produced by the rule diffuse faster when the ACCURACY is higher?

Set the MAX-VALUE slider to a number between 0 and 0.10, and click setup random. Run the model a couple of times with different values for MAX-VALUE:
- Why do you think there is a delay in the occurrence of complex structures?
- Is there a relationship between the initial MAX-VALUE and the length of the delay?  If so, Why?

Change ADD-CONSTANT back to 0.47, and experiment with different values of the ACCURACY slider:
- How does the accuracy affect the patterns?
- How come the effect of the accuracy is more noticeable after a large number of steps? - Why might low accuracies create incongruities in the cellular automata?

Try out different ADD-CONSTANTS under various the ACCURACY slider values.  Now ask yourself, what disadvantages do computer-simulated continuous cellular automata have that discrete cellular automata do not?


EXTENDING THE MODEL
-------------------
There are many iterated maps that could be used to produce chaotic or complex behavior in a continuous cellular automaton.  Try coming up with your own iterated map function.

Try increasing the spatial continuity of the model by increasing the number of neighbors each cell has on either side.

Try making your own number data structure that has a greater accuracy than the normal NetLogo math primitives permit.

Can you come up with a new coloring function to represent values using a wider array of colors, not just a gradient between green and black?


RELATED MODELS
--------------
CA 1D Elementary- the elementary two-state 1D cellular automaton
CA 1D Totalistic- a three-state totalistic 1D cellular automaton
Turbulence (in the Chemistry & Physics section)- a 1D continuous cellular automaton which demonstrates turbulence


CREDITS AND REFERENCES
----------------------
Pattern Dynamics in Spatiotemporal Chaos: Kunihiko Kaneko. 1989 Physics D 34 1-41
A New Kind of Science. Wolfram, S. 2002. Wolfram Media Inc.  Champaign, IL.

Thanks to Eytan Bakshy for his work on this model.

To refer to this model in academic publications, please use:  Wilensky, U. (2003).  NetLogo CA Continuous model.  http://ccl.northwestern.edu/netlogo/models/CAContinuous.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2003 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/CAContinuous for terms of use.
"
Brians Brain,/models/Sample Models/Computer Science/Cellular Automata,"patches-own [
  firing?           ;; white cells
  refractory?       ;; red cells
  firing-neighbors  ;; counts how many neighboring cells are firing
]

to setup-blank
  clear-all
  ask patches
    [ cell-death ]
end

to setup-random
  clear-all
  ask patches
    [ ifelse random-float 1.0 < initial-density
        [ cell-birth ]
        [ cell-death ] ]
end

to cell-birth  ;; patch procedure
  set firing? true
  set refractory? false
  set pcolor white
end

to cell-aging  ;; patch procedure
  set firing? false
  set refractory? true
  set pcolor red
end

to cell-death  ;; patch procedure
  set firing? false
  set refractory? false
  set pcolor black
end

to go
  ask patches
    [ set firing-neighbors count neighbors with [firing?] ]
  ;; Starting a new ""ask patches"" here ensures that all the patches
  ;; finish executing the first ask before any of them start executing
  ;; the second ask.  This keeps all the patches in sync with each other,
  ;; so the births and deaths at each generation all happen in lockstep.
  ask patches
    [ ifelse firing?
        [ cell-aging ]
        [ ifelse refractory?
            [ cell-death ]
            [ if firing-neighbors = 2
                [ cell-birth ] ] ] ]
  tick
end

to add-cells [white?]
  while [mouse-down?]
    [ ask patch mouse-xcor mouse-ycor
        [ ifelse white?
            [ cell-birth ]
            [ cell-aging ] ]
       display ]

end

to remove-cells
  while [mouse-down?]
    [ ask patch mouse-xcor mouse-ycor
        [ cell-death ]
      display ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2002 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2002).  NetLogo Brians Brain model.
; http://ccl.northwestern.edu/netlogo/models/BriansBrain.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2002 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/BriansBrain
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This program is an example of a two-dimensional cellular automaton.  If you are not already familiar with 2D CA, see the model ""Life"" for a basic discussion.

Typical CAs use two cell states (live and dead), but Brian's Brian uses three: firing (white), refractory (red), and dead (black).

This CA is especially interesting to watch because it has many configurations that move steadily across the grid (as opposed to Life, which has only relatively few such configurations).


HOW IT WORKS
------------
Firing (white) cells always become refractory (red) at the next time step.

Refractory (red) cells always die (turn black) at the next time step.

A new firing (white) cell is born in any black cell that has exactly two firing (white) neighbors (of its eight surrounding cells).


HOW TO USE IT
-------------
The INITIAL-DENSITY slider determines the initial density of cells that are firing.  SETUP-RANDOM places these cells.  GO-FOREVER runs the rule forever.  GO-ONCE runs the rule once.

If you want to draw an initial pattern yourself, or add or remove cells in the middle of a run, turn on the ADD WHITE CELLS, ADD RED CELLS, and REMOVE CELLS buttons, then ""draw"" with the mouse in the view.


THINGS TO NOTICE
----------------
Lots of patterns stay stable and move steadily across the grid.  Such patterns are often referred to as ""gliders"".  How many different types of gliders do you see?  Why does this happen?  How do the rules of the CA result in this behavior?


THINGS TO TRY
-------------
Are there any stable shapes that don't move?

Are there any ""glider guns"" (objects that emit a steady stream of gliders)?

On a small enough grid, usually the CA reaches a steady state where there may be movement but nothing new happens.  In Brian's Brain, a square grid usually reaches a steady state more quickly than a rectangular grid (try it!).  Why?


EXTENDING THE MODEL
-------------------
Many other interesting 3-state 2D automata exist.  Experiment with variations on the rules in this model.


RELATED MODELS
--------------
See all of the other models in the ""Cellular Automata"" subsection of the ""Computer Science"" section of the NetLogo Models Library.


CREDITS AND REFERENCES
----------------------
Brian's Brain was invented by Brian Silverman.

To refer to this model in academic publications, please use:  Wilensky, U. (2002).  NetLogo Brians Brain model.  http://ccl.northwestern.edu/netlogo/models/BriansBrain.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2002 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/BriansBrain for terms of use.
"
Life Turtle-Based,/models/Sample Models/Computer Science/Cellular Automata,"breed [cells cell]    ;; living cells
breed [babies baby]   ;; show where a cell will be born

patches-own [
  live-neighbors  ;; count of how many neighboring cells are alive
]

to setup-blank
  clear-all
  set-default-shape cells ""circle""
  set-default-shape babies ""dot""
  ask patches
    [ set live-neighbors 0 ]
end

to setup-random
  setup-blank
  ;; create initial babies
  ask patches
    [ if random-float 100.0 < initial-density
        [ sprout-babies 1 ] ]
  ;; grow the babies into adult cells
  go
  reset-ticks  ;; set the tick counter back to 0
end

;; this procedure is called when a cell is about to become alive
to birth  ;; patch procedure
  sprout-babies 1
    [ ;; soon-to-be-cells are lime
      set color lime + 1 ]  ;; + 1 makes the lime a bit lighter
end

to go
  ;; get rid of the dying cells from the previous tick
  ask cells with [color = gray]
    [ die ]
  ;; babies become alive
  ask babies
    [ set breed cells
      set color white ]
  ;; All the live cells count how many live neighbors they have.
  ;; Note we don't bother doing this for every patch, only for
  ;; the ones that are actually adjacent to at least one cell.
  ;; This should make the program run faster.
  ask cells
    [ ask neighbors
       [ set live-neighbors live-neighbors + 1 ] ]
  ;; Starting a new ""ask"" here ensures that all the cells
  ;; finish executing the first ask before any of them start executing
  ;; the second ask.
  ;; Here we handle the death rule.
  ask cells
    [ ifelse live-neighbors = 2 or live-neighbors = 3
        [ set color white ]
        [ set color gray ] ] ;; gray cells will die next round
  ;; Now we handle the birth rule.
  ask patches
    [ if not any? cells-here and live-neighbors = 3
        [ birth ]
      ;; While we're doing ""ask patches"", we might as well
      ;; reset the live-neighbors counts for the next generation.
      set live-neighbors 0 ]
  tick
end

;; user adds cells with the mouse
to add-cells
  while [mouse-down?]
    [ ask patch mouse-xcor mouse-ycor
        [ if not any? cells-here
            [ ask turtles-here [ die ]  ;; old cells and babies go away
              sprout-cells 1 [ set color white ]
              update
              ask neighbors [ update ] ] ]
      display ]
end

;; user removes cells with the mouse
to remove-cells
  while [mouse-down?]
    [ ask patch mouse-xcor mouse-ycor
        [ ask turtles-here [ die ]
          update
          ask neighbors [ update ] ]
      display]
end

;; this isn't called from GO.  it's only used for
;; bringing individual patches up to date in response to
;; the user adding or removing cells with the mouse.
to update  ;; patch procedure
  ask babies-here
    [ die ]
  let n count cells-on neighbors
  ifelse any? cells-here
    [ ifelse n = 2 or n = 3
        [ ask cells-here [ set color white ] ]
        [ ask cells-here [ set color gray  ] ] ]
    [ if n = 3
        [ sprout-babies 1
            [ set color lime + 1 ] ] ]
  set live-neighbors 0  ;; reset for next time through ""go""
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2005 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2005).  NetLogo Life Turtle-Based model.
; http://ccl.northwestern.edu/netlogo/models/LifeTurtle-Based.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2005 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/LifeTurtle-Based
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model is the same as the Life model, but with a more attractive display.  This display is achieved by basing the model on turtles rather than patches.

This program is an example of a two-dimensional cellular automaton. A cellular automaton is a computational machine that performs actions based on certain rules.  It can be thought of as a board which is divided into cells (such as square cells of a checkerboard).  Each cell can be either ""alive"" or ""dead.""  This is called the ""state"" of the cell.  According to specified rules, each cell will be alive or dead at the next time step.

This particular cellular automaton is called The Game of Life. The rules of the game are as follows.  Each cell checks the state of itself and its eight surrounding neighbors and then sets itself to either alive or dead.  If there are less than two alive neighbors, then the cell dies.  If there are more than three alive neighbors, the cell dies.  If there are 2 alive neighbors, the cell remains in the state it is in.  If there are exactly three alive neighbors, the cell becomes alive. This is done in parallel and continues forever.

There are certain recurring shapes in Life, for example, the ""glider"" and the ""blinker"".  The glider is composed of 5 cells which form a small arrow-headed shape, like this:

|           X
|            X
|          XXX

This glider will wiggle across the world, retaining its shape.  A blinker is a group of three cells (either up and down or left and right) that rotates between horizontal and vertical orientations.


HOW TO USE IT
-------------
The INITIAL-DENSITY slider determines the initial density of cells that are alive.  SETUP-RANDOM places these cells.  GO-FOREVER runs the rule forever.  GO-ONCE runs the rule once.

As the model runs, a small green dot indicates where a cell will be born, but is not treated as a live cell.  Grey cells are cells that are about to die, but are treated as live cells.

If you want to draw your own pattern, use the ADD-CELLS button and REMOVE-CELLS button and then use the mouse to ""draw"" in the view.  Make sure only one of the two buttons is active -- if they're both active, you'll get unexpected behavior.

CURRENT DENSITY is the percent of cells that are on.


THINGS TO NOTICE
----------------
Find some objects that are alive, but motionless.

Is there a ""critical density"" - one at which all change and motion stops/eternal motion begins?


THINGS TO TRY
-------------
Are there any recurring shapes other than gliders and blinkers?

Build some objects that don't die (using ""add-cells"")

How much life can the board hold and still remain motionless and unchanging? (use ""add-cells"")

The glider gun is a large conglomeration of cells that repeatedly spits out gliders.  Find a ""glider gun"" (very, very difficult!).


EXTENDING THE MODEL
-------------------
Give some different rules to life and see what happens.

Experiment with using neighbors4 instead of neighbors (see below).


NETLOGO FEATURES
----------------
The neighbors primitive returns the agentset of the patches to the north, south, east, west, northeast, northwest, southeast, and southwest.

neighbors4 is like neighbors but only uses the patches to the north, south, east, and west.  Some cellular automata, like this one, are defined using the 8-neighbors rule, others the 4-neighbors.


RELATED MODELS
--------------
Life - same as this, but implemented using only patches, not turtles
CA 1D Elementary - a model that shows all 256 possible simple 1D cellular automata
CA 1D Totalistic - a model that shows all 2,187 possible 1D 3-color totalistic cellular automata
CA 1D Rule 30 - the basic rule 30 model
CA 1D Rule 30 Turtle - the basic rule 30 model implemented using turtles
CA 1D Rule 90 - the basic rule 90 model
CA 1D Rule 110 - the basic rule 110 model
CA 1D Rule 250 - the basic rule 250 model


CREDITS AND REFERENCES
-------------------
The Game of Life was invented by John Horton Conway.

See also:

Von Neumann, J. and Burks, A. W., Eds, 1966. Theory of Self-Reproducing Automata. University of Illinois Press, Champaign, IL.

""LifeLine: A Quarterly Newsletter for Enthusiasts of John Conway's Game of Life"", nos. 1-11, 1971-1973.

Martin Gardner, ""Mathematical Games: The fantastic combinations of John Conway's new solitaire game `life',"", Scientific American, October, 1970, pp. 120-123.

Martin Gardner, ""Mathematical Games: On cellular automata, self-reproduction, the Garden of Eden, and the game `life',"", Scientific American, February, 1971, pp. 112-117.

Berlekamp, Conway, and Guy, Winning Ways for your Mathematical Plays, Academic Press: New York, 1982.

William Poundstone, The Recursive Universe, William Morrow: New York, 1985.

To refer to this model in academic publications, please use:  Wilensky, U. (2005).  NetLogo Life Turtle-Based model.  http://ccl.northwestern.edu/netlogo/models/LifeTurtle-Based.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2005 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/LifeTurtle-Based for terms of use.
"
CA 1D Elementary,/models/Sample Models/Computer Science/Cellular Automata,"globals
[
  row           ;; current row
  old-rule      ;; previous rule
  rules-shown?  ;; flag to check if rules have been displayed
  gone?         ;; flag to check if go has already been pressed
]

patches-own
[on?]

to startup  ;; initially, nothing has been displayed
  set rules-shown? false
  set gone? false
  set old-rule rule
end

;;;;;;;;;;;;;;;;;;;;;;;;
;;; Setup Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;

to setup-general  ;; setup general working environment
  cp ct
  set row max-pycor   ;; reset current row
  refresh-rules
  set gone? false
  set rules-shown? false  ;; rules are no longer shown since the view has been cleared
end

to single-cell
  setup-general
  reset-ticks
  ask patches with [pycor = row] [set on? false set pcolor background]  ;; initialize top row
  ask patch 0 row [ set pcolor foreground ]  ;; setup single cell in top center
  ask patch 0 row [ set on? true ]
end

to setup-random
  setup-general
  reset-ticks
  ask patches with [pycor = row]  ;; randomly place cells across the top of the world
  [
    set on? ((random-float 100) < density)
    color-patch
  ]
end


to setup-continue
  let on?-list []
  if not gone?  ;; make sure go has already been called
    [ stop ]
  set on?-list map [[on?] of ?] sort patches with [pycor = row]  ;; copy cell states from the
                                                                 ;; current row to a list
  setup-general
  ask patches with [ pycor = row ]
  [
    set on? item (pxcor + max-pxcor) on?-list  ;; copy states from list to top row
    color-patch
  ]
end


;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; GO Procedures      ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

to go
  if (rules-shown?)  ;; don't do unless we are properly set up
    [ stop ]
  if (row = min-pycor)  ;; if we reach the end, continue from the top or stop
  [
    ifelse auto-continue?
    [
        set gone? true
        display    ;; ensure everything gets drawn before we clear it
        setup-continue
    ]
    [
      ifelse gone?
        [ setup-continue ]       ;; a run has already been completed, so continue with another
        [ set gone? true stop ]  ;; otherwise just stop
    ]
  ]
  ask patches with [ pycor = row ]  ;; apply rule
    [ do-rule ]
  set row (row - 1)
  ask patches with [ pycor = row ]  ;; color in changed cells
    [ color-patch ]
  tick
end


to do-rule  ;; patch procedure
  let left-on? [on?] of patch-at -1 0  ;; set to true if the patch to the left is on
  let right-on? [on?] of patch-at 1 0  ;; set to true if the patch to the right is on

  ;; each of these lines checks the local area and (possibly)
  ;; sets the lower cell according to the corresponding switch
  let new-value
    (iii and left-on?       and on?       and right-on?)          or
    (iio and left-on?       and on?       and (not right-on?))    or
    (ioi and left-on?       and (not on?) and right-on?)          or
    (ioo and left-on?       and (not on?) and (not right-on?))    or
    (oii and (not left-on?) and on?       and right-on?)          or
    (oio and (not left-on?) and on?       and (not right-on?))    or
    (ooi and (not left-on?) and (not on?) and right-on?)          or
    (ooo and (not left-on?) and (not on?) and (not right-on?))
  ask patch-at 0 -1 [ set on? new-value ]
end


;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Utility Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

to color-patch  ;;patch procedure
  ifelse on?
    [ set pcolor foreground ]
    [ set pcolor background ]
end


to-report bindigit [number power-of-two]
  ifelse (power-of-two = 0)
    [ report floor number mod 2 ]
    [ report bindigit (floor number / 2) (power-of-two - 1) ]
end

to refresh-rules  ;; update either switches or slider depending on which has been changed last
  ifelse (rule = old-rule)
  [
    if (rule != calculate-rule)
      [ set rule calculate-rule ]
  ]
  [ extrapolate-switches ]
  set old-rule rule
end

to extrapolate-switches
  ;; set the switches based on the slider
  set ooo ((bindigit rule 0) = 1)
  set ooi ((bindigit rule 1) = 1)
  set oio ((bindigit rule 2) = 1)
  set oii ((bindigit rule 3) = 1)
  set ioo ((bindigit rule 4) = 1)
  set ioi ((bindigit rule 5) = 1)
  set iio ((bindigit rule 6) = 1)
  set iii ((bindigit rule 7) = 1)
end

to-report calculate-rule
  ;; set the slider based on the switches
  let result 0
  if ooo [ set result result +   1 ]
  if ooi [ set result result +   2 ]
  if oio [ set result result +   4 ]
  if oii [ set result result +   8 ]
  if ioo [ set result result +  16 ]
  if ioi [ set result result +  32 ]
  if iio [ set result result +  64 ]
  if iii [ set result result + 128 ]
  report result
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; SHOW-RULES RELATED PROCEDURES ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

to show-rules  ;; preview cell state transitions
  setup-general
  ask patches with [pycor > max-pycor - 12]
    [ set pcolor gray - 1 ]
  let i 0
  foreach list-rules
  [
    let px (min-pxcor + i * floor (world-width / 8) + floor (world-width / 16)) - 4
    ask patch px (max-pycor - 4)
    [
      sprout 1
      [
        set xcor xcor - 3
        print-block item 0 ?  ;; left cell
        set xcor xcor + 3
        print-block item 1 ?  ;; center cell
        set xcor xcor + 3
        print-block item 2 ?  ;; right cell
        setxy (xcor - 3) (ycor - 3)
        print-block item 3 ?  ;; next cell state
        die
      ]
    ]
    set i (i + 1)
  ]
  set rules-shown? true
end

;; turtle procedure
to print-block [print-on?]  ;; draw a 3x3 block with the color determined by the state
  ask patches in-radius 1.5  ;; like ""neighbors"", but includes the patch we're on too
  [
    set on? print-on?
    color-patch
  ]
end

to-report list-rules  ;; return a list of state-transition 4-tuples corresponding to the switches
  report (list lput ooo [false false false]
               lput ooi [false false true ]
               lput oio [false true  false]
               lput oii [false true  true ]
               lput ioo [true  false false]
               lput ioi [true  false true ]
               lput iio [true  true  false]
               lput iii [true  true  true ])
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo CA 1D Elementary model.
; http://ccl.northwestern.edu/netlogo/models/CA1DElementary.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/CA1DElementary
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This program models one-dimensional cellular automata.  A cellular automaton (CA) is a computational machine that performs actions based on certain rules.  It can be thought of as a ""board"" which is divided into cells (such as the square cells of a checkerboard).  Each cell can be either on or off.  This is called the ""state"" of the cell.  The board is initialized with some cells on and some off.  A clock is then started and at each ""tick"" of the clock the rules are ""fired"" and this results in some cells turning ""on"" and some turning ""off"".

There are many kinds of cellular automata. In this model, we explore one-dimensional CA -- the simplest types of CA. In this case of one-dimensional cellular automata, each cell checks the state of itself and its neighbors to the left and right, and then sets the cell below itself to either ""on"" or ""off"", depending upon the rule.  This is done in parallel and continues until the bottom of the board.

This model explores all 256 possible CA rules that can be constructed by each cell checking only its immediate left and immediate right neighbor. Cellular automata can be created on any board size and dimension.

This model is one of a collection of 1D CA models. It is meant for the more sophisticated user. If you are seeing CA for the first time, we suggest you check out one of the simpler CA models such as CA 1D Rule 30.

In his book, ""A New Kind of Science"", Stephen Wolfram argues that simple computational devices such as CA lie at the heart of nature's patterns and that CAs are a better tool than mathematical equations for the purpose of scientifically describing the world.


HOW TO USE IT
-------------
Initialization & Running:
- SETUP-SINGLE initializes the model with a single cell on in the center.
- SETUP-RANDOM initializes the model with a percentage of the cells ""on."" The percentage on is determined by the DENSITY slider.
- AUTO-CONTINUE? CA automatically wraps top the top once it reaches the last row when the toggle is on
- GO begins running the model with the currently set rule. It runs until the end of the screen.  If it is pressed again, the CA continues the current run from the top, stopping again at the end of the screen.
- FOREGROUND & BACKGROUND set the ""on"" and ""off"" cell colors respectively.
- SHOW-RULES clears the view and gives a graphical preview of the rules.  The 8 cases are displayed across the top of the world. To run the model, you must press either SETUP-SINGLE or SETUP-RANDOM and then click GO.

Rule Setup:
There are 8 switches, the names of which correspond to cell states.  ""O"" means off, ""I"" means on. For example, the top switch is called ""OOO"".  (NOTE: the switch names are composed of the letters ""I"" and ""O"", not the numbers zero or one).  If this switch is set to ""on"", then the following rule is created: when a cell is off, its left neighbor cell is off and its right neighbor cell is off, then the cell below it will be set ""on"" at the next time step.  If this switch is set to 0, then the cell below it will be set to ""off"" at the next time step.  So, since each switch has two settings and there are eight switches, there are 256 (2^8) possible rules.  The current rule number is shown by the ""RULE"" slider, and it is calculated by changing a switch's name from binary to decimal and taking the sum of all the switches that are set to one.  For example, if ""011"" and ""001"" are set to ""on"" and all the rest are set to ""off"", then the rule number is 4 (011 = 3, 001 = 1, and 3 + 1 = 4)).

The RULE slider can also be moved to set the current rule.  Doing so will change the current state of the switches in the same way the switches set the rule.


THINGS TO NOTICE
----------------
What different patterns are formed by using a random setup versus a single setup?

Why do some rules always end up the same, regardless of the initial setup?

Are there rules that repeat a pattern indefinitely?

Are there rules that produce seemingly chaotic, random results?

Can all rules be classified into these above types? Are there more rule types than these?

Note that the pictures generated by this model do not exactly match the pictures in Wolfram's book, ""A New Kind of Science"". That's because Wolfram's book computes the CA as an infinite grid while the NetLogo model ""wraps"" around the horizontal boundaries. To get pictures closer to the ones in the book, you may need to increase the size of the world. You can increase the size of the world up to the available memory on your computer. However, the larger the world, the longer time it will take NetLogo to compute and display the results.


THINGS TO TRY
-------------
Find some rules that converge to all cells ""on"" or to all cells ""off"".

Are there any rules that conditionally converge to all cells ""on"" or all cells ""off"", depending upon the initial percentage of on/off cells?

A classic automaton is used to compute various things.  Can these cellular automata be used to compute anything?  How?

Experiment with the density variable and various types of rules. What are some relationships?


EXTENDING THE MODEL
-------------------
What if a cell's neighborhood was five cells -- two to the left, itself, and two to the right?

Classical CA use an ""infinite board"". The CAs shown here ""wrap"" around the horizontal edges of the world (sometimes known as a periodic CA or CA with periodic boundary condition). How would you implement a CA in NetLogo that comes closer to the infinite board?

Try making a two-dimensional cellular automaton.  The neighborhood could be the eight cells around it, or just the cardinal cells (the cells to the right, left, above, and below).

Can you develop some tools to analyze the behavior of CAs?  Compare different iterations from one continuation to the next of the same CA?  Compare different rules?


NETLOGO FEATURES
-----------------
This model takes advantage of a special optimization in the NetLogo compiler that makes the expression ""ask patches with [px/ycor = <local variable>]"" run much faster than it would otherwise.


RELATED MODELS
--------------
Life - an example of a two-dimensional cellular automaton
CA 1D Rule 30 - the basic rule 30 model
CA 1D Rule 30 Turtle - the basic rule 30 model implemented using turtles
CA 1D Rule 90 - the basic rule 90 model
CA 1D Rule 110 - the basic rule 110 model
CA 1D Rule 250 - the basic rule 250 model
CA 1D Totalistic - a model that shows all 2,187 possible 1D 3-color totalistic cellular automata.
CA Stochastic- the probabalistic counterpart to this model


CREDITS AND REFERENCES
-----------------------
Thanks to Eytan Bakshy, Geoff Hulette, and Erich Neuwirth for their help with this model.

The first cellular automaton was conceived by John Von Neumann in the late 1940's for his analysis of machine reproduction under the suggestion of Stanislaw M. Ulam. It was later completed and documented by Arthur W. Burks in the 1960's. Other two-dimensional cellular automata, and particularly the game of ""Life,"" were explored by John Conway in the 1970's. Many others have since researched CA's. In the late 1970's and 1980's Chris Langton, Tom Toffoli and Stephen Wolfram did some notable research. Wolfram classified all 256 one-dimensional two-state single-neighbor cellular automata. In his recent book, ""A New Kind of Science,"" Wolfram presents many examples of cellular automata and argues for their fundamental importance in doing science.

See also:

Von Neumann, J. and Burks, A. W., Eds, 1966. Theory of Self-Reproducing Automata. University of Illinois Press, Champaign, IL.

Toffoli, T. 1977. Computation and construction universality of reversible cellular automata. J. Comput. Syst. Sci. 15, 213-231.

Langton, C. 1984. Self-reproduction in cellular automata. Physica D 10, 134-144

Wolfram, S. 1986. Theory and Applications of Cellular Automata: Including Selected Papers 1983-1986. World Scientific Publishing Co., Inc., River Edge, NJ.

Bar-Yam, Y. 1997. Dynamics of Complex Systems. Perseus Press. Reading, Ma.

Wolfram, S. 2002. A New Kind of Science. Wolfram Media Inc.  Champaign, IL.

To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo CA 1D Elementary model.  http://ccl.northwestern.edu/netlogo/models/CA1DElementary.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/CA1DElementary for terms of use.
"
CA Stochastic,/models/Sample Models/Computer Science/Cellular Automata,"globals
[
  row    ;; current row we are now calculating
  done?  ;; flag set to allow you to press the go button multiple times
]

patches-own [on?]

;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; SETUP PROCEDURES     ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; setup general working environment.  the other setup procedures call this.
to setup-general
  cp
  set row max-pycor   ;; reset current row
  set done? false
end

;; setup a random selection of patches in the top row to have on? true
to setup-random
  setup-general
  reset-ticks
  clear-plot

  ;; randomly place cells across the top of the world
  ask patches with [pycor = row]
  [
    set on? ((random-float 100) < density)
    color-patch
  ]
end

;; setup the patches to continue a particular model run.  this will copy the bottom
;; row of patches to the top row.
to setup-continue
  let on?-list []

  ;; make sure go has already been called
  if not done?  [ stop ]

  if auto-clear?
  [
    clear-plot
    set-plot-x-range ticks (ticks + world-height)
  ]

  set on?-list map [ [on?] of ?] sort patches with [ pycor = row ]  ;; copy states from bottom row to list
  setup-general
  ask patches with [ pycor = row ]
  [
    set on? item (pxcor + max-pxcor) on?-list  ;; copy states from list to top row
    color-patch
  ]
  set done? false
end

;; setup the sliders to have specific values that are interesting to study
to setup-example
  if( example = 1 )
    [ set III 0 set IIO 50 set IOI 50 set IOO 50 set OII 50 set OIO 50 set OOI 50 set OOO 0 ]
  if( example = 2 )
    [ set III 0 set IIO 50 set IOI 0 set IOO 50 set OII 50 set OIO 100 set OOI 50 set OOO 100 ]
  if( example = 3 )
    [ set III 0 set IIO 50 set IOI 50 set IOO 66 set OII 50 set OIO 50 set OOI 100 set OOO 0 ]
  if( example = 4 )
    [ set III 0 set IIO 50 set IOI 50 set IOO 66 set OII 50 set OIO 50 set OOI 50 set OOO 0 ]
  if( example = 5 )
    [ set III 0 set IIO 100 set IOI 0 set IOO 66 set OII 100 set OIO 0 set OOI 66 set OOO 0 ]
  set density 25
  setup-random
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; RUNTIME PROCEDURES   ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; run the model.  this applies the current rules to the patches with pycor equal to row.
;; if that row of patches is the bottom row and auto-continue? is true, we will setup the
;; model to continue.
to go
   ;; if the end has been reached, continue from the top or stop
  if (row = min-pycor)
  [
    ifelse auto-continue?
    [
       ;; if we are stuck in an absorbing state, there is not reason to continue
       ifelse( ((sum ([true-false-to-int on?] of patches with [pycor = row]) = 0) and OOO = 0.0) or
               ((sum ([true-false-to-int on?] of patches with [pycor = row]) = world-width)
                 and III = 100.0))
         [ stop ]
         [
           set done? true
           display    ;; ensure all the patches get drawn before we clear
           setup-continue
         ]
    ]
    [
      ;; if a run has already been completed, continue with another.  otherwise just stop
      ifelse done?
        [ setup-continue ]
        [
          set done? true
          stop
        ]
    ]
  ]
  ask patches with [ pycor = row ]  ;; apply rule
    [ do-rule ]

  if plot? [plot-entropy]

  set row (row - 1)
  ask patches with [ pycor = row ]  ;; color in changed cells
    [ color-patch ]

  tick
end

;; the patch will set the on? value of the patch below it based on three factors,
;; 1) its own on? value
;; 2) the on? values of the patches to the left and right of it
;; 3) the current settings for the rules
to do-rule  ;; patch procedure
  let left-on? [on?] of patch-at -1 0  ;; set to true if the patch to the left is on
  let right-on? [on?] of patch-at 1 0  ;; set to true if the patch to the right is on

  ;; each of these lines checks the local area and (possibly)
  ;; sets the lower cell according to the corresponding switch
  let new-value
    (III != 0  and left-on?       and on?       and right-on?          and (random-float 100) < III)    or
    (IIO != 0  and left-on?       and on?       and (not right-on?)    and (random-float 100) < IIO)    or
    (IOI != 0  and left-on?       and (not on?) and right-on?          and (random-float 100) < IOI)    or
    (IOO != 0  and left-on?       and (not on?) and (not right-on?)    and (random-float 100) < IOO)    or
    (OII != 0  and (not left-on?) and on?       and right-on?          and (random-float 100) < OII)    or
    (OIO != 0  and (not left-on?) and on?       and (not right-on?)    and (random-float 100) < OIO)    or
    (OOI != 0  and (not left-on?) and (not on?) and right-on?          and (random-float 100) < OOI)    or
    (OOO != 0  and (not left-on?) and (not on?) and (not right-on?)    and (random-float 100) < OOO)
  ask patch-at 0 -1 [ set on? new-value ]
end

;; plot topologic / metric entropy
to plot-entropy
  let i min-pxcor  ;; index of where in the row we are currently doing calculations
  ;; make a 16 element list for storing the number of occurrences of each distinct 4-patch pattern
  let counter-list n-values 16 [0]

  ;; fill the counter-list with the appropriate values.  that is to say, count
  ;; the number of occurrences of each distinct 4-patch pattern of on? values.
  while [ i < max-pxcor ]
  [
    let an-index binary-list-to-index (patches-to-binary-list i)
    set counter-list replace-item an-index counter-list (item an-index counter-list + 1)
    set i (i + 1)
  ]

  ;; make a list of the probabilities of each pattern occurring
  let prob-list map [? / (sum counter-list)] counter-list

  ;; X = 4 (correlation length): size of subsequences analyzed
  ;; topological entropy = 1/X * the log of the sum of the probabilities rounded up
  set-current-plot-pen ""topologic""
  plotxy ticks 1 / 4 * (log (sum (map [1] (filter [? > 0] prob-list))) 2)

  ;; metric entropy = -1/X * the sum of the products of each probability and its log
  set-current-plot-pen ""metric""
  plotxy ticks -1 / 4 * sum ( map[? * log ? 2] (filter [? > 0] prob-list) )
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; UTILITY PROCEDURES   ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; report the base 10 equivalent of a binary number represented by a list of 0's and 1's.
;; in the list, the 0th item is the highest power of 2 and the highest item is the lowest power.
to-report binary-list-to-index [binary-list]
  let list-sum 0
  let i 0
  let list-length length binary-list
  while [i < list-length ] [
    set list-sum list-sum + (2 ^ i) * ((item (list-length - i - 1) binary-list) mod 2)
    set i i + 1
  ]
  report list-sum
end

;; report a list of binary digits based on the values of on? for the current row's
;; patches starting at 'offset'
to-report patches-to-binary-list [offset]
  let binary-list []
  set binary-list lput ([true-false-to-int on?] of patch offset row) binary-list
  set binary-list lput ([true-false-to-int on?] of patch (offset + 1) row) binary-list
  set binary-list lput ([true-false-to-int on?] of patch (offset + 2) row) binary-list
  set binary-list lput ([true-false-to-int on?] of patch (offset + 3) row) binary-list
  report binary-list
end

;; convert true/false values to 1/0
to-report true-false-to-int [b]
  ifelse b
    [ report 1 ]
    [ report 0 ]
end

;; color the patch based on whether on? is true or false
to color-patch  ;; patch procedure
  ifelse on?
    [ set pcolor on-color ]
    [ set pcolor off-color ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2003 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2003).  NetLogo CA Stochastic model.
; http://ccl.northwestern.edu/netlogo/models/CAStochastic.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2003 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/CAStochastic
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This is a one-dimensional stochastic cellular automaton.  (See the CA 1D Elementary model if you are unfamiliar with cellular automata.)  Unlike most cellular automata, whose behavior is deterministic, the behavior of a stochastic cellular automaton is probabilistic.  Stochastic cellular automata are models of ""noisy"" systems in which processes do not function exactly as expected, like most processes found in natural systems.

The behavior of these cellular automata tend to be very rich and complex, often forming self-similar tree-like or chaotic behavior.  They are capable of mimicking many phenomena found in nature such as crystal growth, boiling, and turbulence.


HOW IT WORKS
------------
At each time step, every cell in the current row evaluates the state of itself and its immediate neighbors to the right and left.  There are 8 possible on/off rule configurations for every 3-cell neighborhood, each with a certain probability of turning on the cell below it at the next time step.  The rules are applied accordingly, and the next state of the cellular automaton appears in the row directly below, creating a space vs. time view of the cellular automaton's evolution.


HOW TO USE IT
-------------
Set up:
- SETUP RANDOM initializes the model with a percentage of the cells ""on"". The percentage on is determined by the DENSITY slider.
- SETUP EXAMPLE initializes the rule settings according to the EXAMPLE slider
- AUTO-CONTINUE? automatically wraps to the top once it reaches the last row when the switch is on
- GO begins running the model with the currently set rule. It runs until it reaches the bottom of the world.  If GO is pressed after it has completed, it will wrap to the top and continue.
- ON-COLOR & OFF-COLOR set the ""on"" and ""off"" cell colors respectively.

Rule Setup:
There are 8 sliders, the names of which correspond to cell states.  ""O"" means off, ""I"" means on. For example, the upper-right slider is called ""IIO,"" corresponding to the state where a cell and its left neighbor is on, and its right neighbor is off.  (NOTE: the switch names are composed of the letters ""I"" and ""O"", not the numbers zero or one, because NetLogo switches can't have numbers for names.)  If this slider is set to 70%, then the following rule is created: when a cell is on, its left neighbor cell is on and its right neighbor cell is off, then there is a 70% chance the cell below it will be set ""on"" at the next time step, otherwise the cell below it will be set to ""off"" at the next time step.

Plot:
This plot measures two types of entropy, or disorder in a system.  Cellular automata can produce patterns with varying degrees of randomness.  If a pattern is perfectly random, each subsequence occurs with an equal probability, and the entropy is 1.  The more likely certain subsequences occur, the lower the entropy.  If a pattern is perfectly ordered, then the entropy is 0.  In this plot, 4-cell subsequences (""correlation length"") are used to calculate the entropy. The first type of entropy is the spatial topologic entropy, which measures how many subsequences are present.  The second type of entropy, spatial metric entropy, measures the probability that all subsequences occur with the same frequency.

Plot Configuration:
- PLOT? switches plot on or off
- AUTO-CLEAR? if on, the plot is automatically cleared after each complete screen of cellular automata evolution


THINGS TO NOTICE
----------------
Why is it a better idea to have a density that isn't too big or too small?

What is the relationship between the cellular automata display and the entropy plot?

How does the size of the black triangles affect the entropy?

What kinds of configurations lead to long lived chaotic behavior?


THINGS TO TRY
-------------
You may want to set AUTO-CONTINUE? to 'on' in order to study the long-term behavior of each cellular automaton configuration.  Also, if you have a fast enough computer, you may want to increase the size of the world in order to get a better view of the ""big picture.""  If you turn the plot off, it will also increase the speed of your model.

Change the example slider to 1, and click SETUP EXAMPLE.  Click GO and experiment with the III slider, running each configuration a couple of times:
- What happens when III is set to 0%?
- - Why do you think the cellular automaton always ends up in the same uniform, or ""absorbing"" state?
- As you increase III, what happens to the density of the trees that are formed?
- - Does this seem to effect the time it takes to reach an absorbing state?
- What happens when III is set to 100%?
- - It seems very unlikely that this configuration will reach an absorbing state, but is it possible?
- - Why or why not?

Change the example slider to 2, and click SETUP EXAMPLE.  Click GO and experiment with the IOO slider, running each configuration a couple of times:
- Why does this configuration want to have either vertical or horizontal stripes?
- What happens when you change IOO to 0% or 100%?
- - Why does it always end up producing a majority of horizontal or vertical stripes?
- How does changing the OOI slider in conjunction with the IOO slider affect the model?

Change the example slider to 3, and click SETUP EXAMPLE.  Click GO and experiment with the IOO slider, running each configuration a couple of times:
- As you change IOO, what happens to the outer shape of the cellular automaton?
- - What happens to the shape of the triangles inside?
- - How is the value of the IOO slider related to the spread of on cells?
- - What should IOO be set to if you want perfectly symmetric triangles?
- Set IOO to 100%, and experiment with the OOI slider in a similar fashion.
- What is the relation between the IOO and OOI slider?

Change the example slider to 4, and click SETUP EXAMPLE. Click GO and experiment with the IOO slider, running each configuration a couple of times:
- As you increase IOO, what transition do you see in the structures formed by the cellular automata?
- - Why do you think this transition, or ""phase change,"" happens?
- Once you get to 100%, notice that the triangles aren't very symmetric.
- - Which slider should you move accordingly in order to make the triangles look more symmetric?
- Now try moving both sliders together in order to find the point at which the cellular automaton makes its phase transition.

Change the example slider to 5, and click SETUP EXAMPLE Experiment with the OOI and IOO sliders together.
- What differences do you notice between the this example and the previous one?
- Does either cellular automaton have lower phase transition point with respect to the OOI and IOO sliders?
- - If so, what accounts for this difference?


EXTENDING THE MODEL
-------------------
Often times one might want to change multiple sliders in parallel, while leaving other sliders unchanged.  Try automating this process by creating additional switches and sliders.

Can you measure the entropy more accurately by using subsequences greater than 4?

There are many other ways to measure order in a system besides entropy, can you think of any?

Can you make a stochastic cellular automata with more neighbors?  For example, the cellular automata might have two neighbors on each side.

Try making a two-dimensional stochastic cellular automaton.  The neighborhood could be the eight cells around it, or just the cardinal cells (the cells to the right, left, above, and below).


NETLOGO FEATURES
----------------
The plot-entropy procedure makes extensive use of the MAP and FILTER primitives.  First, MAP is used to convert a list containing the number of occurrences of each pattern of ON? values to a list of probabilities of each pattern occurring.  This is done by dividing each item in the first list by the total number of possible patterns.  Since both entropy calculations involve the use of a logarithm, FILTER is used to remove all elements in the list that are equal to 0 so that no errors occur.  For calculating the topological entropy, MAP is used to change all the remaining elements in the probability list to 1.  When calculating the metric entropy, MAP is used to multiply each element in the probability list by its logarithm.  Using MAP and FILTER allows these complex calculations to be done in a clean, compact manner.


RELATED MODELS
--------------
CA 1D Elementary - a widely studied deterministic equivalent to this model
CA 1D Totalistic - a three color 1D cellular automata
Percolation (in Earth Science) - a model demonstrating the percolation of an oil spill using probabilistic rules similar to this model
Turbulence (in Chemistry & Physics) - a continuous cellular automata that exhibits phase change behavior similar to this model
Ising (in Chemistry & Physics) - a microscopic view of a magnetic field which undergoes phase changes with respect to temperature
DLA (in Chemistry & Physics) - a growth model demonstrating how the accumulation of randomly placed particles can lead to complex structures found throughout nature


CREDITS AND REFERENCES
----------------------
Chate, H. & Manneville, P. (1990). Criticality in cellular automata. Physica D (45), 122-135.
Li, W., Packard, N., & Langton, C. (1990). Transition Phenomena in Cellular Automata Rule Space. Physica D (45), 77-94.
Wolfram, S. (1983). Statistical Mechanics of Cellular Automata. Rev. Mod. Phys. (55), 601.
Wolfram, S. (2002). A New Kind of Science. Champaign, IL: Wolfram Media, Inc.

Thanks to Eytan Bakshy for his work on this model.

To refer to this model in academic publications, please use:  Wilensky, U. (2003).  NetLogo CA Stochastic model.  http://ccl.northwestern.edu/netlogo/models/CAStochastic.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2003 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/CAStochastic for terms of use.
"
CA 1D Totalistic,/models/Sample Models/Computer Science/Cellular Automata,"globals [
  current-row
  last-code    ;; used to track whether the rule switches should be updated
               ;; to match the slider, or vice versa
  gone?
]

patches-own [value]

to startup
  set gone? false
end

;; setup single cell of color-one in the top center row
to setup-single
  setup
  ask patches with [pycor = current-row] [ set pcolor color-zero set value 0 ]
  ask patch 0 current-row
  [
    set pcolor color-one
    set value 1
  ]
end

;; setup cells of random distribution across the top row
to setup-random
  setup
  ask patches with [pycor = current-row]
  [
    ifelse random-float 100.0 < density
    [
      ifelse random-float 100.0 > one-two-proportion  ;; proportion between color-one and color-two
        [ set pcolor color-one set value 1 ]
        [ set pcolor color-two set value 2 ]
    ]
        [ set pcolor color-zero set value 0 ]
  ]
end

to setup
  ifelse code = last-code  ;; determine whether to update the switches or the code slider
    [ switch-to-code ]
    [ code-to-switch ]
  set last-code code
  cp ct
  reset-ticks
  set current-row max-pycor  ;; set current row to top position
  set gone? false
end


to setup-continue
  if not gone? [stop]

  let value-list []
  set value-list map [[value] of ?] sort patches with [pycor = current-row]  ;; copy cell states from the current row to a list
  cp ct
  set current-row max-pycor  ;; reset current row to top
  ask patches with [ pycor = current-row ]
  [
    set value item (pxcor + max-pxcor) value-list  ;; copy states from list to top row
    set pcolor value-to-color value
  ]
  set gone? false
end

to go
  if current-row = min-pycor  ;; if we hit the bottom row
  [
    ifelse auto-continue?  ;; continue
    [
      set gone? true
      display    ;; ensure full view gets drawn before we clear it
      setup-continue
    ]
    [
      ifelse gone?
        [ setup-continue ]       ;; a run has already been completed, so continue with another
        [ set gone? true stop ]  ;; otherwise stop
    ]
  ]
  ask patches with [pycor = current-row]
    [ do-rule ]
  set current-row (current-row - 1)
  tick
end

to do-rule  ;; patch procedure
  ask patch-at 0 -1
  [
    ;; set the next state of the cell based on the left, center, and right
    set value get-next-value ([value] of patch-at -1 1 +
                              [value] of myself +
                              [value] of patch-at 1 1)
    ;; paint the next cell based on the new value
    set pcolor value-to-color value
  ]
end

to-report value-to-color [v]  ;; convert cell value to color
  ifelse v = 0
  [ report color-zero ]
  [ ifelse v = 1
      [ report color-one ]
      [ report color-two ]
  ]
end

to-report get-next-value [sum-value]  ;; determines the next state of the CA cell
  if sum-value = 0 [ report sum-0 ]
  if sum-value = 1 [ report sum-1 ]
  if sum-value = 2 [ report sum-2 ]
  if sum-value = 3 [ report sum-3 ]
  if sum-value = 4 [ report sum-4 ]
  if sum-value = 5 [ report sum-5 ]
  if sum-value = 6 [ report sum-6 ]
end

;; switch / code utility interface procedures
to switch-to-code  ;; changes code based on the positions of the switches
  set code sum-0
  set code (code + sum-1 * 3)
  set code (code + sum-2 * 9)
  set code (code + sum-3 * 27)
  set code (code + sum-4 * 81)
  set code (code + sum-5 * 243)
  set code (code + sum-6 * 729)
end

to code-to-switch  ;; changes switches based on the code slider
  let next (trinary-div code) ;; perform long division (base 3)
  set sum-0 (first next)    set next (trinary-div (last next))
  set sum-1 (first next)    set next (trinary-div (last next))
  set sum-2 (first next)    set next (trinary-div (last next))
  set sum-3 (first next)    set next (trinary-div (last next))
  set sum-4 (first next)    set next (trinary-div (last next))
  set sum-5 (first next)    set next (trinary-div (last next))
  set sum-6 (first next)
end

to-report trinary-div [number]  ;; helper function for long division in base 3
  let tri number mod 3
  report (list tri ((number - tri) / 3))
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2002 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2002).  NetLogo CA 1D Totalistic model.
; http://ccl.northwestern.edu/netlogo/models/CA1DTotalistic.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2002 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/CA1DTotalistic
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This program is a one-dimensional three-color totalistic cellular automata. In a totalistic CA, the value of the next cell state is determined by the sum of the current cell and its neighbors, not by the values of each individual neighbor. The model allows you to explore all 2,187 3-color totalistic configurations.

This model is intended for the more sophisticated users who are already familiar with basic 1D CA's. If you are exploring CA for the first time, we suggest you first look at one of the simpler CA models such as CA 1D Rule 30.


HOW IT WORKS
-------------
Each cell may have one of three colors with the value 0, 1, or 2.  The next state of a cell is determined by taking the sum value of the center, right, and left cell, yielding seven possible sums, 0-6, represented as the state-transition sliders sum-0 through sum-6.  Each of these seven possible states maps on to one of the 3 colors which can be set using the state-transition sliders.


HOW TO USE IT
-------------
SETUP SINGLE: Sets up a single color-two cell centered in the top row
SETUP RANDOM: Sets up cells of random colors across the top row based on the following settings:
- one-two-proportion: the proportion between color-one and color-two
- density: what percentage of the top row should be filled randomly with color-one and color-two
AUTO-CONTINUE?: Automatically continue the CA from the top once it reaches the bottom row
GO: Run the CA.  If GO is clicked again after a run, the run continues from the top
CODE: Decimal representation of the seven base three configurations of the totalistic CA
SWITCHES: The rules for the CA.  Examples:
- sum-0: all color-zero
- sum-1: two color-zero and one color-one
- sum-2: two color-one and one color-zero, OR two color-zero and one color-two
- sum-6: all color-two
COLORS: Set the three colors used in the CA


THINGS TO NOTICE
----------------
How does the complexity of the three-color totalistic CA differ from the two-color CA?  (see the CA 1D Elementary model)

Do most configurations lead to constantly repeating patterns, nesting, or randomness? What does this tell you about the nature of complexity?


THINGS TO TRY
-------------
CAs often have a great deal of symmetry.  Can you find any rules that don't exhibit such qualities?  Why do you think that may be?

Try starting different configurations under a set of initial random conditions.  How does this effect the behavior of the CA?

How does the density of the initial random condition relate to the behavior of the CA?

Does the proportion between the first and second color make a difference when starting from a random condition?


EXTENDING THE MODEL
--------------------
Try having the CA use more than three colors.

What if the CA didn't just look at its immediate neighbors, but also its second neighbors?

Try making a two-dimensional cellular automaton.  The neighborhood could be the eight cells around it, or just the cardinal cells (the cells to the right, left, above, and below).


RELATED MODELS
--------------
Life - an example of a two-dimensional cellular automaton
CA 1D Rule 30 - the basic rule 30 model
CA 1D Rule 30 Turtle - the basic rule 30 model implemented using turtles
CA 1D Rule 90 - the basic rule 90 model
CA 1D Rule 250 - the basic rule 250 model
CA 1D Elementary - a simple one-dimensional 2-state cellular automata model
CA Continuous - a totalistic continuous-valued cellular automata with thousands of states


CREDITS AND REFERENCES
-----------------------
Thanks to Eytan Bakshy for his help with this model.

The first cellular automaton was conceived by John Von Neumann in the late 1940's for his analysis of machine reproduction under the suggestion of Stanislaw M. Ulam. It was later completed and documented by Arthur W. Burks in the 1960's. Other two-dimensional cellular automata, and particularly the game of ""Life,"" were explored by John Conway in the 1970's. Many others have since researched CA's. In the late 1970's and 1980's Chris Langton, Tom Toffoli and Stephen Wolfram did some notable research. Wolfram classified all 256 one-dimensional two-state single-neighbor cellular automata. In his recent book, ""A New Kind of Science,"" Wolfram presents many examples of cellular automata and argues for their fundamental importance in doing science.

See also:

Von Neumann, J. and Burks, A. W., Eds, 1966. Theory of Self-Reproducing Automata. University of Illinois Press, Champaign, IL.

Toffoli, T. 1977. Computation and construction universality of reversible cellular automata. J. Comput. Syst. Sci. 15, 213-231.

Langton, C. 1984. Self-reproduction in cellular automata. Physica D 10, 134-144

Wolfram, S. 1986. Theory and Applications of Cellular Automata: Including Selected Papers 1983-1986. World Scientific Publishing Co., Inc., River Edge, NJ.

Bar-Yam, Y. 1997. Dynamics of Complex Systems. Perseus Press. Reading, Ma.

Wolfram, S. 2002. A New Kind of Science. Wolfram Media Inc.  Champaign, IL.

To refer to this model in academic publications, please use:  Wilensky, U. (2002).  NetLogo CA 1D Totalistic model.  http://ccl.northwestern.edu/netlogo/models/CA1DTotalistic.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2002 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/CA1DTotalistic for terms of use.
"
Life,/models/Sample Models/Computer Science/Cellular Automata,"patches-own [
  living?         ;; indicates if the cell is living
  live-neighbors  ;; counts how many neighboring cells are alive
]

to setup-blank
  clear-all
  ask patches [ cell-death ]
end

to setup-random
  clear-all
  ask patches
    [ ifelse random-float 100.0 < initial-density
        [ cell-birth ]
        [ cell-death ] ]
end

to cell-birth
  set living? true
  set pcolor fgcolor
end

to cell-death
  set living? false
  set pcolor bgcolor
end

to go
  ask patches
    [ set live-neighbors count neighbors with [living?] ]
  ;; Starting a new ""ask patches"" here ensures that all the patches
  ;; finish executing the first ask before any of them start executing
  ;; the second ask.  This keeps all the patches in synch with each other,
  ;; so the births and deaths at each generation all happen in lockstep.
  ask patches
    [ ifelse live-neighbors = 3
        [ cell-birth ]
        [ if live-neighbors != 2
            [ cell-death ] ] ]
  tick
end

to add-cells
  while [mouse-down?]
    [ ask patch mouse-xcor mouse-ycor
        [ cell-birth ]
      display ]
end

to remove-cells
  while [mouse-down?]
    [ ask patch mouse-xcor mouse-ycor
        [ cell-death ]
      display ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Life model.
; http://ccl.northwestern.edu/netlogo/models/Life.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Life
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This program is an example of a two-dimensional cellular automaton. A cellular automaton is a computational machine that performs actions based on certain rules.  It can be thought of as a board which is divided into cells (such as square cells of a checkerboard).  Each cell can be either ""alive"" or ""dead.""  This is called the ""state"" of the cell.  According to specified rules, each cell will be alive or dead at the next time step.

This particular cellular automaton is called The Game of Life. The rules of the game are as follows.  Each cell checks the state of itself and its eight surrounding neighbors and then sets itself to either alive or dead.  If there are less than two alive neighbors, then the cell dies.  If there are more than three alive neighbors, the cell dies.  If there are 2 alive neighbors, the cell remains in the state it is in.  If there are exactly three alive neighbors, the cell becomes alive. This is done in parallel and continues forever.

There are certain recurring shapes in Life, for example, the ""glider"" and the ""blinker"".  The glider is composed of 5 cells which form a small arrow-headed shape, like this:

|           X
|            X
|          XXX

This glider will wiggle across the world, retaining its shape.  A blinker is a block of three cells (either up and down or left and right) that rotates between horizontal and vertical orientations.


HOW TO USE IT
-------------
The INITIAL-DENSITY slider determines the initial density of cells that are alive.  SETUP-RANDOM places these cells.  GO-FOREVER runs the rule forever.  GO-ONCE runs the rule once.

If you want to draw your own pattern, use the ADD-CELLS button and REMOVE-CELLS button and then use the mouse to ""draw"" in the view.  Make sure only one of the two buttons is active -- if they're both active, you'll get unexpected behavior.


THINGS TO NOTICE
----------------
Find some objects that are alive, but motionless.

Is there a ""critical density"" - one at which all change and motion stops/eternal motion begins?


THINGS TO TRY
-------------
Are there any recurring shapes other than gliders and blinkers?

Build some objects that don't die (using ""add-cells"")

How much life can the board hold and still remain motionless and unchanging? (use ""add-cells"")

The glider gun is a large conglomeration of cells that repeatedly spits out gliders.  Find a ""glider gun"" (very, very difficult!).


EXTENDING THE MODEL
-------------------
Give some different rules to life and see what happens.

Experiment with using neighbors4 instead of neighbors (see below).


NETLOGO FEATURES
----------------
The neighbors primitive returns the agentset of the patches to the north, south, east, west, northeast, northwest, southeast, and southwest.  So ""count neighbors with [living?]"" counts how many of those eight patches have the living? patch variable set to true.

neighbors4 is like neighbors but only uses the patches to the north, south, east, and west.  Some cellular automata, like this one, are defined using the 8-neighbors rule, others the 4-neighbors.


RELATED MODELS
--------------
Life Turtle-Based - same as this, but implemented using turtles instead of patches, for a more attractive display
CA 1D Elementary - a model that shows all 256 possible simple 1D cellular automata
CA 1D Totalistic - a model that shows all 2,187 possible 1D 3-color totalistic cellular automata
CA 1D Rule 30 - the basic rule 30 model
CA 1D Rule 30 Turtle - the basic rule 30 model implemented using turtles
CA 1D Rule 90 - the basic rule 90 model
CA 1D Rule 110 - the basic rule 110 model
CA 1D Rule 250 - the basic rule 250 model


CREDITS AND REFERENCES
-------------------
The Game of Life was invented by John Horton Conway.

See also:

Von Neumann, J. and Burks, A. W., Eds, 1966. Theory of Self-Reproducing Automata. University of Illinois Press, Champaign, IL.

""LifeLine: A Quarterly Newsletter for Enthusiasts of John Conway's Game of Life"", nos. 1-11, 1971-1973.

Martin Gardner, ""Mathematical Games: The fantastic combinations of John Conway's new solitaire game `life',"", Scientific American, October, 1970, pp. 120-123.

Martin Gardner, ""Mathematical Games: On cellular automata, self-reproduction, the Garden of Eden, and the game `life',"", Scientific American, February, 1971, pp. 112-117.

Berlekamp, Conway, and Guy, Winning Ways for your Mathematical Plays, Academic Press: New York, 1982.

William Poundstone, The Recursive Universe, William Morrow: New York, 1985.

To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Life model.  http://ccl.northwestern.edu/netlogo/models/Life.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Life for terms of use.
"
CA 1D Rule 90,/models/Sample Models/Computer Science/Cellular Automata/CA 1D Simple Examples,"globals [row]  ;; this variable is the current row processed by the CA

;; the following patch variables refer to the colors of the 3 focal patches in a neighborhood
patches-own [left-pcolor center-pcolor right-pcolor]

;; initializes the model
to setup
  clear-all
  set row max-pycor
  ask patch 0 max-pycor [ set pcolor yellow ]  ;; create initial yellow cell in the top center
end

;; runs the CA for one view
to go
  if row = min-pycor [stop]  ;; stop at the last row
  ask patches with [pycor = row]
    [ do-rule ]
  set row (row - 1)
  tick
end

;; set the state of the patch below by applying rule 90
to do-rule  ;; patch procedure
  ;; assign values to patch variables based on current state of the row
  set left-pcolor [pcolor] of patch-at -1 0
  set center-pcolor pcolor
  set right-pcolor [pcolor] of patch-at 1 0
  ifelse ((left-pcolor = yellow and center-pcolor = yellow and right-pcolor = yellow) or  ;; evaluate rule 90
          (left-pcolor = yellow and center-pcolor = black and right-pcolor = yellow) or
          (left-pcolor = black and center-pcolor = yellow and right-pcolor = black) or
          (left-pcolor = black and center-pcolor = black and right-pcolor = black))
    [ ask patch-at 0 -1 [ set pcolor black ] ]
    [ ask patch-at 0 -1 [ set pcolor yellow ] ]
end

;; setup to run the next view
to setup-continue
  ;; copy cells from the bottom of the view to the top
  ask patches with [pycor = max-pycor]
    [ set pcolor ([pcolor] of patch pxcor min-pycor) ]

  ask patches with [pycor != max-pycor]  ;; clear the rest of the view
    [ set pcolor black ]

  set row max-pycor  ;; reset row to top
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2002 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2002).  NetLogo CA 1D Rule 90 model.
; http://ccl.northwestern.edu/netlogo/models/CA1DRule90.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2002 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/CA1DRule90
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This program models one particular one-dimensional cellular automaton -- the one known as ""rule 90"".

A cellular automaton (aka CA) is a computational machine that performs actions based on certain rules.  It can be thought of as a ""board"" which is divided into cells (such as the square cells of a checkerboard). Each cell can be either on or off.  This is called the ""state"" of the cell. The board is initialized with some cells on and some off. A clock is then started and at each ""tick"" of the clock the rules are ""fired"" and this results in some cells turning ""on"" and some turning ""off"".

There are many kinds of cellular automata. In this model, we explore a one-dimensional CA -- the simplest type of CA. In this case of one-dimensional cellular automata, each cell checks the state of itself and its neighbors to the left and right, and then sets the cell below itself to either ""on"" or ""off"", depending upon the rule.  This is done in parallel and continues until the bottom of the board.

This model is one of a collection of 1D CA models. It is meant for the beginning user. If you have experience with CAs, we suggest you check out a more sophisticated model such as CA 1D Elementary.

In his book, ""A New Kind of Science"", Stephen Wolfram argues that simple computational devices such as CA lie at the heart of nature's patterns and that CAs are a better tool than mathematical equations for the purpose of scientifically describing the world.


HOW IT WORKS
------------
As the CA computes, each patch checks the color of itself and the patches directly to the left and right of it, and then paints the patch below it according to Rule 90:

|   B B B    B B Y    B Y B    B Y Y
|     B        Y        B        Y

|   Y B B    Y B Y    Y Y B    Y Y Y
|     Y        B        Y        B

For example, if we have a Rule 90 CA, and the current cell is black and its left neighbor is yellow and its right neighbor is yellow, the cell below it is painted black.


HOW TO USE IT
-------------
Initialization & Running:
- SETUP initializes the model with a single cell on in the center.
- SETUP-CONTINUE copies the last row of the previous run to the top so that you can continue running the model in ""wrapped"" mode when you click GO.
- GO begins running the model with the currently set rule. It continues until it reaches the last row of patches.


THINGS TO NOTICE
----------------
Although the rules are very simple, extremely interesting patterns emerge in Rule 90.  These patterns are are nested and quite regular.

Note that the pictures generated by this model do not exactly match the pictures in Wolfram's book, ""A New Kind of Science"". That's because Wolfram's book computes the CA as an infinite grid while the NetLogo model ""wraps"" around the horizontal boundaries. To get pictures closer to the ones in the book, you may need to increase the size of the world. You can increase the size of the world up to the available memory on your computer. However, the larger the world, the longer time it will take NetLogo to compute and display the results.


THINGS TO TRY
-------------
What happens to the regularity when SETUP-CONTINUE is used a number of times?  Why do you suppose that is?  (Note that in this model, the CA wraps around the sides.)

Is there any consistent pattern to the way this CA evolves?

If you look at the middle vertical line, are there more yellow or black cells?

Can you predict what the color of the nth cell on that line will be?


EXTENDING THE MODEL
-------------------
What if you wanted to observe the behavior of a CA over many iterations without having to click continue every time it reaches the bottom of the view? Simply replace the ""stop"" with ""setup-continue"" in the go procedure:

|  if row = min-pycor
|    [ stop ]

with

|  if row = min-pycor
|    [ setup-continue ]

What if a cell's neighborhood was five -- two to the left, itself, and two to the right?

Classical CAs use an ""infinite board"". The CA shown here ""wraps"" around the edges of the world (sometimes known as a periodic CA or CA with periodic boundary condition). How would you implement in NetLogo a CA that comes closer to the infinite board?

Try making a two-dimensional cellular automaton.  The neighborhood could be the eight cells around it, or just the cardinal cells (the cells to the right, left, above, and below).


RELATED MODELS
--------------
Life - an example of a two-dimensional cellular automaton
CA 1D Rule 30 - the basic rule 30 model
CA 1D Rule 30 Turtle - the basic rule 30 model implemented using turtles
CA 1D Rule 90 - the basic rule 90 model
CA 1D Rule 110 - the basic rule 110 model
CA 1D Elementary - a model that shows all 256 possible simple 1D cellular automata
CA 1D Totalistic - a model that shows all 2,187 possible 1D 3-color totalistic cellular automata.


CREDITS AND REFERENCES
-----------------------
Thanks to Eytan Bakshy for his help with this model.

The first cellular automaton was conceived by John Von Neumann in the late 1940's for his analysis of machine reproduction under the suggestion of Stanislaw M. Ulam. It was later completed and documented by Arthur W. Burks in the 1960's. Other two-dimensional cellular automata, and particularly the game of ""Life,"" were explored by John Conway in the 1970's. Many others have since researched CA's. In the late 1970's and 1980's Chris Langton, Tom Toffoli and Stephen Wolfram did some notable research. Wolfram classified all 256 one-dimensional two-state single-neighbor cellular automata. In his recent book, ""A New Kind of Science,"" Wolfram presents many examples of cellular automata and argues for their fundamental importance in doing science.

See also:

Von Neumann, J. and Burks, A. W., Eds, 1966. Theory of Self-Reproducing Automata. University of Illinois Press, Champaign, IL.

Toffoli, T. 1977. Computation and construction universality of reversible cellular automata. J. Comput. Syst. Sci. 15, 213-231.

Langton, C. 1984. Self-reproduction in cellular automata. Physica D 10, 134-144

Wolfram, S. 1986. Theory and Applications of Cellular Automata: Including Selected Papers 1983-1986. World Scientific Publishing Co., Inc., River Edge, NJ.

Bar-Yam, Y. 1997. Dynamics of Complex Systems. Perseus Press. Reading, Ma.

Wolfram, S. 2002. A New Kind of Science.  Wolfram Media Inc.  Champaign, IL.
See chapters 2 and 3 for more information on 1 Dimensional CA
See index for more information specifically about Rule 90.

To refer to this model in academic publications, please use:  Wilensky, U. (2002).  NetLogo CA 1D Rule 90 model.  http://ccl.northwestern.edu/netlogo/models/CA1DRule90.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2002 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/CA1DRule90 for terms of use.
"
CA 1D Rule 30 Turtle,/models/Sample Models/Computer Science/Cellular Automata/CA 1D Simple Examples,";; the following turtle variables refer to the colors of the 3 focal patches in a neighborhood
turtles-own [left-pcolor center-pcolor right-pcolor]

to setup
  clear-all
  make-turtles
  ask patch 0 max-pycor [ set pcolor yellow ]  ;; create initial yellow cell in the top center of the world
end

to make-turtles
  ask patches with [pycor = max-pycor]  ;; create turtles along the top of the world
  [
    sprout 1 ;; each patch sprouts a turtle
    [
      set heading 180 ;; face the turtle downwards
      ht              ;; make the turtle invisible
    ]
  ]
end

;; run the CA one view
to go
  if (not any? turtles)
    [ stop ]  ;; stop at the last row
  ask turtles
  [
    do-rule      ;; evaluate rule 30 for each turtle
    fd 1         ;; move down to the next row
    if pycor = min-pycor
      [ die ]    ;; if you've reached bottom, die
  ]
  tick
end

;; set the state of the patch below the turtle by applying rule 30
to do-rule  ;; turtle procedure
  set left-pcolor [pcolor] of patch-at -1 0
  set center-pcolor pcolor
  set right-pcolor [pcolor] of patch-at 1 0
  ifelse ((left-pcolor = yellow and center-pcolor = black and right-pcolor = black) or  ;; evaluate rule 30
          (left-pcolor = black and center-pcolor = yellow and right-pcolor = yellow) or
          (left-pcolor = black and center-pcolor = yellow and right-pcolor = black) or
          (left-pcolor = black and center-pcolor = black and right-pcolor = yellow))
    [ ask patch-at 0 -1 [ set pcolor yellow ] ]
    [ ask patch-at 0 -1 [ set pcolor black ] ]
end

;; setup to run the next view
to setup-continue
  ;; copy cells from the bottom to the top
  ask patches with [pycor = max-pycor]
    [ set pcolor ([pcolor] of patch pxcor min-pycor) ]
  ask patches with [pycor != max-pycor]  ;; clear the rest of the patches
    [ set pcolor black ]
  make-turtles  ;; sprout new turtles at the top of the world
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2002 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2002).  NetLogo CA 1D Rule 30 Turtle model.
; http://ccl.northwestern.edu/netlogo/models/CA1DRule30Turtle.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2002 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/CA1DRule30Turtle
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This program models one particular one-dimensional cellular automaton -- the one known as 'rule 30'. It is intended to be a companion model to the CA 1D Rule 30 model and to show an alternate way of modeling a cellular automaton -- by using turtles to do the processing instead of patches.

A cellular automaton (aka CA) is a computational machine that performs actions based on certain rules.  It can be thought of as a ""board"" which is divided into cells (such as the square cells of a checkerboard). Each cell can be either on or off.  This is called the ""state"" of the cell. The board is initialized with some cells on and some off. A clock is then started and at each ""tick"" of the clock the rules are ""fired"" and this results in some cells turning ""on"" and some turning ""off"".

There are many kinds of cellular automata. In this model, we explore a one-dimensional CA -- the simplest type of CA. In this case of one-dimensional cellular automata, each cell checks the state of itself and its neighbors to the left and right, and then sets the cell below itself to either ""on"" or ""off"", depending upon the rule.  This is done in parallel and continues until the bottom of the board.

This model is one of a collection of 1D CA models. It is meant for the beginning user. If you have experience with CA, we suggest you check out a more sophisticated model such as CA 1D Elementary.

In his book, ""A New Kind of Science"", Stephen Wolfram argues that simple computational devices such as CA lie at the heart of nature's patterns and that CAs are a better tool than mathematical equations for the purpose of scientifically describing the world.


HOW IT WORKS
------------
As the turtles move forward, each turtle checks the color of its current patch and the patches directly to the left and right of it, and then paints the patch below it according to Rule 30:

|   Y Y Y     Y Y B     Y B Y     Y B B
|     B         B         B         Y

|   B Y Y     B Y B     B B Y     B B B
|     Y         Y         Y         B

For example, if we have a Rule 30 CA, and the current cell is black and its left neighbor is yellow and its right neighbor is yellow, the cell below it is painted black.


HOW TO USE IT
-------------
Initialization & Running:
- SETUP initializes the model with a single cell on in the center.
- SETUP-CONTINUE copies the last row of the previous run to the top so that you can continue running the model in ""wrapped"" mode when you click GO.
- GO begins running the model with the currently set rule. It continues until it reaches the last row of patches.


THINGS TO NOTICE
----------------
Although the rules are very simple, extremely complex patterns emerge in Rule 30.  These patterns are not highly regular nor are they completely random.

Note that the pictures generated by this model do not exactly match the pictures in Wolfram's book, ""A New Kind of Science"". That's because Wolfram's book computes the CA as an infinite grid while the NetLogo model ""wraps"" around the horizontal edges of the world. To get pictures closer to the ones in the book, you may need to increase the size of the NetLogo world. You can increase the size of the world up to the available memory on your computer. However, the larger the world, the longer time it will take NetLogo to compute and display the results.


THINGS TO TRY
-------------
Is there any consistent pattern to the way this CA evolves?

If you look at the middle vertical line, are there more yellow or black cells?

Can you predict what the color of the nth cell on that line will be?


EXTENDING THE MODEL
-------------------
What if you wanted to observe the behavior of a CA over many iterations without having to click continue every time it reaches the bottom of the view? Simply replace the ""stop"" with ""setup-continue' in the go procedure:

|  if (not any turtles)
|    [ stop ]

with

|  if (not any turtles)
|    [ setup-continue ]

What if a cell's neighborhood was five -- two to the left, itself, and two to the right?

Classical CAs use an ""infinite board"". The CA shown here ""wraps"" around the edges of the world (sometimes known as a periodic CA or CA with periodic boundary condition). How would you implement in NetLogo a CA that comes closer to the infinite board?

Try making a two-dimensional cellular automaton.  The neighborhood could be the eight cells around it, or just the cardinal cells (the cells to the right, left, above, and below).


NETLOGO FEATURES
-----------------
The CA in this model uses turtles to process cells.  While this is functionally identical to the traditional CA, the turtles can be thought of as processors moving down each row, while the cells are used simply as a data set for the processors.  This differs from the patch-baed CA implementation in that the processor and data are decoupled from each other.


RELATED MODELS
--------------
Life - an example of a two-dimensional cellular automaton
CA 1D Rule 30 - the basic rule 30 model
CA 1D Rule 90 - the basic rule 90 model
CA 1D Rule 110 - the basic rule 110 model
CA 1D Rule 250 - the basic rule 250 model
CA 1D Elementary - a model that shows all 256 possible simple 1D cellular automata
CA 1D Totalistic - a model that shows all 2,187 possible 1D 3-color totalistic cellular automata.


CREDITS AND REFERENCES
-----------------------
Thanks to Eytan Bakshy for his help with this model.

The first cellular automaton was conceived by John Von Neumann in the late 1940's for his analysis of machine reproduction under the suggestion of Stanislaw M. Ulam. It was later completed and documented by Arthur W. Burks in the 1960's. Other two-dimensional cellular automata, and particularly the game of ""Life,"" were explored by John Conway in the 1970's. Many others have since researched CA's. In the late 1970's and 1980's Chris Langton, Tom Toffoli and Stephen Wolfram did some notable research. Wolfram classified all 256 one-dimensional two-state single-neighbor cellular automata. In his recent book, ""A New Kind of Science,"" Wolfram presents many examples of cellular automata and argues for their fundamental importance in doing science.

See also:

Von Neumann, J. and Burks, A. W., Eds, 1966. Theory of Self-Reproducing Automata. University of Illinois Press, Champaign, IL.

Toffoli, T. 1977. Computation and construction universality of reversible cellular automata. J. Comput. Syst. Sci. 15, 213-231.

Langton, C. 1984. Self-reproduction in cellular automata. Physica D 10, 134-144

Wolfram, S. 1986. Theory and Applications of Cellular Automata: Including Selected Papers 1983-1986. World Scientific Publishing Co., Inc., River Edge, NJ.

Bar-Yam, Y. 1997. Dynamics of Complex Systems. Perseus Press. reading, Ma.

Wolfram, S. 2002. A New Kind of Science.  Wolfram Media Inc.  Champaign, IL.
See chapters 2 and 3 for more information on 1 Dimensional CA
See index for more information specifically about Rule 30.

To refer to this model in academic publications, please use:  Wilensky, U. (2002).  NetLogo CA 1D Rule 30 Turtle model.  http://ccl.northwestern.edu/netlogo/models/CA1DRule30Turtle.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2002 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/CA1DRule30Turtle for terms of use.
"
CA 1D Rule 30,/models/Sample Models/Computer Science/Cellular Automata/CA 1D Simple Examples,"globals [row]  ;; this variable is the current row processed by the CA

;; the following patch variables refer to the colors of the 3 focal patches in a neighborhood
patches-own [left-pcolor center-pcolor right-pcolor]

;; initializes the model
to setup
  clear-all
  set row max-pycor
  ask patch 0 max-pycor [ set pcolor yellow ]  ;; create initial yellow cell in the top center of the world
end

;; runs the CA from top to bottom of the world
to go
  if (row = min-pycor)
    [ stop ]  ;; stop at the last row
  ask patches with [pycor = row]
    [ do-rule ]
  set row (row - 1)
  tick
end

;; set the state of the patch below by applying rule 30
to do-rule  ;; patch procedure
  ;; assign values to patch variables based on current state of the row
  set left-pcolor [pcolor] of patch-at -1 0
  set center-pcolor pcolor
  set right-pcolor [pcolor] of patch-at 1 0
  ifelse ((left-pcolor = yellow and center-pcolor = black and right-pcolor = black) or  ;; evaluate rule 30
          (left-pcolor = black and center-pcolor = yellow and right-pcolor = yellow) or
          (left-pcolor = black and center-pcolor = yellow and right-pcolor = black) or
          (left-pcolor = black and center-pcolor = black and right-pcolor = yellow))
    [ ask patch-at 0 -1 [ set pcolor yellow ] ]
    [ ask patch-at 0 -1 [ set pcolor black ] ]
end

;; sets up to run the next view
to setup-continue
  ;; copy cells from the bottom to the top
  ask patches with [pycor = max-pycor]
    [ set pcolor ([pcolor] of patch pxcor min-pycor) ]

  ask patches with [pycor != max-pycor]  ;; clear the rest of the patches
    [ set pcolor black ]

  set row max-pycor  ;; reset the current row to the top row
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2002 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2002).  NetLogo CA 1D Rule 30 model.
; http://ccl.northwestern.edu/netlogo/models/CA1DRule30.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2002 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/CA1DRule30
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This program models one particular one-dimensional cellular automaton -- the one known as ""rule 30"".

A cellular automaton (aka CA) is a computational machine that performs actions based on certain rules.  It can be thought of as a ""board"" which is divided into cells (such as the square cells of a checkerboard). Each cell can be either on or off.  This is called the ""state"" of the cell. The board is initialized with some cells on and some off. A clock is then started and at each ""tick"" of the clock the rules are ""fired"" and this results in some cells turning ""on"" and some turning ""off"".

There are many kinds of cellular automata. In this model, we explore a one-dimensional CA -- the simplest type of CA. In this case of one-dimensional cellular automata, each cell checks the state of itself and its neighbors to the left and right, and then sets the cell below itself to either ""on"" or ""off"", depending upon the rule.  This is done in parallel and continues until the bottom of the board.

This model is one of a collection of 1D CA models. It is meant for the beginning user. If you have experience with CA, we suggest you check out a more sophisticated model such as CA 1D Elementary.

In his book, ""A New Kind of Science"", Stephen Wolfram argues that simple computational devices such as CA lie at the heart of nature's patterns and that CAs are a better tool than mathematical equations for the purpose of scientifically describing the world.


HOW IT WORKS
------------
As the CA computes, each patch checks the color of itself and the patches directly to the left and right of it, and then paints the patch below it according to Rule 30:

|   Y Y Y    Y Y B    Y B Y    Y B B
|     B        B        B        Y

|   B Y Y    B Y B    B B Y    B B B
|     Y        Y        Y        B

For example, if we have a Rule 30 CA, and the current cell is black and its left neighbor is yellow and its right neighbor is yellow, the cell below it is painted black.


HOW TO USE IT
-------------
Initialization & Running:
- SETUP initializes the model with a single cell on in the center.
- SETUP-CONTINUE copies the last row of the previous run to the top so that you can continue running the model in ""wrapped"" mode when you click GO.
- GO begins running the model with the currently set rule. It continues until it reaches the last row of patches in the world.


THINGS TO NOTICE
----------------
Although the rules are very simple, extremely complex patterns emerge in Rule 30.  These patterns are not highly regular nor are they completely random.

Note that the pictures generated by this model do not exactly match the pictures in Wolfram's book, ""A New Kind of Science"". That's because Wolfram's book computes the CA as an infinite grid while the NetLogo model ""wraps"" around the horizontal boundaries of the world. To get pictures closer to the ones in the book, you may need to increase the size of the world. You can increase the size of the world up to the available memory on your computer. However, the larger the world, the longer time it will take NetLogo to compute and display the results.


THINGS TO TRY
-------------
Is there any consistent pattern to the way this CA evolves?

If you look at the middle vertical line, are there more yellow or black cells?

Can you predict what the color of the nth cell on that line will be?


EXTENDING THE MODEL
-------------------
What if you wanted to observe the behavior of a CA over many iterations without having to click continue every time the CA reaches the bottom of the view? Simply replace the ""stop"" with ""setup-continue' in the go procedure:

|  if (row = min-pycor)
|    [ stop ]

with

|  if (row = min-pycor)
|    [ setup-continue ]

What if a cell's neighborhood was five -- two to the left, itself, and two to the right?

Classical CAs use an ""infinite board"". The CA shown here ""wraps"" around the edges of the world (sometimes known as a periodic CA or CA with periodic boundary condition). How would you implement in NetLogo a CA that comes closer to the infinite board?

Try making a two-dimensional cellular automaton.  The neighborhood could be the eight cells around it, or just the cardinal cells (the cells to the right, left, above, and below).


RELATED MODELS
--------------
Life - an example of a two-dimensional cellular automaton
CA 1D Rule 30 Turtle - the basic rule 30 model implemented using turtles
CA 1D Rule 90 - the basic rule 90 model
CA 1D Rule 110 - the basic rule 110 model
CA 1D Rule 250 - the basic rule 250 model
CA 1D Elementary- a model that shows all 256 possible simple 1D cellular automata
CA 1D Totalistic - a model that shows all 2,187 possible 1D 3-color totalistic cellular automata.


CREDITS AND REFERENCES
-----------------------
Thanks to Eytan Bakshy for his help with this model.

The first cellular automaton was conceived by John Von Neumann in the late 1940's for his analysis of machine reproduction under the suggestion of Stanislaw M. Ulam. It was later completed and documented by Arthur W. Burks in the 1960's. Other two-dimensional cellular automata, and particularly the game of ""Life,"" were explored by John Conway in the 1970's. Many others have since researched CA's. In the late 1970's and 1980's Chris Langton, Tom Toffoli and Stephen Wolfram did some notable research. Wolfram classified all 256 one-dimensional two-state single-neighbor cellular automata. In his recent book, ""A New Kind of Science,"" Wolfram presents many examples of cellular automata and argues for their fundamental importance in doing science.

See also:

Von Neumann, J. and Burks, A. W., Eds, 1966. Theory of Self-Reproducing Automata. University of Illinois Press, Champaign, IL.

Toffoli, T. 1977. Computation and construction universality of reversible cellular automata. J. Comput. Syst. Sci. 15, 213-231.

Langton, C. 1984. Self-reproduction in cellular automata. Physica D 10, 134-144

Wolfram, S. 1986. Theory and Applications of Cellular Automata: Including Selected Papers 1983-1986. World Scientific Publishing Co., Inc., River Edge, NJ.

Bar-Yam, Y. 1997. Dynamics of Complex Systems. Perseus Press. reading, Ma.

Wolfram, S. 2002. A New Kind of Science.  Wolfram Media Inc.  Champaign, IL.
See chapters 2 and 3 for more information on 1 Dimensional CA
See index for more information specifically about Rule 30.

To refer to this model in academic publications, please use:  Wilensky, U. (2002).  NetLogo CA 1D Rule 30 model.  http://ccl.northwestern.edu/netlogo/models/CA1DRule30.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2002 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/CA1DRule30 for terms of use.
"
CA 1D Rule 250,/models/Sample Models/Computer Science/Cellular Automata/CA 1D Simple Examples,"globals [row] ;; this variable is the current row processed by the CA

;; the following patch variables refer to the colors of the 3 focal patches in a neighborhood
patches-own [left-pcolor center-pcolor right-pcolor]

;; initializes the model
to setup
  clear-all
  set row max-pycor
  ask patch 0 max-pycor [ set pcolor yellow ]  ;; create initial yellow cell in the top center of the world
end

;; runs the CA from top of the world to bottom once
to go
  if (row = min-pycor) [ stop ]  ;; stop at the last row
  ask patches with [pycor = row]
    [ do-rule ]
  set row (row - 1)
  tick
end

;; set the state of the patch below by applying rule 250
to do-rule  ;; patch procedure
  ;; assign values to patch variables based on current state of the model
  set left-pcolor [pcolor] of patch-at -1 0
  set center-pcolor pcolor
  set right-pcolor [pcolor] of patch-at 1 0
  ifelse ((left-pcolor = black and center-pcolor = yellow and right-pcolor = black) or  ;; evaluate rule 250
          (left-pcolor = black and center-pcolor = black and right-pcolor = black))
    [ ask patch-at 0 -1 [ set pcolor black ] ]
    [ ask patch-at 0 -1 [ set pcolor yellow ] ]
end

;; setup to run the next iteration
to setup-continue
  ;; copy cells from the bottom to the top
  ask patches with [pycor = max-pycor]
    [ set pcolor ([pcolor] of patch pxcor min-pycor) ]

  ask patches with [pycor != max-pycor]  ;; clear the rest of the patches
    [ set pcolor black ]

  set row max-pycor  ;; reset the current row
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2002 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2002).  NetLogo CA 1D Rule 250 model.
; http://ccl.northwestern.edu/netlogo/models/CA1DRule250.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2002 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/CA1DRule250
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This program models one particular one-dimensional cellular automaton -- the one known as ""rule 250"".

A cellular automaton (aka CA) is a computational machine that performs actions based on certain rules.  It can be thought of as a ""board"" which is divided into cells (such as the square cells of a checkerboard). Each cell can be either on or off.  This is called the ""state"" of the cell. The board is initialized with some cells on and some off. A clock is then started and at each ""tick"" of the clock the rules are ""fired"" and this results in some cells turning ""on"" and some turning ""off"".

There are many kinds of cellular automata. In this model, we explore a one-dimensional CA -- the simplest type of CA. In this case of one-dimensional cellular automata, each cell checks the state of itself and its neighbors to the left and right, and then sets the cell below itself to either ""on"" or ""off"", depending upon the rule.  This is done in parallel and continues until the bottom of the board.

This model is one of a collection of 1D CA models. It is meant for the beginning user. If you have experience with CAs, we suggest you check out a more sophisticated model such as CA 1D Elementary.

In his book, ""A New Kind of Science"", Stephen Wolfram argues that simple computational devices such as CAs lie at the heart of nature's patterns and that CAs are a better tool than mathematical equations for the purpose of scientifically describing the world.


HOW IT WORKS
------------
As the CA computes, each patch checks the color of itself and the patches directly to the left and right of it, and then paints the patch below it according to Rule 250:

|   B B B       B B Y       B Y B       B Y Y
|     B           Y           B           Y

|   Y B B       Y B Y       Y Y B       Y Y Y
|     Y           Y           Y           Y

For example, if we have a Rule 250 CA, and the current cell is yellow and its left neighbor is black and its right neighbor is black, the cell below it is painted black.


HOW TO USE IT
-------------
Initialization & Running:
- SETUP initializes the model with a single cell on in the center.
- SETUP-CONTINUE copies the last row of the previous run to the top so that you can continue running the model in ""wrapped"" mode when you click GO.
- GO begins running the model with the currently set rule. It continues until the end of the view.


THINGS TO NOTICE
----------------
Although the rules are very simple, interesting patterns emerge in Rule 250.  These patterns are highly regular.

Note that the pictures generated by this model do not exactly match the pictures in Wolfram's book, ""A New Kind of Science"". That's because Wolfram's book computes the CA as an infinite grid while the NetLogo model ""wraps"" around the horizontal boundaries. To get pictures closer to the ones in the book, you may need to increase the size of the world. You can increase the size of the world up to the available memory on your computer. However, the larger the world, the longer time it will take NetLogo to compute and display the results.


THINGS TO TRY
-------------
What happens to the regularity when SETUP-CONTINUE is used a number of times?  Why do you suppose that is?  (Note that in this model, the CA wraps around the sides.)

Is there any consistent pattern to the way this CA evolves?

Can you predict what the color of the nth cell on the vertical midline will be?


EXTENDING THE MODEL
-------------------
What if you wanted to observe the behavior of a CA over many iterations without having to click continue every time the CA reaches the bottom of the view? Simply replace the ""stop"" with ""setup-continue"" in the go procedure:

|  if (row = min-pycor)
|    [ stop ]

with

|  if (row = min-pycor)
|    [ setup-continue ]

What if a cell's neighborhood was five -- two to the left, itself, and two to the right?

Classical CAs use an ""infinite board"". The CA shown here ""wraps"" around the edges of the world (sometimes known as a periodic CA or CA with periodic boundary condition). How would you implement a CA in NetLogo that comes closer to the infinite board?

Try making a two-dimensional cellular automaton.  The neighborhood could be the eight cells around it, or just the cardinal cells (the cells to the right, left, above, and below).


RELATED MODELS
--------------
Life - an example of a two-dimensional cellular automaton
CA 1D Rule 30 - the basic rule 30 model
CA 1D Rule 30 Turtle - the basic rule 30 model implemented using turtles
CA 1D Rule 90 - the basic rule 90 model
CA 1D Rule 110 - the basic rule 110 model
CA 1D Elementary - a model that shows all 256 possible simple 1D cellular automata
CA 1D Totalistic - a model that shows all 2,187 possible 1D 3-color totalistic cellular automata.


CREDITS AND REFERENCES
-----------------------
Thanks to Eytan Bakshy for his help with this model.

The first cellular automaton was conceived by John Von Neumann in the late 1940's for his analysis of machine reproduction under the suggestion of Stanislaw M. Ulam. It was later completed and documented by Arthur W. Burks in the 1960's. Other two-dimensional cellular automata, and particularly the game of ""Life,"" were explored by John Conway in the 1970's. Many others have since researched CA's. In the late 1970's and 1980's Chris Langton, Tom Toffoli and Stephen Wolfram did some notable research. Wolfram classified all 256 one-dimensional two-state single-neighbor cellular automata. In his recent book, ""A New Kind of Science,"" Wolfram presents many examples of cellular automata and argues for their fundamental importance in doing science.

See also:

Von Neumann, J. and Burks, A. W., Eds, 1966. Theory of Self-Reproducing Automata. University of Illinois Press, Champaign, IL.

Toffoli, T. 1977. Computation and construction universality of reversible cellular automata. J. Comput. Syst. Sci. 15, 213-231.

Langton, C. 1984. Self-reproduction in cellular automata. Physica D 10, 134-144

Wolfram, S. 1986. Theory and Applications of Cellular Automata: Including Selected Papers 1983-1986. World Scientific Publishing Co., Inc., River Edge, NJ.

Bar-Yam, Y. 1997. Dynamics of Complex Systems. Perseus Press. Reading, Ma.

Wolfram, S. 2002. A New Kind of Science.  Wolfram Media Inc.  Champaign, IL.
See chapters 2 and 3 for more information on 1 Dimensional CA
See pages 25, 224, 694, 869-870, 952,1089 for information specifically on Rule 250.

To refer to this model in academic publications, please use:  Wilensky, U. (2002).  NetLogo CA 1D Rule 250 model.  http://ccl.northwestern.edu/netlogo/models/CA1DRule250.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2002 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/CA1DRule250 for terms of use.
"
CA 1D Rule 110,/models/Sample Models/Computer Science/Cellular Automata/CA 1D Simple Examples,"globals [row]  ;; this variable is the current row processed by the CA

;; the following patch variables refer to the colors of the 3 focal patches in a neighborhood
patches-own [left-pcolor center-pcolor right-pcolor]

;; initializes the model
to setup
  ca
  set row max-pycor
  ask patch 0 max-pycor [ set pcolor yellow ]  ;; create initial yellow cell in the top center of the world
end

;; runs the CA from the top to the bottom of the world once
to go
  if (row = min-pycor) [ stop ]  ;; stop at the last row
  ask patches with [pycor = row]
    [ do-rule ]
  set row (row - 1)
  tick
end

;; set the state of the patch below by applying rule 110
to do-rule  ;; patch procedure
  ;; assign values to patch variables based on current state of the row
  set left-pcolor [pcolor] of patch-at -1 0
  set center-pcolor pcolor
  set right-pcolor [pcolor] of patch-at 1 0
  ifelse ((left-pcolor = black and center-pcolor = black and right-pcolor = black) or  ;; evaluate rule 110
          (left-pcolor = yellow and center-pcolor = black and right-pcolor = black) or
          (left-pcolor = yellow and center-pcolor = yellow and right-pcolor = yellow))
    [ ask patch-at 0 -1 [ set pcolor black ] ]
    [ ask patch-at 0 -1 [ set pcolor yellow ] ]
end

;; sets up to run the next iteration from top to bottom
to setup-continue
  ;; copy cells from the bottom to the top
  ask patches with [pycor = max-pycor]
    [ set pcolor ([pcolor] of patch pxcor min-pycor) ]

  ask patches with [pycor != max-pycor]  ;; clear the rest of the view
    [ set pcolor black ]

  set row max-pycor  ;; reset the row to the top position
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2002 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2002).  NetLogo CA 1D Rule 110 model.
; http://ccl.northwestern.edu/netlogo/models/CA1DRule110.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2002 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/CA1DRule110
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This program models one particular one-dimensional cellular automaton -- the one known as ""rule 110"".

A cellular automaton (aka CA) is a computational machine that performs actions based on certain rules.  It can be thought of as a ""board"" which is divided into cells (such as the square cells of a checkerboard). Each cell can be either on or off.  This is called the ""state"" of the cell. The board is initialized with some cells on and some off. A clock is then started and at each ""tick"" of the clock the rules are ""fired"" and this results in some cells turning ""on"" and some turning ""off"".

There are many kinds of cellular automata. In this model, we explore a one-dimensional CA -- the simplest type of CA. In this case of one-dimensional cellular automata, each cell checks the state of itself and its neighbors to the left and right, and then sets the cell below itself to either ""on"" or ""off"", depending upon the rule.  This is done in parallel and continues until the bottom of the board.

This model is one of a collection of 1D CA models. It is meant for the beginning user. If you have experience with CAs, we suggest you check out a more sophisticated model such as CA 1D Elementary.

In his book, ""A New Kind of Science"", Stephen Wolfram argues that simple computational devices such as CAs lie at the heart of nature's patterns and that CAs are a better tool than mathematical equations for the purpose of scientifically describing the world.


HOW IT WORKS
------------
As the CA computes, each patch checks the color of itself and the patches directly to the left and right of it, and then paints the patch below it according to Rule 110:

|   Y Y Y       Y Y B       Y B Y       Y B B
|     B           Y           Y           B

|   B Y Y       B Y B       B B Y       B B B
|     Y           Y           Y           B

For example, if we have a Rule 110 CA, and the current cell is yellow and its left neighbor is black and its right neighbor is black, the cell below it is painted yellow.


HOW TO USE IT
-------------
Initialization & Running:
- SETUP initializes the model with a single cell on in the center.
- SETUP-CONTINUE copies the last row of the previous run to the top so that you can continue running the model when you click GO.
- GO begins running the model with the currently set rule. It continues until the end of the view.


THINGS TO NOTICE
----------------
Although the rules are very simple, extremely complex patterns emerge in Rule 110.  These patterns are not highly regular nor are they completely random.

Note that the pictures generated by this model do not exactly match the pictures in Wolfram's book, ""A New Kind of Science"". That's because Wolfram's book computes the CA as an infinite grid while the NetLogo model ""wraps"" around the horizontal boundaries of the world. To get pictures closer to the ones in the book, you may need to increase the size of the world. You can increase the size of the world up to the available memory on your computer. However, the larger the world, the longer time it will take NetLogo to compute and display the results.


THINGS TO TRY
-------------
Try changing the dimensions of the world either to see more of the CA's pattern or to focus in on a region of interest.

What happens to the regularity when SETUP-CONTINUE is used a number of times?  Why do you suppose that is? (Note that in this model, the CA wraps around the sides.)

Is there any consistent pattern to the way this CA evolves?

If you look at a vertical line, are there more yellow or black cells?

Can you predict what the color of the nth cell on a line will be?


EXTENDING THE MODEL
-------------------
What if you wanted to observe the behavior of a CA over many iterations without having to click continue every time the CA reaches the bottom of the view? Simply replace the ""stop"" with ""setup-continue' in the go procedure:

|  if (row = min-pycor)
|    [ stop ]

with

|  if (row = min-pycor)
|    [ setup-continue ]

What if a cell's neighborhood was five -- two to the left, itself, and two to the right?

Classical CAs use an ""infinite board"". The CA shown here ""wraps"" when it reaches the edge of the world (sometimes known as a periodic CA or CA with periodic boundary condition). How would you implement in NetLogo a CA that comes closer to the infinite board?

Try making a two-dimensional cellular automaton.  The neighborhood could be the eight cells around it, or just the cardinal cells (the cells to the right, left, above, and below).


RELATED MODELS
--------------
Life - an example of a two-dimensional cellular automaton
CA 1D Rule 30 - the basic rule 30 model
CA 1D Rule 30 Turtle - the basic rule 30 model implemented using turtles
CA 1D Rule 90 - the basic rule 90 model
CA 1D Rule 250 - the basic rule 250 model
CA 1D Elementary - a model that shows all 256 possible simple 1D cellular automata
CA 1D Totalistic - a model that shows all 2,187 possible 1D 3-color totalistic cellular automata.


CREDITS AND REFERENCES
-----------------------
Thanks to Eytan Bakshy for his help with this model.

The first cellular automaton was conceived by John Von Neumann in the late 1940's for his analysis of machine reproduction under the suggestion of Stanislaw M. Ulam. It was later completed and documented by Arthur W. Burks in the 1960's. Other two-dimensional cellular automata, and particularly the game of ""Life,"" were explored by John Conway in the 1970's. Many others have since researched CA's. In the late 1970's and 1980's Chris Langton, Tom Toffoli and Stephen Wolfram did some notable research. Wolfram classified all 256 one-dimensional two-state single-neighbor cellular automata. In his recent book, ""A New Kind of Science,"" Wolfram presents many examples of cellular automata and argues for their fundamental importance in doing science.

See also:

Von Neumann, J. and Burks, A. W., Eds, 1966. Theory of Self-Reproducing Automata. University of Illinois Press, Champaign, IL.

Toffoli, T. 1977. Computation and construction universality of reversible cellular automata. J. Comput. Syst. Sci. 15, 213-231.

Langton, C. 1984. Self-reproduction in cellular automata. Physica D 10, 134-144

Wolfram, S. 1986. Theory and Applications of Cellular Automata: Including Selected Papers 1983-1986. World Scientific Publishing Co., Inc., River Edge, NJ.

Bar-Yam, Y. 1997. Dynamics of Complex Systems. Perseus Press. Reading, Ma.

Wolfram, S. 2002. A New Kind of Science.  Wolfram Media Inc.  Champaign, IL.
See chapters 2 and 3 for more information on 1 Dimensional CAs
See index for more information specifically about Rule 110.

To refer to this model in academic publications, please use:  Wilensky, U. (2002).  NetLogo CA 1D Rule 110 model.  http://ccl.northwestern.edu/netlogo/models/CA1DRule110.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2002 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/CA1DRule110 for terms of use.
"
Painted Desert Challenge,/models/Sample Models/Computer Science,"turtles-own [ chip? chip-color ]
patches-own [ leaves ]

to setup
  clear-all
  set-default-shape turtles ""bug""
  ask patches
    [ if random-float 100 < density
        [ set pcolor ((random colors) * 10) + 5 ] ]
  crt number
    [ set chip-color ((random colors) * 10) + 5
      set color white
      set chip? false
      setxy random-xcor random-ycor
      set size 3 ] ;; easier to see
end

to go
  find-chip                 ;; find a wood chip and pick it up
  find-new-pile             ;; find another wood chip
  find-empty-spot           ;; find a place to put down wood chip
end

to find-chip
  if (chip-color = pcolor)  ;; if wood-chip is my color
    [ set pcolor black      ;; then pick up the chip
      set chip? true
      set color chip-color
      get-away
      stop ]
  wiggle
  find-chip
end

to find-new-pile
  if (pcolor = chip-color)
    [ stop ]
  fd 10
  wiggle
  find-new-pile
end

to find-empty-spot
  if pcolor = black         ;; if find a patch without a wood chip
    [ set pcolor chip-color ;; put down wood chip in patch
      set chip? false
      set color white
      fd 20
      stop ]
  rt random-float 360
  fd 1
  find-empty-spot
end

to get-away
  rt random-float 360
  back 10
  if (pcolor = black)
    [ stop ]                ;; exit this procedure if not on a pile
  get-away
end

to wiggle
  fd 1
  rt (random-float 50 - random-float 50)
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Painted Desert Challenge model.
; http://ccl.northwestern.edu/netlogo/models/PaintedDesertChallenge.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/PaintedDesertChallenge
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model is based on the Termites model.  In Termites, the agents follow a set of simple rules that results in them moving all of the wood chips into a single pile.  Painted Desert Challenge adds the dimension of multiple types (colors) of wood chips.  The challenge is to get the termites to sort each chip type into its own pile.


HOW IT WORKS
------------
Each termite starts wandering randomly. If it bumps into a wood chip, it picks the chip up, and continues to wander randomly. When it bumps into another wood chip of that color, it finds a nearby empty space and puts its wood chip down.  With these simple rules, the woodchips eventually end up in piles sorted by color.


HOW TO USE IT
-------------
Click the SETUP button to set up the termites (white) and wood chips (all other colors). Click the GO button to start the simulation.  A termite that is carrying a wood chip turns the color of the chip.

The NUMBER slider controls the number of termites. (Note: Changes in the NUMBER slider do not take effect until the next setup.) The DENSITY slider controls the initial density of wood chips.  The SIM-DELAY slider can be used to slow down the speed of the simulation. The PILES slider allows the user sets the number of different chip types (i.e., the number of different piles to be made).


THINGS TO NOTICE
----------------
As piles of wood chips begin to form, the piles are not ""protected"" in any way. That is, termites sometimes take chips away from existing piles. That strategy might seem counter-productive. But if the piles were ""protected"", you would end up with lots of little piles, not one big one.

The final piles are roughly round.  Why is this?  What other physical situations also produce round things?

In general, the number of piles decreases with time. Why?  Some piles disappear, when termites carry away all of the chips. And there is no way to start a new pile from scratch, since termites always put their wood chips near other wood chips. So the number of piles must decrease over time. (The only way a ""new"" pile starts is when an existing pile splits into two.)

How do the termites know which color chip to take?  This model assigns to each termite a variable that tells it which color chip to pick up. But, why do the termites sort the different types into discrete piles? Why don't they just make mixed groupings of chips?

This project is a good example of a DECENTRALIZED strategy.  There is no termite in charge, and no special pre-designated site for the piles. Each termite follows a set of simple rules, but the colony as a whole accomplishes a rather sophisticated task.


THINGS TO TRY
-------------
Do the results change if you use just a single termite?  What if you use several thousand termites?

Try changing the 'fd 10' command in the find-new-pile method.  How does it affect the termites' behavior if the 'fd 10' becomes a 'forward 1', or is taken out altogether?

When there are just two piles left, which of them is most likely to ""win"" as the single, final pile? How often does the larger of the two piles win? If one pile has only a single wood chip, and the other pile has the rest of the wood chips, what are the chances that the first pile will win?


EXTENDING THE MODEL
-------------------
Currently, the each termite 'belongs' to a chip type.  Can you extend the model so that the a termite can pick up chips of any type, and yet still sort the chips into discrete piles?

Plot the number of piles, or their average size, or the number of termites carrying wood chips, as the model runs.


NETLOGO FEATURES
----------------
Notice that the wood chips do not exist as objects. They are just represented as colors in the patches. The termites update the patch colors as they pick up and put down the wood chips. In effect, the screen is being used as the data structure. This strategy is useful in many NetLogo programs.


RELATED MODELS
--------------
Termites, Shepherds


CREDITS AND REFERENCES
------------------------
Resnick, M. & Wilensky, U. (1998). Diving into Complexity: Developing Probabilistic Decentralized Thinking through Role-Playing Activities. Journal of Learning Sciences, Vol. 7, No. 2.

To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Painted Desert Challenge model.  http://ccl.northwestern.edu/netlogo/models/PaintedDesertChallenge.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/PaintedDesertChallenge for terms of use.
"
Wandering Letters,/models/Sample Models/Computer Science,"globals
[
  text        ;; text to be written
  left-edge   ;; pxcor of leftmost column where letters can go
  right-edge  ;; ditto for rightmost
]

turtles-own
[
  word-length ;; the length of the word the turtle is in
  num-word    ;; the number the turtle's word is in the text
  leader      ;; the turtle with the character before this turtle's character
  new-line?   ;; whether we should start a new line or not
]

;; setup the variables and the View
to setup
  ca
  set text (word ""These are the times that try men's souls. ""
                ;; the next two sentences each contain all 26
                ;; letters of the alphabet!  (which makes them
                ;; good for testing typewriters)
                ""The quick brown fox jumped over the lazy dog. ""
                ""Pack my box with five dozen liquor jugs."")
  draw-margins
  ;; make the turtles ""disappear"" using a shape that has nothing
  ;; in it.  we can't use hide-turtle since we want to be able to see the
  ;; turtle's label
  set-default-shape turtles ""blank""
  ;; create enough turtles to have one for every character in text
  crt (length text)
  [
    set word-length 0
    set leader nobody
    set new-line? false
    scatter
  ]
  setup-letters
end

to scatter  ;; turtle procedure
  setxy random-xcor random-ycor
end

to draw-margins
  ask patches
    [ ifelse (pxcor = left-margin + min-pxcor) or
             (pxcor = max-pxcor - right-margin)
        [ set pcolor red ]
        [ set pcolor black ] ]
end

;; assign the letters to the turtles, determine who leads them,
;; and set how long each word is
to setup-letters
  let remaining-text text
  let word-count 1
  let prev-letter nobody

  ask turtles
  [
    set label first remaining-text
    set leader prev-letter
    set num-word word-count
    if label = "" ""
    [
      set word-count word-count + 2
      set num-word num-word + 1
    ]
    set remaining-text but-first remaining-text
    set prev-letter self
  ]

  let index 1
  repeat word-count
  [
    let turtles-in-word turtles with [num-word = index]
    ask turtles-in-word
      [ set word-length count turtles-in-word ]
    set index index + 1
  ]
end

;; the main procedure called by the GO forever button
to go
  update-margins
  ask turtles
  [
    set new-line? false
    pick-heading  ;; choose the heading to the appropriate patch
    ;; if the turtle is not satisfied with where it is in
    ;; relation to its leader, go forward a bit
    ifelse happy?
      [ move-to patch-here ]  ;; move to center of patch
      [ fd 0.5 ]
  ]
  tick
end

;; updates the left-edge and right-edge variables to match the margin
;; sliders, and redraws the margins if necessary
to update-margins
  if left-edge != left-margin + min-pxcor + 1
    [ set left-edge left-margin + min-pxcor + 1
      draw-margins ]
  if right-edge != max-pxcor - right-margin - 1
    [ set right-edge max-pxcor - right-margin - 1
      draw-margins ]
end

;; set the heading of the turtle to the appropriate patch
to pick-heading
  ifelse leader = nobody
    ;; first letter goes to upper-leftmost patch
    [ face patch left-edge max-pycor ]
    ;; other patches head toward patch to the right of leader's patch
    [
      let p [patch-at 1 0] of leader
      if p != nobody
      [ face p ]
      ifelse right-edge - left-edge < word-length
      [
        ;; if our word is too long for the width of text,
        ;; check to see if the patch to the right of the leader is on or over
        ;; the right margin
        if [pxcor] of leader >= right-edge
        [
          ;; if it is change the heading to the beginning of the next line
          set new-line? true
          face patch left-edge new-line-pycor
        ]
      ]
      [
        ;; if our word is short enough to fit on a single line but there is not
        ;; enough room on this particular line, try to word wrap.  that is to say,
        ;; if the turtle is at the beginning of a word and the word is too long to
        ;; be completed on a single line given the starting point of the word,
        ;; have the leader of the word, move to the next line.
        if (num-word != [num-word] of leader) and
           ([pxcor] of leader + word-length >= right-edge)
        [
          ;; if it is change the heading to the beginning of the next line
          set new-line? true
          face patch left-edge new-line-pycor
        ]
      ]
  ]
end

;; reports pycor of the new line the turtle is supposed to go to
;; based on the location of its leader and the width of the text
to-report new-line-pycor  ;; turtle procedure
  ifelse abs ([pycor] of leader - line-spacing) > max-pycor
    [ report [pycor] of leader ]
    [ report [pycor] of leader - line-spacing ]
end

;; reports true if turtle is satisifed with its current position
to-report happy?  ;; turtle procedure
  if leader = nobody  ;; if the turtle is the first letter...
    ;; ...is it on the upper-left-most patch that it can be?
    [ report (pxcor = left-edge) and (pycor = max-pycor) ]
  ifelse new-line?  ;; do we want to start a new-line?
    ;; is the turtle at the beginning of the next line?
    [ report (pxcor = left-edge) and (pycor = new-line-pycor) ]
      ;; is the turtle on the patch to the right of its leader?
    [ report patch-at -1 0 = [patch-here] of leader ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Wandering Letters model.
; http://ccl.northwestern.edu/netlogo/models/WanderingLetters.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/WanderingLetters
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model illustrates how to build a word processor where each of the letters acts independently.  Each letter knows only which letter comes before it and how long its word is.  When the letters or margins are moved, the letters find their own ways back to their proper locations.


HOW IT WORKS
------------
Each letter looks both for changes in the margins and for being out of sync with its ""leader"", which is the letter before it in the text.  If it is not in its proper place relative to its leader, it takes a step in its leader's direction.


HOW TO USE IT
-------------
SETUP initializes the margins and some sample sentences for the text.

GO starts and stops the simulation.

The LEFT-MARGIN and RIGHT-MARGIN sliders let you move the sliders.  You can move these sliders while GO is running and the letters will adjust on the fly.

SCATTER LETTERS scatters the letters randomly about the View.  You can press this even while GO is running.

LINE-SPACING controls how much space there is between lines.


THINGS TO NOTICE
----------------
How do the letters find their way home?  In what ways is this different from the behavior of letters in a standard word processor?


THINGS TO TRY
-------------
While GO is pressed try:
--Moving the margin sliders
--Changing the spacing
--Pushing the scatter button
--Combinations of all three


EXTENDING THE MODEL
-------------------
Can you extend the model so the user can type his/her own message?  You might want to use the user-input primitive for this.

Sometimes a space will end up at the beginning of a new line.  Try to fix it so that spaces are ignored at the ends of lines.


NETLOGO FEATURES
----------------
Note the use of a blank shape to make a turtle that is invisible except for its label.


CREDITS AND REFERENCES
----------------------
This model is based on a Smalltalk program of the same name developed by Ted Kaehler of Disney Interactive.

To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Wandering Letters model.  http://ccl.northwestern.edu/netlogo/models/WanderingLetters.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/WanderingLetters for terms of use.
"
Merge Sort,/models/Sample Models/Computer Science/Unverified,"breed [ mergers merger ]
breed [ elements element ]

elements-own [ value ]
mergers-own [ merge-group ]
globals
[
  group-count     ;; Number of groups (lists) of elements
  group-list      ;; List of lists of elements
  step-number     ;; Number of complete merge steps finished
  current-loc     ;; Group position of next element to be drawn, used by single-sort
  current-group   ;; Group number of next element to be drawn, used by single-sort
  current-count   ;; Element number of next element to be drawn, used by single-sort
]

;;;;;;;;;;;;;;;;;;;;;;
;; Setup Procedures ;;
;;;;;;;;;;;;;;;;;;;;;;

to setup
  ca
  set current-count 1
  set current-loc 0
  set current-group 0
  set step-number 0
  set group-list []
  set group-count number-of-elements
  setup-elements
end

to setup-elements
  set-default-shape turtles ""circle""
  create-elements number-of-elements
  [
    set size 5
    set value (random (4 * number-of-elements))
    ;; (list self) creates a list with its sole item being the turtle itself
    set group-list lput (list self) group-list
  ]
  draw
end

;;;;;;;;;;;;;;;;;;;;;;;;
;; Runtime Procedures ;;
;;;;;;;;;;;;;;;;;;;;;;;;

;; Do one set of group merges.  That is, have each pair of neighboring groups merge.
to step-row
  ;; Finish displaying current step if need be
  if (current-count > 1)
  [
    draw
    set current-count 1
    set current-loc 0
    set current-group 0
    stop
  ]
  ;; Stop if the first group contains all elements which means all elements
  ;; have been sorted.
  if (length (item 0 group-list) = number-of-elements)
    [ stop ]
  set step-number (step-number + 1)
  combine-groups
  draw
end

;;;;;;;;;;;;;;;;;;;;;;;;
;; Merging Procedures ;;
;;;;;;;;;;;;;;;;;;;;;;;;
to combine-groups
  let num 0
  ;; Create a merger for every two groups
  ;; Each merger will combine two groups
  create-mergers (group-count / 2)
  [
    set merge-group num
    set num (num + 2)
  ]
  ask mergers
  [
    merge (item merge-group group-list) (item (merge-group + 1) group-list) merge-group
    die
  ]
  ;; Remove empty groups (-1's) from our list
  set group-list remove -1 group-list
  set group-count length group-list
end

;; Merge lists 1 and 2 into one list, maintaining order
to merge [ list1 list2 location ] ;; mergers procedure
  let new-list []
  ;; Sort the lists into new-list until either list1 or list2 is empty.
  ;; The groups are merged into increasing/decreasing order depending on
  ;; whether the increasing-order switch in on/off.
  let item1 0
  let item2 0
  while [(not empty? list1) and (not empty? list2)]
  [
    set item1 item 0 list1
    set item2 item 0 list2
    ifelse ( [value] of item1 < [value] of item2 )
    [
      set new-list lput item1 new-list
      set list1 but-first list1
    ]
    [
      set new-list lput item2 new-list
      set list2 but-first list2
    ]
  ]
  ;; One of the lists is always going to be non-empty after the above loop.
  ;; Put the remainder of the non-empty list into new-list.
  ifelse (empty? list1)
    [ set new-list sentence new-list list2 ]
    [ set new-list sentence new-list list1 ]
  ;; Copy the new-list into the appropriate location in group-list.
  ;; [(a+b) b c d] becomes [(a+b) -1 c d]
  ;; The -1's will be removed once the entire step is complete.
  ;; We do this instead of removing it here to keep order and length intact.
  set group-list (replace-item location group-list new-list)
  set group-list (replace-item (location + 1) group-list -1)
end

;;;;;;;;;;;;;;;;;;;;;;;;
;; Display Procedures ;;
;;;;;;;;;;;;;;;;;;;;;;;;
to step-item
  ;; If we have finished this round of sorting, reset our values
  if (current-count > number-of-elements)
  [
    set current-count 1
    set current-loc 0
    set current-group 0
  ]
  ;; Do a round of sorting before we display if necessary
  if (current-count = 1)
  [
    ;; Stop if the first group contains all elements which means all elements
    ;; have been sorted.
    if (length (item 0 group-list) = number-of-elements)  [stop]
    set step-number (step-number + 1)
    combine-groups
    ;; To display the step number.
    ask patch (min-pxcor + 2) (max-pycor - 5 - (step-number * 10))
      [set plabel-color green set plabel step-number]
  ]
  ;; Display the current element with its new position and color.
  let tcolor [color] of first (item current-group group-list)
  ask (item current-loc (item current-group group-list))
  [
    set pcolor color
    set color tcolor
    set ycor (max-pycor - 5 - (10 * step-number))
    set xcor (min-pxcor + (current-count * ((2 * max-pxcor) / (number-of-elements + 1))))
    ask patch-at 0 4 [set plabel-color white set plabel [value] of myself]
  ]
  ;; Update information about which turtle to display next
  set current-count (current-count + 1)
  ifelse(length (item current-group group-list) = (current-loc + 1))
  [
    set current-loc 0
    set current-group (current-group + 1)
  ]
  [ set current-loc (current-loc + 1) ]
end

;; Move the turtles to their appropriate locations
to draw
  let list-loc 0
  let element-num 1
  ;; Evenly space the elements across the view
  let separation ((2 * max-pxcor) / (number-of-elements + 1))
  ;; To display the step number.
  ask patch (min-pxcor + 2) (max-pycor - 5 - (step-number * 10))
    [set plabel-color green set plabel step-number]
  while [list-loc < group-count]
  [
    let current-list item list-loc group-list
    let tcolor [color] of first current-list
    while [not empty? current-list]
    [
      ask (item 0 current-list)
      [
        ;; To keep track of what group an element belonged to before the current step,
        ;; we leave the color and display the value at it's previous place.
        if (step-number != 0) [ set pcolor color]
        set color tcolor
        set ycor (max-pycor - 5 - (10 * step-number))
        set xcor (min-pxcor + (element-num * separation))
        ask patch-at 0 4 [set plabel-color white set plabel [value] of myself]
      ]
      set element-num (element-num + 1)
      set current-list but-first current-list
    ]
    set list-loc (list-loc + 1)
  ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2005 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2005).  NetLogo Merge Sort model.
; http://ccl.northwestern.edu/netlogo/models/MergeSort.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2005 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/MergeSort
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model is a visual demonstration of a standard sort algorithm called merge sort.  The algorithm reorders, or permutes, n numbers into ascending order.  This is accomplished by dividing the numbers into groups and then merging smaller groups to form larger groups. Order is maintained as the lists are merged so when the algorithm finishes there is only one sorted list containing all n items.

Note that it is possible to express merge sort in NetLogo much more concisely than is done in this model.  Since this model aims to demonstrate the sort algorithm visually, the code is more complex than would be needed if the model only needed to sort the numbers.


HOW IT WORKS
------------
We start out with as many independent groups as we have elements.  As the algorithm progresses through the list, it merges each adjacent pair of groups; thus, after each pass, the number of groups is halved.

To merge two groups:
1. Compare the first elements of the two groups to each other
2. Place the smallest/largest element (depending on the increasing-order? switch) of the two in a third group
3. Remove that element from its source group
4. Repeat until one of the source groups is empty
5. Place all of the remaining elements from the non-empty source group onto the end of the third group
6. Substitute, in place, the third group for the two source groups

We do this merge repeatedly for each set of two groups until there is only one group left.  This final group is the original set of numbers in sorted order.

The number of steps required to sort n items using this algorithm is the ceiling of logarithm (base 2) of n.  Each step requires at most n comparisons between the numbers.  Therefore, the time it takes for the algorithm to run is about n log n.  Computer scientists often write this as O(n log n) where n is how many numbers are to be sorted.


HOW TO USE IT
--------------
Change the value of the NUMBER-OF-ELEMENTS slider to modify how many numbers to sort.

Pressing SETUP creates NUMBER-OF-ELEMENTS random values to be sorted.

STEP (1 ITEM) merges one number into its new group.

STEP (1 ROW) does one full round of group merges.


THINGS TO NOTICE
-----------------
Groups are represented by color.  Numbers in the same group have the same color.  When two groups merge, the numbers take the color of the smallest/largest element in the new group.  Can you predict what would be the final color of all elements before starting?

Would merging more than two groups at a time lead to the elements getting sorted in fewer steps?  Would this change make the algorithm any faster?


THINGS TO TRY
-------------
We stated above that the algorithm will take at most a constant factor times n log n time to execute.  Can you figure out why the constant factor is needed to make this statement accurate?


EXTENDING THE MODEL
-------------------
Can you make the elements draw their paths across the view?

There are many different sorting algorithms. You can find a few described at http://en.wikipedia.org/wiki/Sorting_algorithm.  Try implementing the different sorts in NetLogo and use BehaviorSpace to compare them.  Do different sorts perform better with different input sets (uniformly random, nearly sorted, reverse sorted, etc.)?


NETLOGO FEATURES
----------------
This model uses lists extensively.

Note that NetLogo includes SORT and SORT-BY primitives; normally, you would just use one of these, rather than implementing a sort algorithm yourself.  SORT arranges items in ascending order; SORT-BY lets you specify how items are to be ordered.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (2005).  NetLogo Merge Sort model.  http://ccl.northwestern.edu/netlogo/models/MergeSort.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2005 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/MergeSort for terms of use.
"
Perceptron,/models/Sample Models/Computer Science/Unverified,"globals [
          epoch-error   ;; average error in this epoch
          perceptron    ;; a single output-node
        ]

;; A perceptron is modeled by input-node and bias-node agents
;; connected to an output-node agent.

;; Connections from input nodes to output nodes
;; in a perceptron.
links-own [ weight ]

;; input-nodes have an activation value of 1 or -1
breed [ input-nodes input-node ]
input-nodes-own [ activation ]

;; bias nodes are input-nodes whose activation
;; is always 1.
breed [ bias-nodes bias-node ]
bias-nodes-own [ activation ]

;; Output nodes compute the weighted some of their
;; inputs and then set their activation to 1 if
;; the sum is greater than their threshold.  An
;; output node can also be the input-node for another
;; perceptron.
breed [ output-nodes output-node ]
output-nodes-own [ threshold activation]

;; set up a perceptron
to setup

  ;; clear the world
  ca

  ;; set our background to something more viewable than black
  ask patches [ set pcolor white - 3 ]

  ;; set up the shapes for all the entities
  set-default-shape input-nodes ""circle""
  set-default-shape bias-nodes ""bias-node""
  set-default-shape output-nodes ""output-node""

  ;; create output node
  create-output-nodes 1 [
    set activation random-activation
    set xcor 6
    set size 2
    set threshold 0
    set perceptron self
  ]

  ;; create bias node
  create-bias-nodes 1 [
    set activation 1
    setxy 3 7
    set size 1.5
    my-create-link-to perceptron
  ]

  ;; create input nodes
  let input-node-count 1
  create-input-nodes 2 [
    set activation random-activation
    set label (word ""Node "" input-node-count)
    set label-color magenta
    setxy -6 10 - input-node-count * 5
    set size 1.5
    my-create-link-to perceptron
    set input-node-count input-node-count + 1
  ]

  ask perceptron [ compute-activation ]

end

;; links an input or bias node to an output node
to my-create-link-to [ anode ] ;; input or bias node procedure
    create-link-to anode [
      set color red + 1
      ;; initialize the weight of the link
      set weight random-float .1 - .05
    ]
end

to-report perceptron-input-nodes ;; output-node-procedure
  report in-link-neighbors with [ breed != bias-nodes ]
end

to-report perceptron-input-links ;; output-node procedure
  report my-in-links with [ [breed] of end1 != bias-nodes ]
end

to-report perceptron-bias-node ;; output-node procedure
  report one-of in-link-neighbors with [ breed = bias-nodes ]
end

to-report perceptron-bias-links ;; output-node procedure
  report my-in-links with [ [breed] of end1 = bias-nodes ]
end


to compute-activation ;; output-node procedure
  ;; computes activation by summing the inputs * weights and running through step function
  set activation sign sum [ [activation] of end1 * weight ] of my-in-links
  recolor
end

to update-weights [ target-answer ] ;; output-node procedure
  ;; declare a variable for the output answer
  let output-answer activation

  ;; calculate error for output nodes
  let output-error target-answer - output-answer

  ;; update the epoch-error
  set epoch-error epoch-error + (target-answer - sign output-answer) ^ 2

  ;; examine input output edges and set their new weight
  ;; increasing or decreasing it by a value determined by the learning-rate
  ask my-in-links [
    set weight weight + learning-rate * output-error * [activation] of end1

  ]

end
;; computes the sign function given an input value
to-report sign [input]  ;; output-node procedure
  ifelse input > threshold [
    report 1
  ]
  [
    report -1
  ]
end

to-report random-activation ;; observer procedure
  ifelse random 2 = 0
    [ report 1 ]
    [ report -1 ]
end

to-report compute-target-answer ;; observer procedure
    ;; compute the correct answer
    ;; this is the parity problem
    ;; count the number of 1's if its even or 0 return a negative answer
    if (target-function = ""xor"") [
      report [my-xor] of perceptron
    ]
    if (target-function = ""or"") [
      report [my-or] of perceptron
    ]
    if (target-function = ""nor"") [
      report [my-nor] of perceptron
    ]
    if (target-function = ""and"") [
      report [my-and] of perceptron
    ]
    if (target-function = ""nand"") [
      report [my-nand] of perceptron
    ]
end


to-report my-or ;; output-node procedure
  ;; this is or
  ifelse any? perceptron-input-nodes with [ activation = 1 ] [
    report 1
  ]
  [
    report -1
  ]
end

to-report my-xor ;; output-node procedure
    ;; this is xor
    let ones-count 0
    ask perceptron-input-nodes [
      if activation = 1 [
        set ones-count ones-count + 1
      ]
    ]
    ifelse ( ones-count = 1 )
      [ report 1 ]
      [ report -1 ]
end

to-report my-and ;; output-node procedure
    ;; this is xor
    let ones-count 0
    ask perceptron-input-nodes [
      if activation = 1 [
        set ones-count ones-count + 1
      ]
    ]
    ifelse ( ones-count = 2 )
      [ report 1 ]
      [ report -1 ]
end

to-report my-nor ;; output-node procedure
    ;; this is xor
    let ones-count 0
    ask perceptron-input-nodes [
      if activation = 1 [
        set ones-count ones-count + 1
      ]
    ]
    ifelse ( ones-count = 0 )
      [ report 1 ]
      [ report -1 ]
end


to-report my-nand ;; output-node procedure
    ;; this is xor
    let ones-count 0
    ask perceptron-input-nodes [
      if activation = 1 [
        set ones-count ones-count + 1
      ]
    ]
    ifelse ( ones-count != 2 )
      [ report 1 ]
      [ report -1 ]
end

;; train sets the input nodes to a random input
;; it then computes the output
;; it determines the correct answer and back propagates the weight changes
to train ;; observer procedure
  let counter 0
  set epoch-error 0
  while [counter < examples-per-epoch] [

    ;; set the input nodes randomly
    ask perceptron [
      ask perceptron-input-nodes [ set activation random-activation ]
    ]

    ;; distribute error
    ask perceptron [
      compute-activation
      update-weights compute-target-answer
      recolor
    ]

    ;; increment the counter
    set counter counter + 1
  ]

  ;; plot stats
  set epoch-error epoch-error / examples-per-epoch
  set epoch-error epoch-error * 0.5
  tick
  plot-error
  plot-learned-line
end

;; test runs one instance and computes the output
to test ;; observer procedure
  ;; initialize the input nodes
  ask perceptron
  [ (foreach sort perceptron-input-nodes
        (list test-input-node-1-value
            test-input-node-2-value) [
          ask ?1 [ set activation ?2 ]
        ])
  ]

  ;; compute the correct answer
  let target-answer compute-target-answer

  ;; color the nodes
  ask perceptron [ compute-activation ]

  ;; compute the answer

  let output-answer [activation] of perceptron

  ;; output the result
  ifelse output-answer = target-answer [
    user-message (word ""Output: "" output-answer ""\nTarget: "" target-answer ""\nCorrect Answer!"")
  ]
  [
    user-message (word ""Output: "" output-answer ""\nTarget: "" target-answer ""\nIncorrect Answer!"")
  ]
end


;; Sets the color of the perceptron's nodes appropriately
;; based on activation
to recolor ;; output, input, or bias node procedure
  ifelse activation = 1
    [ set color white ]
    [ set color black ]
  ask in-link-neighbors [ recolor ]

  ifelse (show-weights? = true) [
    resize-recolor-links
  ]
  [
    ask my-in-links [
      __set-line-thickness 0
      set label """"
      set color red + 1
    ]
  ]

end

;; plot the error from the training
to plot-error ;; observer procedure
  set-current-plot ""Error vs. Epochs""
  plotxy ticks epoch-error
end

;; plot the decision line learned
to plot-learned-line ;; observer procedure
  set-current-plot ""Rule Learned""

  ;; clear the previous plot
  clear-plot

  if ( target-function = ""or"" )
   [ set-current-plot-pen ""positives""
     plotxy -1 1
     plotxy 1 1
     plotxy 1 -1
     set-current-plot-pen ""negatives""
     plotxy -1 -1
   ]

  if ( target-function = ""xor"" )
   [ set-current-plot-pen ""positives""
     plotxy -1 1
     plotxy 1 -1
     set-current-plot-pen ""negatives""
     plotxy 1 1
     plotxy -1 -1
   ]

   if ( target-function = ""and"" )
   [ set-current-plot-pen ""positives""
     plotxy 1 1
     set-current-plot-pen ""negatives""
     plotxy 1 -1
     plotxy -1 1
     plotxy -1 -1
   ]

   if ( target-function = ""nor"" )
   [ set-current-plot-pen ""positives""
     plotxy -1 -1
     set-current-plot-pen ""negatives""
     plotxy 1 1
     plotxy 1 -1
     plotxy -1 1
   ]

   if ( target-function = ""nand"" )
   [ set-current-plot-pen ""positives""
     plotxy -1 -1
     plotxy 1 -1
     plotxy -1 1
     set-current-plot-pen ""negatives""
     plotxy 1 1
   ]
  ;; cycle through all the x-values and plot the corresponding x-values
  let x1 -2
  let edges sort [perceptron-input-links] of perceptron
  let edge1 first edges
  let edge2 item 1 edges

  while [x1 <= 2] [

    ;; calculate w0 (the bias weight)
    let w0 sum [weight] of ([perceptron-bias-links] of perceptron)


    ;; put it all together
    let x2 ( (- w0 - [weight] of edge1 * x1) / [weight] of edge2 )

    ;; plot x1, x2
    set-current-plot-pen ""rule""
    plotxy x1 x2

    ;; increment x
    set x1 x1 + 1
  ]
end


;; resize and recolor the edges
;; resize to indicate weight
;; recolor to indicate positive or negative
to resize-recolor-links
  ask links [
    set label precision weight 4
    set thickness .1 + 4 * abs weight
    ifelse (weight > 0) [
      set color red + 1
    ]
    [
      set color blue
    ]
  ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2006 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Rand, W. and Wilensky, U. (2006). NetLogo Perceptron model.
; http://ccl.northwestern.edu/netlogo/models/Perceptron.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2006 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Perceptron
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
Artificial Neural Networks (ANNs) are computational parallels of biological neurons. The ""perceptron"" was the first attempt at this particular type of machine learning.  It attempts to classify input signals and output a result.  It does this by being given a lot of examples and attempting to classify them, and having a supervisor tell it if the classification was right or wrong.  Based on this information the perceptron updates its weights until it classifies all inputs correctly.

For a while it was thought that perceptrons might make good general pattern recognition units.  However, it was discovered that a single perceptron can not learn some basic tasks like 'xor' because they are not linearly separable.  This model illustrates this case.


HOW IT WORKS
------------
The nodes on the left are the input nodes. They can have a value of 1 or -1.   These are how one presents input to the perceptron.  The node in the middle is the bias node.  Its value is constantly set to '1' and allows the perceptron to use a constant in its calculation.  The one output node is on the right.  The nodes are connected by links.  Each link has a weight.

To determine its value, an output node computes the weighted sum of its input nodes.  The value of each input node is multiplied by the weight of the link connecting it to the output node to give a weighted value.  The weighted values are then all added up. If the result is above a threshold value, then the value is 1, otherwise it is -1.  The threshold value for the output node in this model is 0.

While the network is training, inputs are presented to the perceptron.  The output node value is compared to an expected value, and the weights of the links are updated in order to try and correctly classify the inputs.


HOW TO USE IT
-------------
SETUP will initialize the model and reset any weights to a small random number.

Pressing the TRAIN button will present a group of examples to the perceptron and weight will be updated.

Moving the EXAMPLES-PER-EPOCH slider changes the number of training examples presented to the perceptron during each step of the TRAIN event.

Moving the LEARNING-RATE slider changes the maximum amount of movement that any one example can have on a particular weight.

Pressing TEST will input the values of TEST-INPUT-NODE-1-VALUE and TEST-INPUT-NODE-2-VALUE to the perceptron and compute the output.

If SHOW-WEIGHTS? is on then the size of the edges will indicate the weight, and the color will indicate the sign.  Blue indicates negative edges, and red indicates positive edges.

The TARGET-FUNCTION chooser allows you to decide which function the perceptron is trying to learn.


THINGS TO NOTICE
----------------
The perceptron will quickly learn the 'or' function.  However it will never learn the 'xor' function.  Not only that but when trying to learn the 'xor' function it will never settle down to a particular set of weights as a result it is completely useless as a pattern classifier for non-linearly separable functions.  This problem with perceptrons can be solved by combining several of them together as is done in multi-layer networks.  For an example of that please examine the ANN Neural Network model.

The RULE LEARNED graph visually demonstrates the line of separation that the perceptron has learned, and presents the current inputs and their classifications.  Dots that are green represent points that should be classified positively.  Dots that are red represent points that should be classified negatively.  The line that is presented is what the perceptron has learned.  Everything on one side of the line will be classified positively and everything on the other side of the line will be classified negatively.  As should be obvious from watching this graph, it is impossible to draw a straight line that separates the red and the green dots in the 'xor' function.  This is what is meant when it is said that the 'xor' function is not linearly separable.

The ERROR VS. EPOCHS graph displays the relationship between the squared error and the number of training epochs.


THINGS TO TRY
-------------
Try different learning rates and see how this affects the motion of the RULE LEARNED graph.

Try training the perceptron several times using the 'or' rule and turning on SHOW-WEIGHTS?  Does the model ever change?

How does modifying the number of EXAMPLES-PER-EPOCH affect the ERROR graph?


EXTENDING THE MODEL
-------------------
Add additional target functions beside 'or' and 'xor.'

Can you come up with a new learning rule to update the edge weights that will always converge even if the function is not linearly separable?

Can you modify the LEARNED RULE graph so it is obvious which side of the line is positive and which side is negative?


NETLOGO FEATURES
----------------
This model makes use of some of the link features.  It also treats each node and link as an individual agent.  This is distinct from many other languages where the whole perceptron would be treated as a single agent.


RELATED MODELS
--------------
Artificial Neural Net shows how arranging perceptrons in multiple layers can overcomes some of the limitations of this model (such as the inability to learn 'xor')


CREDITS AND REFERENCES
----------------------
Several of the equations in this model are derived from Tom Mitchell's book ""Machine Learning"" (1997).

Perceptrons were initially proposed in the late 1950s by Frank Rosenblatt.

A standard work on perceptrons is the book Perceptrons by Marvin Minsky and Seymour Paper (1969).  The book includes the result that single-layer perceptrons cannot learn XOR.  The discovery that multi-layer perceptrons can learn it came later, in the 1980s.

Thanks to Craig Brozefsky for his work in improving this model.

To refer to this model in academic publications, please use:  Rand, W. and Wilensky, U. (2006).  NetLogo Perceptron model.  http://ccl.northwestern.edu/netlogo/models/Perceptron.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2006 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Perceptron for terms of use.
"
Artificial Neural Net,/models/Sample Models/Computer Science/Unverified,"links-own [weight]

;; define the four node types
breed [bias-nodes bias-node]
bias-nodes-own [activation error]
breed [input-nodes input-node]
input-nodes-own [activation error]
breed [output-nodes output-node]
output-nodes-own [activation error]
breed [hidden-nodes hidden-node]
hidden-nodes-own [activation error]

globals [
  epoch-error
]

;;;
;;; SETUP PROCEDURES
;;;

to setup
  clear-all
  ask patches [ set pcolor gray + 2 ]
  set-default-shape bias-nodes ""bias-node""
  set-default-shape input-nodes ""circle""
  set-default-shape output-nodes ""output-node""
  set-default-shape hidden-nodes ""output-node""
  setup-nodes
  setup-links
  propagate
end

to setup-nodes
  create-bias-nodes 1 [ setxy -5 5 ]
  ask bias-nodes [ set activation 1 ]
  create-input-nodes 1 [ setxy -5 -1 ]
  create-input-nodes 1 [ setxy -5 1 ]
  ask input-nodes [ set activation random 2 ]
  create-hidden-nodes 1 [ setxy 0 -1 ]
  create-hidden-nodes 1 [ setxy 0 1 ]
  ask hidden-nodes [ set activation random 2
                     set size 1.5 ]
  create-output-nodes 1 [ setxy 5 0 ]
  ask output-nodes [ set activation random 2 ]
end

to setup-links
  connect-all bias-nodes hidden-nodes
  connect-all bias-nodes output-nodes
  connect-all input-nodes hidden-nodes
  connect-all hidden-nodes output-nodes
end

to connect-all [nodes1 nodes2]
  ask nodes1 [
    create-links-to nodes2 [
      set weight random-float 0.2 - 0.1
    ]
  ]
end

to recolor
  ask turtles with [breed != links] [
    set color item (step activation) [black white]
  ]
  ask links [
    set thickness 0.1 * abs weight
    ifelse weight > 0
      [ set color red ]
      [ set color blue ]
  ]
end

;;;
;;; TRAINING PROCEDURES
;;;

to train
  set epoch-error 0
  repeat examples-per-epoch [
    ask input-nodes [ set activation random 2 ]
    propagate
    back-propagate
  ]
  tick
  set epoch-error epoch-error / examples-per-epoch
  plotxy ticks epoch-error
end

;;;
;;; FUNCTIONS TO LEARN
;;;

to-report target-answer
  ifelse target-function = ""xor""
    [ report my-xor ]
    [ report my-or ]
end

to-report my-or
  ;; assumes exactly two input nodes
  ifelse [activation] of input-nodes = [0 0]
    [ report [0] ]
    [ report [1] ]
end

to-report my-xor
  ;; assumes exactly two input nodes
  let vals [activation] of input-nodes
  ifelse item 0 vals = item 1 vals
    [ report [0] ]
    [ report [1] ]
end

;;;
;;; PROPAGATION PROCEDURES
;;;

;; carry out one calculation from beginning to end
to propagate
  ask hidden-nodes [ set activation new-activation ]
  ask output-nodes [ set activation new-activation ]
  recolor
end

to-report new-activation  ;; node procedure
  report sigmoid sum [[activation] of end1 * weight] of my-in-links
end

;; changes weights to correct for errors
to back-propagate
  ;; plot stats
  ;; computing error for output nodes
  ;;  this assumes that the nodes-list will be in the same order that the list of the correct
  ;;     answers is in
  let example-error 0
  (foreach target-answer (sort output-nodes) [
    ask ?2 [ set error activation * (1 - activation) * (?1 - activation) ]
    set example-error example-error + ( (?1 - [activation] of ?2) ^ 2 )
  ] )
  set epoch-error epoch-error + (example-error / count output-nodes)
  ask hidden-nodes [
    set error activation *
              (1 - activation) *
              sum [weight * [error] of end2] of my-out-links
  ]
  ask links [
    set weight weight + learning-rate * [error] of end2 * [activation] of end1
  ]
end

;;;
;;; MISC PROCEDURES
;;;

;; computes the sigmoid function given an input value and the weight on the link
to-report sigmoid [input]
  report 1 / (1 + e ^ (- input))
end

;; computes the step function given an input value and the weight on the link
to-report step [input]
  ifelse input > 0.5
    [ report 1 ]
    [ report 0 ]
end

;;;
;;; TESTING PROCEDURES
;;;

;; test runs one instance and computes the output
to test
  ;; output the result
  ifelse test-success? input-1 input-2
    [ user-message ""Correct."" ]
    [ user-message ""Incorrect."" ]
end

to-report test-success? [n1 n2]
  ask item 0 sort input-nodes [ set activation n1 ]
  ask item 1 sort input-nodes [ set activation n2 ]
  propagate
  report target-answer = map [step [activation] of ?] sort output-nodes
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2006 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Rand, W. and Wilensky, U. (2006). NetLogo Artificial Neural Net model.
; http://ccl.northwestern.edu/netlogo/models/ArtificialNeuralNet.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2006 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/ArtificialNeuralNet
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This is a model of a very small neural network.  It is based on the Perceptron model, but instead of one layer, this network has two layers of ""perceptrons"".  That means it can learn operations a single layer cannot.

The goal of a network is to take input from its input nodes on the far left and classify those inputs appropriately in the output nodes on the far right.  It does this by being given a lot of examples and attempting to classify them, and having a supervisor tell it if the classification was right or wrong.  Based on this information the neural network updates its weight until it correctly classifies all inputs correctly.


HOW IT WORKS
------------
Initially the weights on the links of the networks are random.  When inputs are fed into the network on the far left, those inputs times the random weights are added up to create the activation for the next node in the network.  The next node then sends out an activation along its output link.  These link weights and activations are summed up by the final output node which reports a value.  This activation is passed through a sigmoid function, which means that values near 0 are assigned values close to 0, and vice versa for 1.  The values increase nonlinearly between 0 and 1 with a sharp transition at 0.5.

To train the network a lot of inputs are presented to the network along with how the network should correctly classify the inputs.  The network uses a back-propagation algorithm to pass error back from the output node and uses this error to update the weights along each link.


HOW TO USE IT
-------------
To use it press SETUP to create the network and initialize the weights to small random numbers.

Press TRAIN ONCE to run one epoch of training.  The number of examples presented to the network during this epoch is controlled by EXAMPLES-PER-EPOCH slider.

Press TRAIN to continually train the network.

In the view, the larger the size of the link the greater the weight it has.  If the link is red then its a positive weight.  If the link is blue then its a negative weight.

To test the network, set INPUT-1 and INPUT-2, then press the TEST button.  A dialog box will appear telling you whether or not the network was able to correctly classify the input that you gave it.

LEARNING-RATE controls how much the neural network will learn from any one example.

TARGET-FUNCTION allows you to choose which function the network is trying to solve.


THINGS TO NOTICE
----------------
Unlike the Perceptron model, this model is able to learn both OR and XOR.  It is able to learn XOR because the hidden layer (the middle nodes) in a way allows the network to draw two lines classifying the input into positive and negative regions.  As a result one of the nodes will learn essentially the OR function that if either of the inputs is on it should be on, and the other node will learn an exclusion function that if both of the inputs or on it should be on (but weighted negatively).

However unlike the perceptron model, the neural network model takes longer to learn any of the functions, including the simple OR function.  This is because it has a lot more that it needs to learn.  The perceptron model had to learn three different weights (the input links, and the bias link).  The neural network model has to learn ten weights (4 input to hidden layer weights, 2 hidden layer to output weight and the three bias weights).


THINGS TO TRY
-------------
Manipulate the LEARNING-RATE parameter.  Can you speed up or slow down the training?

Switch back and forth between OR and XOR several times during a run.  Why does it take less time for the network to return to 0 error the longer the network runs?


EXTENDING THE MODEL
-------------------
Add additional functions for the network to learn beside OR and XOR.  This may require you to add additional hidden nodes to the network.

Back-propagation using gradient descent is considered somewhat unrealistic as a model of real neurons, because in the real neuronal system there is no way for the output node to pass its error back.  Can you implement another weight-update rule that is more valid?


NETLOGO FEATURES
----------------
This model uses the link primitives.  It also makes heavy use of lists.


RELATED MODELS
--------------
This is the second in the series of models devoted to understanding artificial neural networks.  The first model is Perceptron.


CREDITS AND REFERENCES
----------------------
The code for this model is inspired by the pseudo-code which can be found in Tom M. Mitchell's ""Machine Learning"" (1997).

Thanks to Craig Brozefsky for his work in improving this model.

To refer to this model in academic publications, please use:  Rand, W. and Wilensky, U. (2006).  NetLogo Artificial Neural Net model.  http://ccl.northwestern.edu/netlogo/models/ArtificialNeuralNet.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2006 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/ArtificialNeuralNet for terms of use.
"
Hex Cell Aggregation,/models/Sample Models/Computer Science,"globals [
  ;; This list contains the numbers of the switches that are on,
  ;; for example, if all six switches are on, the list will be
  ;; [1 2 3 4 5 6].  The list is only built during SETUP and
  ;; READ-SWITCHES.
  switches
  ;; This is a list of cells which are eligible to become alive.
  eligibles
]

;; About the use of lists in this model:
;;
;; The model could be coded more simply without the ""switches"" and
;; ""eligibles"" lists.  But using those lists enables the model to run
;; much faster.
;;
;; The ""switches"" list is used so a cell can quickly check its live
;; neighbors count against the six switches without having to actually
;; inspect the switches one by one.  If the user flips a switch,
;; the list will be out of date, which is why we ask the user to
;; press the SETUP or READ-SWITCHES buttons after changing switches.
;;
;; The ""eligibles"" list is used so that when we are trying to decide
;; what cell will become alive next, we don't have to check every
;; cell.  The list contains only those cells we know are eligible.
;; Every time a cell becomes alive, we remove it from the list.
;; We must also check that cell's neighbors to see if they need
;; to be added or removed from the list.

breed [cells cell]

cells-own [
  hex-neighbors
  live-neighbor-count
  eligible?
]

to setup
  clear-all
  setup-grid
  read-switches
  ;; start with one live cell in the middle
  ask cells-on patch 0 0 [ become-alive ]
end

to go
  if empty? eligibles [ stop ]
  ask one-of eligibles [ become-alive ]
  tick
end

to become-alive  ;; cell procedure
  show-turtle
  set eligible? false
  set eligibles remove self eligibles
  ask hex-neighbors [
    set live-neighbor-count live-neighbor-count + 1
    if live-neighbor-count = 6 [ set color red ]
    update-eligibility
  ]
end

to update-eligibility  ;; cell procedure
  ifelse eligible?
  ;; case 1: currently eligible
  [
    if not member? live-neighbor-count switches [
      set eligible? false
      set eligibles remove self eligibles
    ]
  ]
  ;; case 2: not currently eligible
  [
    ;; the check for hidden? ensures the cell isn't already alive
    if hidden? and member? live-neighbor-count switches [
      set eligible? true
      ;; The order of the list doesn't matter, but in NetLogo
      ;; (as in Logo and Lisp generally), FPUT is much much
      ;; faster than LPUT.
      set eligibles fput self eligibles
    ]
  ]
end

;;; only allow the new alive cells to have number of neighbors as allowed by the switches
to read-switches
  set switches []
  if one-neighbor?    [ set switches lput 1 switches ]
  if two-neighbors?   [ set switches lput 2 switches ]
  if three-neighbors? [ set switches lput 3 switches ]
  if four-neighbors?  [ set switches lput 4 switches ]
  if five-neighbors?  [ set switches lput 5 switches ]
  if six-neighbors?   [ set switches lput 6 switches ]
  ask cells [
    set eligible? hidden? and member? live-neighbor-count switches
  ]
  set eligibles [self] of cells with [eligible?]
end

;;; this was mostly taken from Hex Cells Example
to setup-grid
  set-default-shape turtles ""hex""
  ask patches [
    sprout-cells 1 [
      hide-turtle
      set color orange
      set eligible? false
      if pxcor mod 2 = 0 [
        set ycor ycor - 0.5
      ]
    ]
  ]
  ask cells [
    ifelse pxcor mod 2 = 0 [
      set hex-neighbors cells-on patches at-points [[0  1] [ 1  0] [ 1 -1]
                                                    [0 -1] [-1 -1] [-1  0]]
    ][
      set hex-neighbors cells-on patches at-points [[0  1] [ 1  1] [ 1  0]
                                                    [0 -1] [-1  0] [-1  1]]
    ]
  ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2007 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2007).  NetLogo Hex Cell Aggregation model.
; http://ccl.northwestern.edu/netlogo/models/HexCellAggregation.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2007 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/HexCellAggregation
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This is a model of growth.  It takes place on a two-dimensional hexagonal grid of cells.  Cells can either be alive or dead.  Various growth patterns result, depending on the exact rules governing growth.


HOW IT WORKS
------------
SETUP arranges cells in a hexagonal grid, as in Hex Cells Example.  The edges of the grid do not wrap.

Only the center cell is alive at the start.

The switches determine which dead cells are eligible to become alive.  For example, if the ONE-NEIGHBOR? switch is on, dead cells that have exactly one alive neighbor are eligible for growth, and so on for the rest of the switches.

Each tick, one eligible dead cell goes live.

Dead cells are invisible (black).  Live cells are shown in orange or red depending on whether they have any dead neighbors.


HOW TO USE IT
-------------
SETUP places one alive cell in the middle of the grid.

GO advances the growth process.

X-NEIGHBORS? are switches that, when on, allow new cells to grow where they will have X alive neighbors. X ranges from one to six because the cells are on a hexagonal grid and so each cell has 6 neighbors.

READ-SWITCHES makes your settings for the switches take effect. (They don't take effect right away because the model is coded in a special way in order to run faster.)


THINGS TO NOTICE
----------------
When some switches are turned off, ""holes"" appear in the pattern. Depending on which X-NEIGHBORS? switches are on and which are off, those holes can be different shapes. Some interesting configurations are {1, 2, 4} (ONE-NEIGHBOR?, TWO-NEIGHBORS?, AND FOUR-NEIGHBORS? on while all other switches are off), {1}, {1, 4, 5}, {1, 3, 5, 6}, and {1, 3, 4, 5, 6}.

Often, as the alive cells approach the border, the overall shape resembles a circle.

For different configurations of the X-NEIGHBORS? switches, the ""Cell Types"" plot shows very different numbers of alive, dead, and inner-edge cells when the model stops.


THINGS TO TRY
-------------
Change the size of the world. If it's much bigger, the model might run too slowly. If it's smaller, can you get different patterns?

Switch off TWO-NEIGHBORS? for a run. Does the overall shape look any different? After the model has been running for a while, change the switches to not allow 1 or 2 neighbors while allowing for 3 and up. (Don't forget to press the CHANGE-SWITCHES button.) Watch it go. What happens if you then change it to allow only for 1 or 2?


EXTENDING THE MODEL
-------------------
Implement the model on a regular square grid using both neighbors4 and neighbors instead of the neighbors6 we used in this model. Figure out a way to measure how quickly the alive cells spread to the edge in different configurations.

To better see the near-circular shape of the aggregation as the growth gets near the edge, add a check that stops the model when a cell on the edge becomes alive.

Add a plot that tracks the ratio of orange to red cells.

Each tick one eligible dead cell goes live.  This one-at-a-time update rule differs from many cell-based models which update all the cells at once.  (This update rule is specified in the reference in the CREDITS AND REFERENCES section.)  Change the rules so that each tick, all of the eligible dead cells go live. What different result do you observe, if any?


NETLOGO FEATURES
----------------
The code uses lists in order to make the model run faster.  The code would be considerably simpler if these lists weren't used, but it would also run much slower.  See the comments in the Procedures tab for details on the use of lists in this model.


RELATED MODELS
--------------
Diffusion Limited Aggregation
Life
Hex Cells Example


CREDITS AND REFERENCES
----------------------
This model was inspired by Stephen Wolfram's A New Kind of Science. A very similar model is discussed here: http://www.wolframscience.com/nksonline/page-331?firstview=1. In the notes at the end of the book, many extensions are suggested, although none on a hexagonal grid.

Thanks to Josh Unterman and Seth Tisue for their work on this model.

To refer to this model in academic publications, please use:  Wilensky, U. (2007).  NetLogo Hex Cell Aggregation model.  http://ccl.northwestern.edu/netlogo/models/HexCellAggregation.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2007 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/HexCellAggregation for terms of use.
"
Dining Philosophers,/models/Sample Models/Computer Science,"breed [ philosophers philosopher ]
breed [ forks fork ]

globals
[
  HUNGRY EATING THINKING  ;; these are constants for the states
  colors                  ;; this will be a list mapping states -> colors
  table-size turtle-size  ;; constant sizes for things in the gw
  fork-offset             ;; this is a heading offset used to place the forks
  fork-distance           ;; this is a distance used to place the forks
]

philosophers-own
[
  ;; how to draw the left fork when i'm holding it
  left-fork-xpos left-fork-ypos left-fork-heading
  ;; how to draw the right fork when i'm holding it
  right-fork-xpos right-fork-ypos right-fork-heading
  state                   ;; my current state
  left-fork right-fork    ;; the forks on my right and left
  total-eaten             ;; how much i've have to eat
]

forks-own
[
  xpos ypos save-heading  ;; where i belong when i'm on the table
  owner                   ;; the philosopher that currently owns me (if any)
  marked?                 ;; whether i'm currently marked
]

to setup
  clear-all

  ; constants
  set HUNGRY 0
  set EATING 1
  set THINKING 2
  set colors [ red green blue ]
  set table-size 0.6
  set turtle-size 0.1
  set fork-offset 10
  set fork-distance 0.1

  ; set up the model
  make-turtles
  recolor

  ; set up the plots
  setup-plots
  do-plots

end

;; create all the turtles, place them, and associate forks with philosophers
to make-turtles
  let previous-left nobody
  let current-turn 0
  set-default-shape philosophers ""person torso""
  set-default-shape forks ""fork""

  ;; the tactic is to create one fork and one philosopher at a time,
  ;; associating each new philosopher with the new fork and with the fork
  ;; we created last time (stored in previous-left). the direction each new
  ;; turtle faces is incremented as we go, and they're moved to the edge of
  ;; the table.
  repeat num-philosophers
  [
    let new-left nobody
    ;; we want two circles of evenly spaced
    ;; turtles, create-ordered-turtles creates
    ;; turtles with evenly spaced headings so
    ;; we can just move them fd to make the circles.
    create-ordered-forks 1
    [
      set color 9
      set size turtle-size
      set marked? false
      set owner nobody
      rt current-turn
      rt 360 / (2 * num-philosophers)
      jump ((table-size - turtle-size) / 2)
      rt 180 ;; turn around so i look prettier.
      set new-left self

      ;; save my position and heading, so the philosophers can replace me later
      set xpos xcor
      set ypos ycor
      set save-heading heading
    ]
    create-ordered-philosophers 1
    [
      set size turtle-size
      set state THINKING
      set right-fork previous-left
      set previous-left new-left
      set left-fork new-left
      rt current-turn
      jump ((table-size + turtle-size) / 2)
      calculate-fork-positions
    ]
    set current-turn (current-turn + 360 / num-philosophers)
  ]
  ; since create-ordered-philosophers assigns ids to the turtles
  ; in order around the circle, this ties the knot.
  ask first sort philosophers [ set right-fork previous-left ]
  ask one-of forks [ set marked? true ]
end

to go
  ifelse take-turns? [ update-one ] [ update-all ]
  recolor
  tick
  do-plots
end

;; here we figure out where to place the forks when we pick them up. basically
;; they go above the philosophers head, the left on the left side and the
;; right on the right side. fork-offset determines how far apart they are, and
;; fork-distance determines how far above the head.
to calculate-fork-positions ;; philosopher procedure
  rt fork-offset
  set left-fork-xpos (xcor + dx * fork-distance)
  set left-fork-ypos (ycor + dy * fork-distance)
  set left-fork-heading heading
  lt fork-offset * 2
  set right-fork-xpos (xcor + dx * fork-distance)
  set right-fork-ypos (ycor + dy * fork-distance)
  set right-fork-heading heading
  rt fork-offset
end

;; everybody gets a new color.
to recolor
  ask philosophers
  [
    ;; look up the color in the colors list indexed by our current state
    set color (item state colors)
  ]
  ask forks
  [
    ;; we'll indicate marked forks only if cooperation is on.
    ifelse cooperation? and marked?
    [
      set color magenta
    ]
    [
      set color 9
    ]
  ]
end

to update-one
  ask one-of philosophers
  [
    if state = THINKING
    [
      if random-float 1.0 < hungry-chance
      [
        set state HUNGRY
      ]
      stop
    ]
    if state = EATING
    [
      ;; keep track of how much we're eating.
      set total-eaten (total-eaten + 1)
      if random-float 1.0 < full-chance
      [
        ;; put down forks
        ifelse cooperation?
        [
          release-forks-smart
        ]
        [
          release-forks-naive
        ]
        ;; continue thinking
        set state THINKING
      ]
      stop
    ]
    if state = HUNGRY
    [
      ; try to pick up the forks.
      ifelse cooperation?
      [
        acquire-forks-smart
      ]
      [
        acquire-forks-naive
      ]
      ; if we've got both forks, eat.
      if got? left-fork and got? right-fork
      [
        set state EATING
      ]
      stop
    ]
  ]
end

;; here's where philosophers actually do their thing. note that a philosopher
;; can go through several states in the same call to update.
to update-all
  ask philosophers
  [
    ;; some thinking philosophers may get hungry.
    if state = THINKING
    [
      if random-float 1.0 < hungry-chance
      [
        set state HUNGRY
      ]
      stop
    ]
    ;; some eating philosophers may get full.
    if state = EATING
    [
      ;; keep track of how much we're eating.
      set total-eaten (total-eaten + 1)
      if random-float 1.0 < full-chance
      [
        ;; put down forks
        ifelse cooperation?
        [
          release-forks-smart
        ]
        [
          release-forks-naive
        ]
        ;; continue thinking
        set state THINKING
      ]
      stop
    ]
    if state = HUNGRY
    [
      ; try to pick up the forks.
      ifelse cooperation?
      [
        acquire-forks-smart
      ]
      [
        acquire-forks-naive
      ]
      ; if we've got both forks, eat.
      if got? left-fork and got? right-fork
      [
        set state EATING
      ]
      stop
    ]
  ]
end

;; a more sophisticated strategy for releasing the forks, which switches any
;; marks to the other fork. see the info tab for details.
to release-forks-smart ;; philosopher procedure
  ;; check left fork
  ifelse [marked?] of left-fork
  [
    ask left-fork [ set marked? false ]
    ask right-fork [ set marked? true ]
  ]
  [
    ;; otherwise, check right fork.
    if [marked?] of right-fork
    [
      ask right-fork [ set marked? false ]
      ask left-fork [ set marked? true ]
    ]
  ]
  ;; release the forks.
  release left-fork
  release right-fork
end

;; just drop the forks.
to release-forks-naive ;; philosopher procedure
  release left-fork
  release right-fork
end

;; to release a fork, we set its owner to nobody and replace it on the table.
to release [ fork ] ;; philosopher procedure
  ask fork
  [
    set owner nobody
    setxy xpos ypos
    set heading save-heading
  ]
end

;; just try to pick each fork up. if i get only one, i'll just hold it
;; until i get the other one.
to acquire-forks-naive ;; philosopher procedure
  ;; try left fork
  if [owner] of left-fork = nobody
  [
    acquire-left
  ]
  ;; try right fork
  if [owner] of right-fork = nobody
  [
    acquire-right
  ]
end

;; a more sophisticated strategy for acquiring the forks. see the info tab
;; for details.
to acquire-forks-smart ;; philosopher procedure
  ;; try left fork
  if [owner] of left-fork = nobody
  [
    if (not [marked?] of left-fork) or got? right-fork
    [
      acquire-left
    ]
  ]
  ;; try right fork
  if [owner] of right-fork = nobody
  [
    if (not [marked?] of right-fork) or got? left-fork
    [
      acquire-right
    ]
  ]
end

;; grab the left fork
to acquire-left ;; philosopher procedure
  acquire left-fork left-fork-xpos left-fork-ypos left-fork-heading
end

;; grab the right fork
to acquire-right ;; philosopher procedure
  acquire right-fork right-fork-xpos right-fork-ypos right-fork-heading
end

;; pick up a fork by setting its owner to me and moving it to a new
;; location
to acquire [ fork new-x new-y new-heading ] ;; philosopher procedure
  ask fork
  [
    set owner myself
    setxy new-x new-y
    set heading new-heading
  ]
end

;; i've got a fork if it's owned by me.
to-report got? [ fork ] ;; philosopher procedure
  report ([owner] of fork) = self
end

;; set up the plots. our ranges are dynamic, so we need this.
to setup-plots
  set-current-plot ""Spaghetti consumed""
  set-plot-x-range 0 (count philosophers + 1)

  set-current-plot ""Resource allocation""
  set-plot-y-range 0 (count philosophers)
end

;; do the plotting.
to do-plots
  set-current-plot ""Spaghetti consumed""
  set-current-plot-pen ""default""
  plot-pen-reset
  ask philosophers [ plotxy (who / 2) total-eaten ]
  set-current-plot ""Resource allocation""
  set-current-plot-pen ""Thinking""
  plot (count philosophers with [ state = THINKING ])
  set-current-plot-pen ""Hungry""
  plot (count philosophers with [ state = HUNGRY ])
  set-current-plot-pen ""Eating""
  plot (count philosophers with [ state = EATING ])
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2003 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2003).  NetLogo Dining Philosophers model.
; http://ccl.northwestern.edu/netlogo/models/DiningPhilosophers.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2003 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/DiningPhilosophers
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
The Dining Philosophers problem is a classic case study in the synchronization of concurrent processes.  It will be familiar to many students of Computer Science, but is applicable to many situations in which several independent processes must coordinate the use of shared resources.

The problem is fairly simple.  Suppose there is a group of philosophers sitting at a round table eating spaghetti.  These are boring philosophers: they do nothing but think, get hungry and eat.  In particular, they do not communicate with one another.

A fork sits on the table in between each pair of philosophers, so there are exactly as many forks as philosophers.  However, the spaghetti is quite messy, so in order to eat, each philosopher needs to be holding two forks, both the fork to her left and the fork to her right.  Clearly, if all the philosophers are to get some spaghetti, they'll have to share the forks.

There are many ways that this can go wrong.  A given philosopher can pick up both forks and begin eating, and never stop.  This guarantees that (at least) her immediate neighbors will never get to eat.  (Though at least SOMEONE gets to eat!)

What happens if every philosopher immediately picks up the fork to her right, then waits for the fork to her left to become available?  (To try it, set hungry-chance to 1.0, turn cooperation? and take-turns? off, then press setup and go.)  This situation is called ""deadlock,"" and it is the bane of designers of concurrent systems.

The goal of the problem is to come up with a strategy that the philosophers can use to guarantee that:
1. At least one hungry philosopher can always eat.
2. On average, all the philosophers get the same amount to eat.

There is one other feature of the system that aids in finding a solution: while a philosopher is holding a fork, she has the ability to place a mark on it or to remove an existing mark.  These marks are visible to any philosopher who inspects the fork.  One random fork will always start out marked, but in order to avoid confusion, marked forks are not visually distinguished unless cooperation is enabled (in which case they are a different color).

Can you think of a way to feed the philosophers?

Remember that the philosophers shouldn't, in principle, communicate (apart from marking forks, though that arguably constitutes a communication channel).  This means that the assignment of global group properties (such as ""even/odd-numbered philosophers"" or ""first philosopher"") is not allowed.  The astute reader will note that the initial marking of a single fork violates this rule by assigning a globally unique property to a single philosopher.  In the absence of such an initially distinguished fork, can you think of a way to feed the philosophers?


HOW IT WORKS
------------
There are two types of agents: philosophers and forks.  Philosophers know which fork is on their left and which fork is on their right.  They also know what state they're in (thinking, hungry or eating) and how much they've eaten in total.  Forks know who they're currently being held by, if anyone, and whether or not they're marked.

To pick up a fork, a philosopher must first check that the fork isn't already being held by his associate, then set the fork's owner to himself.  It is possible in this model to steal a fork from another philosopher, therefore it is up to each philosopher not to do so.

To release a fork, a philosopher simply sets the fork's owner to nobody.

All the philosophers are initially thinking (blue).  At each time step, a thinking philosopher may become hungry (red) with probability hungry-chance.  A hungry philosopher will try to acquire both forks, and until she has done so will remain hungry.  A hungry philosopher with both forks immediately begins eating (green).  An eating philosopher may become full with probability full-chance, at which point she will release both forks and resume thinking (blue).

The value of the cooperation? switch determines which strategy is used to acquire and release the forks. With cooperation off, the following naive strategy is used to pick up the forks:
1. If the left fork is available, take it.
2. If the right fork is available, take it.
3. If you have both forks, begin eating. Otherwise, try again.
When full, the forks are simply released. Marks are completely ignored.

With cooperation on, a more sophisticated strategy using marks is used. To acquire the forks:
1. If the left fork is available, take it.
2. If you have the left fork and it is marked and you're not already holding the right fork, release the left fork.
3. If the right fork is available, take it.
4. If you have the right fork and it is marked and you're not already holding the left fork, release the right fork.
5. If you have both forks, begin eating. Otherwise, try again.
Once you are done eating, to release the forks:
1. If either fork is marked, unmark it and mark the other fork.
2. Release the forks.


HOW TO USE IT
-------------
Initial settings:
- num-philosophers: how many philosophers you'd like to feed.

The setup button will set the initial conditions. The go button will run the simulation, and the ""go once"" button will run the simulation for just one step, allowing you to watch what happens in more detail.

Other settings:
- hungry-chance: The probability of any thinking philosopher becoming hungry at any step.
- full-chance: The probability of any eating philosopher becoming full at any step.
- cooperation?: If off, the philosophers will use a naive strategy to acquire their forks; if on, they'll use a more sophisticated strategy. See HOW IT WORKS above.
- take-turns?: If on, only one philosopher will be allowed to move per time step (i.e., per press of ""go once""); if off, every philosopher will be given a chance to move. Note that with take-turns? on, some philosophers may move twice before all the philosophers have moved. On average, however, the philosophers will each get the same number of turns.

Plots:
- Spaghetti consumed: plots the amount of spaghetti each philosopher has consumed (based on how many time steps she has spent in the eating state).
- Resource allocation: plots the number of philosophers in each state over time.


THINGS TO NOTICE
----------------
Play with take-turns? for different configurations of hungry-chance and full-chance and different numbers of philosophers.  Notice that take-turns? effects more than just the speed of the simulation, because not all the philosophers are guaranteed to get a chance to move once before any are allowed to move a second time.  Do you think that, in the long run, this will make a difference in the outcomes of simulations?  Why or why not? If so, under what circumstances?

Play with different configurations of hungry-chance and full-chance.  See how different combinations stress the system in different ways.  Notice how, although the system works well under certain circumstances, more stressful circumstances may expose a weakness.  This demonstrates the importance of ""stress testing"" when assessing the scalability of a system, particularly in the presence of concurrency.


THINGS TO TRY
-------------
Experiment with cooperation in combination with different settings for hungry-chance and full-chance.  See if you can find a situation where there is a striking contrast between the behaviors of the cooperating philosophers and the naive philosophers.

Try running the system for a long time in a variety of different configurations.  Does it ever seem to perform well at first, but eventually degrade (and maybe even deadlock)?  What about vice versa?  What do you think this shows about the value of ""longevity testing"" when assessing the stability and performance of a concurrent system?


EXTENDING THE MODEL
-------------------
Try to think of a different strategy for the philosophers, then implement it and see how well it works!  You will probably want to make use of marks, so remember that they are not visible unless cooperation is enabled; you may wish to change this.  Can you come up with a simpler strategy than the one we demonstrate?

Can you think of other configurations of processes and resources that might be interesting to experiment with?  For example, suppose there is one salt shaker on the table where all the philosophers can reach it, and suppose that each time a philosopher has acquired both forks, she must acquire the salt shaker and salt her spaghetti before she begins eating.  She can release the salt shaker after only one time step (i.e., before she finishes eating her pasta and releases the forks), so several philosophers can still eat at once.  Can this modification lead to deadlock? What if there are both salt and pepper?  Test your intuition!

There are many, many other such possibilities, and many are directly analogous to situations that frequently arise in practical resource allocation problems.


CREDITS AND REFERENCES
----------------------
Thanks to Matt Hellige for his work on this model.

To refer to this model in academic publications, please use:  Wilensky, U. (2003).  NetLogo Dining Philosophers model.  http://ccl.northwestern.edu/netlogo/models/DiningPhilosophers.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2003 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/DiningPhilosophers for terms of use.
"
Particle System Fountain,/models/Sample Models/Computer Science/Particle Systems,"turtles-own [
  mass
  velocity-x             ; particle velocity in the x axis
  velocity-y             ; particle velocity in the y axis
  force-accumulator-x    ; force exerted in the x axis
  force-accumulator-y    ; force exerted in the y axis
]

to setup
  clear-all
  set-default-shape turtles ""circle""
end

to go
  if count turtles < max-number-of-particles and random 100 < rate
    [ create-particle ]
  compute-forces ; calculate the forces and add them to the accumulator
  apply-forces   ; calculate the new location and speed by multipying the
                 ; forces by the step-size
  tick
end

to create-particle
  ask patch 0 (min-pycor + 1)
  [
    sprout 1
    [
      set color blue
      set size 0.1 + random-float 1.0
      set mass size ^ 2  ; mass proportional to size squared
      set velocity-x initial-velocity-x - random-float initial-range-x + random-float initial-range-x
      set velocity-y initial-velocity-y
    ]
  ]
end

to compute-forces
  ask turtles
  [
    set force-accumulator-x 0
    set force-accumulator-y 0
    apply-gravity
    apply-wind
    apply-viscosity
  ]
end

to apply-gravity  ; turtle procedure
  set force-accumulator-y force-accumulator-y - gravity-constant / mass
end

to apply-wind  ; turtle procedure
  set force-accumulator-x force-accumulator-x + wind-constant-x
  set force-accumulator-y force-accumulator-y + wind-constant-y
end

to apply-viscosity  ; turtle procedure
  set force-accumulator-x force-accumulator-x - viscosity-constant * velocity-x
  set force-accumulator-y force-accumulator-y - viscosity-constant * velocity-y
end

; calculates the position of the particles at each step
to apply-forces
  ask turtles
  [
    ; calculate the new velocity of the particle
    set velocity-x velocity-x + force-accumulator-x * step-size
    set velocity-y velocity-y + force-accumulator-y * step-size
    ; calculate the displacement of the particle
    let step-x velocity-x * step-size
    let step-y velocity-y * step-size
    ;; if the turtle tries to leave the world let it die
    if patch-at step-x step-y = nobody [ die ]
    ;; if the turtle does not go out of bounds
    ;; add the displacement to the current postition
    let new-x xcor + step-x
    let new-y ycor + step-y
    facexy new-x new-y
    setxy new-x new-y
  ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2007 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Kornhauser, D. and Wilensky, U. (2007). NetLogo Particle System Fountain model.
; http://ccl.northwestern.edu/netlogo/models/ParticleSystemFountain.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2007 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/ParticleSystemFountain
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This particle system models a particle fountain emitting particles from the bottom of the world.

In this model each particle has two main behaviors:
- If there is room ahead it continues its trajectory.
- If it's about to touch the edge of the world, it dies.
Forces such as gravity, wind, and viscosity act on the particles as well.


HOW IT WORKS
------------
A particle with an initial velocity emerges from the bottom center of world. It is subjected to the force of gravity, which slows it down and pulls it to the bottom of the world. In addition, forces of wind and viscosity are present.  The maximum number of particles and particle rate can be changed with the appropriate sliders. Finally, the step of the systems which controls the precision of the system calculations can be increased or decreased, but it will change the speed of the systems since more calculations have to be done for a more precise simulation. Below, the use of each slider, button and switch is explained.


HOW TO USE IT
-------------
Press GO to start the particle fountain.  You can then modify the settings to change how the fountain behaves.  Note that once the maximum number of particles is reached, particles will cease to emerge until another particle leaves room by dying when it is about to touch the sides or ceiling.

- Initial velocities: The INITIAL-VELOCITY-X and INITIAL-VELOCITY-Y sliders control the initial velocity in the x and y axes for each particle.

- INITIAL-RANGE-X: To make the particle system appear more realistic, each particle can be given a different random velocity at startup.  To set the random velocities, give INITIAL-RANGE-X a nonzero value.  Larger values will spread the fountain out more.  (Even when this switch is off, the particles will have distinct trajectories, due to their different masses.)

- Gravity: Gravity acts downwards, and is implemented by adding a negative number, the GRAVITY-CONSTANT, to the y force accumulator. Gravity is unrealistic in this system, in that its acceleration changes depending on the particle's mass. This is an important characteristic of particles systems: We can create motions that do not strictly follow real-world physical rules.

- Wind: The wind force sways the particles of the system left and right in the world by adding a WIND-CONSTANT-X force in the x-axis.

- Viscosity: The viscosity force resists the motion of a particle by exerting an opposite force proportional to the VISCOSITY-CONSTANT to the speed of the particle.  A higher VISCOSITY-CONSTANT means the particles flow easier.

- Step size: A smaller step will increase the precision of the trajectories but slow down the model computation, while a large step will decrease the precision of the trajectories but speed up the model computation.  Every iteration, the STEP-SIZE scales the velocity and change in location of the particle.

- Maximum particle number: The number of particles in the system is bounded by the MAX-NUMBER-OF-PARTICLES slider.  Once the particle count reaches the MAX-NUMBER-OF-PARTICLES limit the generation of new particles is stopped.  Note that each time a particle reaches the edge of the world it dies, hence by providing room for another particle to be created.

- Particle rate: The particle RATE sets the percent-change a particle will be generated.  Thus, a RATE of 100 will generate a particle whenever MAX-NUMBER-OF-PARTICLES hasn't been reached, while a RATE of 0 will stop the fountain's flow.


THINGS TO TRY
-------------
Move the sliders and switches to see the behaviors you get from each force.  For example, by moving all sliders but GRAVITY-CONSTANT to a neutral position, you can see how gravity acts on the particles.  After you have seen how each individual force acts  (initial velocities, viscosity, wind, gravity coefficient), combine them to see how they act together.

Move the sliders in order to make the model look the most like a real water fountain.

Remember that you can move the sliders while the model is running.


EXTENDING THE MODEL
-------------------
Hide the particles and put the pen down in the CREATE-PARTICLE procedure to see the trajectories of the particles accumulate over time.

Change the position of the particle source.

Change the model to make it look like another physical phenomenon, such as lava or soap bubbles.

Make the particle system look like rain, snow, or another phenomenon by changing the model to emit particles from different locations at the top of the world.


NETLOGO FEATURES
----------------
A difficulty in this example is to detect when a particle has reached the edge of the world, so it can be made to disappear.  Check the APPLY-FORCES procedure to see how the PATCH-AT and NOBODY primitives are used to do this detection.


RELATED MODELS
--------------
Particle System Basic
Particle System Waterfall
Particle System Flame


CREDITS AND REFERENCES
----------------------
See Particle System Basic for a list of references on particle systems.

Thanks to Daniel Kornhauser for his work on this model.

To refer to this model in academic publications, please use:  Kornhauser, D. and Wilensky, U. (2007).  NetLogo Particle System Fountain model.  http://ccl.northwestern.edu/netlogo/models/ParticleSystemFountain.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2007 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/ParticleSystemFountain for terms of use.
"
Particle System Basic,/models/Sample Models/Computer Science/Particle Systems,"turtles-own
[
  velocity-x             ; particle velocity in the x axis
  velocity-y             ; particle velocity in the y axis
  force-accumulator-x    ; force exerted in the x axis
  force-accumulator-y    ; force exerted in the y axis
]

to setup
  clear-all
  ask patch 0 (max-pycor / 2) [
    sprout num-particles [
      set velocity-x 10 - (random-float 20) ; initial x velocity
      set velocity-y 10 - (random-float 20) ; initial y velocity
      pen-down
    ]
  ]
end

to go
  if not any? turtles [ stop ]
  compute-forces ; calculate the forces and add them to the accumulator
  apply-forces   ; calculate the new location and speed by multipying the
                 ; forces by the step-size
  tick
end

; calculate and sum all the forces exerted on the particles
to compute-forces
  ask turtles
  [
    ; clear force accumulators
    set force-accumulator-x 0
    set force-accumulator-y 0
    ; calculate forces
    apply-gravity
  ]
end

; updates the accumulator with the gravity force
to apply-gravity  ;; turtle procedure
  set force-accumulator-y force-accumulator-y - gravity-constant
end

; calculates the position of the particles at each step
to apply-forces
  ask turtles
  [
    ; calculate the new velocity of the particle
    set velocity-x velocity-x + (force-accumulator-x * step-size)
    set velocity-y velocity-y + (force-accumulator-y * step-size)
    ; calculate the displacement of the particle
    let step-x velocity-x * step-size
    let step-y velocity-y * step-size
    ;; if the turtle tries to leave the world let it die
    if patch-at step-x step-y = nobody [ die ]
    ;; if the turtle does not go out of bounds
    ;; add the displacement to the current postition
    let new-x xcor + step-x
    let new-y ycor + step-y
    facexy new-x new-y
    setxy new-x new-y
  ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2007 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Kornhauser, D. and Wilensky, U. (2007). NetLogo Particle System Basic model.
; http://ccl.northwestern.edu/netlogo/models/ParticleSystemBasic.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2007 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/ParticleSystemBasic
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
Particle systems are used in computer graphics to simulate the appearance of physical phenomena that can be modeled as a collection of particles.  For example, some typical particle systems include: waterfalls, fire, smoke, explosions, snow, and meteors.

This example demonstrates how to write a very simple particle system only.  For example, particles are only created at setup time.   See the other particle system models for elaborations on the basic particle system idea.


HOW IT WORKS
------------
At each iteration of the GO routine, tiny forces steer the particle through its trajectory. Particles have a velocity in the x and y axes, a step and a force accumulator. This model uses a procedure to compute the forces (COMPUTE-FORCES) and another one to apply the forces (APPLY-FORCES). Combined, these procedures continuously move the particles over time.

Below are the steps for moving each particle:

1.- Initialization
First, the force accumulators are cleared of the previously calculated forces.

2.- Force Calculation
Force calculation is trivial for this particular particle system since the sole force of the model, gravity, is represented by a constant negative number. However, force calculation in general can be harder when more complicated forces, such as springs, are involved.

3.- Force Summation
After all of the individual forces are computed, the APPLY-FORCES routine sums all of them and calculates the resulting velocity of the particle.

4.- Displacement
Finally, a new position is calculated by multiplying the velocity by STEP-SIZE and adding the displacement to the current particle location. STEP-SIZE represents the small amount of time during which the forces are applied.

Notice that in this model the particles die when they reach the world boundaries.


HOW TO USE IT
-------------
To observe only one particle at a time:

1.- Change the PARTICLES-NUMBER and STEP-SIZE.
2.- Press SETUP
3.- Press GO (Observe how the turtles move through the world.)
5.- You can optionally change the GRAVITY-CONSTANT and observe how the behavior changes.

Note that you can change the GRAVITY-CONSTANT and the STEP-SIZE while the particle is moving. For example, if the user wants the particles to fly higher he can decrease the gravity, but if he wishes the particles to stay lower he can increase the gravity pull.


THINGS TO NOTICE
----------------
The more particles you create, the slower the model runs.

The greater the step size, the faster the model runs.  (What happens if you make the step size too large?)


THINGS TO TRY
-------------
Change the GRAVITY-CONSTANT slider while the particle is moving. Note how it stays floating or falls quickly depending when and how you adjust the gravity constant slider.


RELATED MODELS
--------------
Particle System Waterfall
Particle System Smoke
Particle System Flame


CREDITS AND REFERENCES
----------------------
Particle Systems
http://www.siggraph.org/education/materials/HyperGraph/animation/particle.htm

Particle Systems by Allen Martin
http://web.cs.wpi.edu/~matt/courses/cs563/talks/psys.html

William T.  Reeves, ""Particle Systems - A Technique for Modeling a Class of Fuzzy Objects"", Computer Graphics 17:3 pp.  359-376, 1983 (SIGGRAPH 83).
http://portal.acm.org/citation.cfm?id=357320

Physically based modeling Online SIGGRAPH 2001 Course Notes
http://www.pixar.com/companyinfo/research/pbm2001/

Particle Systems on Wikipedia
http://en.wikipedia.org/wiki/Particle_system

Thanks to Daniel Kornhauser for his work on this model.

To refer to this model in academic publications, please use:  Kornhauser, D. and Wilensky, U. (2007).  NetLogo Particle System Basic model.  http://ccl.northwestern.edu/netlogo/models/ParticleSystemBasic.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2007 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/ParticleSystemBasic for terms of use.
"
Particle System Flame,/models/Sample Models/Computer Science/Particle Systems,"turtles-own
[
  mass
  velocity-x             ; particle velocity in the x axis
  velocity-y             ; particle velocity in the y axis
  force-accumulator-x    ; force exerted in the x axis
  force-accumulator-y    ; force exerted in the y axis
]

to setup
  clear-all
  set-default-shape turtles ""circle""
end

to go
  if count turtles < max-number-of-particles and random 100 < rate
    [ create-particle ]
  compute-forces ; calculate the forces and add them to the accumulator
  apply-forces   ; calculate the new location and speed by multipying the
                 ; forces by the step-size
  age-particles  ; make particles gradually smaller and darker
  tick
end

to create-particle
  crt 1
  [
    set color red + 3.5
    set size 0.3 + random-float 1.5
    set mass size ^ 2   ; mass proportional to square of size
    ;; The following few lines place the particle along the bottom of the world
    ;; randomly within a range of initial-position-x around the horizontal center.
    ;; for example, if initial-position-x is set to 1, each particle will be placed
    ;; randomly between -.5 and .5, where 0 is the horizontal center of the world.
    setxy (random-float initial-position-x - initial-position-x / 2)
          (min-pycor + 1)
    set velocity-x  (random-float initial-velocity-x - initial-velocity-x / 2)
    set velocity-y  initial-velocity-y
  ]
end

to compute-forces
  ask turtles
  [
    set force-accumulator-x 0
    set force-accumulator-y 0
    apply-wind
  ]
end

to apply-wind  ;; turtle procedure
  ifelse xcor > 0
    [ set force-accumulator-x force-accumulator-x - wind-constant ]
    [ set force-accumulator-x force-accumulator-x + wind-constant ]
end

; calculates the position of the particles at each step
to apply-forces
  ask turtles
  [
    ; calculate the new velocity of the particle
    set velocity-x velocity-x + (force-accumulator-x * step-size)
    set velocity-y velocity-y + (force-accumulator-y * step-size)
    ; calculate the displacement of the particle
    let step-x velocity-x * step-size
    let step-y velocity-y * step-size
    ;; if the turtle tries to leave the world let it die
    if patch-at step-x step-y = nobody [ die ]
    ;; if the turtle does not go out of bounds
    ;; add the displacement to the current postition
    let new-x xcor + step-x
    let new-y ycor + step-y
    facexy new-x new-y
    setxy new-x new-y
  ]
end

to age-particles
  ask turtles
  [
    set color color - 0.0005 / step-size
    if color < red - 4 [ die ]
    set size size - step-size / 3
    if size <= 0 [ die ]
  ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2007 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Kornhauser, D. and Wilensky, U. (2007). NetLogo Particle System Flame model.
; http://ccl.northwestern.edu/netlogo/models/ParticleSystemFlame.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2007 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/ParticleSystemFlame
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This particle system models a flame.

For basics on particle systems, start with Particle System Basic.


HOW IT WORKS
------------
A particle with an initial velocity emerges from the bottom center of world with an INITIAL-VELOCITY-X and INITIAL-VELOCITY-Y around a random INITIAL-POSITION-X. It is subjected to forces of wind from both sides, swaying the particles to left and right of the middle of the world.  The particles rise upwards, decrease in size, and become darker as they are swung left and right.

The MAX-NUMBER-OF-PARTICLES, and particle RATE can be changed using the bottom sliders. Finally, the system's STEP-SIZE controls the precision of the system calculations. For example, decreasing the STEP-SIZE will slow down the model's speed since more calculations are needed for a more precise simulation. Below the use of each slider, button and switch is explained.


HOW TO USE IT
-------------
Press the SETUP followed by the GO button to start the particle flame.  You can then modify the settings to change how the flame behaves.  Note that if the maximum number of particles is reached, particles will cease to emerge until another particle disappears.

Initial velocities: The INITIAL-VELOCITY-X and INITIAL-VELOCITY-Y sliders control the initial velocity in the x and y axes for each particle.

Initial position in the x axis: To make the particle system appear more realistic, each particle can be given a random starting point.  When INITIAL-POSITION-X is set to zero, the particles will emerge from the middle of the screen, however if the initial INITIAL-POSITION-X slider is increased the particles will emerge at a random distance between 0 and INITIAL-POSITION-X from the bottom center of the world.

Wind: The wind force sways the particles of the system towards the center of the world by adding a WIND-CONSTANT force in the x-axis to draw the particle towards the middle of the world.

Step size: A smaller step will increase the precision of the trajectories of each particle, but will also slow down the model computation; A large step will decrease the precision of the trajectories but speed up the model computation. Upon each iteration, the STEP-SIZE scales the velocity and location of the particle.

Maximum particle number: The number of particles in the system is bounded by the MAX-NUMBER-OF-PARTICLES slider. Once the turtle count reaches the MAX-NUMBER-OF-PARTICLES limit the generation of new particles is stopped.  Note that each time a particle reaches the edge of the screen it dies, providing room for another particle to be created.

Particle rate: RATE is the chance that a new particle will be generated, assuming that MAX-NUMBER-OF-PARTICLES has not been reached.  A RATE of 100 will generate one new particle on every tick (again, assuming that there are fewer than the maximum number), while a RATE of 0 will stop the fountain's flow.


THINGS TO NOTICE
----------------
Note the wind in this model behaves differently than other particle system models: it flows from the left and right to the center of the world.

There is no viscosity and no gravitational force in this model.


THINGS TO TRY
-------------
Move the sliders and switches to see the behaviors you get from the initial condition and the wind force.  For example, move all the sliders except WIND-CONSTANT to a neutral position, to see how wind acts on the particles.  After you have seen how the wind force, initial velocities, and initial positions affect the flame shape, combine them to see how they act together.

Move the sliders in order to make the model look the most like a flame to you.

Remember, you can move the sliders while the model is running.


EXTENDING THE MODEL
-------------------
Hide the particles and ask one or a few particles to put their pen down to trace their trajectories.

Change the color of the particles to another color.

Add some randomness to the aging of the particles so they do not darken evenly.

Change the model to emit particles with different shapes, sizes, and colors in order to make the particle system look like air bubbles in water or other physical phenomena.


RELATED MODELS
--------------
Particle System Basic
Particle System Waterfall
Particle System Smoke


CREDITS AND REFERENCES
----------------------
See Particle System Basic for a list of references on particle systems.

Thanks to Daniel Kornhauser for his work on this model.

To refer to this model in academic publications, please use:  Kornhauser, D. and Wilensky, U. (2007).  NetLogo Particle System Flame model.  http://ccl.northwestern.edu/netlogo/models/ParticleSystemFlame.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2007 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/ParticleSystemFlame for terms of use.
"
Particle System Waterfall,/models/Sample Models/Computer Science/Particle Systems,"turtles-own
[
  mass
  velocity-x             ; particle velocity in the x axis
  velocity-y             ; particle velocity in the y axis
  force-accumulator-x    ; force exerted in the x axis
  force-accumulator-y    ; force exerted in the y axis
]

to setup
  clear-all
  set-default-shape turtles ""circle""
end

; Calculate the forces a particule gets subjected to at each step
; and apply them to the particle velocity and position
to go
  if count turtles < max-number-of-particles and random 100 < rate
    [ create-particle ]
  compute-forces ; calculate the forces and add them to the accumulator
  apply-forces   ; calculate the new location and speed by multipying the
                 ; forces by the step-size
  tick
end

to create-particle
  ask patch min-pxcor max-pycor
  [
    sprout 1
    [
      set color blue
      set size 0.5 + random-float 0.5
      set mass 5 * size ^ 2   ; mass proportional to square of size
      setxy min-pxcor max-pycor
      set velocity-x initial-velocity-x
                     - random-float initial-range-x
                     + random-float initial-range-x
      set velocity-y initial-velocity-y
    ]
  ]
end

to compute-forces
  ask turtles
  [
    ; clear the force-accumulator
    set force-accumulator-x 0
    set force-accumulator-y 0
    ; calculate the forces
    apply-gravity
    apply-wind
    apply-viscosity
  ]
end

to apply-gravity  ;; turtle procedure
  ; scale the force of the gravity according to the particle's mass; this
  ; simulates the effect of air resistance
  set force-accumulator-y force-accumulator-y - gravity-constant * mass
end

to apply-wind  ;; turtle procedure
  set force-accumulator-x force-accumulator-x + wind-constant-x
  set force-accumulator-y force-accumulator-y + wind-constant-y
end

to apply-viscosity  ;; turtle procedure
  set force-accumulator-x force-accumulator-x - viscosity-constant * velocity-x
  set force-accumulator-y force-accumulator-y - viscosity-constant * velocity-y
end

; calculates the position of the particle at each step but bounces if the particle
; reaches the edge
to apply-forces
  ask turtles
  [
    ; calculate the new velocity of the particle
    set velocity-x velocity-x + ( force-accumulator-x * step-size)
    set velocity-y velocity-y + ( force-accumulator-y * step-size)
    ; calculate the displacement of the particle
    let step-x velocity-x * step-size
    let step-y velocity-y * step-size
    let new-x xcor + step-x
    let new-y ycor + step-y
    if patch-at step-x step-y = nobody
    [
      ; if the particle touches a wall or the ceiling, it dies
      if new-x > max-pxcor or new-x < min-pxcor or new-y > max-pycor
        [ die ]
      ; if the particle touches the floor, bounce with floor-damping
      set velocity-y (- velocity-y * restitution-coefficient)
      set step-y velocity-y  * step-size
      set new-y ycor + step-y
    ]
    facexy new-x new-y
    setxy new-x new-y
  ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2007 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Kornhauser, D. and Wilensky, U. (2007). NetLogo Particle System Waterfall model.
; http://ccl.northwestern.edu/netlogo/models/ParticleSystemWaterfall.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2007 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/ParticleSystemWaterfall
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This particle system models a waterfall where a steady stream of particles is created, then fall and bounce off the bottom.

For basics on particle systems, start with Particle System Basic and Particle System Fountain.


HOW IT WORKS
------------
In this model each particle has three main behaviors:
- If there is room ahead, it continues its trajectory.
- If it's about to touch the floor, its velocity-y is reversed and scaled by a restitution coefficient.
- If it's about to touch the left side, right side or ceiling, it disappears.

A particle with an initial velocity emerges from the top left of the world. It is subjected to the force of gravity, which slows it down and pulls it to the bottom of the world. In addition, forces of wind and viscosity are present. The maximum number of particles and the particle rate can be changed with the appropriate sliders. Finally, the step of the systems, which controls the precision of the system calculations can be increased or decreased, but it will change the speed of the systems since more calculations have to be done for a more precise simulation. Below, the use of each slider, button and switch is explained.


HOW TO USE IT
-------------
Press GO to start the particle waterfall.  You can then modify the settings to change how the waterfall behaves.  Note that no new particles will emerge once MAX-NUMBER-OF-PARTICLES has been reached, until one or more die by reaching the ceiling or sides.

- World boundaries: When a particle leaves the world, the PATCH-AT command returns NOBODY.  Thus, every iteration, if PATCH-AT does not return NOBODY, the particle continues its trajectory.  However, if the particle is close to the left wall, right wall or ceiling, and the patch-at command returns that the next patch does not exist (i.e., NOBODY), and the particle ""dies"".

- Bouncing: In order to bounce off the floor, the particle must detect if its next position will be outside of the world.  If the patch at the next location is equal to NOBODY and the particle is away from the other walls, the particle's velocity-y (VELOCITY-Y in the code) is multiplied by a negative constant (related to RESTITUTION-COEFFICIENT) to make it bounce vertically.

- Energy restitution: RESTITUTION-COEFFICIENT models the energy interchanged by the particle when it bounces off the walls.  If the coefficient is less than 1, it models a realistic damping caused by the energy dissipated in the collision.  If the coefficient is greater than 1, the walls increment the particle's kinetic energy with each bounce. This behavior can be sometimes observed in pinball machines.

- Initial velocities: The INITIAL-VELOCITY-X and INITIAL-VELOCITY-Y sliders control the initial velocity in the x and y axes for each particle.

- INITIAL-RANGE-X: To make the particle system appear more realistic, each particle can be given a different random velocity at startup.  To set the random velocities, give INITIAL-RANGE-X a nonzero value.  Larger values will spread the waterfall out more.  (Even when this switch is off, the particles will have distinct trajectories, due to their different masses.)

- Maximum particle number: The number of particles in the system is bounded by the MAX-NUMBER-OF-PARTICLES slider.  Once the particle count reaches the MAX-NUMBER-OF-PARTICLES limit, the generation of new particles is stopped.  Note that each time a particle reaches the edge of the screen it dies, providing an opening for another particle to be created.

- Gravity: Gravity acts downwards, and is implemented by adding a negative number, the GRAVITY-CONSTANT, to the y force accumulator. We also scale the effect of gravity according to the particle's mass.  This simulates the effect of air resistance.

- Wind: The wind force sways the particles of the system left and right in the world by adding a WIND-CONSTANT-X force in the x-axis.

- Viscosity: The viscosity force resists the motion of a particle by exerting an opposite force proportional to the VISCOSITY-CONSTANT to the speed of the particle.  A higher VISCOSITY-CONSTANT means the particles flow easier.

- Step size: A smaller STEP-SIZE will increase the precision of the trajectories but slow down the model computation. A large STEP-SIZE will decrease the precision of the trajectories but speed up the model computation.  Every iteration, STEP-SIZE scales the particle's velocity and change in location.

- Particle rate: RATE is the chance that a new particle will be generated, assuming that MAX-NUMBER-OF-PARTICLES has not been reached.  A RATE of 100 will generate one new particle on every tick (again, assuming that there are fewer than the maximum number), while a RATE of 0 will stop the fountain's flow.


THINGS TO NOTICE
----------------
The particles spread out horizontally according to size. Why?


THINGS TO TRY
-------------
Move the sliders and switches to see the behaviors you get from each force.  For example, by moving all sliders but GRAVITY-CONSTANT to a neutral position, you can see how gravity acts on the particles.  After you have seen how each individual force acts  (initial velocities, viscosity, wind, and the restitution coefficient), combine them to see how they act together.

You should pay particular attention to RESTITUTION-CONSTANT, what happens when the restitution constant is below 1 and what happens when the restitution constant is above 1?

Move the sliders in order to make the model look the most like a real waterfall to you.

Remember you can move the sliders while the model is running.


EXTENDING THE MODEL
-------------------
Hide the particles and put the pen down in the CREATE-PARTICLE procedure to see the trajectories of the particles accumulate over time.

Change the color of the particles when they bounce.

Change the position of the particle source.

Try to make the particles bounce off the right and left wall so the water accumulates.

Add a repulsion force so the particles do not overlap and the water level goes up.

Change the model to make it look like another physical phenomena.


NETLOGO FEATURES
----------------
A difficulty in this example is to detect when a particle is going to hit a wall in order to make it bounce or die.  Check the APPLY-FORCES procedure to see how the PATCH-AT, NOBODY, MAX-PXCOR, MAX-PYCOR, and MIN-PXCOR primitives are used to do this detection.  If you do not take care to detect the boundaries and you try to move the turtle out of bounds you will receive the following error message:

|  Cannot move turtle beyond the world's edge.

In order to avoid getting this error message, check if the patch in the following xcor ypos position exists with for example the following true/false reporter:

|  patch-at step-x step-y = nobody


RELATED MODELS
--------------
Particle System Basic
Particle System Flame
Particle System Fountain
Particle System Smoke


CREDITS AND REFERENCES
----------------------
See Particle System Basic for a list of references on particle systems.

Thanks to Daniel Kornhauser for his work on this model.

To refer to this model in academic publications, please use:  Kornhauser, D. and Wilensky, U. (2007).  NetLogo Particle System Waterfall model.  http://ccl.northwestern.edu/netlogo/models/ParticleSystemWaterfall.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2007 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/ParticleSystemWaterfall for terms of use.
"
Division,/models/Sample Models/Mathematics,"globals [
  block-to-go              ;; which block is acting during go
  circles-on-block-to-go
  other-block              ;; the block with which block-to-go compares itself
  circles-on-other-block
]

patches-own [ block-number ]

;;;;;;;;;;;;;;;;;;;;
;;SETUP PROCEDURES;;
;;;;;;;;;;;;;;;;;;;;

to setup
  ca
  setup-blocks
  setup-circles
  set block-to-go 0
  set circles-on-block-to-go circles-on-block block-to-go
end

to setup-blocks
  let size-of-columns floor (world-width / (divisor + 1))
  let extra-in-base world-width mod (divisor + 1)
  let active-block-number 0
  let active-column-number 0
  ;; draws a few extra columns in the base
  repeat extra-in-base + size-of-columns
         [ ask patches with [ pxcor = active-column-number + min-pxcor ]
             [ set pcolor black
               set block-number 0
             ]
           set active-column-number active-column-number + 1
         ]
  set active-block-number 1
  ;; now the rest of the blocks get drawn
  repeat divisor
    [ repeat size-of-columns
        [ ask patches with [ pxcor = active-column-number + min-pxcor ]
            [ set pcolor 10 * active-block-number + 5
              set block-number active-block-number
            ]
          set active-column-number active-column-number + 1
        ]
      set active-block-number active-block-number + 1
    ]
  ;; now go through and give each block a label with its number
  set active-block-number 0
  let label-pxcor min-pxcor
  ask patch label-pxcor min-pycor
        [ set plabel-color white
          set plabel active-block-number
        ]
  set active-block-number active-block-number + 1
  set label-pxcor label-pxcor + extra-in-base
  repeat divisor
    [ set label-pxcor label-pxcor + size-of-columns
      ask patch label-pxcor min-pycor
        [ set plabel-color black
          set plabel active-block-number
        ]
      set active-block-number active-block-number + 1
    ]
end

to setup-circles
  set-default-shape turtles ""circle""
  crt dividend [ set color white
                 setxy ( min-pxcor ) random-ycor
               ]
end


;;;;;;;;;;;;;;;;;;;;;;;
;;RUN TIME PROCEDURES;;
;;;;;;;;;;;;;;;;;;;;;;;

to go
  if done? [ stop ]
  compare-blocks
  get-new-blocks
  tick
end

to compare-blocks
  ifelse block-to-go = 0
    [ if circles-on-block-to-go >= divisor
        [ ask turtles with [ block-number = 0 ]
            [ set xcor [pxcor] of one-of
                patches with [ block-number = ((random divisor) + 1)]
            ]
        ]
    ]
    [ ifelse (circles-on-block-to-go - circles-on-other-block) > 1
        [ move-turtle block-to-go other-block ]
        [ if (circles-on-block-to-go - circles-on-other-block) = 1
            [ move-turtle block-to-go 0 ]
        ]
    ]
end

to get-new-blocks
  ifelse cycle-in-order?
    [ set block-to-go block-to-go + 1 ]
    [ set block-to-go random (divisor + 1) ]
  if (block-to-go > divisor)
    [ set block-to-go 0 ]
  set circles-on-block-to-go circles-on-block block-to-go

  ifelse not next-is-other?
    [ set other-block (random divisor) + 1
      while [ other-block = block-to-go ]
        [ set other-block (random divisor) + 1 ]
    ]
    [ ifelse block-to-go != divisor
        [ set other-block block-to-go + 1 ]
        [ set other-block 1 ]
    ]
  set circles-on-other-block circles-on-block other-block
end

;; checks to see if anything is going to change
;; if nothing is going to, returns true
to-report done?
  report equal-stripes-check and (circles-on-block 0 < divisor)
end


;;;;;;;;;;;;;;;;;;;;;
;;MONITOR REPORTERS;;
;;;;;;;;;;;;;;;;;;;;;

to-report average-answer
  report count turtles-on patches with [block-number != 0] / divisor
end

to-report remainder-count
  report count turtles-on patches with [block-number = 0]
end


;;;;;;;;;;;;;;;;;;;;;
;;HELPER PROCEDURES;;
;;;;;;;;;;;;;;;;;;;;;

; reports how many circles are on the given block
to-report circles-on-block [ index ]
  report count turtles-on patches with [block-number = index]
end

to move-turtle [ from-block to-block ]
  ask one-of turtles with [ block-number = from-block ]
    [ set xcor ([pxcor] of one-of patches with [ block-number = to-block]) ]
end

to-report equal-stripes-check
  let equal-stripes-answer true
  let index 1
    repeat divisor - 1
      [ if circles-on-block index != circles-on-block (index + 1)
          [ set equal-stripes-answer false ]
        set index index + 1
      ]
  report equal-stripes-answer
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2002 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2002).  NetLogo Division model.
; http://ccl.northwestern.edu/netlogo/models/Division.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2002 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Division
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
""What's 65 divided by 14?"" There are many ways to answer this question. Some examples are 4.643, 4, four and nine fourteenths, and 4 with 9 left over. The last answer is an example of the kind of result this model would give.

Just as there are many ways to answer the question of ""What's 65 divided by 14?"" there are many methods to coming up with each answer.  This model shows an interesting method that distributes the work of finding a solution among a group of separate agents.

DIVIDEND circles get spread out as evenly as possible among the DIVISOR colorful blocks. The result is QUOTIENT with REMAINDER left over on the black block to the far left. Note that REMAINDER is smaller than the number of colorful blocks. Otherwise, each of the colorful blocks could have at least one more circle.


HOW IT WORKS
------------
The blocks take turns acting trying to accomplish the goal of distributing the circles evenly.

The colorful blocks act as follows: The block that's acting compares how many circles it has on itself with how many circles are on another colorful block. If it has at least two more than the other block, it can afford to give the other block one, so it does. If the acting block has exactly one more circle than the other block, it sends that extra circle to the black block on the far left. Since the colorful blocks act in this way, no colorful block can have more circles on it than any other colorful block.

The black block is special. While the colorful blocks are trying to spread the circles out evenly, the black block is keeping the extra circles. When the black block acts, it checks how many circles it has on it. If it has enough at least enough to put one circle on each of the colorful blocks, it sends all of the circles on it out to the colorful blocks randomly. Since the black block acts in this way, the maximum number of circles will be spread evenly on the colorful blocks.


HOW TO USE IT
-------------
Set DIVIDEND and DIVISOR to the desired numbers, press SETUP to set the problem up, and press GO to have the model find the answer.

DIVIDEND is the number of circles that will get spread out.

DIVISOR is the number of colorful blocks the circles will be spread out onto.

SETUP sets the problem up.

GO solves the problem.

When the model stops, the QUOTIENT monitor displays the number of circles on each of the colorful blocks.

When the model stops, the REMAINDER monitor displays the number of circles on the black block, which is the number of circles left over.

If CYCLE-IN-ORDER? is on, the blocks take turns acting in order. If it's off, the next block to act is chosen randomly.

IF NEXT-IS-OTHER? is on, the colorful blocks compare with the block to their right. If it's off, they compare with a random other colorful block.

To help watch the algorithm working, there are a few other monitors and a GO ONCE button that has just one block act at a time.

BLOCK-TO-GO shows which block is acting.

CIRCLES-ON-BLOCK-TO-GO show how many circles are on BLOCK-TO-GO.

OTHER-BLOCK shows which block BLOCK-TO-GO is comparing itself with.

CIRCLES-ON-OTHER-BLOCK shows how many circles are on OTHER-BLOCK.


THINGS TO NOTICE
----------------
Sometimes, the circles are piled up on top of each other. When this happens, it may look like there are fewer circles on a block than there actually are.

The time it takes for the algorithm to work varies quite a bit, even with the same settings.

Different remainders change how long the algorithm takes. What remainders are faster? What remainders are slower?

What else effects how long the algorithm takes? In what ways?


THINGS TO TRY
-------------
What switches, if any, make a difference in the time it takes for the algorithm to work and in what way?

Can you find settings that you know the algorithm will never work for? If so, how do you know?


EXTENDING THE MODEL
-------------------
The QUOTIENT monitor finds the average number of circles on the colorful blocks. Finding the average involves dividing by DIVISOR. Figure out another way to display the QUOTIENT that doesn't use division.

Make a way to time the model.

Don't allow more than one circle to be on a single patch within a block unless there's no other way to fit the circles onto the block.

Modify the algorithm to speed it up. Some ideas: Try having the blocks balance out with each other as much as possible before moving on to the next block. Try having the algorithm ""settle twice"", that is, go through once trying to share among the colorful blocks and once to send extras to the remainder.


CREDITS AND REFERENCES
----------------------
The algorithm that this model uses comes from a post to the starlogo-users mailing list by Ted Kaehler.

Thanks to Josh Unterman for his work on this model.

To refer to this model in academic publications, please use:  Wilensky, U. (2002).  NetLogo Division model.  http://ccl.northwestern.edu/netlogo/models/Division.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2002 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Division for terms of use.
"
3D Solids,/models/Sample Models/Mathematics,"turtles-own
[
  x-pos  ;; x-pos, y-pos, and z-pos are the cartesian coordinates
  y-pos  ;; don't confuse them with xcor and ycor, which are predefined
  z-pos  ;;   NetLogo variables for turtles
  p      ;; p, theta, and phi are the spherical coordinates
  theta
  phi
 ]

to setup
  clear-all
  set-default-shape turtles ""circle""
end

to setup-sphere
  setup
  ;; generate a sphere of radius SHAPE-SIZE
  crt num-turtles
  [
    set p shape-size            ; all points are equal distance from the center
    set theta random-float 360  ; however, random distribution on the surface of the sphere
    set phi random-float 180
    render-turtle
  ]
end

; a filled 3D cube
to setup-cube-filled
  setup
  ;; generate a square with edge of length radius
  ;; placing a point randomly anywhere inside the square
  crt num-turtles
  [
    cartesian ((- shape-size) + 2 * (random-float shape-size))
              ((- shape-size) + 2 * (random-float shape-size))
              ((- shape-size) + 2 * (random-float shape-size))
    render-turtle
  ]
end

; cube with turtles only on its surface
to setup-cube-surface
  setup
  crt num-turtles
  [
    let temp-alpha shape-size * (1 - 2 * (random 2))   ; +-shape-size
    ; random distribution bounded by +-shape-size
    let temp-beta shape-size - 2 * (random-float shape-size)
    let temp-gamma (random 2)                          ; front/back or left/right?
    ifelse temp-gamma = 0                              ; generate front & back surfaces
    [
      cartesian (temp-alpha)
                (temp-beta)
                (shape-size - (2 * (random-float shape-size)))
    ]
    [
      cartesian (temp-beta)                             ; generating the side surfaces
                (temp-alpha)
                (shape-size - (2 * (random-float shape-size)))
    ]
    render-turtle
  ]
end


; 3D cone
to setup-cone
  setup
  crt num-turtles
  [
    set theta (random-float 360)        ; points have a random angle
    set p (random-float shape-size)
    cartesian (p * (cos theta))     ; x = r*cos(theta)
              (p * (sin theta))     ; y = r*sin(theta)
              (shape-size - 2 * p)  ; this centers the cone at the origin
                                   ; instead of it only being in positive space
    render-turtle
  ]
end

; vertical cylinder
to setup-cylinder-v
  setup
  ;the code is almost the same as the setup-cone code
  ;except the xy-plane radius remains constant
  crt num-turtles
  [
    let temp-alpha (random 3) - 1         ; which surface (left, right, or body?)
    set theta (random-float 360)
    ifelse temp-alpha = 0
    [
      cartesian (shape-size * (cos theta))
                (shape-size * (sin theta))
                ((- shape-size) + 2 * (random-float shape-size))
    ]
    [
      cartesian ((random-float shape-size) * (cos theta))
                ((random-float shape-size) * (sin theta))
                (temp-alpha * shape-size)
    ]
    render-turtle
  ]
end

; horizontal cylinder
to setup-cylinder-h
  setup
  ;generates a cylinder in a horizontal position with capped ends
  crt num-turtles
  [
    let temp-alpha (random 3) - 1      ; which surface (left, right, or body?)
    set theta (random-float 360)
    ifelse temp-alpha = 0              ; generating the actual cylinder
    [
      cartesian ((- shape-size) + 2 * (random-float shape-size))
                (shape-size * (cos theta))
                (shape-size * (sin theta))
    ]
    [
      cartesian (temp-alpha * shape-size)
                ((random-float shape-size) * (cos theta))
                ((random-float shape-size) * (sin theta))
    ]
    render-turtle
  ]
end

to setup-pyramid
  setup
  crt num-turtles
  [
    let temp-alpha (- shape-size) + 2 * (random-float shape-size)  ; z coordinate
    set theta (random 2)                         ; front/back or side?
    let temp-beta (shape-size - temp-alpha) / 2
    let temp-gamma -1 + 2 * (random 2)           ; left/right or front/back (-1 or 1)
    ifelse theta = 0
    [
      cartesian (temp-beta * temp-gamma)          ;  left & right surfaces
                ((- temp-beta) + 2 * (random-float temp-beta))
                (temp-alpha)
    ]
    [
      cartesian ((- temp-beta) + 2 * (random-float temp-beta)) ;  front & back surfaces
                (temp-beta * temp-gamma)
                (temp-alpha)
    ]
    render-turtle
  ]
end

;; convert from cartesian to spherical coordinates
to cartesian [x y z]
  set p sqrt((x ^ 2) + (y ^ 2) + (z ^ 2))
  set phi (atan sqrt((x ^ 2) + (y ^ 2)) z)
  set theta (atan y x)
end

to go
  ; rotate-turtles on z axis
  ask turtles
  [
    set theta (theta + theta-velocity) mod 360  ; increment angle to simulate rotation
    render-turtle
  ]
  tick
end

to render-turtle
  calculate-turtle-position
  set-turtle-position
end

;; convert from spherical to cartesian coordinates
to calculate-turtle-position
  set y-pos p * (sin phi) * (sin theta)
  set x-pos p * (sin phi) * (cos theta)
  set z-pos p * (cos phi)
end

;; set the turtle's position and color
to set-turtle-position
  ifelse view = ""side""                                     ; sideview
  [
    setxy x-pos z-pos
    set color scale-color display-color y-pos (- shape-size) shape-size
  ]
  [
    ifelse view = ""top""                                  ; topview
    [
      setxy x-pos y-pos
      set color scale-color display-color z-pos (- shape-size) shape-size
    ]
    [
      setxy (p * (sin phi) * (cos theta))              ; bottomview
            (- (p * (sin phi) * (sin theta)))
      set color scale-color display-color (- z-pos) (- shape-size) shape-size
    ]
  ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo 3D Solids model.
; http://ccl.northwestern.edu/netlogo/models/3DSolids.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/3DSolids
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model creates 3D shapes out of 2D turtles by mapping turtles between cartesian and spherical three-dimensional coordinates.


HOW IT WORKS
------------
To create the 3D shapes the program randomly generates turtles about the shell of the shape in either cartesian (x, y, z) or spherical (theta, phi, z) coordinates, depending on which is easier to accomplish but always stores the information converting when necessary in spherical coordinates.  To render the sphere in the NetLogo view, it translates the turtles from spherical to cartesian coordinates using color to simulate depth. The positions of the turtles are always stored as spherical coordinates because they are rotated on the z-axis, and the simplest way to do so is to increase theta in spherical coordinates.

Converting from cartesian to spherical coordinates:

x = r * cos(theta) = p * sin(phi) * cos(theta)
y = r * sin(theta) = p * sin(phi) * sin(theta)
z = p * cos(theta)

theta:  angle of the turtle's projection on the x-y plane.
phi:  turtles angle of incidence to the z axis.
p: distance of the turtle from the origin.


HOW TO USE IT
-------------
Click the different setup-SHAPE buttons to generate different 3d-shapes. The turtles are randomly distributed about the surface of the shape. Click the go (forever) button to run the model.

GO starts rotating the model.

COLOR determines the color that is used to simulate depth in generating the various shapes (uses predefined NetLogo color constants).

NUM-TURTLES determines the number of turtles that are used to generate the various shapes.

SHAPE-SIZE determines the overall size of the shape.  Most often it is radius or edge length.

THETA-VELOCITY determines the speed at which the turtles are rotated.

(Rotating turtles in the rotate-turtles procedure is implemented simply by increasing each turtle's theta variable by theta-velocity!  ROTATING turtles (on its z-axis) is easy in spherical coordinates.  However it's far easier to TRANSPOSE turtles in cartesian coordinates.)


THINGS TO NOTICE
----------------
Notice that turtles closer (positive) on the y-axis appear lighter in shade and turtles further away (negative) appear darker in shade.


THINGS TO TRY
-------------
Try adjusting the theta-vel or render-color slider as the model is running.  This will provide real time feedback to your adjustments.


EXTENDING THE MODEL
-------------------
[EASY] Adjust the setup-square procedure to generate a rectangle.

Create a procedure to transpose turtle coordinates.  Remember that it is easier to transpose in cartesian coordinates.

Create a procedure to generate new 3D geometries.

Try animating the phi variable.  Conceptually why does this not make sense?

Create a procedure to rotate the geometries on a different axis.

[VERY DIFFICULT] Create a procedure to view the geometries at ANY angle instead of the present three.


NETLOGO FEATURES
----------------
Notice the use of scale-color to show the depth of turtles and thereby simulate 3D.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo 3D Solids model.  http://ccl.northwestern.edu/netlogo/models/3DSolids.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/3DSolids for terms of use.
"
Birthdays,/models/Sample Models/Mathematics/Probability,"globals [
  days            ;; a list of the dates of all 365 days in the year
  successes       ;; how many ticks had at least one duplicate birthday
]

turtles-own [
  birthday        ;; this turtle's birthday as a number from 0 to 364
]

to setup
  clear-all
  set successes 0
  ;; create lists of each month and the number of days in each month
  ;; then iterate through the two lists and expand into a single list  
  ;; of every day of the year
  let months [""January"" ""February"" ""March"" ""April"" ""May"" ""June"" ""July""
              ""August"" ""September"" ""October"" ""November"" ""December""]
  let month-lengths [31 28 31 30 31 30 31 31 30 31 30 31]
  ;; now build up the list of all the day names in the year
  set days []
  ;; sets ?1 equal each month name and ?2 to the number of days in that month
  (foreach months month-lengths 
  [ ;; use ""sentence"" to repeatedly glue lists together, so we wind
    ;; up with one big list
    set days (sentence days make-month ?1 ?2) 
  ])
end

;; this procedure generates all of the day names within a month
to-report make-month [month month-length]
  ;; use n-values to generate a list of the numbers from 1 to
  ;; the end of the month
  let day-numbers n-values month-length [? + 1]
  ;; now glue onto the month name each number
  report map [(word month "" "" ?)] day-numbers
end

to go
  ;; kill off the turtles from the last round
  clear-turtles
  ;; populate the room with new turtles
  make-turtles
  ;; arrange the turtles in order by birthday
  sort-turtles
  ;; turn turtles with matching birthdays green
  show-matches
  ;; keep track of cumulative results
  if any? turtles with [color = green]
    [ set successes successes + 1 ]
  tick
end

to make-turtles
  ;; ask the patches along the right edge of the world
  ;; to each sprout a turtle
  ask patches with [pxcor = max-pxcor]
  [ 
    sprout 1
    [ 
      set heading 90
      set color blue + 3
      ;; pick a random birthday (a number from 0 to 364)
      set birthday random length days
      ;; we use ""word"" to add some spaces onto the end
      ;; of the turtle's labels, otherwise the label
      ;; would visually overlap the turtle.  ITEM
      ;; is used to look up our day name in the list
      ;; of all day names.
       set label word (item birthday days) ""     "" 
     ] 
   ]
end

to sort-turtles
  ;; sort-by takes an agentset and returns a sorted list
  let sorted sort-by [[birthday] of ?1 < [birthday] of ?2] turtles
  ;; finally, we position each turtle according to its position
  ;; in the sorted list
  ask turtles
    [ set ycor max-pycor - position self sorted ]
end

to show-matches
  ;; if there are any turtles with the same birthday
  ;; show it.
  ask turtles
    [ if any? other turtles with [birthday = [birthday] of myself]
        [ set color green
          set label-color green ] ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2004 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2004).  NetLogo Birthdays model.
; http://ccl.northwestern.edu/netlogo/models/Birthdays.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2004 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Birthdays
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
In a room of 23 people, what are the chances that some two of them will have the same birthday?

Make your best guess, then run the model and see how often it happens.


HOW IT WORKS
-------------
Each turtle is randomly assigned a birthday.  If a turtle has the same birthday as another turtle in the room, it turns green.

The model doesn't take leap years into account (there are no February 29th birthdays).


HOW TO USE IT
-------------
Press SETUP to initialize the model.

Press GO ONCE to generate a single room full of people.

Press GO to repeatedly generate many rooms full of people.  The SUCCESS RATE monitor will show what percentage of those rooms had at least one matching birthday.


THINGS TO NOTICE
----------------
Is the success rate higher or lower than you expected?


THINGS TO TRY
-------------
To try a room with more people in it, edit the view and increase max-pycor.

How many people need to be in the room before the chance of a matching birthday is at least 90%?  (Is this higher or lower than you expected?)

Can you work out mathematically what the odds should be?  (Hint: start by considering the odds when the number of people is small.)


EXTENDING THE MODEL
-------------------
Include leap year birthdays in the list of possibilities.


NETLOGO FEATURES
----------------
This model uses lists a lot, including list primitives such as MAP, FOREACH, ITEM, POSITION, SENTENCE, and SORT-BY.  Lists are used mostly to make the model display actual day names, instead of just numbers from 0 to 364.  Lists are also used when sorting the turtles by birthday.


RELATED MODELS
--------------
The ProbLab suite of models, in the Mathematics/Probability section, contains many explorations of basic questions about probability and statistics.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (2004).  NetLogo Birthdays model.  http://ccl.northwestern.edu/netlogo/models/Birthdays.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2004 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Birthdays for terms of use.
"
Three Doors,/models/Sample Models/Mathematics/Probability,"globals [
  done?  ; indicates whether the race is over or not yet
]

turtles-own [
  guess      ; what each turtle guesses to be the right door
  prize      ; where the prize is located
  other-door ; the number of the door that the host or hostess does NOT open
  hunch      ; the bias each turtle has to switch or not to switch doors
]

to setup
  ca
  ask patches [ set pcolor green ]
  crt number
  [
    ifelse (gradation?)
      [ set hunch (random-float 100) ]             ; gradation is on, so give a hunch BETWEEN 0 and 100
      [ set hunch ((random 2) * 100 )]       ; gradation is off, so give a hunch of 0 or 100
    set color scale-color gray hunch 0 100 ; set the color based on the hunch of the turtles
    set heading 0
    ; spread the turtles out across the bottom of the world
    setxy random-xcor min-pycor
  ]
  set done? false  ; the race is not over yet
end

to go
  if done? [ stop ]
  ask turtles
  [
    make-choices  ; choose a door that the turtles will choose, a door for the prize, and set the other door
    do-switch?    ; should each turtle switch to the other door?
    award-prizes  ; make the winning turtles go forward and don't do anything if the race has been won
  ]
  tick
end

; choose a door that the turtles will choose (guess), a door for the prize (prize), and set the other door that is not opened (other)
to make-choices
  set prize (random 3)
  set guess (random 3)
  if (prize = 0)  ; the prize is behind door number 0
  [
    ifelse (guess = 0)
    ; the turtle guessed door 0
      [ set other-door ((random 2) + 1) ]  ; since the prize is in the door the turtle picked, pick door 1 or 2 to not be opened by the host or hostess
    ; the turtle guessed door 1 or 2
    ; it doesn't matter which door is picked to be not opened since both doors 1 and 2 have the junk behind them
      [ set other-door 0 ]
  ]
  if (prize = 1)  ; the prize is behind door number 1
  [
    ifelse (guess = 0)
    ; the turtle guessed door 0- a door with junk behind it
      [ set other-door 1 ]  ; so set the door not to be opened to door 1, the door with the prize behind it.  now door 2- with junk behind it- can be opened.
      [
        ifelse (guess = 1)
        ; the turtle guessed door 1
          [ set other-door ((random 2) * 2) ]  ; since the prize is in the door the turtle picked, pick door 0 or 2 to not be opened by the host or hostess
        ; the turtle guessed door 2- a door with junk behind it
          [ set other-door 1 ]  ; so set the door not to be opened to door 1, the door with the prize behind it.  now door 0- with junk behind it- can be opened.
      ]
  ]
  if (prize = 2)  ; the prize is behind door number 2
  [
    ifelse (guess = 0)
    ; the turtle guessed door 0- a door with junk behind it
      [ set other-door 2 ]  ; so set the door not to be opened to door 2, the door with the prize behind it.  now door 2- with junk behind it- can be opened.
      [
        ifelse (guess = 1)
        ; the turtle guessed door 1- a door with junk behind it
          [ set other-door 2 ]    ; so set the door not to be opened to door 2, the door with the prize behind it.  now door 0- with junk behind it- can be opened.
        ; the turtle guessed door 2
          [ set other-door (random 2) ]  ; since the prize is in the door the turtle picked, pick door 0 or 1 to not be opened by the host or hostess
      ]
  ]
end

; should each turtle switch to the other door?  this is based on the hunch in each turtle
to do-switch?
  if (random-float 100 < hunch)
    [ set guess other-door ]
end

; make the winning turtles go forward and don't do anything if the race has been won
to award-prizes
  if (guess = prize)
  [
    if (not done?)  ; if the race is not done, move the winners forward by 1 patch
    [ fd 1 ]
  ]
  ; if a turtle has reached the top of the world, set done? to be true
  if (ycor = max-pycor)
    [ set done? true ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Three Doors model.
; http://ccl.northwestern.edu/netlogo/models/ThreeDoors.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/ThreeDoors
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
You are a contestant on a game show.  You, of all people, have made it to the final round, where you have the chance to win some fabulous prize -- a car, a million dollars, eternal youth, etc...  The host or hostess of the game show takes you up on stage, where you stand before three doors, marked ""0"", ""1"", and ""2"".

""Your prize is behind one of these three doors.  Behind the other two are goats, and you don't want these goats.  So, which one will you pick?"" she or he says.  You make your selection, and reach for the door -- but before you open it, the hostess or host says to you: ""All right, now I'm going to give you a choice.""  She or he opens another one of the doors, one you didn't pick.  And sure enough, there's an ugly old goat.

The hostess or host then points to the other door, saying: ""If you want, you can change your mind, and pick the last door; the door you didn't pick that I didn't open.  So now, which will it be?  Your first selection?  Or the other door?""  You think for a brief moment...

Which will it be?  Will you stick with your first choice, or switch to the other door?  Does it matter?  Do you have better odds of winning the prize by switching or sticking?  Or is it even odds either way?  (We're assuming here that you want the prize and have an aversion to goats.  If you really would prefer the goat, then the prize is the goat, and the two other doors are empty, or contain mulch, whatever...)

This is a classic puzzle in thinking about probability.  It has several other names: the 'Monty Hall' puzzle (named after the host of the game show this is taken from: ""Let's Make a Deal"") and 'Goats-and-Car' being the two most common.  The puzzle is based around the questions being asked above, which really boil down to one question at the heart of the matter: which is it better to do, stick or switch?

This project is called Three Doors.  Essentially what goes on is this: an arbitrary number of turtles (around several hundred, usually) gather together at the bottom of the world.  They then begin to play this three-doors game over and over again.  The prize they can win is a turtle-command: 'fd 1'.  If they lose, nothing happens.  Thus, the turtles are having a race to the top of the world, and they can only advance in the race if they win a prize.

Turtles determine the results of each round of the contest by themselves, alternately acting as contestant and host or hostess.  Also, each turtle has a 'hunch' - a percentage chance that it will switch to the other door.  The value of 'hunch' determines a turtle's color.  A turtle that always sticks with its original choice of doors has a hunch of 0 and is colored black.  A turtle that always switches its choice of doors has a hunch of 100 and is colored white.


HOW TO USE IT
-------------
Before you begin playing with the model, read the paragraphs above.  Ask yourself what YOU would do -- stick with your initial pick, or switch to the other door.  Why?  Try to come up with an argument for your decision.  And then, think about the alternative.  Suppose you think it's 'better' to switch.  Why do you think so?  How much better do you think it is?  Why might it be better to stick with your initial decision?  Think about those questions, and talk about them with some of your peers (explain the scenario if they haven't already heard it).

This model is quite easy to run.  First, select the number of turtles you want to be present with the NUMBER slider.  (The more, the better, but you don't want to sacrifice too much speed.)  When you are ready to begin, press the SETUP button.  This will spread turtles randomly across the bottom row of patches.

Make a prediction as to how the different colors of turtles will perform in their race.  The turtles will repeatedly play the three-doors game, until one turtle has made it to the top of the world.  Finally, when you are all set, press the GO button.

If the GRADATION? switch is on, each turtle will be assigned a random 'hunch' *between* 0 and 100, instead of exactly 0 or 100.  Turtles who tend to 'stick' will have a lower hunch and be darker. Turtles who tend to 'switch' will have a larger hunch and be lighter.


THINGS TO NOTICE
----------------
The main point of this model is demonstrated by the results of the turtles' race.  Try to understand these results.  Run the model a second time, with the same value for NUMBER and see what happens.  Do you accept these results?  In light of what you have observed, ask yourself the above questions again.  Is it better for a turtle to 'play its hunch'?

Try running the model with many more turtles, or just a few turtles.  How does the number of turtles relate to the behavior?

In the first paragraph of 'How To Use It', it asks you to discuss this puzzle with some of your peers.  Important 'things to notice' are their own arguments one way or another.  How vehement were their beliefs?  How sound were their arguments?  How did you react to what they said, and how did they react to the results of this project?

The host or hostess will always open a door that contains a goat -- we're assuming that he or she has perfect information about the location of the prize.  Of what importance is this to the model?  How would the model be different if she or he opened a random door instead of a goat-door?


THINGS TO TRY
-------------
Turn the GRADATION? switch on. How does the pattern of turtles change?

Look at the code for this model, especially if you disagree with its results.  Try to step through the procedure 'make-choices'.  Do you think this procedure, and the model as a whole, is fair?

Next, try writing your own procedure for one round of the three-doors contest.  Compare its performance with what you've seen here.

Find someone who hasn't yet seen this model, or thought about this problem before.  Ask them for their opinion, and listen to their argument in defense of their choice.  Try not to argue with them (yet), just hear them out.  Then have them run this model, and see what they think.  If you've looked at the code, try to explain to them what is really going on.


EXTENDING THE MODEL
-------------------
This model has been kept very simple for a good reason -- to allow you to expand upon it at your leisure.  There are several directions in which it could go.  First of all, as mentioned above, try writing a different set of procedures for running a round of the contest.

Change the number of doors from three to four, or five, or n (where 'n' could be a slider value).  How will this change the model?  You also might consider having several doors lead to prizes.

If there are 'n' doors, and 'm' different kinds of prizes, as suggested above, you could assign different values to the different prizes.  Maybe create different breeds of turtles, each of which has a different set of prize-values?

Regardless of what you do, always make sure to make a prediction about what you think will happen, and to compare the actual results with what you see.

Try inventing a way to display how well each rule does, on average.  You could use monitors or plots.

Create a plot of the effectiveness of the different strategies and setups of the problem described above.


NETLOGO FEATURES
-----------------
As the turtles are all competing with one another, it's important that they all take the same amount of time to 'do a round'.  If you have many turtles, it's possible that some turtles could cheat, and get ahead of the others, just by getting through the code quicker.  Thus, we make use of an ""ask turtles"" block in the GO function.  Whenever you use ""ask"", all the agents must finish the block of code before the code will continue.  This makes sure that all turtles have caught up to the end of the block.  So any place in your code where ensuring lockstep (i.e. making sure that all turtles act in synchrony) just might be an issue, use an ""ask"".

Note that it does no harm to have a turtle determine the prize door itself -- it does not use this knowledge when deciding which door to pick.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Three Doors model.  http://ccl.northwestern.edu/netlogo/models/ThreeDoors.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/ThreeDoors for terms of use.
"
Random Walk 360,/models/Sample Models/Mathematics/Probability,"turtles-own
[
  xc     ; unwrapped xcor
  yc     ; unwrapped ycor
  dist   ; distance from home using xc, yc
]

to setup
  clear-all
  ; if the user so chooses, draw rings around (0, 0) to give a sense of how far turtles have traveled
  ; the furthest in-view distance from home is world-width * sqrt (2) / 2
  if draw-rings? [
    ;; draw the rings by making ring shape turtles that stamp their shape
    ;; and then go away
    crt floor (world-width * sqrt 2 / (ring-radius * 2)) [
      set color gray - 1
      set shape ""ring""
      set size ring-radius * 2 * (who + 1)
      stamp
      die
    ]
    ;; draw X and Y axes
    crt 1 [
      set heading 0
      set color gray - 1
      set shape ""line""
      set size world-height
      stamp
      rt 90
      set size world-width
      stamp
      die
    ]
  ]
  crt num-turtles
  setup-plots
  draw-plots
end

to go
  ask turtles
  [
    ; head in a random direction
    rt random-float 360
    set xc xc + (step-size * cos heading)
    set yc yc + (step-size * sin heading)
    ; hide turtles who have moved out of the world
    ifelse patch-at (xc - xcor) (yc - ycor) = nobody
      [ ht ]
      [ st
        set xcor xc
        set ycor yc ]
    set dist sqrt (xc * xc + yc * yc)
  ]
  tick
  draw-plots
end

to setup-plots
  set-current-plot ""Average Distance""
  set-plot-y-range 0 (5 * step-size)

  set-current-plot ""Average X-Distance""
  set-plot-y-range 0 (5 * step-size)

  set-current-plot ""Std.Dev. of Distance""
  set-plot-y-range 0 (5 * step-size)
end

to draw-plots

  ; plot the average distance of all the turtles from (0,0)
  set-current-plot ""Average Distance""
  plot ((sum [ dist ] of turtles) / count turtles)

  ; plot the average xc of all the turtles
  set-current-plot ""Average X-Distance""
  plot (sum [abs xc] of turtles) / num-turtles

  ; plot the standard deviation of the distance of all the turtles from (0,0)
  set-current-plot ""Std.Dev. of Distance""
  plot (standard-deviation [ dist ] of turtles)

end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Random Walk 360 model.
; http://ccl.northwestern.edu/netlogo/models/RandomWalk360.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/RandomWalk360
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
In this model the turtles engage in a ""random walk.""  Each turtle walks one step away from its current location in a different random direction at each clock tick. This movement is known as walking a 360-gon ""lattice.""  A lattice is a set of points on the plane (or in space) that form a grid on which turtles walk.

As the simulation continues, one can expect the turtles to become more spread out.  Will they ever return home (to their point of origin at 0 0)? Observe the kinds of patterns that develop as the turtles move.


HOW TO USE IT
-------------

General Settings
----------------
Use the NUM-TURTLES slider to select how many turtles will participate in the random walk.

Use the STEP-SIZE slider to decide how far from its current location a turtle will move on each step.

How steps are implemented: if STEP-SIZE is set to n it will add (n * cos(theta)) to its current xcor value and it will add (n * sin(theta)) to its current ycor value.  It will have moved n patch units from its current location.  (Why?)

Each of the above movements would be considered a single ""pace.""


Distance Rings
--------------
Set DRAW-RINGS to ON to draw the x-axis, y-axis, and a set of concentric circles about the point (0 0).  This switch must be set prior to pressing SETUP.

Use the RING-RADIUS slider to set the incremental distance between the distance rings.


Plots
------------
""Average Distance""
- measures the average distance over all turtles, from home (the origin at 0,0) to their current coordinates.

""Average X-Distance""
- measures the average distance over all turtles along the x-axis away from the origin (x = 0).

""Std.Dev. of Distance""
- measures the standard deviation of all turtles' true distance from home to their current position.  NetLogo's standard deviation primitive is used.

Note that xcor and ycor values are stored in such a way that turtles are tracked even if they move outside the boundaries of the world.  These 'out of bounds' values are used to measure distances.  They are stored at turtle variable xc (for xcor) and yc (for ycor).

Distances are either zero or positive.

Monitors
--------
The CLOCK monitor displays how many paces the turtles have taken.

Buttons
-------
Press SETUP when all of the above selections have been made.  This will create the selected number of turtles at the bottom center of the world.

Press GO-ONCE to make the turtles move one pace.

Press GO to make the turtles move continuously.  To stop the turtles, press the GO button again.


HOW TO USE IT
-------------
Try starting with 500 turtles with a step size of 1.  If you want to show distance rings, try setting the radius increment to 20.

Press SETUP then press GO.

The turtles all start at (0,0) (home).

Think about how you would define an 'average' turtle and an 'average' walk.

Where would you expect an average turtle to end up at a given time?  Why?

Will all turtles eventually return home?  If so, how many paces would you expect a turtle to travel before it returned to home?  Why?

What kinds of calculations or measurements would you use in trying to answer these questions?


THINGS TO NOTICE
----------------
Two characteristics of the plots you see are their smoothness and their slope.

To think about smoothness of the plots, notice how much the lines move up and down over time.

To think about slope of the plots, consider whether the plot appears to be going 'uphill' or 'downhill' and consider whether the 'hill' is steep or flat.

What do you notice about the smoothness and slope of the plots?
- Are they smooth?  Why or why not?
- Are they steep?  Why or why not?
- For a given plot, is its steepness the same at the far edges and at the center?  Why or why not?

Does the plot have any symmetry?  Would you expect it to?  Why?

Does a single line plot ever change between positive and negative slopes?  Why or why not?  If it does, what does that mean?


THINGS TO TRY
-------------
Try to answer the following questions before running the simulations.  Record your predictions.  Compare your predicted results with the actual results.
- What reasoning led you to correct predictions?
- What assumptions that you made need to be revised?

Try different numbers of turtles while keeping all other slider values the same.
- What happens to the plot's smoothness and slope when the number of turtles is increased?
- What happens to the plot's smoothness and slope when the number of turtles is decreased?
- Does the simulation finish faster or slower than the first model?

Try different numbers of steps while keeping all other slider values the same.
- What happens to the plot's smoothness and slope when the number of steps is increased?
- What happens to the plot's smoothness and slope when the number of turtles is decreased?
- Does the simulation finish faster or slower than the first model?

How do your answers to the above questions compare to the average values calculated for all turtles in a given simulation?


EXTENDING THE MODEL
-------------------
In this simulation, turtles can only move based on integer values of heading.  Change the model so that any value of heading between 0 and 360 degrees is possible.

Does this change the amount of time it would take for a turtle to return home?  How?  Why?

How does this change impact answers to other questions asked above?

One of the plots measures the average x-distance away from the origin over all turtles.  Obviously, it could have measured the y-distance instead.  Watch the plot under one run of the model, and then change the procedure so that it measures y-distance.  How do the plots differ?

Create a new monitor called home-turtles.  Have it display the number of turtles at (or very near) home.  Create a plot to display this information.


NETLOGO FEATURES
-----------------
Since NetLogo does not allow the world to be unbounded, the special code below is needed for this model to simulate the behavior, instead of stopping at the edge of the world the turtles hide themselves when they have moved outside the world.

|    set xc xc + (step-size * cos heading)
|    set yc yc + (step-size * sin heading)
|    ; hide turtles who have moved out of the world
|    ifelse patch-at (xc - xcor) (yc - ycor) = nobody
|      [ ht ]
|      [ st
|        set xcor xc
|        set ycor yc ]
|    set dist sqrt (xc * xc + yc * yc)

This model takes advantage of NetLogo's multiple plots.  There are three different plots available at any one time.  The auto-plot-on command allows the plots to be automatically resized once a plot pen reaches the borders of a plot.

Stamping of turtle shapes is used to draw a polar coordinate grid in the view.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Random Walk 360 model.  http://ccl.northwestern.edu/netlogo/models/RandomWalk360.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/RandomWalk360 for terms of use.
"
Galton Box,/models/Sample Models/Mathematics/Probability,"globals [
  balls        ;; how many balls have been created
  counters     ;; agentset of patches where ball counts are displayed
]

;; We use two breeds of turtle: one for balls which are still falling,
;; and second for balls which have landed in piles.
breed [falling-balls falling-ball]
breed [piled-balls piled-ball]

;;; SETUP PROCEDURES

to setup
  clear-all
  set-default-shape turtles ""circle""
  set balls 0
  ask patch 0 (max-pycor - 2) [
    sprout 1 [ propagate ]
  ]
  set counters patches with [counter?]
  ask counters [
    set plabel 0
    set pcolor green - 3
    ;; make the column numbers at the bottom
    ask patch pxcor min-pycor [
      set plabel round (abs pxcor / 2)
    ]
  ]
end

;; The way we make the pegs is a bit tricky.  We use turtles,
;; starting with one turtle at the top.  Each turtle colors
;; the patch yellow, then creates two more turtles, one below
;; and left, one below and right.  The parent dies, and the
;; the cycle continues until the last row has been made.
;; This procedure is recursive.
to propagate  ;; peg procedure
  if ycor < max-pycor - 2 - 2 * number-of-rows [ die ]
  set pcolor yellow
  set ycor ycor - 2
  hatch 1 [
    set xcor xcor - 1
    propagate
  ]
  hatch 1 [
    set xcor xcor + 1
    propagate
  ]
  die
end

to-report counter?  ;; patch procedure
  report (yellow-at? 1 2 or yellow-at? -1 2)
    and not yellow-at? -2 0
    and not yellow-at? 2 0
end

to-report yellow-at? [x-offset y-offset] ;; patch procedure
  let p patch-at x-offset y-offset
  report p != nobody and [pcolor] of p = yellow
end

;;; GO PROCEDURES

to go
  if time-for-new-ball? [ new-ball ]
  if full? [
    ask falling-balls with [ycor > [pycor] of one-of counters] [
      set balls balls - 1
      die
    ]
  ]
  if not any? falling-balls [ stop ]
  ask falling-balls [ fall ]
  ask falling-balls-on counters [
    set plabel plabel + 1
    if not pile-up? [ die ]
  ]
  tick
end

to fall  ;; falling-balls procedure
  ifelse [pcolor] of patch-at 0 -1 = yellow
  ;; if peg below, go left or right
  [ ifelse random-float 100 < chance-of-bouncing-right
      [ set xcor xcor + 1 ]
      [ set xcor xcor - 1 ]
  ]
  ;; if no peg below, go down
  [ set ycor ycor - 1
    if done-falling? [
      set breed piled-balls
    ]
  ]
end

to-report done-falling?  ;; falling-ball procedure
  report ycor = (min-pycor + 1)
         or any? piled-balls-on patch-at 0 -1
end

to new-ball
  ask patch 0 max-pycor [
    sprout-falling-balls 1 [
      set color red
    ]
  ]
  set balls balls + 1
end

to-report time-for-new-ball?
  ;; we release a ball every other tick; keeping space
  ;; between the balls makes it easier to ensure that two
  ;; balls never simultaneously occupy the same patch
  report balls < number-of-balls
         and not any? falling-balls-on patch 0 (max-pycor - 1)
end

to-report full?
  report any? counters with [any? piled-balls-on patch-at 0 -1]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2002 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2002).  NetLogo Galton Box model.
; http://ccl.northwestern.edu/netlogo/models/GaltonBox.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2002 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/GaltonBox
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
A Galton box is a triangular board that contains several rows of staggered but equally spaced pegs.  Balls are dropped from the top, bounce off the pegs and stack up at the bottom of the triangle.  The resulting stacks of balls have a characteristic shape.

The model enables you to observe how nature produces the binomial coefficients from Pascal's Triangle and their relation to a Gaussian bell-shaped normal curve. The model can also simulate coin tossing experiments with biased coins which result in skewed distributions

There are many applications for the concepts encompassed in a Galton box.  People employed in a wide variety of fields use binomial and normal distributions to make precise calculations about the likelihood of events or groups of events occurring.


HOW IT WORKS
------------
With the default settings, the model reproduces a traditional Galton box.  But you can also adjust the probability of the balls bouncing right or left when it hits a peg to be something other than 50-50.


HOW TO USE IT
-------------
Click the SETUP to set up the rows of the triangle, the number of balls, and other parameters.  Click to GO button to begin the simulation.

The PILE-UP? button controls if the balls create piles or simply disappear when they reach the bottom of the triangle.  If PILE-UP? is on and the pile of balls reaches the bottom of the triangle, the model will stop.  Note: if you are running a trial with a large number of balls you might want to turn PILE-UP? off.


THINGS TO NOTICE
----------------
With a small number of balls it is hard to notice any consistent patterns in the results.

As you increase the number of balls, clear patterns and distributions start to form.  By adjusting the CHANCE-OF-BOUNCING-RIGHT you can see how different factors can change the distribution of balls.  What types of distributions form when the CHANCE-OF-BOUNCING-RIGHT is set at 20, 50, or 100?

This model is a good example of an independent trials process.  Each ball has a probability of falling one way, and its decision is unrelated to that of any of the other balls.  The number of rows the balls must fall through affects the amount of variation present in a run of the model.


THINGS TO TRY
-------------
Change the NUMBER-OF-BALLS and NUMBER-OF-ROWS sliders.  How does varying numbers alter how balls stack up?

Change the CHANCE-OF-BOUNCING-RIGHT slider as balls have begun to fall.  What kinds of ball distributions can you produce?

Change the NUMBER-OF-BALLS slider.  What is the best way to produce a standard binomial distribution (or approximate a bell curve)?

Set a CHANCE-OF-BOUNCING-RIGHT then try to predict the resulting stacks of balls.  How would you calculate the mean and variances of a given stack for a given setting?


EXTENDING THE MODEL
-------------------
Make the balls shade the patches as they fall, so the more balls pass a patch the lighter it gets.  This will let the user how frequently different paths are traveled.

Modify the program to allow independent adjustment of each peg, so that they can adjust their own orientation, rather than having all the pegs synchronized.

Change the shape of the board.  Maybe flip the triangle upside down.  How does this effect how the balls get distributed?

In addition to changing the shape of the board, change the direction balls can go.  Maybe allow balls to go in all directions.

Make it so you can select a specific peg.  If a ball bounces off that peg, stop the ball.  Keep track of how many balls are stopped.  What specific insight does this provide about the independent trials process and ball distributions?.


RELATED MODELS
--------------
Random Walk Left Right, Binomial Rabbits


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (2002).  NetLogo Galton Box model.  http://ccl.northwestern.edu/netlogo/models/GaltonBox.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2002 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/GaltonBox for terms of use.
"
Random Basic,/models/Sample Models/Mathematics/Probability/ProbLab,"globals
[
  time-to-stop?   ;; boolean that discontinues run when columns reach to top
  the-messenger       ;; holds identity of the single turtle of breed 'messengers'
                  ;; (see EXTENDING THE MODEL)
  max-y-histogram ;; how high the columns can rise (or how far up the yellow goes)
]

breed [ column-counters column-counter ] ;; they keep track of their respective histogram columns
breed [ frames frame ]    ;; square frames that indicate events in histogram columns
breed [ messengers messenger  ]  ;; carry the random value to its column
                  ;; (currently just one single messenger implemented)


column-counters-own
[
  ;; if you choose a sample-space 7 then you get 7 column-counters
  ;; and their respective my-columns will be 1 thru 7
  my-column
  ;; each column-counter holds all patches that are in its column as an agentset
  my-column-patches
]

to setup
  ca
  ;; computes the height the user has requested so as to get the value that makes sense
  ;; in this model because the histogram grows from the negative-y values and not from 0
  set max-y-histogram (min-pycor + height)
  create-histogram-width
  setup-column-counters
  set time-to-stop? false
end

to create-histogram-width
  ask patches
  [
    ;; deals with both even and odd sample-spaces
    ;; this is one way of centering the histogram.
    ;; that means that the '50' of the red-green slider
    ;; will always be aligned with the middle of the histogram
    ifelse (pxcor >= (- sample-space) / 2) and (pxcor < sample-space / 2)
            and (pycor < max-y-histogram) ;; this shapes the top of the yellow zone
    [ set pcolor yellow ]
    [ set pcolor brown ]
  ]
end

    ;; column-counters are turtles who form ""place-holders"" so that
    ;; the messenger will ""know"" where to take its value.
    ;; they are like the values on the x-axis of your sample space.
to setup-column-counters
  ask patches with [(pycor = min-pycor) ;; bottom of the view
                       and pcolor = yellow]      ;; and in the histogram band width
  [
    sprout-column-counters 1
    [
      ht  ;; it is nice to see them but probably visually redundant
      set heading 0
      ;; this assigns a column name to column-counters that
      ;; corresponds with the parameter setting of sample-space
      set my-column floor (pxcor + sample-space / 2 + 1)
      set my-column-patches patches with [ pxcor = [pxcor] of myself ]
    ]
  ]

end

to go ;; forever button
  if time-to-stop? [ stop ]
  select-random-value
  send-messenger-to-its-column
  ifelse colors?
    [ paint ]
    [ ask patches with [pcolor != brown] [ set pcolor yellow ]]
  tick
end

    ;; 'messenger' is a turtle who carries the random value
    ;; on its back as a label
to select-random-value
  ask patch 0 (max-y-histogram + 4)
  [
    sprout-messengers 1
    [
      set shape ""default""
      set color black
      set heading 180
      set size 12
      set label 1 + random sample-space
      ;; currently there is just one messenger, so we assign it to a 'messenger'
      ;; variable. this will save time when the model run. if the user chooses
      ;; to add more messengers then this shortcut may have to be done away with
      set the-messenger self
    ]
  ]
end

    ;; messenger is the dart-shaped large turtle that carries the random value
    ;; on its back. it takes this value directly to the appropriate column
to send-messenger-to-its-column
                ;; 'it' holds the column-counter who is master of the
                ;; column towards which the messenger orients and advances
                ;; to dispatch its event
  let it one-of column-counters with [ my-column = [label] of the-messenger ]

  ask the-messenger
  [
    face it
    ;; keep advancing until you're all but covering your destination
    while [ distance it > 3 ]
    [
      fd 1 ;; to the patch above you to prepare for next event
      display
    ]
    die
  ]
  ask it
  [ create-frame
    fd 1
    ;; if the histogram has become too high, we just stop.
    ;; this could be extended so as to have the whole population
    ;; of events collapse down one patch, as in Galton Box
    if ycor = max-y-histogram [ set time-to-stop? true ]
  ]

end

;; make the square frames that look like accumulating cubes
to create-frame ;; turtle procedure
  ask patch-here
  [
    sprout-frames 1
    [
      set shape ""frame""
      set color black
    ]
  ]
end

    ;; patches are red if they are as far to the right within the sample-space
    ;; as indexed by the red-green slider; otherwise, the are green
    ;; Note that currently there is no rounding -- just a cut-off contour.
to paint
  ask column-counters
  [
    ifelse my-column <= (red-green * sample-space / 100)
    [ ask my-column-patches with [ pycor < [pycor] of myself ] [ set pcolor red ] ]
    [ ask my-column-patches with [ pycor < [pycor] of myself ] [ set pcolor green ] ]
  ]
end

;; reports the percentage of red patches out of all patches that have frames
;; so we know what percent of events are to the left of the cut off line
to-report %-red
  report precision (100 * count patches with [pcolor = red] / count frames) 2
end

to-report %-full
  report precision ( 100 * (count frames ) / ( height * sample-space ) ) 2

end

;; biggest-gap is the greatest difference in height between all columns
to-report biggest-gap
  let max-column max [count my-column-patches with [pycor < [pycor] of myself] ] of column-counters

  let min-column min [count my-column-patches with [pycor < [pycor] of myself] ] of column-counters

  report max-column - min-column
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2004 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Abrahamson, D. and Wilensky, U. (2004). NetLogo Random Basic model.
; http://ccl.northwestern.edu/netlogo/models/RandomBasic.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2004 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/RandomBasic
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
Random Basic is the simplest of all the ProbLab models. It can either be used first or as a detour from a more complex model to explain randomness.  This model introduces the user to the random generator in NetLogo. Randomness means that in the short term you cannot guess a value but in the long term all possible values will have occurred more or less equally often.

Here we see a bar chart grow reflecting a real-time succession of random events. You can think of the bar chart as a competition between the columns and ask whether one of the columns wins more often than others. Or you can think of it as some goodies being given out and think about whether the goodies are being given out fairly. Or think about it some other way -- that's fine.

You can set the size of the sample space. Also, you can split the bar chart into two sub-regions (red and green) and track the convergence of the distribution on proportion values that you have set.

This model is a part of the ProbLab curriculum. The ProbLab Curriculum is currently under development at the CCL. For more information about the ProbLab Curriculum please refer to http://ccl.northwestern.edu/curriculum/ProbLab/.


HOW IT WORKS
------------
At every tick, the computer selects a random number between 1 and ""sample-space"" (a slider in the interface tab). For instance, if the slider reads 100, then the random number will be between 1 and 100, inclusive. This random number piggy-backs on a virtual dart. In this program the dart is called the 'messenger' because it carries the number from the top of the view to the appropriate column. Each column is associated with one number. Once the messenger gets to its column, the messenger vanishes but the column becomes taller by one square (the squares are called 'frames' in this and other models in ProbLab). The columns grow until one of them reaches the brown half of the view, which stops the run.


HOW TO USE IT
-------------
Choose a sample-space (you can leave it at the default value of '100') and press Setup. Now press Go. The messenger (the dart) will obtain a random number and carry it to the correct column. The red-green slider changes which columns are red and which are green. If it's set at 50% and if the sample space is 100 then patches up to 50 will be red and the rest will be green. If it's set at 50% and the sample space is 30 then patches up to 15 will be red. There are cases where this might be confusing: for instance, if it's set at 50% and if the sample space is 5 then patches up to 2 will be red. The '3'-column will be green because it goes further than 50% of 5.  That is, all columns up to and including the 3-column are more than 50% of the columns in the sample-space of 5 -- they are actually 60% because each of the 5 columns makes up 20% (and 5 * 20% is 100%). (See the section EXTENDING THE MODEL, below.)

These are the widgets in order of appearance from top to bottom:
SAMPLE-SPACE is a slider for setting how many columns you want to be filling up. Also, it sets the range of numbers that will be randomly selected. If you set the slider to 3 then you will have 3 columns and the values will always be either 1, 2, or 3.
SETUP - prepares the model for running with your sample-space parameter setting.
GO - runs the model with the current settings.
BIGGEST GAP - shows the biggest vertical difference between all columns. For instance, if the highest column is 10 squares high and the lowest is at 3 squares high then this monitor will show '7'.
%-RED - shows what percentage of the squares are red out of all the squares.
COLORS? - when this switch is on the patches get painted either red or green depending on the red-green slider value and their position.
RED-GREEN - sets the cut-off line for which patches are painted red and which green. When your sample-space is 100 then the position of the little handle on the slider (what you grab and move) is exactly at the cut-off line. For sample spaces other than 100 it will be under the cut-off line only when it is set at 50. This is because currently this slider works according to percentage of events and not column value.
%-FULL - the proportion of the yellow area that has been filled up by squares.

THINGS TO NOTICE
----------------
What happens to the biggest gap as the model runs. Does it change? Does it get consistently bigger? Smaller? Is this connected to the size of the sample space or not? Come up with an explanation for this. Also, if you keep running the model with the same sample space until it stops, are you getting the same biggest gap each time? Is it ""kind of the same""?


THINGS TO TRY
-------------
How does the size of the Sample-Space affect your sense of ""fairness?"" Is it more ""fair"" when the sample-space is small (narrow) or when it is big (wide)? Try changing the sample-space slider and see if you feel that the events are being equally distributed across the bar chart. You can set the red-green slider at 50%, then at other values, and, looking at the %-red monitor, evaluate how long it takes for the red-green and the %-red values to be more or less the same. Perhaps a good way to go about this is by using a sample-space of size 2. This is much like flipping a coin. Now set it to a sample-space of 6. This is kind of like rolling a die.

Actually, what is fairness? Is the difference between two columns of heights 0 and 3 the same as the difference between two columns of heights 20 and 23?

How does the passage of time -- more and more events -- affect how close the red-green slider and the %-red are?


EXTENDING THE MODEL
-------------------
Currently, the red-green slider shows you how many patches there are that are smaller than a cut-off value. But you may want to know, for instance, how often the value '1' appeared and compare it to how many times the value '2' appeared. You could just count, but you may want to compare the ratio between these accumulations and see what happens to it as the program runs.

Another idea is to keep track of how many times, on average, a certain value, for instance '1' occurs out of every 10 trials. Partitioning the events into groups of 10 is called ""sampling.""

Keep track of how long it takes, on average, to get a certain value (for instance, '1'). That's called ""waiting time"".

Even another thing to check is how often you get a ""double,"" that is, how often you get the same value back to back. How would the sample size affect that?

Build plots of your extensions to the model.

Implement a monitor that shows the smallest gap. There is currently a monitor which shows the biggest gap.

The red-green slider could work differently. For instance, instead of indexing the percentage, it could index the column number. If the red-green were set to 7 then it could index all the columns from 1 through 7.

What would happen if you added more messengers? Perhaps you could sprout them at different locations and have them execute the same code. Would this change the way the type of experimental outcomes?

Add a slider that allows you to choose specific columns and find out how many squares have accumulated in it.

Perhaps you noticed that each time you setup and run the model (each experiment) the random numbers come in a different order. But you may want to explore the same set of random numbers in several experiments where you modify some parameters. To do this, you should try working with the NetLogo primitive ""random-seed"" (see the NetLogo User Manual for details). If you keep sample-space constant, you should get the same numbers in the same order.


NETLOGO FEATURES
----------------
We use the 'random' primitive a great deal in NetLogo and especially in ProbLab, where we care about probability. But how does NetLogo produce random numbers? Does it roll a die or flip a coin? Actually, NetLogo uses the ""Mersenne Twister"" random generator. This generator is sometimes called a 'pseudo-random' number generator because it uses a certain mathematical algorithm to produce numbers that appear random, but are actually predictable given enough time to figure out the pattern.


RELATED MODELS
--------------
All of the ProbLab models use randomness. Having worked with this model, you may now have a better sense of where these random numbers are coming from and what to expect when the random primitive is used. In particular, note how other ProbLab models use randomness to control the movement of agents.


CREDITS AND REFERENCES
----------------------
This model is a part of the ProbLab curriculum. The ProbLab Curriculum is currently under development at Northwestern's Center for Connected Learning and Computer-Based Modeling. . For more information about the ProbLab Curriculum please refer to http://ccl.northwestern.edu/curriculum/ProbLab/.

To refer to this model in academic publications, please use:  Abrahamson, D. and Wilensky, U. (2004).  NetLogo Random Basic model.  http://ccl.northwestern.edu/netlogo/models/RandomBasic.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2004 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/RandomBasic for terms of use.
"
Prob Graphs Basic,/models/Sample Models/Mathematics/Probability/ProbLab,"globals [
  event
  total-attempts
  total-successes
  counter
  counter-list
  successes-per-sample-list
  attempts-this-sample
  successes-this-sample
  samples-counter ]

to setup  ;; resets everything to appropriate initial values
  ca
  set event ""-""
  set total-attempts 0
  set total-successes 0
  set counter 0
  set counter-list []
  set attempts-this-sample 0
  set successes-this-sample 0
  set samples-counter 0
  set successes-per-sample-list []
end

to go
  if samples-counter = how-many-samples? [stop]
  set total-attempts total-attempts + 1
  set counter counter + 1
  select-and-check
  tick
  update-and-plot
end

to select-and-check
  ;; This procedure simulates a chance event by randomly selecting a number between 1 and
  ;; sample-space-size, for instance between 1 and 5, as if you are rolling a die with 5
  ;; sides. Next, the procedure checks to see if this event (what you ""rolled"") happens to
  ;; be '1.' A '1' is a success. Note that 'random' reports a number between 0 and value,
  ;; so ""random 1"" is only 0, and ""random 2"" is 0 or 1. That is why we have to add 1.
  set event ( 1 + random sample-space-size )
  if  event = 1
    [
     set total-successes total-successes + 1
     set counter-list lput counter counter-list
     set counter 0
     set successes-this-sample successes-this-sample + 1
    ]
end

to update-and-plot  ;; updates values for each of the three plots
  update-and-plot-m/n
  update-and-plot-attempts
  update-and-plot-successes
end

to update-and-plot-m/n
  set-current-plot ""m/n convergence to limiting value""
  plot (total-successes / total-attempts)
end

to update-and-plot-attempts
  if length counter-list = 0 [stop]
  set-current-plot ""Attempts-until-Success Distribution""

  ;; setting the range just beyond the maximum value (e.g.,5 beyond but it could be more or less)
  ;; helps the eye pick up that the right-most value is indeed the maximum value
  set-plot-x-range 0 ( (max counter-list) + 5)
  histogram counter-list
end

to update-and-plot-successes
  set attempts-this-sample attempts-this-sample + 1
  if attempts-this-sample = sample-size
  [
    set successes-per-sample-list lput successes-this-sample successes-per-sample-list
    set-current-plot ""Successes-per-Sample Distribution""

    ;; This line adjusts the top range of the x-axis so as to stabilize and centralize
    ;; the distribution. The idea is to try and keep the emergent graph shape in the
    ;; middle of the plot. The 'ceiling' primitive keeps the maximum range value an integer.
    set-plot-x-range 0 ( max ( list plot-x-max
                                    ( 3 + ( ceiling ( 2 * mean successes-per-sample-list ) ) ) ) )
    histogram successes-per-sample-list
    set attempts-this-sample 0
    set successes-this-sample 0
    set samples-counter samples-counter + 1
  ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2004 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Abrahamson, D. and Wilensky, U. (2004). NetLogo Prob Graphs Basic model.
; http://ccl.northwestern.edu/netlogo/models/ProbGraphsBasic.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2004 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/ProbGraphsBasic
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
Prob Graphs Basic is a basic introduction to probability and statistics.

A sample space is the collection of all possible outcomes in an experiment. An example of a sample space is the numbers ""1, 2, 3, 4, 5, 6, 7.""  An event is what you get when you run an experiment. For example, if I am running an experiment that randomly selects a single number out of the sample space ""1, 2, 3, 4, 5, 6, 7,"" then an event might be ""5."" A sample is a collection of events that occur in an experiment. You could have a sample of size 1 that contains just 1 event, but you could have a sample of size 4 that contains 4 events, e.g., ""5, 3, 3, 7.""

In this model, 3 graphs monitor a single experiment as it unfolds. The experiment here is finding how often the number ""1"" shows up when you randomly select a number within a range that you define. This range could be, for example, between 1 and 2. An example of a sample space of only two values is a coin that can be either 'heads' or 'tails.' An example of a sample space of 6 values is a die that can land on the values 1 thru 6. Through observing this simple experiment through 3 different graphs, you will learn of 3 different ways of making sense of the phenomenon.

The top graph, ""m/n convergence to limiting value,"" shows how the rate settles down to the expected- or mathematical probability. For instance, the limiting value of a coin falling on ""heads"" is .5 because it happens 1/2 of the time. So, the unit of analysis is a single trial and the rate is always informed by all previous trials. To explain this further, lets think of ""batting average."" The sample space in batting is a 'hit' or a 'no hit,' which is much the same as whether a coin falls on ""heads"" or on ""tails"" (only of course batting is not random like tossing a coin or otherwise Babe Ruth's average would have been the same as anyone's). So there are exactly 2 possible outcomes. The ""batting average"" keeps track, over time, of how many ""hits"" occurred out of all attempts to hit, known as ""at bats."" So the ""batting average"" is calculated as

|                       Hits / At-Bats  =  Batting Average

For instance, using ""H"" for hit and ""N"" for no-hit, a baseball player's at-bat events may look like this, over 20 attempts:

|                       N N N H H N N N N H N H N N H H H N N H

'Hits' are called 'favored events' because when we do the statistics, what we care about, count, and calculate is all about how often 'hits' occurred out of all the at-bat events. The m/n interpretation (favored events / total events) would interpret this string of events as 8 hits / 20 at bats, .4 probability (the same as .400), or a score of 400 (out of 1000).

You may be familiar with the fact that as the baseball season progresses, it is more and more difficult for an individual player to change his ""average."" This model may help you understand or at least simulate this phenomenon. But remember that a batter, unlike a coin or a die, is not behaving randomly. But in this model the behavior will be random. We have discussed batting only to give you context for thinking about the graph. A truer context, though, would be a coin that has 2 sides.  In fact, this model can simulate not just objects with 2 sides, but with more. You know all about dice that have 6 sides, right? If you have set the size of your sample space to 5, then the model will simulate an experiment in which a die of 5 sides is rolled over and over again.

The middle graph, ""Attempts-until-Success Distribution"" counts how many trials it takes for the favored event to occur. For instance, if you're tossing a coin, it takes on average 2 tosses to get ""heads,"" and if you're rolling a die it takes on average 6 rolls to get a ""5."" This graph is tracking the exact same experiment as the top graph; only it is ""parsing"" the events differently, that is, it is using a different rule to divide up the sequence of events over time. (We will continue using ""N"" and ""H"" but you can think of the coin with 2 sides or of the die with as many sides as you want.)

|                      N N N H    H    N N N N H    N H    N N H    H    H    N N H

So the unit of analysis in this interpretation of the experiment's results is the number of events leading up to and including a hit. As you see, the number of events per unit changes. In this example the string of numbers is [4; 1; 5; 2; 3; 1; 1; 3]. Note that in this string the numeral ""1"" appears 3 times, the numeral ""2"" appears 1 time, the numeral ""3"" appears 2 times, the numeral ""4"" appears 1 time, and the numeral ""5"" appears 1 time. The histogram of this string would peak over '1' (this peak will be of height 3), then go down to '2' (frequency of 1), etc.  Perhaps this interpretation is a bit like what a batter's fans feel -- their suspense grows over failed hits until there is a hit, they are relieved and happy, and then they start counting again. So according to the context you are in -- what you're interested in finding, how you're feeling -- the world can appear different.

The bottom graph, ""Successes-per-Sample distribution,"" takes yet another perspective on the experiment, namely a sampling perspective. The sampling perspective is used in statistics. Lets analyze the same string of events from our experiment, this time chopping it up into samples of equal size, say size 5.

|                     N N N H H   N N N N H   N H N N H   H H N N H

See that in the first sample there are 2 hits, in the second sample there is 1 hit, in the third sample there are 2 hits, and in the last sample there are 3 hits. This observation could be summed up as [2; 1; 2; 3]. A histogram of this result would show a frequency of 0 (y axis) over the 0 (x axis), because all samples had at least a single 'H.' Then over the '1' there will be a column of height 1, over the '2' there will be a column of height 2, and over the '3' there will be a column of height 1.

Understanding the differences and relations between these 3 graphs will give you a strong head start in studying Probability and Statistics.

This model is a part of the ProbLab curriculum. The ProbLab Curriculum is currently under development at the CCL. For more information about the ProbLab Curriculum please refer to http://ccl.northwestern.edu/curriculum/ProbLab/.


HOW IT WORKS
------------
The model first generates a random value between 1 and sample-space-size inclusive.  The number of attempts (trials) is increased by one.  If the random value is equal to 1, then the number of successes (favored events or ""hits"") is also increased by one.  The number of attempts and the number of successes are interpreted in three different ways with each way shown in a graph as follows: (1) single attempt (trial) and single success; (2) trials (attempts) thru to each success; or (3) successes in each sample (fixed number of trials).  Each of the graphs comes to be associated with typical shapes.


HOW TO USE IT
-------------
Begin with the default settings. If you have changed them, then do the following: set the sample-space-size to 2 (so outcomes are either '1' or '2'), set the sample-size to '10' (so each sample will be a string of 10 events), and set the 'how-many-samples?' slider to 300 (so that the experiment will run a total of 300 samples of size 10 each, making a total of 3,000 trials). Press 'setup' to be sure all the variables are initialized, so that you will not have leftover values from a previous experiment). Press 'go.' Watch the 'event' monitor to see the number that the randomized procedure has reported. It will be either '1' or '2' because you have set the value to 2.

You may want to use the speed slider in the control strip at the top of the view to slow down the simulation. As you become more comfortable with understanding what you are seeing, you can speed up the simulation by moving the slider farther right.

Note how the event does not necessarily alternate between '1' and '2' according to any particular pattern.  Rather, only in the long run do you see what the constant is in the phenomenon you are observing. ""In the long run"" is precisely what this experiment shows. You can control how long this run will be by increasing or decreasing both the 'sample-size' and/or the 'how-many-samples?' slider.

Button:
'setup' -- initializes all variables. Press this button to begin a new experiment.
'go' -- begins the simulation running. You can press it again to pause the model.

Sliders:
'sample-space-size' - set the size of the sample space (in integers).
'sample-size' - set the number of trials per sample.
'how-many-samples?'- set the number of samples you wish to run in the experiment.

Monitors:
'event' -- the number that the randomized procedure has generated this trial.
'total-successes' -- total number of favored events over all trials.
'total-attempts' -- total number of trials.
'rate' -- total-successes / total-attempts.
'counter' -- shows how many trials have passed since last success (or, if you've only just set up and run the model, then it will show how many trials have passed since the model began running).
'attempts-this-sample' -- counts how many trials there have been since the last success (or, if you've only just set up and run the model, then it will show how many trials have passed since the model began running).
'successes-this-sample' -- counts how many successes there have been since the last success (or, if you've only just set up and run the model, then it will show how many trials have passed since the model began running).
'samples counter' -- counts how many samples there have been since the beginning of this experiment
'min', 'mean', 'max' -- the minimum, mean, and maximum values of the Successes-per-Sample distribution

Plots:
m/n convergence to limiting value -- cumulative rate of successes (hits or favored events) per total trials.
Attempts-until-Success Distribution -- histogram of number of trials it takes until each success.
Successes-per-Sample Distribution -- histogram of number of successes within each sample.


THINGS TO NOTICE
----------------
What are the characteristic shapes of each graph?

Look at the 'rate' monitor. What can you say about the fluctuation of numbers? What can you say about the value it settles on? What other settings in the model can you relate to this rate value?

The ""Attempts-until-Success Distribution"" never has values for 0, whereas the other plots sometimes do. Why is that?
Also, what can you say about the mean of this distribution? Does this make sense to you?


THINGS TO TRY
-------------
A sample-size of 10 that is run 300 times and a sample-size of 300 that is run 10 times both produce 3000 trials, because 10 and 300 are the factors of 3000 regardless of their order in a context. Run the experiment under both combination conditions. Did this make any difference? If so, which of the three graphs did it affect and which did it not affect? Run the experiment under other pairs of combination conditions. How different do the factors have to be to cause any difference in the graphs? How does the sample-space-size play in with all this?

By now you may have noticed the typically bell-shaped histogram of the Successes-per-Sample distribution.  Try to find settings that do not create this shape and analyze why this is the case.


EXTENDING THE MODEL
-------------------
As a beginning, try adding monitors to show values from variables you are interested in tracking. For instance, you may want to know the minimum, mean, and maximum values of the ""Attempts-until-Success Distribution."" Also, you may want to change parameters of the sliders.

Challenge: Add to the ""Attempt-until-Success"" plot a line that indicates the mean.

Challenge: Think of modification that keeps the 'random' reporter, but ""helps"" the program have more hits. Of course, this will change completely the nature of the simulation, so you can think of what you have created, and give the program a new name.


NETLOGO FEATURES
----------------
This model is unusual in that it doesn't use the view at all.  Everything that happens visually happens in the plots and monitors.


CREDITS AND REFERENCES
---------------------
This model is a part of the ProbLab curriculum. The ProbLab Curriculum is currently under development at Northwestern's Center for Connected Learning and Computer-Based Modeling. . For more information about the ProbLab Curriculum please refer to http://ccl.northwestern.edu/curriculum/ProbLab/.

To refer to this model in academic publications, please use:  Abrahamson, D. and Wilensky, U. (2004).  NetLogo Prob Graphs Basic model.  http://ccl.northwestern.edu/netlogo/models/ProbGraphsBasic.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2004 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/ProbGraphsBasic for terms of use.
"
Random Combinations and Permutations,/models/Sample Models/Mathematics/Probability/ProbLab/Unverified,"globals [
          instructions       ;; The messages that appear in the instructions monitor

     ;; Booleans to preempt run-time errors and/or user confusions
          am-I-set-up?
          combi-exists?
          abort-create-combi?

          patches-in-set-block     ;; agentset of patches where the user sets up the game
          patches-in-guess-block   ;; agentset of patches where the random guesses are generated
          num-choices
          color-list           ;; the source options of colors to choose from
          dice-list            ;; the source options of dice faces to choose from
          color-rotation       ;; the list of colors available to choose from in a particular experiment
          dice-rotation        ;; the list of dice faces available to choose from in a particular experiment

     ;; variables for keeping track of the accumulating statistical data
          count-steps                   ;; counts the number of outcomes in the current sample
          #combi-successes-per-sample-list      ;; list of outcomes per sample that were exactly like
                                                ;; the original combination
          #permis-successes-per-sample-list   ;; list of outcomes per sample that are the original
                                              ;; combination or its permutation
          samples-counter             ;; how many sample have elapsed in an experiment
          permis-choices              ;; list of choices in original combination irrespective of their original order
          permis-choices-check        ;; list of choices in a guessed combination irrespective of their original order
          permis-success?             ;; Boolean that tracks whether there has been a hit under the permutation condition
          count-combi-successes       ;; counts up hits under the combi condition
          count-permis-successes      ;; counts up hits under the permutation condition
          mean-combi-per-sample       ;; mean number of same-order outcomes per sample
          mean-permis-per-sample      ;; mean number of either-order outcomes per sample
          all-combi-match?            ;; Boolean that is true when a combination has been discovered
          all-permis-match?           ;; Boolean that is true when a permutation of a combination has been discovered

     ;; Boolean associated with the Hide/Reveal button
          hide?
        ]

patches-own
        [
          my-color    ;; color property for the experimental mode in which the combinations consist of colors
          my-shape    ;; shape property for the experimental mode in which the combinations consist of dice face.
                      ;; patches register the shape of the dice-turtles that are in the original combination
          my-guess-block-buddy  ;; each patch in the set-block has a buddy patch in the guess-block
        ]

breed [ frames frame ] ;; frames are the black perimeters of patches that help the user distinguish between
                       ;; neighboring patches of same color. The frames are constant throughout the experiment
                       ;; and are never part of the statistical analysis.
breed [ dice a-die ]         ;; dice are the dice-face turtles

to startup
    initialize
    ask patches [ set pcolor brown ]
    set instructions ""Hi! Press Setup or set new values in the 'width' and 'height' sliders and then press Setup.""
end

to initialize
  ca

  ;; building the optional colors for the color combinations
  set color-list [ green blue magenta cyan pink yellow ]

  ;; building the optional shapes for the dice combinations
  set dice-list [ ""one"" ""two"" ""three"" ""four"" ""five"" ""six"" ]

  ;; These two variables track the combination search according to the two interpretation
  ;; of what a success is (see Info tab)
  set all-combi-match? false
  set all-permis-match?  false

  ;; Variables for managing use of the model
  set combi-exists? false
  set am-I-set-up? false

  ;; List variables for selecting and searching values
  set color-rotation []
  set dice-rotation []

  ;; List variables for accumulating the experimental outcomes
  set permis-choices []
  set #combi-successes-per-sample-list []
  set #permis-successes-per-sample-list []

  set bars? true
  set abort-create-combi? false
  set num-choices #choices
  set hide? true
end

;;--------------------------------------------------------------------------------------------------------
;;--------------------------------------------------------------------------------------------------------

to setup
  set-default-shape frames ""frame""
  set am-I-set-up? false
  initialize
  create-set-block   ;; the set-block is the group of patches to be used in setting the combination
  create-guess-block ;; the set-block is the group of patches to be used in guessing the combination
  ask patches-in-set-block [ setup-frames ]
  ask patches-in-guess-block [ setup-frames ]
  set instructions (word ""OK, you have created a "" width ""-by-"" height
                         "" block with "" count patches-in-set-block
                         "" squares in it.  Now press Create Combi."")
  set am-I-set-up? true
end


;; The following procedure is perhaps more elaborate than is called for here, but it is powerful in that
;; it will work if you decide to modify the 'width' and 'height' setting to greater maximum values
to create-set-block
  let x-pos false
  let x-neg false
  let y-pos false
  let y-neg false
  ifelse ( width / 2 ) = floor ( width / 2 )
    [ set x-pos  (width / 2)          set x-neg ( - ( ( width / 2 ) - 1 ) ) ]
    [ set x-pos floor (width / 2)     set x-neg ( - ( floor ( width / 2 ) ) ) ]
  ifelse ( height / 2 ) = floor ( height / 2 )
    [ set y-pos ( height / 2 )           set y-neg ( - ( ( height / 2 ) - 1 ) ) ]
    [ set y-pos floor ( height / 2 )     set y-neg ( - ( floor ( height / 2 ) ) ) ]
  set patches-in-set-block patches with [ pxcor <= x-pos and pxcor >= x-neg and
                                          pycor <= y-pos + 1 and pycor >= y-neg + 1 ]
  ask patches-in-set-block [ set pcolor green ]
  ask patches with [ pcolor != green ] [ set pcolor brown ]
end

;; To create the guess-block of patches, each patch in the set-block assigns a value to
;; a patch 3 patches lower down.  The patch variable my-color is used in this context
;; even though it is not a color context, to save an agentset variable
to create-guess-block
  ask patches-in-set-block
  [
    set my-guess-block-buddy patch-at 0 -3
    ask my-guess-block-buddy [ set my-color ""buddy"" ]
  ]
  set patches-in-guess-block patches with [ my-color = ""buddy"" ]
end

to setup-frames  ;;patches procedure
  sprout-frames 1
  [ set color black ]
end

;; procedure for choosing the combination
to create-combi
  if not am-I-set-up? [ wait .1 alert-setup stop ]
  if not dice? [ask dice [ die ] ]
  if abort-create-combi? [ stop ]

  set instructions word ""Click on the green squares repeatedly to create your combination. ""
                        ""Then Unpress Create Combi.""
  ifelse dice? [ set-dice-rotation ] [ set-color-rotation ]
  assign-color-or-image

  ;; explaining to the user the order of actions that is suitable for running this model
  if ( dice? and ( #choices != num-choices ) ) or
     ( not dice? and ( #choices != num-choices ) )
       [
        set #choices num-choices
        set instructions word ""Sorry.  To change the '#choices' slider,""
                              "" unpress Create Combi, set the slider and press SETUP.""
        wait 5
       ]
  how-many-of-each-choice?
  set combi-exists? true
end

;; coordinating between user's clicks on the patches in the combi and shapes/colors of these patches
to assign-color-or-image
  if mouse-down?
  [
    ask patches-in-set-block with [ ( pxcor = round mouse-xcor ) and ( pycor = round mouse-ycor ) ]
    [
       ifelse dice?
        [
          ifelse not any? dice-here
          [
             make-dice
          ]
          [
            ;; see NETLOGO FEATURE in the Information tab.
            ask dice-here [ set shape item ( ( 1 + position shape dice-rotation ) mod num-choices ) dice-rotation ]
          ]
        ]
        [
         ;; see NETLOGO FEATURE in the Information tab.
         set pcolor item ( ( 1 + position pcolor color-rotation ) mod num-choices ) color-rotation
        ]
       wait 0.3  ;; this wait gives the user a chance to lift the finger after clicking
                 ;; so that the procedure doesn't go again
    ]
  ]
  ask patches-in-set-block
    [
      ifelse dice?
        [ ask dice-here [ set my-shape shape ] ]
        [ set my-color pcolor ]
    ]
  if dice?
  [
    ask patches-in-set-block
    [
      ask my-guess-block-buddy
      [
        if not any? dice-here [ make-dice ]
        ask dice-here [ ht ]
      ]
    ]
  ]
end

to make-dice
  sprout-dice 1
    [
     set color black
     set shape ""one""
    ]
end

;; Creates a new list with items from the color-list. For instance, if #choices is 3, then the
;; new list will contain the first 3 color names from the color-list
;; See also NETLOGO FEATURE in the Information tab.
to set-color-rotation
  let color-list-counter 0
  ifelse length color-rotation = num-choices [ stop ] [set color-rotation [] ]
  repeat num-choices
  [
    set color-rotation lput ( item color-list-counter color-list ) color-rotation
    set color-list-counter color-list-counter + 1
  ]
end

;; Creates list from part of the dice-list. See also NETLOGO FEATURE in the Information tab.
to set-dice-rotation
 let dice-list-counter 0
 ifelse length dice-rotation = num-choices [ stop ] [ set dice-rotation [] ]
 repeat num-choices
  [
    set dice-rotation lput ( item dice-list-counter dice-list ) dice-rotation
    set dice-list-counter dice-list-counter + 1
  ]
end

;; For the permutations condition, counts up how many times each choice appears
to how-many-of-each-choice?
  let rotation-counter 0
  set permis-choices []
  repeat num-choices
  [
    ifelse dice?
      [ set permis-choices lput count dice with
        [ ( pycor > 0 ) and (shape = item rotation-counter dice-rotation ) ] permis-choices ]
      [ set permis-choices lput count patches-in-set-block with
        [pcolor = (item rotation-counter color-rotation ) ] permis-choices ]
    set rotation-counter rotation-counter + 1
  ]
end

;; the core super-procedure for generating random combinations and searching for matches
;; with the original combination
to search-combi
  if ( dice? ) and ( sum permis-choices != count patches-in-set-block ) [ alert-forgot-choice stop ]

  ;; managing the user-code interface
  if not am-I-set-up? or not combi-exists? [ alert-setup stop ]
  set abort-create-combi? true
  set instructions word ""The program guesses combinations randomly and tracks""
                        "" the number of times it discovers your combination.""
  if dice? and count dice < width * height
    [ set instructions ""You are in dice mode.  Please first set up all your dice or change to color mode"" stop ]
  ifelse dice?
    [ set #choices length dice-rotation ]
    [ set #choices length color-rotation ]

  ;; These two Boolean variables track whether a search is successful. The point is that by default the search is
  ;; considered a success, as if the guessed combi matches the user's combi. Later, in the check procedure, if
  ;; there is a mismatch it is found out.
  set all-combi-match? true
  set all-permis-match? true
  ask patches-in-set-block [ guess ]
  ask patches-in-set-block [ check ]
  check-permis
  set count-steps count-steps + 1

  if all-combi-match?
    [ set count-combi-successes count-combi-successes + 1  ]

  if all-permis-match?
     [ set count-permis-successes count-permis-successes + 1 ]

  ;; for 'single-success?' true, we want the program to stop after a combination has been found that
  ;; matches the user's combination
  if single-success? [
    ifelse Analysis-Type = ""both"" [
      if all-combi-match? [
        congratulate-combi
        stop
      ]
      if all-permis-match? [
        congratulate-permi
        stop
      ]
    ] [
      ifelse Analysis-Type = ""combination"" [
        if all-combi-match? [
           congratulate-combi
           stop
        ]
      ] [
        if  all-permis-match? [
          congratulate-permi
          stop
        ]
      ]
    ]
  ]
  if count-steps = sample-size [ plot-sample ]
end

to congratulate-combi
  let calc-combi-help  ( length #combi-successes-per-sample-list  * sample-size ) + count-steps
  set instructions (word ""Congratulations! You discovered the hidden combination in ""
                         calc-combi-help "" steps. Set up and try again."")
  little-setup
end

to congratulate-permi
  let calc-permis-help  ( length #permis-successes-per-sample-list  * sample-size ) + count-steps
  set instructions (word ""Congratulations!  You discovered a permutation of the hidden combination in ""
                         calc-permis-help "" steps. Set up and try again."")
  wait 1
  little-setup
end

to little-setup
  set count-steps 0
  set count-combi-successes 0
  set #combi-successes-per-sample-list []
  set count-permis-successes 0
  set #permis-successes-per-sample-list []
end

;; the model guesses by trying out a combination of random values from the dice or color lists
to guess  ;; patches-in-set-block procedure
  ifelse dice?
  [
    ask my-guess-block-buddy
    [
       ask dice-here
       [
         set shape item ( random length dice-rotation ) dice-rotation
         st
       ]
    ]
  ]
  [
    let new-pcolor item ( random length color-rotation ) color-rotation
    ask my-guess-block-buddy [ set pcolor new-pcolor ]
  ]
end

;; if a non-correspondence was found between the guessed and original combi, this specific
;; search trial is registered as failed
to check  ;; patches-in-set-block procedure
  let my-color-help my-color
  let my-shape-help my-shape
  ifelse dice?
  [
    ask my-guess-block-buddy
      [ ask dice-here [ if shape != my-shape-help [ set all-combi-match? false ] ] ]
  ]
  [
     ask my-guess-block-buddy
       [ if pcolor != my-color-help [ set all-combi-match? false ] ]
  ]
end

;; For the permutation search, we have earlier made a list of how many times each choice appears
;; in the combination. Now we create the guessed-combination list, then compare these two lists.
to check-permis
  let rotation-counter 0
  set permis-choices-check []
  repeat num-choices
  [
    ifelse dice?
      [ set permis-choices-check lput count dice with
        [ ( pycor < 0 )  and ( shape = item rotation-counter dice-rotation ) ] permis-choices-check ]
      [ set permis-choices-check lput count patches-in-guess-block with
        [ pcolor =  item rotation-counter color-rotation ] permis-choices-check ]
    set rotation-counter rotation-counter + 1
  ]

  set rotation-counter 0
  ifelse permis-choices-check = permis-choices
    [ set all-permis-match? true ]
    [ set all-permis-match? false ]
end

;; toggles between hiding and revealing the patches-in-set-block
to hide/reveal
  ifelse not combi-exists? [
     user-message ""Please first create a combination."" stop
   ] [
     ifelse hide?
       [ hide-set-block ]
       [ reveal-set-block]
   ]
end

to hide-set-block
  if dice?
    [ ask patches-in-set-block [ ask dice-here [ ht ] ] ]
  ask patches-in-set-block [set pcolor gray - 2 ]
 set hide? false
end

;; procedure that re-assigns to patches-in-set-block the appearance properties of the original combination
to reveal-set-block
  ifelse dice?
    [ ask dice with [ pycor > 0 ] [ set pcolor green st ] ]
    [ ask patches-in-set-block [ set pcolor my-color ] ]
 set hide? true
end

to alert-forgot-choice
  set instructions word ""You are in Dice mode.""
                        "" Please make sure you pick dice faces for each and every one of the squares""
end

to alert-setup
   set instructions ""Please work this way: press Setup, and then Create Combi.""
end

to plot-sample
  set samples-counter samples-counter + 1
  set #combi-successes-per-sample-list fput count-combi-successes #combi-successes-per-sample-list
  set #permis-successes-per-sample-list fput count-permis-successes #permis-successes-per-sample-list
  set-current-plot ""Successes per Sample Distribution""
  ifelse Analysis-Type = ""both""
  [
    ;; this line regulates the appearance of the plot -- it centers the two histograms
    set-plot-x-range 0  max ( list ( round 1.5 * ceiling ( mean  #permis-successes-per-sample-list ) )
                                  ( 1 + max #permis-successes-per-sample-list ) .1 )
  ]
  [
    ifelse Analysis-Type = ""combination""
      [set-plot-x-range 0 max ( list ( 2 * ceiling ( mean  #combi-successes-per-sample-list ) )
                                    ( 1 + max #combi-successes-per-sample-list ) .1 ) ]
      [set-plot-x-range 0 max (list ( 2 * ceiling ( mean  #permis-successes-per-sample-list ) )
                                    ( 1 + max #permis-successes-per-sample-list ) .1 ) ]
  ]

  ;; In order to collapse two procedures into one, we use (below) the do-plot procedure.
  ;; Here, we assign values for this procedure according to the two conditions of search (combi and permis).
  if Analysis-Type != ""permutations""
    [ do-plot #combi-successes-per-sample-list ""combination"" ]
  if Analysis-Type != ""combination""
    [ do-plot #permis-successes-per-sample-list ""permutations"" ]
end

;; plotting procedure
to do-plot [ event-list current-plot-name ]
  if Analysis-Type = ""combination"" [ set-current-plot-pen ""combination"" plot-pen-reset ]
  if Analysis-Type = ""permutations""  [ set-current-plot-pen ""permutations"" plot-pen-reset ]
  set-current-plot-pen current-plot-name
  ifelse bars? [ set-plot-pen-mode 1 ] [ set-plot-pen-mode 0 ]
  histogram event-list
  set count-steps 0
  set count-permis-successes 0
  set count-combi-successes 0
end

;; procedure for running repeatedly between the #1 thru #6 monitors and updating their values.
to-report # [ index ]
  ifelse ( num-choices >= index )
    [ report item ( index - 1 ) permis-choices ]
    [ report ""N/A"" ]
end

to-report ratio
  ;; we want the ratio to be rounded after two decimal points
  let ratio-help precision ( mean #permis-successes-per-sample-list / mean #combi-successes-per-sample-list ) 2
  report word ""1 : "" ratio-help
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2004 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Abrahamson, D. and Wilensky, U. (2004). NetLogo Random Combinations and Permutations model.
; http://ccl.northwestern.edu/netlogo/models/RandomCombinationsandPermutations.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2004 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/RandomCombinationsandPermutations
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
""Random Combinations and Permutations"" is a virtual laboratory for learning about probability, and specifically about combinations and permutations, sample space, samples, favored events, and outcome distributions. The model invites you to pick a secret combination and then see how long it takes the computer to find it. The computer discovers your secret combination by just guessing blindly until it happens to guess correctly.

The user defines the size of the combinatorial sample space and then picks a particular combination from this sample space. Next, at the user's command, the model generates random combinations selected out of the sample space. The model both matches each random combination against the user's secret combination and checks whether the random combination is a permutation of the original combination. Results of these two checks accumulate and are shown both in real-time, in monitors, and at the completion of samples, in the plot (the user can choose whether to only observe one of these measures or both of them).

This model is a part of the ProbLab curriculum. The ProbLab Curriculum is currently under development at the CCL. For more information about the ProbLab Curriculum please refer to http://ccl.northwestern.edu/curriculum/ProbLab/.


PEDAGOGICAL NOTE
----------------
In this model, you will:
- Create a sample space by choosing how many objects you will be experimenting with and how many different appearances each of these can have, e.g., how many dice you will be rolling and how many different faces these dice have. For example, you can work with 3 dice that each has 4 faces. (Alternatively, you can work with colors instead of dice faces.)
- Select from this sample space a particular combination that will be the favored event out of all outcomes of the experiment. For instance, you may create the dice combination ""4, 1, 3.""
- Distinguish between combinations and permutations and understand the implications of this distinction to the interpretation of the experimental outcomes. For instance, you decide to accept as a favored event ('success' or 'hit') only the original order of you combination, ""4, 1, 3."" However, you may decide that the order is not important  and accept
- Set the size of the sample, for instance 1,000 outcomes. That is, the experiment will rapidly generate one outcome after another, and every 1,000 outcomes it will show in the plot how many of these were the favored event. So the endless stream of outcomes is parsed into linked sections of equal length
- Run a simulated experiment in empirical probability. The program will choose randomly from the sample space that you have set, creating combinations that you will see in the view. The program monitors for outcomes that are your favored event.
- Analyze distribution plots and monitors to understand relations between the sample space you created and the experimental outcomes. For instance, 3 dice each with 4 faces create a sample space of 4*4*4 = 64. Whatever your favored event was, for instance, ""4, 1, 3,"" it will occur once in every 64 rolls, on average. So if your sample was of size 1,000 rolls, it should occur every 1,000/64 = 15.625 rolls, on average.
- Understand more deeply the sample space you initially created, in order to calculate and anticipate sample outcomes. That is, why do 3 dice each with 4 faces create a sample space of 4*4*4? Why not, for instance, 3*3*3*3? Or just 3*4? 3+4?...
- Distinguish between combinations and permutations and understand the implications of this distinction to the interpretation of the experimental outcomes. You will see that whether you are looking just for the original permutations of your combination (""4, 1, 3"") or for any permutation (""4, 1, 3,"" ""4, 3, 1,"" 3, 4, 1"" etc.), the distributions of favored-events-per-sample will be different. These distributions will differ in their central-tendency indices: both in their mean and in their 'shape' (range and variance).
- Master the model by integrating all the above in understanding the ratio between the means of the two distributions


HOW TO USE IT
-------------
Buttons
SETUP -- initializes variables and assigns as objects in the experiment as many squares as you have set with the WIDTH and HEIGHT sliders.
CREATE COMBI - allows you to use the mouse to click on squares so as to select the dice/colors for your combination of choice.  Clicking repeatedly on the same square loops the die-faces / colors through an option cycle that has as many options as the value you set for the HOW-MANY-CHOICES slider.  For instance, if the slider is set to ""3"" and you are working with colors, clicking repeatedly on a single square will give the colors green, blue, pink, green, blue, pink, green, etc.
HIDE/REVEAL COMBI -- toggles between hiding and revealing the secret combination. This function is useful when you pose a riddle to a friend and you do not want them to know what your chosen combination is.
SEARCH COMBI - activates the random search. The program generates random dice-faces / colors and matches the outcome against the combination you had created.

Sliders:
#CHOICES - sets the number of dice-face / colors you wish to include in the sample space. You do not have to use for your combination as many different faces / colors as you set this slider to. For instance, you might want to set this slider to 5 but then only use two of these options.
WIDTH & HEIGHT -- sliders for setting the values of the width and height dimensions, respectively, of the combination you are creating.
SAMPLE SIZE -- sets the number of program-generated guesses per sample. At the end of each sample, the plot is updated as well as the RATIO monitor (see below)

Choices:
Analysis-Type --
- ""Permutations"" - That is, order does not matter, so '1 2 3' is considered the same as its permutation '3 2 1' (it is registered as a favored event)
-  ""Combination"" - That is, order matters, so '1 2 3' is not accepted as the same as its permutation '3 2 1' (it is not registered as a favored event)
-  ""both"" - That is, the experiment will analyze outcomes from both the 'Permutations' and 'Combination' perspectives, and each will be represented in the plot.

Switches:
SINGLE-SUCCESS? -- If ""On,"" the program will stop running after it has guessed the combination correctly once.  If ""Off,"" the program will continue running indefinitely.
DICE? - toggles between two options:
- ""On"" means you will be creating and searching dice faces
- ""Off"" means you will be creating and searching colors
BARS? -- ""On"" gives you a histogram in the plot window; ""Off"" gives you a line graph.

Monitors:
#SAMPLES -- shows how many samples have run up to this moment in the experiment
#STEPS IN THIS SAMPLES -- shows how many guesses (or ""attempts"") the program has conducted in this sample, regardless of whether or not they were successful.
COMBINATION -- shows how many successes (hit guesses) the program has performed in this sample according to the conditions that order matters
PERMUTATIONS -- shows how many successes (hit guesses) the program has performed in this sample according to the conditions that order does not matter
'#1' thru '#6' -- When you have set up your combination, these monitors will accumulate your setting according to type.  For example, if you have set DICE? to ""On"" and the #CHOICES to 4 and you have set up the five dice faces as  '4 2 3 3 2,' then
- Monitor #1 will show ""0,"" because there are no '1's in your combination, even though there could have been.
- Monitor #2 will show ""2"" because there are two '2's in your combination.
- Monitor #3 will show ""2"" because there are two '3's in your combination
- Monitor #4 will show ""1"" because there is just a single '3' in your code.
- Monitors #5 and #6 show ""N/A"" (""not available"") -- telling us that there cannot be any number here, since the '5' and the '6' dice faces were not in your pool of choices.
COMBI : PERMIS -- shows the ratio between the mean values of the sample outcome distributions corresponding to the conditions ""combination"" and ""permutation,"" respectively. This monitor updates each time a sample has been completed.

Plot
SUCCESSES PER SAMPLE DISTRIBUTION -- shows the counts of successes per sample for the conditions selected in the ANALYSIS-TYPE slider.

Follow the instructions in the ""instructions"" monitor window, which will lead you through the following process:
- set the WIDTH and HEIGHT sliders or just use the default settings that are 1 by 3
- press SETUP
- set the values of the #CHOICES slider (default is 2)
- select your choice in the ANALYSIS-TYPE choice (you can change this later, too)
- press CREATE COMBI.
- set the DICE? switch either to ""On,"" to work with dice, or ""Off"", to work with colors
- click on each green square repeatedly until you are happy with your combination
- optionally, press HIDE/REVEAL (you can always press this again to see your combination)
- if you have set the SINGLE-SUCCESS?' switch to ""On,"" then the search will stop the moment it has matched your original combination, according to your choice of ANALYSIS-TYPE
- if you have set the SINGLE-SUCCESS?' switch to ""Off,"" then the program will begin a new search and will generate random combinations on and on until you stop it. While it runs, monitors constantly update you on the progress of this process. A plot helps you track the accumulation of outcomes from the search in terms of your ANALYSIS-TYPE
- press SEARCH COMBI


THINGS TO NOTICE
----------------
As the search procedure is running, look at the monitor #STEPS IN THIS SAMPLES. See how it is updating much faster than the monitor to its left, #SAMPLES.  The number in #SAMPLES increases by 1 each time #STEPS IN THIS SAMPLES reaches the number that is set in the slider SAMPLE SIZE.

After you have setup a combination, look at the six monitors under the view. Some of them, perhaps all of them, have numbers in them. Some might have 'N/A' ('not available') in them. In any case, there are exactly as many monitors with numbers in them as the number of choices you have set up in the slider #CHOICES.

As the search procedure is running, watch the monitors COMBINATION and PERMUTATIONS. Note whether or not they are updating their values at the same pace. For most combinations that you set, PERMUTATIONS updates much faster. This is because PERMUTATIONS registers a successeach time the model hits on the set of colors / dice-faces you selected even if they appear in a different order form what you had selected.

As the search procedure is running, watch the monitor COMBI-TO-PERMI RATIO. At first, it changes rapidly, and then it changes less and less. Eventually, it seems to stabilize on some value. Why is this so?

Unless the red histogram (""permutations"") covers the black histogram (""combination"") entirely, you will see that the ""permutations"" histogram always becomes both wider and shorter than the ""combinations"" histogram. What does this mean? Why is this so? We say of the wider histogram that it has a greater ""variance"" as compared to the narrower histogram. The ""permutations"" histogram (red) typically stretches over a greater range of values as compared to the ""combination"" histogram (black).

Also, you may notice that the ""permutations"" and ""combination"" histograms cover the same area. That is because the total area of each histogram, irrespective of their location along the horizontal axis and irrespective of their shape, indicates the number of samples they represent. We know that the two histograms represent the same number of samples. Therefore, they have the same area.


THINGS TO TRY
-------------
Find a combination for which the monitors COMBINATION and PERMUTATIONS change at the same pace. What other features on the interface are unique for this combination?  For instance, is the plot behaving the same as before? How is the COMBI-TO-PERMIS RATIO monitor behaving?

For different settings, we get different distances between the two histograms. Which settings are these and how do the affect the distance??

If you work with a friend, then the friend can try to set up combinations on your computer.  You will need to guess what the combination is by looking at the information in the view as the program is running. What would make for a difficult combination? What would make for an easy combination? That is, are there some combinations that are harder to guess than others? Which are they?

Set the WIDTH slider at 2 and the HEIGHT slider at 1. Set the #CHOICES slider at 2. Create a combination with one green square and one blue square. Press SEARCH COMBI. Watch the plot and the COMBI-TO-PERMIS RATIO monitor. You will get a 1:2 ratio between the ""combinations"" and ""permutation"" distribution means. Now set the model again, changing only the #CHOICES slider to 3. Run the experiment. Once again, you will get a 1:2 ratio between the ""combinations"" and ""permutation"" distribution means. Has anything at all changed in your experimental results?

Create a combination and then try to figure out what the value of COMBI-TO-PERMIS RATIO will be before you run the experiment. For instance, what should the ratio be under the following settings:
- #CHOICES at 4
- In your combination, two of the squares are green, one is blue, and one is pink


NETLOGO FEATURES
----------------
The model uses the same ""looping"" list containing the choices of colors (or dice faces) both for building and for searching for the combination. There are 6 optional colors or dice faces. These lists are created in the ""initialize"" procedure:

|    set color-list [ green blue magenta cyan pink yellow]
|    set dice-list [""one"" ""two"" ""three"" ""four"" ""five"" ""six""]

Once the user has set how many choices are wanted, part of this list is copied onto a new list -- either the 'color-rotation' list or the 'dice-rotation' list (see the ""set- color-rotation "" and ""set-dice-rotation"" procedures, respectively). For instance, for a HOW-MAY-CHOICES? setting of 3, the model will copy 'green blue magenta.' Later, in the search-combi procedure (actually, in the 'guess' sub-procedure), the program will randomly select an item from the color-rotation or dice-rotation lists. To create shorter lists form longer lists, we use a local variable, color-list-counter, that counts up as many choices as the user has set. For every count, an additional item from the list is copied onto the new list:

|   repeat num-choices
|   [
|     set color-rotation lput (item color-list-counter color-list)
|                             color-rotation
|     set color-list-counter color-list-counter + 1
|   ]

These lists are ""rotating"" lists because in the assign-color-or-image procedure we move along the list and when we get to its end we start over from the beginning of the list, as in a loop. For instance, a patch command in the assign-color-or-image procedure is the following:

|    set pcolor item ((1 + position pcolor color-rotation) mod num-choices)
|                    color-rotation

The critical code word in the above line is ""mod."" If we have 3 colors in the color-rotation list, then ""1 + position etc."" could exceed the limit of only 3 colors and be 4. But there is no 4th color in the list. ""mod"" works like this: '5 mod 3' is 2 because 5 has 2 more than 3. But '8 mod 3' is also 2, because 8 is 2 greater than 6, which is the greatest integer multiple of 3 that is contained in 8. Try typing ""show 4 mod 3"" in the command center, then try ""show 7 mod 3"" etc.


EXTENDING THE MODEL
-------------------
Create a plot that tracks, over time, the value that is shown in the RATIO monitor.

It should be interesting to track how long it takes the model from one success to another. Add code, monitors,  and a plot to do so.

Following is an extension idea for applying this model towards thinking about search algorithms. Currently, the program guesses combinations randomly. This could be improved upon so that the program finds the combination in less guesses. For instance, the moment one of the squares has the correct color or dice face, the program would continue guessing only for the other squares. Another idea might be to create a systematic search procedure.


CREDITS AND REFERENCES
----------------------
This model is a part of the ProbLab curriculum. The ProbLab Curriculum is currently under development at Northwestern's Center for Connected Learning and Computer-Based Modeling. . For more information about the ProbLab Curriculum please refer to http://ccl.northwestern.edu/curriculum/ProbLab/.

To refer to this model in academic publications, please use:  Abrahamson, D. and Wilensky, U. (2004).  NetLogo Random Combinations and Permutations model.  http://ccl.northwestern.edu/netlogo/models/RandomCombinationsandPermutations.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2004 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/RandomCombinationsandPermutations for terms of use.
"
9-Blocks,/models/Sample Models/Mathematics/Probability/ProbLab/Unverified,"globals [results]  ;; accumulates values from repeated runs; these are histogrammed
patches-own [my-color]
breed [frames frame]  ;; frames are black frames around each patch; they help count the colored patches

to setup
  ca
  set results []
  ask patches [ set pcolor white ]
  setup-frames
end

to setup-frames ;; each individual patch in the block is framed, creating an overall effect
                 ;; of a grid that helps distinguish individual patches in the block
  set-default-shape frames ""frame""
  ask patches [
    sprout 1 [
      set breed frames
      set color black
    ]
  ]
end

to go
  ask patches [ set pcolor gray - 2 ]
  ask patches [
    set pcolor one-of [green blue]
    if one-by-one-choices? [ display wait 0.1 ]
  ]
  tick
  let result count patches with [pcolor = green]
  set results fput result results
  histogram results
  if one-by-one-choices? [ wait 0.5 ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2004 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Abrahamson, D. and Wilensky, U. (2004). NetLogo 9-Blocks model.
; http://ccl.northwestern.edu/netlogo/models/9-Blocks.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2004 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/9-Blocks
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
9-Blocks accompanies classroom work on the Combinations Tower, the giant bell-shaped histogram of all the 512 different green/blue combinations of the 3-by-3 array.  Whereas building the Combinations Tower is a form of theoretical probability -- combinatorial analysis -- the 9-Block model complements with empirical probability of the same 3-by-3 object.  In the plot window, a tall histogram grows that has the same shape as the Combinations Tower.  How can that be?  That is the theme question of this model.

To better see the resemblance between the Combinations Tower and 9-Blocks histogram, you can either open another NetLogo window in the 9-Block Stalagmite model or open a JPEG of the 9-Block Stalagmite model as it looks when the entire sample space has been found.  (This JPEG will be available with ProbLab curricular material.)  Place this JPEG alongside the 9-Blocks histogram, to its right, editing the .jpg's dimensions as necessary to maximize the resemblance between the histogram and the .jpg.

The 9-Blocks model is a simplified version of the Stochastic Patchwork model.  Here, your green/blue combinations are always of size 3 by 3.  Also, the probability of a patch being either green or blue is always .5 in this model.  Finally, the plot shows the number of green squares and not the percentage of green squares out of all the squares.

This model is a part of the ProbLab curriculum.  The ProbLab Curriculum is currently under development at the CCL.  For more information about the ProbLab Curriculum please refer to http://ccl.northwestern.edu/curriculum/ProbLab/.


HOW IT WORKS
------------
At every iteration through Go, each patch ""flips a coin"" to decide whether it should be green or blue.  This ""coin"" works as follows: The patch chooses randomly between ""0"" and ""1.""  If it got ""1,"" it becomes green on this run, but if it got ""0,"" it becomes blue on this run.  At every run through Go, the number of green patches in the block is counted up.  This number is added to a list that grows in length from run to run.  The entire list is plotted as a histogram at each run.  The columns or bars in this histogram represent how many 9-blocks have occurred with 0 green squares, 1 green square, 2 green squares, ..., 8 green squares, and 9 green squares (for a total of 10 possible columns).

Over many runs, the histogram begins to look bell-shaped, just like the Combinations Tower that you may have built in your classroom and just like the tower in the 9-Block Stalagmite model.


HOW TO USE IT
-------------
Buttons:
'Setup; - initializes the variables and erases the plot.
'Go' - activates the procedures just once.  So you will get a single 9-block and a short column in the histogram.
'Go'  - activates the procedures.  It is set to work ""forever,"" that is, it will repeat until you press it again.

Switches:
'one-by-one-choices?' - when On, each square will settle on its color at a different moment. Also, there will be a pause between 9-blocks, as though the lights were switched off for a moment. This is meant to remind us that even though we are looking at 9-blocks, actually each square chooses its color independently of other squares. Notice how the monitor '# target color' updates per each target color that is added.

Monitors:
'# target color' - shows how many patches are green.
'how many trials' - shows how many times the model has chosen random 9-blocks in this experiment (so it's also showing how many items we have in the list that is being plotted every run).


THINGS TO NOTICE
----------------
As you run this model, the histogram grows.  Pretty soon, the central columns grow taller than other columns.  This shows us that there is a higher chance of getting 9-blocks that have 4 or 5 green squares as compared to 9-blocks that have 3 or 6 green squares.  Likewise, there is a higher chance of getting 9-blocks that have 3 or 6 green squares as compared to 9-blocks that have 2 or 7 green squares.  Also, there is a higher chance of getting 9-blocks that have 2 or 7 green squares as compared to 9-blocks that have 1 or 8 green squares.  Finally, there is a higher chance of getting 9-blocks that have 1 or 8 green squares as compared to 9-blocks that have 0 or 9 green squares.


THINGS TO TRY
-------------
Compare between the histogram you are getting and the Combinations Tower.  Why is it that they are the same shape?

How many 9-blocks do you need to sample before the histogram begins to look like the Combinations Tower?


NETLOGO FEATURES
----------------
Look at the histogram as it grows.  What happens when it reaches the top?  More and more combinations are coming but there is no room to count them.  Instead of leaping out of the box, the number at the top-left corner of the plot -- the value of the y-axis -- updates and the histogram is redrawn for a larger scale. This helps us attend to whether and how the shape of the histogram changes after the number of combinations exceeds the range of values on the original histogram.


EXTENDING THE MODEL
-------------------
In many ways, the Stochastic Patchwork model extends this model.  However, there are other ways of extending this model.  For instance, you may want to plot different aspects of the probabilistic experiment, to answer such questions as:
- how often do we get the same combinations twice one after the other?
- are there particular combinations you like?  You could add code to see how long it takes the model to find these combinations (as in the Random Combinations and Permutations model).


CREDITS AND REFERENCES
----------------------
This model is a part of the ProbLab curriculum. The ProbLab Curriculum is currently under development at Northwestern's Center for Connected Learning and Computer-Based Modeling. . For more information about the ProbLab Curriculum please refer to http://ccl.northwestern.edu/curriculum/ProbLab/.

To refer to this model in academic publications, please use:  Abrahamson, D. and Wilensky, U. (2004).  NetLogo 9-Blocks model.  http://ccl.northwestern.edu/netlogo/models/9-Blocks.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2004 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/9-Blocks for terms of use.
"
ProbLab Genetics,/models/Sample Models/Mathematics/Probability/ProbLab/Unverified,"globals [ z-distr
          dom-color ;; dominant gene color
          res-color ;; recessive gene color
          dom-shape
          res-shape
          prev-x
          prev-y
        ]

breed [ output-shapes outer-shape ]
breed [ fish a-fish ]

fish-own [ age my-genes  ]

patches-own [ orig-color family ]

to setup
  ca
  set dom-color green
  set res-color blue
  set dom-shape ""fish-green-fin""
  set res-shape ""fish-blue-fin""
  ;;prepares the patch colors
  ask patches [ set pcolor red + random 3 ]
  ;; the origin is moved toward the top of the view so
  ;; the single row of patches with positive pycors
  ;; can easily be used to display genetic information
  ;; when a fish is selected in ""reveal genes"" mode
  ask patches with [ pycor > 0 ] [ set pcolor white ]
  ask patches [ set orig-color pcolor  set family [] ]
  update-graphs false
end

to add-fish [ x ]
  repeat x [ let k add-custom-fish choose-random-n-z ]
  update-graphs true
end

;;returns the who of the addition
to-report add-custom-fish [ child ]
  let who-child 0
  create-fish 1
  [
    set my-genes child
    ifelse read-from-string (item 3 my-genes) = 1 or read-from-string (item 4 my-genes) = 1
    [ set color dom-color ]
    [ set color res-color ]
    ifelse read-from-string (item 5 my-genes) = 1 or read-from-string (item 6 my-genes) = 1
    [ set shape dom-shape ]
    [ set shape res-shape ]

    setxy random-xcor
          random-float min-pycor

    ;;checks, so stays in-bounds next move
    let p patch-ahead 1
    while [ p = nobody or [pycor] of p > (max-pycor - 1)]
    [
      rt random 360
      set p patch-ahead 1
    ]
    set who-child who
  ]
  report who-child
end

to-report choose-random-n-z
  let combination []
  repeat 4
  [
    set combination lput random 2 combination
  ]
  let name """"
  set name (word name length filter [ ? = 1 ] combination ""-"")
  foreach combination [ set name word name ? ]
  report word ""f"" name
end

to go
  ask fish with [ age >= life-span ] [ die ]
  ask fish [ set age age + 1 ]
  ask patches with [ pcolor = yellow or pcolor = white ] [ set pcolor orig-color  set family [] ]

  let to-collide []
  ask patches [ set family [] ]

  ask fish [ wander-around ]

  ;;collects agents that are on the same patch
  ;;and chooses 2 of them randomly (if more than 2)
  ask patches
  [
    if (count fish-here > 1) [ set to-collide lput (n-of 2 fish-here) to-collide ]
  ]

  ;;collides the fish, 2 at a time
  foreach to-collide
  [
    ;; make sure the first parent has a lower who number than the
    ;; second parent
    collide (first sort ?) (last sort ?)
  ]
  tick
  update-graphs false
end

to collide [ parent1 parent2 ]
  if mating-rules-check parent1 parent2
  [
    ;;makes a child
    let child create-child ([patch-here] of parent1) [my-genes] of parent1 [my-genes] of parent2
    ask [patch-here] of parent1 [ set pcolor yellow ]
    let who-child add-custom-fish child

    ask [patch-here] of parent1 [ set family fput turtle who-child family ]
    ask [patch-here] of parent1 [ set family fput parent2 family ]
    ask [patch-here] of parent1 [ set family fput parent1 family ]
  ]
end

to-report mating-rules-check [ parent1 parent2 ]
  if mate-with = ""Any Fish""
    [ report true ]
  if mate-with = ""Same Body""
    [ report ([color] of parent1 = [color] of parent2) ]
  if mate-with = ""Same Fin""
    [ report ([shape] of parent1 = [shape] of parent2) ]
  if mate-with = ""Same Both""
    [ report (([color] of parent1 = [color] of parent2) and ([shape] of parent1 = [shape] of parent2)) ]
  report false
end

to-report create-child [ yellow-patch genes1 genes2 ]
  ;;makes the child
  let c-list []
  let new-genes []
  ;;top left
  let rand random 2
  set new-genes lput rand new-genes
  set c-list lput item (3 + rand) genes1 c-list
  ;;top right
  set rand random 2
  set new-genes lput rand new-genes
  set c-list lput item (3 + rand) genes2 c-list
  ;;bottom left
  set rand random 2
  set new-genes lput rand new-genes
  set c-list lput item (5 + rand) genes1 c-list
  ;;bottom right
  set rand random 2
  set new-genes lput rand new-genes
  set c-list lput item (5 + rand) genes2 c-list

  let child """"
  set child (word ""f""
                  length filter [ ? = ""1"" ] c-list
                  ""-"")
  foreach c-list [ set child word child ? ]
  ask yellow-patch [ set family new-genes ]
  report child
end

to reveal-genes
  ifelse mouse-down?
  [
    ;;checks so not looking at same patch again
    if not (prev-x = mouse-xcor and prev-y = mouse-ycor)
    [
      set prev-x mouse-xcor
      set prev-y mouse-ycor
      ;;reveals genes -- with two fish mating, if patch is yellow
      ifelse [pcolor] of patch mouse-xcor mouse-ycor = yellow
      [
        ;;hides all fish, other than the ones related to the patch
        ask fish [ set hidden? true ]
        foreach (filter [is-turtle? ? ] [family] of (patch mouse-xcor mouse-ycor)) [ ask ? [ set hidden? false ] ]
        ask patches [ set pcolor orig-color ]
        ask patch mouse-xcor mouse-ycor [ set pcolor yellow ]
        output-genetics (patch mouse-xcor mouse-ycor)
      ]
      ;;finds closest turtle if patch not yellow
      [
        let min-d -1
        let dist 3
        ask fish-on patch round mouse-xcor round mouse-ycor
        [
          if dist > distancexy mouse-xcor mouse-ycor
          [
            set dist distancexy mouse-xcor mouse-ycor
            set min-d who
          ]
        ]
        ;;reveals shape, if there is a turtle
        if min-d != -1
        [
          ask fish with [ who = min-d ]
          [
            set shape my-genes
          ]
        ]
      ]
    ]
  ]
  ;;changes state to normal
  [
    ask fish with [ hidden? = true ] [ set hidden? false ]
    if count fish with [ shape != res-shape and shape != dom-shape ] > 0
    [
      ask fish with [ read-from-string (item 5 my-genes) = 1 or read-from-string (item 6 my-genes) = 1 ]
        [ set shape dom-shape ]
      ask fish with [ not (read-from-string (item 5 my-genes) = 1 or read-from-string (item 6 my-genes) = 1) ]
        [ set shape res-shape ]
    ]
    if count output-shapes != 0 [ ask output-shapes [ die ] ]
    ask patches with [ family != [] and pcolor != yellow ] [ set pcolor yellow ]
  ]
  display
end

to output-genetics [ yellow-patch ]
  ;;genes: ""shape1"" ""shape2"" ""child"" top-left top-right bottom-left bottom-right
  let shape1  [my-genes] of item 0 [family] of yellow-patch
  let shape2  [my-genes] of item 1 [family] of yellow-patch
  let child   [my-genes] of item 2 [family] of yellow-patch
  let t-left  item 3 [family] of yellow-patch
  let t-right item 4 [family] of yellow-patch
  let b-left  item 5 [family] of yellow-patch
  let b-right item 6 [family] of yellow-patch

  ;;makes the parents and children
  create-output-shapes 1 [ set shape shape1 setxy min-pxcor max-pycor ]
  create-output-shapes 1 [ set shape shape2 setxy (min-pxcor + 1.5) (max-pycor) ]
  create-output-shapes 1 [ set shape ""arrow"" setxy (min-pxcor + 2.5) (max-pycor) set heading 90 ]
  create-output-shapes 1 [ set shape child setxy (min-pxcor + 3.5) (max-pycor) ]

  ;;makes the frames
  ;;top left
  if t-left = 0
    [ create-output-shapes 1 [ set shape ""frame-thicker"" set size .5 setxy (- 5.25) 1.25 set color orange ] ]
  if t-left = 1
    [ create-output-shapes 1 [ set shape ""frame-thicker"" set size .5 setxy (- 4.75) 1.25 set color orange ] ]
  ;;top right
  if t-right = 0
    [ create-output-shapes 1 [ set shape ""frame-thicker"" set size .5 setxy (- 3.75) 1.25 set color orange ] ]
  if t-right = 1
    [ create-output-shapes 1 [ set shape ""frame-thicker"" set size .5 setxy (- 3.25) 1.25 set color orange ] ]
  ;;bottom left
  if b-left = 0
    [ create-output-shapes 1 [ set shape ""frame-thicker"" set size .5 setxy (- 5.25) 0.75 set color 74 ] ]
  if b-left = 1
    [ create-output-shapes 1 [ set shape ""frame-thicker"" set size .5 setxy (- 4.75) 0.75 set color 74 ] ]
  ;;bottom right
  if b-right = 0
    [ create-output-shapes 1 [ set shape ""frame-thicker"" set size .5 setxy (- 3.75) 0.75 set color 74 ] ]
  if b-right = 1
    [ create-output-shapes 1 [ set shape ""frame-thicker"" set size .5 setxy (- 3.25) 0.75 set color 74 ] ]
  ;;shows the plus
  create-output-shapes 1 [ set shape ""plus""  setxy (min-pxcor + .75) (max-pycor)  set size .5 ]
end

to wander-around
  every .1
  [
    ;;moves one
    fd 1

    ;;checks so doesn't go out of bounds next move
    rt random 360
    let p patch-ahead 1
    while [ p = nobody or [pycor] of p > (max-pycor - 1)]
    [
      rt random 360
      set p patch-ahead 1
    ]
  ]
end

to update-graphs [ just-histogram? ]
  set z-distr []
  ask fish [ set z-distr lput read-from-string item 1 my-genes z-distr ]
  set-current-plot ""4-Block Distribution""
  set-current-plot-pen ""Count""
  plot-pen-reset
  histogram z-distr
  ;;plots a vertical line at mean
  set-current-plot-pen ""Average""
  plot-pen-reset
  if z-distr != []
  [
    plotxy mean z-distr plot-y-min
    plot-pen-down
    plotxy mean z-distr plot-y-max
    plot-pen-up
  ]

  if not just-histogram?
  [
    set-current-plot ""Percent Fish by Properties""
    ifelse count fish != 0
    [
      set-current-plot-pen ""G-body G-fin""
      plot 100 * count fish with [ color = green and shape = dom-shape ] / count fish
      set-current-plot-pen ""G-body B-fin""
      plot 100 * count fish with [ color = green and shape = res-shape ] / count fish
      set-current-plot-pen ""B-body G-fin""
      plot 100 * count fish with [ color = blue and shape = dom-shape ] / count fish
      set-current-plot-pen ""B-body B-fin""
      plot 100 * count fish with [ color = blue and shape = res-shape ] / count fish
    ]
    [
      set-current-plot-pen ""G-body G-fin""
      plot 0
      set-current-plot-pen ""G-body B-fin""
      plot 0
      set-current-plot-pen ""B-body G-fin""
      plot 0
      set-current-plot-pen ""B-body B-fin""
      plot 0
    ]
  ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2004 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Abrahamson, D. and Wilensky, U. (2004). NetLogo ProbLab Genetics model.
; http://ccl.northwestern.edu/netlogo/models/ProbLabGenetics.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2004 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/ProbLabGenetics
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model demonstrates some connections between probability and the natural sciences.  Specifically, the model uses combinatorial space, sampling, and distribution in a genotype/phenotype analysis of fish procreation. The model allows you to look ""under the hood"": you can study a Mendel-type visualization of the combinations of dominant and recessive genes that underlie changes and trends in genetic distribution.

Fish vary by body and fin color, each of which can be either green or blue, so there are four different phenotypes.  Underlying this variation are dominant and recessive genes, expressed in ""4-blocks.""  A 4-block is a 2-by-2 array of squares, each of which can be either green or blue.  Initially, fish are randomly distributed by 4-block genotype. Then, fish seek mates and reproduce, and the genetic distribution changes.

This model is a part of the ProbLab curriculum.  The ProbLab curriculum is currently under development at the CCL. For more information about the ProbLab curriculum please refer to http://ccl.northwestern.edu/curriculum/ProbLab/.


PEDAGOGICAL NOTE
-----------
Fishes' Mendel-type dominant/recessive genetic combinations are shown as ""4-Blocks,"" such as the following:

[B][G] = Blue in the top left corner, Green in the top right corner
[B][B] = Blue in the bottom left corner, Blue in the bottom right corner

The top row of the 4-block, e.g., ""B G,"" is the fish's genetic code for body color, and the bottom row, e.g., ""B B,"" is for fin color. Green is the dominant gene both for body and fin color, whereas blue is the recessive gene for those attributes.  Thus, a green-green top row makes for a green body color and so does green-blue and blue-green.  Only a blue-blue top row would give a blue body color.  The same applies to the bottom row, with respect to fin color.  For example, the fish with the genes in the 4-block above, has a green body and a blue fin.

When two fish mate, the offspring's each parent contributes one genetic ""square"" from each of its rows.  The selection is random.  It is therefore possible for two green-bodied fishes to beget a blue-bodied fishlet.


HOW IT WORKS
------------
When you add fish to the pool, each fish's genotype is selected randomly from the sample space of all 16 different combinations that a 4-block can take.  Fishes' phenotype is determined directly by their genotype.  Upon activating the simulation, the fish swim around randomly.  If at least two fish are on the same square (a NetLogo ""patch""), they might mate and procreate if they are matched according to the pre-set mating rules (see 'THINGS TO NOTICE').  For instance, the fish might need to have the same fin color (see 'HOW TO USE IT').

When the fish mate, the offspring's genotype, both for the body color and the fin color, is determined as a combination of the parents' genetic material (combinations of blocks from their respective 4-Blocks).  When mating is selective, certain offspring are less likely to appear, so the population distribution changes, and these changes, in turn, further impact mating chances.  The simulation enables you to witness these processes.  Interface monitors and graphs keep track of fish distribution both by genotype and phenotype.


HOW TO USE IT
-------------
Press SETUP, and then add as many fish as you'd like, in increments of 10, by pressing ADD FISH.  Change the mating rules in the MATE-WITH chooser and the LIFE-SPAN of a fish.  Then, press GO ONCE or GO to see the fish interact.  Below are more features that will let you take full advantage of the model's capabilities.

Sliders:
LIFE-SPAN -- sets the number of ""years,"" or time-steps, a fish will live.

Buttons:
SETUP -- initializes variables, re-colors the tiles, and resets the monitors and the graphs.

ADD FISH -- adds 10 fish to the display, updating the 4-BLOCK DISTRIBUTION histogram.

GO ONCE -- activates a single run through the 'go' procedure during which the fish move one step in the direction they were facing; if two fish land on the same patch and they are suited to mate according to the current settings of the mating rules, an offspring of the two fish is born and appears somewhere in the world. A patch turns yellow to indicate that two fish are mating on it.

GO -- forever button that keeps running through the 'go' procedure (GO ONCE runs through the procedure only once).

REVEAL GENES -- when the button is pressed, click on specific fish on the display to view their 4-Block Genotype. If you click on a mating fish (it's on a yellow patch), the genes of both of the parents and the child are revealed at the top of the display, and all other fish are temporarily hidden.

Monitors:
G-BODY G-FIN -- displays the number of fish with a green body and a green fin.

G-BODY B-FIN -- displays the number of fish with a green body and a blue fin.

B-BODY G-FIN -- displays the number of fish with a blue body and a green fin.

B-BODY B-FIN -- displays the number of fish with a blue body and a blue fin.

G-BODY TOTAL -- displays the number of fish with a green body (G-BODY G-FIN + G-BODY B-FIN).

B-BODY TOTAL -- displays the number of fish with a blue body (B-BODY G-FIN + B-BODY B-FIN).

TOTAL G-FIN -- displays the number of fish with a green fin (G-BODY G-FIN + B-BODY G-FIN).

TOTAL B- FIN -- displays the number of fish with a blue fin (G-BODY B-FIN + B-BODY B-FIN).

# of ITERATIONS -- displays the number of time-steps the current experiment had run.

AVE BLOCK -- gives the mean number of green squares in the genetic material (4-Blocks) of the entire fish population.

Plots:
PERCENT FISH BY PROPERTIES -- keeps track of the trends of the different sub-populations over multiple time-steps.

4-BLOCK DISTRIBUTION -- histogram of fish genotype, grouped by the number of green squares in the 4-Blocks.  The vertical red line represents the AVE BLOCK.

Choosers:
MATE-WITH -- Represents the four different mating-rule choices:
1. ""Any Fish"" -- Any fish with another fish.
2. ""Same Body"" -- Only fish with the same body color.
3. ""Same Fin"" -- Only fish with the same fin color.
4. ""Same Both"" -- Only fish with the same body and fin color (same phenotype).


THINGS TO NOTICE
----------------
Press SETUP and then press ADD FISH 10 times. Watch the group of monitors in the top-right area of the interface. What can you say about the distribution of fish by body and fin color? Why is this distribution consistent when you repeat this little activity? Why do we get this specific initial distribution?

What is the setting of the LIFE-SPAN slider that would keep the population from depleting? How, if at all, does this depend on the setting of the MATE-WITH choice button and on the initial size of the population?

If you set the MATE-WITH choice button to ""SAME BODY,"" fish will only mate with other fish that have the same body color and they do (they could differ in fin color).  How do you expect this should affect trends in the distribution of fish by phenotype, as viewed in the PERCENT FISH BY PROPERTIES plot?

In the current version of the model, at each 'go' only two fish per patch are selected randomly for a possible mating even if more than two fish are present on that patch.  In fact, two non-matching fish may be selected even there are matches on that patch.  This constraint limits the maximum reproduction rate to the number of patches in the graphic window.  Thus, the population may reach equilibrium, rather than explode. See 'EXTENDING THE MODEL' for ideas on how to make the model more realistic.

What is the total number of fish when the population reaches equilibrium, and how does this number depend on the LIFE-SPAN?

An experiment may reach a point where the number of blue-bodied fish is 0.  However, as the experiment continues, one or more blue-bodied fish may appear.  Can you explain this? Set MATE-WITH to ""Same Body"" for an example of such behavior.

Note that the PERCENT FISH BY PROPERTIES plot tracks the fish population by phenotype, while the 4-BLOCK DISTRIBUTION plot represents the fish population by genotype.

Note that for low values of LIFE-SPAN, your fish population may deplete and for higher values, the population might grow sharply but eventually arrive at equilibrium, at a point that is determined by the life span.


THINGS TO TRY
-------------
Press SETUP and then press ADD FISH 10 times.  Watch the group of monitors in the top-right area of the model.  What can you say about the distribution of fish by body and by fin color? Why is this distribution quite consistent each time you repeat this little activity?  Why do we get this specific initial distribution? What if we added a 1000 fish --would the distribution be as far off of your expectation (in terms of absolute numbers?; in proportionate terms?).

Run the model with MATE-WITH set at ""Any Fish."" After the model has been running for a while, will the population make-up stay the same, or will it change?  Do you expect any type of fish to dominate? Which one and why?  Which 4-Block will dominate?

Run GO with MATE-WITH set at ""Same Body."" After the model has been running for a while, what do you predict will happen to the fish population?

How about MATE-WITH set at ""Same Fin""? Which 4-Block would dominate now? After a while, what is the relationship between the G-G and G-B population?  Do these outcomes depend on the starting population?  If so, how so?

How do you expect the setting of MATE-WITH to affect trends in the distribution of fish by phenotype, as viewed in the ""Percent Fish by Properties"" graph?

Run GO with MATE-WITH set at ""Same Both."" What do you think will happen? Is it just a faster way of getting to the same body/same fin final result? Track the 4-Block population while doing so by slowing down the model.  Over repeated trials, you may notice that the population is quite sensitive to the random configuration of fish at the starting point?  (See 'EXTENDING THE MODEL').

Is there a connection between the mating rules and the tendency of the population to die out?


EXTENDING THE MODEL
-------------------
Change the mating procedures of the model so that instead of only two fish mating per patch, all fish on a patch get an opportunity to mate.  For example, if there are 6 fish on the same patch, a total of three pairs may reproduce.  This would make the model more realistic.

The model continuously plots four different fish populations in terms of the number in each.  You may want to track different aspects of the population, such as according to the number of green squares in each fish's 4-block.  Add a plot and edit the 'update-graphs' procedure to do so.

The current interface of the model allows the user to add exactly 10 fish at a time.  Give the user more control over the number of fish to be added.  To do so, you can add a 'user-input,' asking for the number of fish to be added, or you may want to add a slider where the user can select the number of fish to be added.  A simple way of adding an exact number of fish, x, is to type 'add-fish x' in the Command Center.

What is the connection between the original set of fish, the MATE-WITH choice, and the set of fish that the population ultimately ""settles"" on? Can you determine any rules? To do this, you would first want to create buttons that let the user add specific types of fish, for instance a blue-bodied/blue-finned fish. You could then explore the following question, for example: if the original population set has a higher presence of  B-BODY B-FIN fish, could this phenotype become dominant under any setting of MATE-WITH?


NETLOGO FEATURES
----------------
The model utilizes the mouse-clicking capabilities of NetLogo.  Note that a forever button must be running in order for the model to detect a mouse click.

Note the white band at the top of the view. The procedures ensure that no fish may enter the area of the white band. The origin is moved so that the white band has positive y-coordinates so bounds checking is easier.  The band was designed for this model as a unique form of output to the user, because we required output features that cannot be displayed in a standard output area.

There are 16 different 4-blocks, for each of which a new shape had to be created in order for the fish to be able to REVEAL GENES.  While drawing one shape is not a very arduous task in NetLogo's Shapes Editor, drawing 16 or more is. (And imagine the task of creating all 512 shapes of a ""9-block""!)  To create the blocks, we opened the NetLogo file in WordPad, in which all shapes are represented in text as circles, polygons and lines with coordinates and colors. Using this text-based version of the graphical elements greatly simplified the task of managing and generating the entire set of desired 4-Block shapes -- we simply used a straightforward combinatorial analysis expressed in simple symbols.  When we re-loaded the file in NetLogo, the entire set of 4-blocks was there just as if we had made them in the Shapes Editor.


RELATED MODELS
--------------
ProbLab Genetics, though it may not seem so at first glance, is very closely related to the 9-Block Stalagmite model of the ProbLab curriculum.  In that model, 4-blocks are chosen and then stacked in a ""histogram,"" to show the distribution of the blocks by type.  Similarly, we may track the distribution of the 4-blocks, the fishes' genotype, upon adding fish and watching the 4-BLOCK DISTRIBUTION histogram update.

In terms of interactions between breeds, several NetLogo models track the number of specimens in breeds that compete over resources. For an example, see the Wolf-Sheep Predation model.

In Expected Value Advanced, a model of the ProbLab Curriculum, the same metaphor of roaming fish is used.  As in this model, where a fish carries the value of the number of green squares in its 4-block, fish in Expected Value Advanced carry an underlying monetary value that may be collected and quantified.  Additionally, the fish's appearance is dependent on their underlying value (the larger the value, the lighter the body color).


CREDITS AND REFERENCES
----------------------
This model is a part of the ProbLab curriculum. The ProbLab Curriculum is currently under development at Northwestern's Center for Connected Learning and Computer-Based Modeling. . For more information about the ProbLab Curriculum please refer to http://ccl.northwestern.edu/curriculum/ProbLab/.

Thanks to Steve Gorodetskiy for his design and programming work.

To refer to this model in academic publications, please use:  Abrahamson, D. and Wilensky, U. (2004).  NetLogo ProbLab Genetics model.  http://ccl.northwestern.edu/netlogo/models/ProbLabGenetics.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2004 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/ProbLabGenetics for terms of use.
"
Shuffle Board,/models/Sample Models/Mathematics/Probability/ProbLab/Unverified,"globals [
  ;; the patch color that will signify a favored event.
  target-color

  ;; the patch color that will signify an unfavored event
  other-color

  ;; list of colors of all patches in the graphic window.
  pcolor-list

  ;; list of positions, in the graphic window, of all patches with the target-color
  ;; (the positions begin at the top-left corner, run across to the left, and then
  ;; hop to the beginning of the second-from-top row, and so on)
  target-color-list

  ;; list of the differences between each two consecutive patches with the target color
  ;; for instance, if the first three items in the target-color-list are 4, 9, and 11,
  ;; then the first two items in the target-color-differences-list will be 5 (9 - 4) and 2 (11 - 9)
  target-color-differences-list

  ;; cumulative list of consecutive blocks of successes of 1 or more
  target-color-successive-list

  just-started? ;; Boolean variable that indicates in Go if this is the first time through

  shape-names              ;; list of shapes of prizes
  colors                   ;; list of colors of prizes
  max-possible-codes       ;; number of shape/color combinations
  ]

;; lines are either straight ""lines"" with a circle in the center, representing a failed event
;; or ""outlines"" if they are a target event
;; prizes are the icons that appear inside the outlines
breed [ lines line ]
breed [ prizes prize ]


patches-own [
  ;; num is the a running number beginning from 0 at the top-left corner,
  ;; then running across the top row, then to the next row, etc.
  num

  next-patch ;; patch that is the ""right"" neighbor
  previous-patch ;;patch that is the ""left"" neighbor

  ;; steps-to-me shows, for a white patch, how many steps there are from the previous white patch up to it
  steps-to-me
]


to initialize
  ca
  set target-color yellow
  set other-color black
  set target-color-differences-list []
  set target-color-successive-list []
  set just-started? true
  setup-colors-and-shapes
  set-plot-range
end

to setup
  initialize
  ask patches  ;;set up
  [
    set steps-to-me 0
    sprout 1 [ set breed lines set shape ""lines"" set label-color black ]
    sprout 1 [ set breed prizes set size 0.5 set shape ""blank""]
  ]
  assign-neighbors
  distribute-prizes
  count-steps-to-colored-patches
  collect-data
  re-label
  do-plot
end

to go
  ask patches [ set steps-to-me 0 ]

  if just-started?
  [
    clear-plot
    set-plot-range
    set just-started? false
    set target-color-differences-list []
    set target-color-successive-list []
  ]

  shuffle-prizes
  tick
  count-steps-to-colored-patches
  re-label
  ask prizes [
  ifelse prize-shapes?
    [ show-turtle ]
    [ hide-turtle ]
  ]
  collect-data
  do-plot
end

to setup-colors-and-shapes
  set shape-names [""box"" ""star"" ""target"" ""cat"" ""dog""
                   ""butterfly"" ""leaf"" ""car"" ""airplane""
                   ""monster"" ""key"" ""cow skull"" ""ghost""
                   ""cactus"" ""moon"" ""heart""]
  set colors      [ gray   brown   green  sky  blue violet orange ]
  set colors lput ( gray - 2 ) colors
  set colors lput ( green - 2 ) colors
  set colors lput ( blue + 2 ) colors
  set colors lput ( red - 2 ) colors
  set colors lput ( turquoise - 1 ) colors
  set colors lput ( lime - 1 ) colors
  set colors lput ( cyan - 2 ) colors
  set colors lput ( magenta - 1 ) colors
end

;; assign patches ""next"" and ""previous"" patches
;; patches essentially form a circular doubly linked list
to assign-neighbors
  let i 0
  ask patches
    [ set num i
      set i i + 1

      ;;if we are at the edge, wrap around to determine the NEXT neighbor
      ifelse pxcor = max-pxcor
      [
        ifelse pycor = min-pycor
          ;;if we are in the lower right corner, next neighbor is upper left
          [ set next-patch patch min-pxcor max-pycor ]
          ;;if we are all the way to the right, the next neighbor is one row below, on right
          [ set next-patch patch min-pxcor ( pycor - 1 ) ]
      ]
      [ set next-patch patch-at 1 0 ]

      ;;if we are at the edge, wrap around to determine the PREVIOUS neighbor
      ifelse pxcor = min-pxcor
      [
        ifelse pycor = ( max-pycor )
          ;;if we are in the upper left corner, previous neighbor is lower right
          [ set previous-patch patch ( max-pxcor ) min-pycor ]
          ;;if we are in the upper left corner, previous neighbor is lower right
          [ set previous-patch patch ( max-pxcor ) ( pycor + 1 ) ]
      ]
        [ set previous-patch patch-at -1 0 ]
    ]
end

;; creates a uniform distribution of prizes patches according to the setting of 'average-distance'
to distribute-prizes
  ask patches with [ num mod average-distance = 0 ] [
      ask one-of lines-here [ set shape ""outline"" ]
      ask one-of prizes-here [
         set shape one-of shape-names set color one-of colors
         if (not prize-shapes?)
            [hide-turtle]
     ]
      set pcolor target-color
    ]
end


;; each target-colored patch swaps its prize's shape and color with a randomly chosen
;; other-colored patch. the target-colored cell is then replaced with a line shape and other-color.
to shuffle-prizes
  ask patches with [pcolor = target-color]
  [
    let prize1 one-of prizes-here
    ask one-of patches with [pcolor = other-color]
    [
      set pcolor target-color
      ask one-of lines-here [ set shape ""outline"" ]
      ask one-of prizes-here [ set color [color] of prize1
                               set shape [shape] of prize1 ]
    ]
    set pcolor other-color
    ask one-of lines-here [ set shape ""lines"" ]
    ask one-of prizes-here [ set shape ""blank"" ]
  ]
end

;; gathers histogram information
to collect-data
  set target-color-differences-list
    sentence ( [ steps-to-me ] of patches with [ steps-to-me > 0 ] ) target-color-differences-list
  set target-color-successive-list
    sentence ( [ consecutive-targets 0 ] of patches with [ pcolor = target-color and patch-at -1 0 != target-color ]
    ) target-color-successive-list
end

to count-steps-to-colored-patches
  ask patches with [ pcolor = target-color ] [ set steps-to-me step-count 0 ]
end


;; patch procedure
;; counts the number of previous patches that aren't the target-color
to-report step-count [previous-count]
   ifelse [pcolor] of previous-patch != target-color
     [ report [ 1 + step-count previous-count ] of previous-patch ]
     [ report 1 ]
end

;; patch procedure
;; counts the number of consecutive patches with prizes
to-report consecutive-targets [num-previous-targets]
   ifelse [pcolor] of next-patch = target-color
     [ report [ 1 + consecutive-targets num-previous-targets ] of next-patch ]
     [ report 1 ]
end

;; procedures for determining the mean ratio between consecutive columns in a histogram list
;; The logic is to create one list of all the columns heights and from that list create
;; a copy of it with the first item missing. Then we can 'map' one list onto the other
;; so that each item in one list divides an item in the other list that is in the corresponding position.
;; Also, we don't want columns that have zero items in them, because we cannot divide by zero.
;; Finally, we don't use more columns than is indicated by the value of the 'truncate-columns' slider.
to-report relative-heights [ listerama ]
  if listerama = []
    [ report ""N/A"" ]
  let binned-list but-first bin-list listerama
  let stop-bin min (list (position 0 binned-list) (position 1 binned-list) truncate-after-column)
  if stop-bin = 0  ;; if the smallest bin is 0, we cannot calculate relative-heights
    [ report ""N/A"" ]
  let list-of-divisors first-n stop-bin binned-list
  let list-of-dividends list-of-divisors
  set list-of-divisors but-last list-of-divisors
  set list-of-dividends but-first list-of-dividends
  if empty? list-of-divisors  ;; if there are no divisors (or similarly, dividends)
    [ report ""N/A"" ]            ;; it is not possible to calculate relative-heights
  report mean ( map [ ?1 / ?2 ] list-of-dividends list-of-divisors )
end

to-report first-n [index full-list]
  ifelse (index > 0 and not empty? full-list)
    [ report sentence ( first full-list ) ( first-n ( index - 1 ) ( butfirst full-list ) ) ]
    [ report [] ]
end

to-report bin-list [input-list]
  if input-list = [] [ report [] ]
  let result []
  let bin 0
  foreach n-values ( max input-list + 1 ) [?] [
    set bin ?
    set result lput ( length filter [ ? = bin ] input-list ) result
  ]
  report result
end

;; after a shuffle, the number labels are updated
to re-label
  ask lines [
    ifelse label? [
      if steps-to-me > 0 [
        set color black
        set label steps-to-me
      ]
    ]
    [ set label """" ]
  ]
end

;; code for plotting outcomes as histograms
to set-plot-range
  set-current-plot ""Frequency of Distances to Prizes""
  set-plot-x-range 1 ( 5 * average-distance )
  set-current-plot ""Frequency of Streaks by Length""
  ;; the following line uses a ""magic number"". The code used to be ""15 - average-distance""
  ;; but that crashes when a user resets the average-distance slider to a higher maximum.
  set-plot-x-range 1 ( average-distance + round ( 20 / average-distance ) )
end

to do-plot
  set-current-plot ""Frequency of Distances to Prizes""
  histogram target-color-differences-list

  set-current-plot ""Frequency of Streaks by Length""
  histogram target-color-successive-list
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2004 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Abrahamson, D. and Wilensky, U. (2004). NetLogo Shuffle Board model.
; http://ccl.northwestern.edu/netlogo/models/ShuffleBoard.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2004 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/ShuffleBoard
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
Shuffle Board investigates distributions of favored events in a series of outcomes.  The basic analogy is that there are a lot of candy boxes, but only some have prizes in them.  You are buying one candy box after another, waiting for prizes, and keeping track of two things: how many boxes do you need to buy until you get a prize? When you had lucky streaks, how long were they?

A possibly counter-intuitive result in this simulation is that the shorter the ""waiting time,"" the more frequently it occurs.  Another result is that the shorter the ""lucky streak,"" the more frequently it occurs.

Shuffle Board explores the relation between the length of the ""waiting time"" and its frequency, and between the length of a lucky streak and its frequency.  This exploration is designed to help learners understand the mathematical functions associated with these distributions.

This model is a part of the ProbLab curriculum. The ProbLab curriculum is currently under development at the CCL. For more information about the ProbLab curriculum please refer to http://ccl.northwestern.edu/curriculum/ProbLab/.


HOW IT WORKS
------------
The basic analogy underlying Shuffle Board is that there are a lot of candy boxes, but only some of them have prizes in them (like a blue teddy bear). You know how long it should take you, on average, to get a prize, because this information is announced by the candy manufacturer. You are buying one candy box after another and keeping track of two things:
- How many boxes did you need to buy since last prize until you got the next prize?
- When you had lucky streaks, how long were they?

Both are plotted automatically in the ""Frequency of Distances to Prizes"" and ""Frequency of Streaks by Length"" graphs.

The view features yellow lines that are broken by blue dots (candy boxes without prizes) and colored squares (candy boxes with prizes). Each blue dot or colored square is an ""outcome"". So think of a very long string with 121 outcomes that has been chopped up into 11 shorter strings, each with 11 outcomes, so as to fit into the View. The string runs from the top left spot on the board (the first outcome) towards the right. When it gets to the end of the top row, it skips to the left-most spot on the second row from top, and so on. When it gets to the bottom-right corner, it counts on to the top left corner, as though the string is closed in a necklace.

When you first open the model and whenever you press Setup, prizes are distributed uniformly across the View according to the settings of the slider 'average-distance'. For instance, if this slider is set to '5', then literally every 5th outcome will be a prize. Next, the prizes shuffle randomly to new locations on the board, so this initial uniform distribution is upset.

Why do we shuffle?  We are exploring for hidden distribution patterns. Sometimes it takes a lot of data to find hidden patterns.  If we had space in the view for thousands of boxes, we would have enough data to find any patterns that might be there. But there is not enough room in the view to make the boxes big enough so you can see the prizes.  So, instead, we shuffle.  It is as though each time we get another bit out of a larger population -- it is as though each shuffle gives us a new sample.  After each shuffle, you can track individual prizes as they move from one location to another.

Note that the string of outcomes is forms a loop. So if at the tail end of the string -- towards the bottom-right corner -- there are 4 boxes without prizes, these will count towards the first prize in the top row.


HOW TO USE IT
-------------
Sliders:
AVERAGE-DISTANCE -- If set at, say, 5, then every 5th square will bear a prize, when you press Setup.
TRUNCATE-AFTER-COLUMN -- determines how many of the ""Distances to Prizes"" histogram columns, beginning from left, will be included in the calculation of the mean ratio between consecutive columns. For instance, if this slider is set at ""4"", then the program will calculate the quotients of Column 2 divided by Column 1, Column 3 divided by Column 2, and Column 4 divided by Column 3. Next, the program will determine the mean of these three quotients and report them in the ""Columns-Factor"" monitor.

Switches:
PRIZE-SHAPES? -- if set to 'On', you will see what prize is waiting for you in each candy box. When set to 'Off', you will know that there is a prize in the box, but you will not know what it is.
LABELS? -- if set to 'On', each prize box will show how many boxes had to be bought since the previous box so as to get this prize.

Buttons:
SETUP -- initializes variables, creates a collection of prizes in accordance with the value of 'average-distance', and represents the distances to prizes and the lucky streaks in their respective plots.
GO ONCE -- Runs the program through a single 'Go' procedure, in which prizes are shuffled and their distances and streaks are calculated and plotted.
GO -- Runs the program over and over.

Monitors:
Columns Factor -- the height of each column in the histogram is divided by the height of the column immediately to its left. The monitor shows the mean of all these quotients. The total number of columns included in this calculation is determined by the slider 'truncate-after-column'.

Plots:
FREQUENCY OF DISTANCES TO PRIZES -- shows the accumulating distribution of distances between prizes in repeated samples.
FREQUENCY OF STREAKS BY LENGTH -- shows the accumulating distribution of streaks of consecutive successes
Note that after you press Setup, when you first click on 'Go' or 'Go Once', the plots initialize, but later they accumulate information from previous runs.

Set the 'average-distance' slider and press 'Setup'. Now press 'Go Once' and watch the histograms appear in the plots. If you press 'Go', the program will run indefinitely, until you press 'Go' again.



THINGS TO NOTICE
----------------
When you press 'Go Once' the prizes rearrange on the board. Choose your favorite prize and track it. This way, you'll be sure that no prizes vanish!

After a single shuffle, what is the most common distance between every two consecutive prizes? You can see this in the View -- the number labels show these distances, and so you can count up how many ""1""s you see, and how many ""2""s, ""3""s, etc. Also, look at the plot to see which bar is the highest. Keep looking at the plot over more runs. See the typical graph shape that forms.

As the program runs over and over, the value in the Column Factor monitor gradually converges.


THINGS TO TRY
-------------
When you press Setup, you get a uniform distribution of prizes. After you shuffle the prizes, the distribution is not uniform. But what is the average distance between prizes now? In the Command Center, type

|    show precision mean target-color-differences-list 2

Now press Enter. This code calculates for you the mean distance between each two consecutive white patches. Can you explain the value you received?

Watch the value in the 'Column Factor' monitor. Can you find a relation between these relative heights and the 'average-distance' setting?

Play with the 'truncate-columns' slider. What does including more columns do as compared to including fewer columns? What, if any, is the relation of these actions to the value in the 'Columns Factor' monitor?

What is the relation between the value of average-distance and the curves you get in the plot 'Frequency of Streaks by Length'? Does this make sense to you?

Here is an experiment you can try without NetLogo that might shed more light on the model:
Set up a deck of cards that has 13 face cards and 39 number cards. That is a 1:3 ratio of faces to numbers. One fourth of the cards are faces. Thus, the probability that any random card drawn from this deck is a face is 1 out of 4 -- that is, a 25% chance. Now distribute the face cards uniformly in the deck so that literally every fourth card is a face. Next, shuffle the cards thoroughly. Still, every fourth card on average will be a face. But what is hiding behind this sense of ""average"" in ""every fourth card on average is a face""? Count up to each face card and create a histogram of the frequencies of each number of attempts until success. What have you learned? Can you explain this? Note that two decks put together with the same ""number:face"" ratio (for a total of 26:78) will bring quicker results.

Shuffle Board is a NetLogo analogy to shuffling a deck of cards and then going through the cards one by one and counting how long it takes to find each face.  To be precise, the shuffling procedure in this model is less rule governed than standard shuffling of cards (see for example http://www.sciencenews.org/articles/20001014/mathtrek.asp).


EXTENDING THE MODEL
-------------------
Add a plot to show how the Columns Factor value changes over time.

Add pens to the plots to represent the averages of the outcomes.

Add a switch that flips the orientation of the shuffle board so that distances to prizes are counted vertically instead of horizontally.

Choose a specific location on the View (one of the ""patches"") and monitor how often that location gets a prize over repeated shuffles. Design an experiment to determine any possible relationships between the frequency of getting a prize in that location and the setting of the 'average-distance' slider.


RELATED MODELS
--------------
The model is closely related to Prob Graphs Basic, and especially to the middle graph in that model. That middle graph looks at distances or 'attempt-until-success' (""waiting time"") between consecutive ""hits"" that are determined randomly according to a sample-space setting. Shuffle Board shows the same idea, but it does so using a more visible analogy that allows you to scan for yourself the distances between all of the favored events. This helps us understand that the shorter distances are more ubiquitous as compared to the longer distances. In particular, we see that the distance ""1"" is relatively dominant.


CREDITS AND REFERENCES
----------------------
This model is a part of the ProbLab curriculum. The ProbLab Curriculum is currently under development at Northwestern's Center for Connected Learning and Computer-Based Modeling. . For more information about the ProbLab Curriculum please refer to http://ccl.northwestern.edu/curriculum/ProbLab/.

Thanks to Ethan Bakshy for his extensive work on this model.

To refer to this model in academic publications, please use:  Abrahamson, D. and Wilensky, U. (2004).  NetLogo Shuffle Board model.  http://ccl.northwestern.edu/netlogo/models/ShuffleBoard.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2004 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/ShuffleBoard for terms of use.
"
Partition Perms Distrib,/models/Sample Models/Mathematics/Probability/ProbLab/Unverified,"globals [
  ;; the-short-list is a list of the addends for the current total
  ;; it is used to display the addends in the command center, and it is initialized for each new search
  ;; also, the ""sum the-short-list"" gives us the running total and is used to check if we're at the target yet
  the-short-list

  ;; used to display in a monitor the previous list of addends
  previous-short-list

  ;; the-long-list is a list of all the-short-lists, and it is used for the histogram
  the-long-list

  ;; addend is the number randomly generated by the model at each trial. Note that in this version of the model,
  ;; addends are drawn randomly from a sample space of addends that can still fit into the target total,
  ;; given the running total. So if the target-total slider is set to 20, and the running total is at 16,
  ;; then the addends are drawn randomly from a sample space between 1 and 4.
  ;; Thus, the active sample space decreases as the running total grows.
  addend

  ;; successes-so-far counts up how many times the-short-list has summed up to the total since last setup
  ;; it should be periodically equal to the quotient of ""sum the-long-list / target-total""
  successes-so-far

  ;; counter of how many addends each series is taking
  #addends-so-far-in-this-series

  ;; list of how many addends it took to complete each total
  partition-series-list
  ]

to startup
  setup
end

to setup
  ca
  ;; during setup, both the-short-list and the-long-list are initialized,
  ;; but during the run, the-short-list keeps initializing at each success, whereas the-long-list does not
  set the-long-list []
  set the-short-list []
  set partition-series-list []
  set-current-plot ""Addends""
  set-plot-x-range 1 ( target-total + 1 )
end

to go
  if ( successes-so-far >= num-successes ) [ stop ]
  random-guess-and-update-total
  tick
  update-plot
  finish-up
end

to random-guess-and-update-total
  let running-total sum the-short-list

  let temp-sample-space 0
  ifelse diminishing-sample-space?
  [
    ;; we draw a random number from the space remaining between the running total and the target-total
    set temp-sample-space ( target-total - running-total )
  ]
  [
    ;; we draw a random number from the entire target-total
    set temp-sample-space target-total
  ]


  ;; we add 1 because random x reports numbers between 0 and (x-1)
  set addend ( 1 + random temp-sample-space )

  ;; if the addend is small enough not to exceed the target-total, we keep it in the-short-list, and paint it in
  if sum the-short-list + addend <= target-total [
    set the-short-list lput addend the-short-list
    paint
  ]
  set #addends-so-far-in-this-series #addends-so-far-in-this-series + 1
  set the-long-list lput addend the-long-list
end

;;; make a histogram of all the addends in the-long-list at the right times
to update-plot
  set-current-plot ""Addends""
  histogram the-long-list
end

to paint
  let pxcor-of-right-most-colored-patch 0
  ifelse length the-short-list = 1
    ;; we want to create a ribbon of addends, each addend with a different color
    [set pxcor-of-right-most-colored-patch ( -1 * max-pxcor - 1 ) ]
    [set pxcor-of-right-most-colored-patch ( max [ pxcor ] of patches with [ pcolor != black ] )]

  ;; temp-color will be any of 14 colors from the NetLogo color space
  let temp-color ( 10 * random 14 ) + 5

  ;; we color only the patches that reflect the latest addend
  ask patches with
    [ ( pxcor > pxcor-of-right-most-colored-patch ) and ( pxcor <= ( pxcor-of-right-most-colored-patch + addend ) ) ]
      [ set pcolor temp-color ]
end

to finish-up
  if sum the-short-list = target-total
  [
    set partition-series-list lput #addends-so-far-in-this-series partition-series-list
    set-current-plot""#Addends Per Total""
    set-plot-x-range 1 ( 1 + max partition-series-list )
    histogram partition-series-list
    set #addends-so-far-in-this-series 0
    set previous-short-list the-short-list
    set the-short-list []
    set addend ""-""
    set successes-so-far successes-so-far + 1
    if wait-at-full? [ wait .5 ]
    cp ct
  ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2004 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Abrahamson, D. and Wilensky, U. (2004). NetLogo Partition Perms Distrib model.
; http://ccl.northwestern.edu/netlogo/models/PartitionPermsDistrib.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2004 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/PartitionPermsDistrib
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
Partition Permutation Distribution is a model built around the idea of a partition function. This function relates between an integer, e.g., 4, and the number of different ways you can break this integer up into groups of integers, where order does not matter. For instance, 4 can be broken up in 5 ways:

(1) 4;
(2) 3 + 1;
(3) 2 + 2;
(4) 2 + 1 + 1; and
(5) 1 + 1 + 1 + 1.

Notice that in the above example, the number '1' appeared more often than the number '4.' Why is that? To address this question, this model allows you to repeatedly find partitions of a number and look at the distribution of integers in the partitions.

This model is a part of the ProbLab curriculum. The ProbLab Curriculum is currently under development at the CCL. For more information about the ProbLab Curriculum please refer to http://ccl.northwestern.edu/curriculum/ProbLab/.


HOW IT WORKS
------------
In this model, you choose a target-total, for instance 20, and the code randomly generates addends of the total and adds them to the running-total. These addends are represented in the view, too, as colorful lines that each are as long as the addend it represents. For instance, an addend of 13 will be 13 ""patches"" long (""patches"" are the NetLogo square areas that make up the grid of the view). When the running-total reaches the total, there's been a 'success.' Unlike the actual partition function, this model will not return a value. Moreover, in this model, there is no explicit attempt to exhaust all the partitions. Instead, the randomized procedure keeps adding up the totals randomly. Over many such brute-force addings, a graph shape emerges, and the same shape emerges both for constant totals over many runs and for different totals. The question is why this shape emerges and what this shape means in terms of partitions. So this model uses partitions as an engaging riddle to explore the idea of distribution.

Note:
The shape of the graph does not correspond to a simple distribution of all possible permutations, nor to a simple scaling up of such a distribution, such as we would expect the model to create through repetition of previously created partitions. That is, it is not the case that the model chooses randomly from the set of all possible partition permutations of some total. There are two conditions for running this model, depending on the setting of the slider 'diminishing-sample-space?' The following comment refers to the case that the switch is set to 'On.'

The model chooses a first addend out of a space of the whole total, a second addend out of the space of the remainder of the total, and so on. So, the greater addends are ""over represented."" For instance, for a total of '5,' there is only a single partition with a single addend - the partition ""[5]"" that includes only '5' as an addend, whereas there are numerous partitions that do not include '5.' So you might expect that '5' would occur very rarely as compared to, say, '1.' However, due to the rationale of the model, '5' actually occurs much more often. Involved here are some subtleties and possible confusions as to what we mean by 'often' -- what our unit of analysis is: Are we counting per addend or per total? Each time a total has been obtained and the model begins creating a new total, there is a 1-out-of-5 chance that the first addend will be '5.' Another way to think of this is that you might expect the partition [5] to occur as often as the partition [1 1 1 1 1], but actually the partition [1 1 1 1 1] occurs 1/ 3125 as often as the partition [5], because we have to get a '1' AND a '1' AND a '1' AND a '1' AND a '1,' whereas for [5], all we have to get is a '5.' Understanding these subtleties may help you develop a more nuanced understanding of statistics experiments.


HOW TO USE IT
-------------
When you open the model, numerical and Boolean values will already be set for an easy start, as following:
To begin, you can slow down the model with the 'adjust-speed' slider that is on the top-left corner of the view. TARGET-TOTAL is set at 20. Press GO and watch the RUNNING-TOTAL and ADDEND monitors. The addend will be a random number between 1 and 20. Immediately, this addend, say 7, will move over to the running-total, and now there will be a new addend. This new addend will be a random value between 1 and 13 (because the default setting of the switch 'DIMINISHING-SAMPLE-SPACE?' is set so that addends are chosen from the difference remaining up to the total). Say the second addend is 2. So now the running-total becomes 9. The third addend could be 5, so we'd get 14, and so on. Let us say that this run gave us the addends 7 + 2 + 5 + 1 + 4 for a total of 20.  The histogram grows one notch up for each of these addends.

Switches:
WAIT-AT-FULL? If it is set to 'On,' the experiment will wait briefly each time the target-total has been achieved.
DIMINISHING-SAMPLE-SPACE? -- if 'On,' addends will be selected from a sample space that is the size of the remaining difference to the target-total. For example, if the running total of the current adding-up is at 16 and our target-total is 20, then the next addend will be selected from the range 1-thru-4. However, if the switch is set to 'Off,' then the range will always be the target-total, 20.

Sliders:
TARGET-TOTAL -- sets the total towards which the program will be adding up the randomly generated values
NUM-SUCCESSES -- sets how many times the program will sum up to the target-total you have set

Monitors:
RUNNING-TOTAL -- shows how far towards the target-total the adding has gone
ADDEND -- shows the current value that has just been generated and added to the running-total
SUCCESSES-SO-FAR -- shows how many times the total has been reached. Once this is equal to the NUM-SUCCESSES slider value, the program stops.
MEAN #ADDENDS PER TOTAL -- shows how many acceptable addends it took, on average, to fill the target-total that you set, over all the trials
PREVIOUS LIST OF INCLUDED ADDENDS -- shows the last completed series of addends up to the target total

Buttons:
SETUP -- initialize variables
GO -- run the model under your chosen settings. It will run through as many 'num-successes' as you have set.
ADD-ONCE -- A single addend is added to the running-total and the histogram is updated. Use this to run the program step by step.

Plots:
ADDENDS -- plots the addends as they are randomly selected
#ADDENDS PER TOTAL -- plots the number of addends it takes to complete each target-total


THINGS TO NOTICE
----------------
When 'diminishing-sample-space?' is set to 'Off,' the addends get smaller as you get closer to the total.

The histogram columns get smaller as you move from left to right.

When 'diminishing-sample-space?' is set to 'Off,' the 'mean addends per total' value converges to the value of 'target-total.' Why is this so? Also, the 'Addends Per Total' distribution slopes down to the right. What can you say of that?

When 'diminishing-sample-space?' is set to 'On,' the 'mean addends per total' value converges to some value. Can you say anything about this value in relation to other settings in the model? Also, the 'Addends Per Total' distribution is normal. Why is that?


THINGS TO TRY
-------------
Set the target-total to .5. Run the model over many num-successes, 'diminishing-sample-space?' set to 'On,' and with a high target-total.
The 2-column will be 1/2 the height of the 1-column.
The 3-column will be 1/3 the height of the 1-column.
The 4-column will be 1/4 the height of the 1-column.
The 5-column will be 1/5 the height of the 1-column.
etc. So we get a '1/n' function. Why is this? Does is work for other target-total values?

Another way to express this relation between the columns is as follows. Say we look at Column 'i.' The relation between the height of Column i and the column immediately to its left (Column 'i - 1') is      (i - 1) / i . For instance, the relation between the heights of Column 9 and Column 8 is that Column 9 is 8/9 as tall as Column 8.

Set target-total to 2 and 'diminishing-sample-space?' to 'On.' Set 'num-successes' to 10,000 and run the model until it stops. Compare the value of 'Successes So Far' to the y-value of the 1-Column in the ""Addends"" plot. You will see that these values are very similar. So over many runs, we expect that the '1' will occur as many times as we have had runs. (See ProbLab model 'Expected Value' for an explanation of how to make predictions of expected values.) This is true for other target-totals -- we chose 2 so as to make this work fast.

Now look at the 'mean #addends per total' you received. It should be very near to 1.5.  This is related to our finding, above, that the 2-Column is 1/2 (.5) as tall as the 1-Column and to our expectation to get as many '1's as we have had successes. These ideas combined suggest that we should get .5 as many '2's as we have had successes. So the 1-Column and the 2-Column together are 1.5 as large as the number of successes. This means that there are about 1.5 addends in each total. For the case of a target-total of '3,' we'd need to add '1 + 1/2 + 1/3.' So we'd expect a mean of 1.833 addends per toal. Try this, too!


EXTENDING THE MODEL
-------------------
Add a monitor that shows the minimum, average, and maximum number of partitions in every run (the number of items is the length of the-short-list).
Add plots for these values.
What shape do you expect this distribution to have?
Will the values change per target-total?

Note that currently we are using this logic:
|     set addend ( 1 + random temp-sample-space )

This means that the model chooses addends with an eye to how much space is left up to the total (temp-sample-space is the difference between the running total and the target total).  If we removed this, and only asked for ""random total"", how would the model change, if at all? How would the above extensions change, if at all?


NETLOGO FEATURES
----------------
Note that in the above line of code, we set the addend to ""1 +...etc."" This is due to the nature of the 'random' reporter.  The command 'random 3' returns numbers between 0 and 2, and will never return the number 3. So by adding 1, we get the values we actually want. You will come across this often in NetLogo, such as when working with lists. For example, if we had a list named ""friends"" [""pat"" ""bob"" ""joe"" ""kate""], the 3th value, 'joe,' is called ""item 2 friends.""


PEDAGOGICAL NOTE
----------------
This model is related to other models in the ProbLab suite. Like other models, it looks at the evolution of a distribution that reflects procedures that have random elements. However, unlike other models, the distribution here is never bell-shaped. The greatest learning gain expected to come from working with this model is in comparing it to other models in ProbLab. This comparison should in particular revolve around an articulation, possibly in general terms, of what precisely about this model makes a bell-shaped distribution unlikely.

This model is related in an interesting way to 9-Block Stalagmite. In that model, the distribution of permutations reflects the sample space of all possible permutations. But in this model, the distribution does not reflect the sample space directly (see introduction, above).

Also, the model is related to the Attempts-Until-Success histogram in Prob Graph Basic and to the Distances to Whites histogram in Shuffle Board. Actually, those two histograms behave similar, whereas the histogram in this model behaves differently. Understanding this difference may sensitize you to ""graph families."" Just because all these graphs decrease monotonously, it does not necessarily mean that they describe the same or related functions.


CREDITS AND REFERENCES
----------------------
This model is a part of the ProbLab curriculum. The ProbLab Curriculum is currently under development at Northwestern's Center for Connected Learning and Computer-Based Modeling. . For more information about the ProbLab Curriculum please refer to http://ccl.northwestern.edu/curriculum/ProbLab/.

To refer to this model in academic publications, please use:  Abrahamson, D. and Wilensky, U. (2004).  NetLogo Partition Perms Distrib model.  http://ccl.northwestern.edu/netlogo/models/PartitionPermsDistrib.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2004 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/PartitionPermsDistrib for terms of use.
"
9-Block Stalagmite,/models/Sample Models/Mathematics/Probability/ProbLab/Unverified,"globals [
         ;; colors of the background of the view and of the two possible colors in samples
         background-color column-color target-color other-color
         num-columns ;; how many columns there are in the graphics-window histogram
         num-target-color  ;; how many of the squares (patches) in the sample are of the favored color
         sample-right-xcor ;; the x-coordinate of the moving sample (not the magnified sample)
         sample-location-patch-agentset ;; patches where the moving sample will sprout
         token-sample-dude ;; bottom-left turtle in the moving sample
         stop-all? ;; Boolean variable for stopping the experiment
         ]
patches-own [ column ]

breed [ column-kids column-kid ]
breed [ sample-dudes sample-dude ]
breed [ baby-dudes baby-dude ]

sample-dudes-own [distance-for-jump ]
column-kids-own [ binomial-coefficient sample-list ]

;; This procedure colors the view, divides patches into columns of equal length ( plus a single partition column),
;; and numbers these columns, beginning from the left, 0, 1, 2, 3, etc.
to setup
  clear-all
  set-default-shape turtles ""square big""
  set background-color white - 1
  set column-color gray
  set target-color green
  set other-color blue
  set-plot-x-range 0 ( 2 ^ ( side ^ 2 ) ) ;; the max of the range is set to be large enough to begin with

  ;; num-columns is how many columns (bars) there are in the graphics-window histogram.
  ;; We need side ^ 2 + 1 columns in a histogram. For example, 3-by-3 samples (9 patches)
  ;; have 10 -- that is, 3 ^ 2 + 1 -- different possible counts of target-color (0, 1, 2, 3, ...9).
  set num-columns ( side ^ 2 + 1)

  ;; determines the location of the sample array beginning one column to the left of the histogram
  set sample-right-xcor -1 * round ( ( num-columns / 2 ) * ( side + 1 ) )

  ;; assigns each patch with a column number. Each column is as wide as the value set in the 'side' slider
  ask patches
  [
    set pcolor background-color
    ;; The following both centers the columns and assigns a column number to each patch
    ;; We use ""side + 1"" and not just ""side"" so as to create an empty column between samples
    set column floor ( ( pxcor + ( ( num-columns * ( side + 1 ) ) / 2 ) ) / ( side + 1 ) )
    if column < 0 or column >= num-columns
      [ set column -100 ]
  ]

  ;; leave one-patch strips between the columns empty
  ask patches with
  [ [column] of patch-at -1 0 != column ]
  [
    set column -100  ;; so that they do not take part in commands that report relevant column numbers
  ]

   ;; colors the columns with two shades of some color, alternately
   ask patches
   [
     if column != -100
     [
       ifelse int ( column / 2 ) = column / 2
       [ set pcolor column-color ][ set pcolor column-color - 1 ]
     ]
   ]

  ;; This draws the yellow base-line and creates a sample-kids turtle at the base of each column
  ask patches with
  [ ( pycor = -1 * max-pycor + side + 3 ) and  ;; The base line is several patches above the column labels.
    ( column != -100 ) ]
  [
    set pcolor yellow
    if [column] of patch-at -1 0 != column   ;; find the leftmost patch in the column...
    [
      ask patch (pxcor + side - 1)  ;; ...then move over to the right of the column
                ( -1 * max-pycor + 1 )
        [ set plabel column ]
      ask patch (pxcor + floor (side / 2))  ;; ...then move over to the middle of the column
                ( -1 * max-pycor + 1 )
      [
       sprout 1
        [
          hide-turtle
          set color pcolor
          set breed column-kids
          set sample-list []

          ;; each column-kid knows how many different combinations his column has
          set binomial-coefficient item column binomrow (num-columns - 1)
        ]
      ]
    ]
  ]
  set stop-all? false
  set num-target-color false
end

to go
  if stop-all? [stop]
  ;; The model keeps track of which different combinations have been discovered. Each
  ;; column-kid reports whether or not its column has all the possible combinations. When bound? is true,
  ;; a report from ALL column-kids that their columns are full will stop the run.
  if stop-at-all-found? [if count column-kids with [length sample-list = binomial-coefficient] = count column-kids
    [stop]]
  sample
  ifelse magnify? [ magnify-on-side ] [ ask baby-dudes [ die ] ]
  drop-in-bin
  ;; the counter keeps track of how many samples have been taken (not how many different samples have been discovered)
  tick
  if plot? [ plot %-full ]
end

;; This procedure creates a square sample of dimensions side-times-side, e.g., 3-by-3,
;; located to the left of the columns. Each patch in this sample sprouts a turtle.
;; The color of the sample-dudes in this square are either target-color or other-color,
;; based on a random algorithm (see below)
to sample
  ;; creates a square agentset of as many sample-dudes as determined by the 'side' slider,
  ;; positioning these sample sample-dudes at the top of the view and to the left of the histogram columns
  set sample-location-patch-agentset patches with
  [
    ( pxcor <= sample-right-xcor ) and
    ( pxcor > sample-right-xcor - side ) and
    ( pycor > ( max-pycor - side ) ) ]
  ask sample-location-patch-agentset
  [
    sprout 1
    [
      ht
      set breed sample-dudes
      setxy pxcor pycor

    ;; Each turtle in the sample area chooses randomly between the target-color and the other color.
    ;; The higher you have set the probability slider, the higher the chance the turtle will get the target color
    ifelse random 100 < probability-to-be-target-color
      [ set color target-color ]
      [ set color other-color ]
    st
    ]
  ]
  ;; num-target-color reports how many sample-dudes in the random sample are of the target color
  set num-target-color count sample-dudes with [ color = target-color ]
end

;; procedure in which the sample turtles create an enlarged duplicate on the left side of the view and this enlarged sample makes
;; a large duplicate of the sample. This helps users see the samples that may otherwise be too small to see comfortably.
;; Samples are small for side = 3 because we want the entire sample space to fit into the view.
to magnify-on-side
  ask baby-dudes [die] ;; clears the way for new magnified sample
  ask sample-dudes
  [
    hatch-a-big-baby
  ]
end

to hatch-a-big-baby ;; sample-dudes procedure
  hatch 1
  [
    set breed baby-dudes
    set size 12 * ( 8 - side ) / side
    ;; This is tricky.  We want to center the new turtles vertically, and
    ;; put them to the right of all the columns, with a little space between.
    setxy -1 * ( size * .75 ) + ( sample-right-xcor + ( size * ( xcor - sample-right-xcor ) ) )
          ( ( side - 1 ) * size / 2 ) + ( size * ( ycor + min-pycor ) )
    set size size * .95
  ]
end

;; This procedure moves the random sample sideways to its column and then down above other previous samples
;; in that column.
to drop-in-bin
  find-your-column
  descend
end

;; The random sample moves to the right until it is in its correct column, that is, until it is in the column
;; that collects samples which have exactly as many sample-dudes of the target color as this sample has.
;; The rationale is that the as long as the sample is not in its column, it keeps moving sideways.
;; So, if the sample has 9 sample-dudes (3-by-3) and is moving sideways, but 6 of them are not yet in their correct column,
;; the sample keeps moving. When all of the 9 sample-dudes are the sample's correct column, this procedure stops.
to find-your-column
  ask sample-dudes [ set heading 90 ]
  while
  [ count sample-dudes with [ column = num-target-color ] != side ^ 2  ]
  [
    ask sample-dudes
    [ fd 1 ]
  ]
end

;; Moves the sample downwards along the column until it is either on the base line or
;; exactly over another sample in that column.
to descend
  let lowest-in-sample min [ pycor ] of sample-dudes
  ask sample-dudes
  [ set heading 180 ]

  ;; The lowest row in the square sample is in charge of checking whether or not the sample has arrived all the way down
  ;; In order to determine who this row is -- as the samples keeps moving down -- we find a turtle with the lowest y coordinate
  ;; checks whether the row directly below the sample's lowest row is available to keep moving down
  set token-sample-dude one-of sample-dudes with [ pycor = lowest-in-sample ]
  while
  [
    [pcolor] of [patch-at 0 -2] of token-sample-dude != yellow and
    [pcolor] of [patch-at 0 -2] of token-sample-dude != target-color and
    [pcolor] of [patch-at 0 -2] of token-sample-dude != other-color
  ]
  [
    ;; As in find-your-column, shift the sample one row down
    ask sample-dudes
    [ fd 1 ]
    display
  ;; Instead of establishing again the lowest row in the sample, the y coordinate of the row
  ;; gets smaller by 1 because the sample is now one row lower than when it started this 'while' procedure
  set lowest-in-sample ( lowest-in-sample - 1 )
  ]

  ;; Once sample-dudes have reached as low down in the column as they can go (they are on top of either the base line
  ;; or a previous sample) they might color the patch with their own color before they ""die.""
  finish-off

  ;; If the column has been stacked up so far that it is near the top of the view, the whole supra-procedure stops
  ;; and so the experiment ends
  if max-pycor - lowest-in-sample < ( side + 1 ) [ set stop-all? true ]
end

to finish-off
  ;; creates local list of the colors of this specific sample, for instance the color combination of a 9-square,
  ;; beginning from its top-left corner and running to the right and then taking the next row and so on
  ;; might be ""green green red green red green""
  let sample-color-combination [ color ] of sample-dudes

  ;; determines which turtle lives at the bottom of the column where the sample is
  let this-column-kid one-of column-kids with [ column = [column] of token-sample-dude]

  ;; accepts to list only new samples and makes a previously encountered sample if keep-duplicates? is on
  ifelse not member? sample-color-combination [sample-list] of this-column-kid
  [
    ask this-column-kid
    [ set sample-list fput sample-color-combination sample-list ]
    ask sample-dudes
    [ set pcolor color die ]
  ]
  [
    ifelse keep-repeats? [
      ask sample-dudes
       [ set pcolor color die ]
    ] [
      ask sample-dudes
        [  die ]
    ]
  ]
end

;; procedure for calculating the row of coefficients
;; column-kids needs their coefficient so as to judge if their column has all the possible different combinations
to-report binomrow [n]
  if n = 0 [ report [1] ]
  let prevrow binomrow (n - 1)
  report (map [?1 + ?2] fput 0 prevrow
                        lput 0 prevrow)
end

;;if the model has been run, report the number of patches
;;with the target-color -- otherwise, display ""--""
to-report #-target-color
  ifelse ticks != 0.0
  [ report count patches with [ pcolor = target-color ] ]
  [ report ""--"" ]
end

;;if has been run, report the number of patches
;;with the other-color -- otherwise, display ""--""
to-report #-other-color
  ifelse ticks != 0.0
  [ report count patches with [ pcolor = other-color ] ]
  [ report ""--"" ]
end

;; reports the proportion of the sample space that has been generated up to now
to-report %-full
  report precision ( samples-found / ( 2 ^ ( side ^ 2 ) ) ) 3
end

to-report samples-found
  report sum [ length sample-list ] of column-kids
end

to-report total-samples-to-find
  report 2 ^ ( side ^ 2 )
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2004 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Abrahamson, D. and Wilensky, U. (2004). NetLogo 9-Block Stalagmite model.
; http://ccl.northwestern.edu/netlogo/models/9-BlockStalagmite.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2004 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/9-BlockStalagmite
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
9-Block Stalagmite draws on and connects several central ideas in the study of probability, both theoretical and empirical: combinatorics, sample space, binomial distributions, and frequency distribution function.  In the related curricular material, students use crayons and paper to build the Combinations Tower.  The Combinations Tower is a giant bell-shaped histogram of all the 512 different combinations of a 3-by-3 array of squares that can each be either green or blue.

In the tower, these combinations are grouped in columns according to how many green squares there are in each.  9-Block Stalagmite accompanies these curricular activities.

The model generates random samples (with repetitions), counts how many green squares are in each sample, and collects these samples into columns, creating a histogram that grows up like a stalagmite.  If enough samples are taken, then the stalagmite approximates a bell curve.  When the probability in the model is set at .5, the shape of this histogram resembles the combinations tower.  If all repeating samples are removed from this histogram as it grows up, the model eventually exhausts the sample space at each run of the experiment, providing the view allows the tower to grow tall enough.

This model is a part of the ProbLab curriculum.  The ProbLab Curriculum is currently under development at the CCL.  For more information about the ProbLab Curriculum please refer to http://ccl.northwestern.edu/curriculum/ProbLab/.


HOW IT WORKS
------------
At the top of the view, a square array of ""patches"" (the NetLogo square agents that don't move) generates green and blue ""turtles"" (the NetLogo agents that move).  These turtles' colors -- whether they are green or blue -- are determined randomly according to probabilities set by the user.  For instance, an 80% chance for each turtle to be green (so 20% chance for each turtle to be blue).  Next, the model moves this turtle-sample towards the right so that it arrive in a column that matches the number of green turtles in the sample.  Lastly, the model moves the sample down along the column and stacks it on top either of the bottom of the column or a previous sample that has already been positioned there.  When the turtles stop, they mark their color onto the patches, and then they ""die"".  For each sample that is generated, a larger duplicate appears on the side for the user's viewing convenience.

Note that for a 9-block there are 10 columns in the view.  This is because we need a column for all combinations that have 0 greens, a column for 1 green, a column for 2 green, ..., and a columns for 9 green for a total of 10 columns (9 + 1).


HOW TO USE IT
-------------
Buttons:
'Setup' - prepares the view, including erasing the coloration from a previous run of the experiment.
'Go' - a forever button that runs the experiment according to the values you have set in the sliders.
'Go Once' - a button that runs the experiment only once.

Sliders:
'side' - determines the size of the square sample arrays.  For instance, for a value of 3, the model will create a 3-by-3 square (9 turtles).
'probability-to-be-target-color' - determines the chance of each turtle in the sample array to be green (or any other color you have set the model to).  A value of 50 means that each turtle has an equal chance of being green or blue, a value of 80 means that each turtle has a 80% chance of being green (so each has a 20% chance of being blue).

Switches:
'keep-repeats?' - when ""Off,"" each column will have only different combinations with no repetitions; when ""On,"" there will most probably be repetitions in at least some of the columns.  (For 2-by-2 samples, there will be very rare cases that the whole sample space will be discovered without repetitions.  For 3-by-3 samples, the cases are so rare that you probably won't ever see it!! Actually, how rare are they?..)
'magnify?' - when ""On,"" you get a larger version of the sample on the side.  This helps when you're working with very small patch sizes, such as when you want to have very tall columns so as to exhaust the sample space corresponding to the value of 'side,' e.g,. 512 for 'side = 3.'
'stop-at-all-found?' - when ""On,"" each run will end if all the different combinations have been discovered.  When ""Off,"" the run will continue until one of the columns reaches the top.

Monitors:
'#-target-color' - displays the total number of squares of target-color, e.g., 'green.'
'#-other-color' - displays the total number of squares of other-color, e.g., 'blue.'
'%-target-color' - displays as a percentage the proportion of target-color squares out of all colored squares.
'combinations found' - displays the proportion of the sample space that has been revealed
'?-blocks' shows the square of 'side.' So if 'side' is set to 3, '?-blocks' will show 9. This means that each sample of side 3 has 9 squares.

Plots:
'filling-up-sample-space' - plots the total number of combinations that have been discovered as a proportion of the sample space that has been discovered.

Set the sliders according to the values you want, press Setup, and then press Go.

Note that once you have pressed Go, changing the slider values would ""confuse"" the model.  Instead, you should un-press Go, wait until the button jumps back up, and only then change the sliders as you wish, press Setup, and then press Go


THINGS TO NOTICE
----------------
Setup the model in its default settings ('side' slider set to the value of 3; 'probability' slider set to the value of .5), slow down the model with the speed slider at the top left of the view, and press Go.  Note the following: the more green squares there are in the random sample the further to the right the block will move before descending down. See that at the bottom of each column there is a number.  This number tells you the type of sample that will be collected in this column.  For instance, in the column labeled '2,' samples that have exactly 2 green patches will stop moving to the right and will descend.  So, as the columns grow up, note that each sample will descend over a previous sample that has exactly as many green squares.  Overall, the columns on the right are greener than the columns on the left.  As you shift your gaze from side to side, the color density changes.

Run the model over and over and watch the shape of the colorful histogram that is plotted.  Note any consistencies in the shape of this histogram.


THINGS TO TRY
-------------
Work in the 'side' = 2 setup. Set 'keep-duplicates?' to Off.  How many samples do you need to fill the entire sample space?  Does this change according to the settings of 'probability'?  If so, why might this be so? If the probability is set at 80%, does it take as many trials to fill the sample space as compared to a setting of 50%? If not, why not?

Setup the model with the 'side' value at 2 and the 'probability' at 70%.  Press Setup and then Go.  (If you have previously slowed down the model, you're welcome to speed it up now.)  Note that the %-target-color tends to 70%. Also note that more sample combinations collect up in the column of 3 green patches than any other column.  So '3' is the mode.  We have found it interesting and perhaps somewhat confusing to shift between thinking about the 'mode' and thinking about the 'mean.' For instance, if you set the 'probability' to 83%, you might think that 83% of 4 is 3.32 and so the mode should still be '3.' Is it? What is going on here? So for some probability setting, the 3-column will most often get to the top before other columns. For other probability settings, the 4-column wins. Try to determine the probability ranges in which each column ""rules."" Hint: How many ranges should there be?

Edit the view so that the y-axis value is 260 and the patch size is 1 pixel. Now, if you set up in 'side = 3,' all 512 different 9-blocks will fit in. Try this.


EXTENDING THE MODEL
-------------------
Add monitors and/or graphs that will feature aspects of the experiments that are difficult to see in the current version.  For instance:
- How many samples does it take for the experiment to produce an all-green sample?  How is this dependent on the various settings?
- Are there more samples with an even number of green squares as compared to those with an odd number of green squares?
- How symmetrical is the histogram?  How would you define ""symmetry?""  How would you quantify and display its change over time?


NETLOGO FEATURES
----------------
Turtle Shapes -- The top panel of the view features a red arrow-like turtle shape.  Pressing on this button toggles between Turtles-Shape ""On"" and ""Off.""  In many NetLogo models, turtles represent specific agents (""creatures"") in the situation or phenomenon that is being modeled.  So in many models the turtles have distinctive shapes (icons) that approximate or at least suggest what they are modeling.  However, this model is an example of a case where we do not want any special turtle shape.  In fact, we actually want the turtles to look like the patches -- just squares.  So we have turned the Turtle-Shapes to ""Off.""  Try running the model with the Turtles-Shapes ""On"" (you can change this while running the model) and see which mode you prefer.  The difference between these two modes will be most noticeable when you are running the model slowly and/or when the 'magnify?' switch is turned to 'On.""  You could also edit the size of the turtles.  Perhaps you will discover that you prefer having the turtles be some special shape.  How might that affect the histogram?


RELATED MODELS
--------------
Some of the other ProbLab (curricular) models, including SAMPLER -- Computer HubNet Participatory Simulation -- feature related visuals and activities.  In Stochastic Patchwork and especially in 9-Blocks you will see the same 3-by-3 array of green-or-blue squares.  In the 9-Block Stalagmite model, when 'keep-duplicates?' is set to 'Off' and the y-axis value of the view is set to 260, we get the whole sample space without any duplicates.  In the Stochastic Patchwork model and especially in 9-Blocks model, we see frequency distribution histograms.  These histograms compare in interesting ways with the shape of the combinations tower in this model.


CREDITS AND REFERENCES
----------------------
This model is a part of the ProbLab curriculum. The ProbLab Curriculum is currently under development at Northwestern's Center for Connected Learning and Computer-Based Modeling. . For more information about the ProbLab Curriculum please refer to http://ccl.northwestern.edu/curriculum/ProbLab/.

To refer to this model in academic publications, please use:  Abrahamson, D. and Wilensky, U. (2004).  NetLogo 9-Block Stalagmite model.  http://ccl.northwestern.edu/netlogo/models/9-BlockStalagmite.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2004 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/9-BlockStalagmite for terms of use.
"
Random Basic Advanced,/models/Sample Models/Mathematics/Probability/ProbLab/Unverified,"globals
[
  counter         ;; used in setting up the messengers
  at-top?         ;; Boolean that discontinues run when columns reach the top of the space
  max-y-histogram ;; how high the columns can rise (or how far up the yellow goes)
  list-of-labels  ;; list of all the outcomes
  list-of-label-means ;; list of the mean values of messengers in each iteration through Go


  height          ;; height, from the bottom of the view, that bricks may rise to
  space-color     ;; background color of space where bricks stack up
]

breed [ messengers messenger ]      ;; messengers carry a brick to the random-value column.
                                    ;; they place the brick on top of the column
breed [ column-counters column-counter ] ;; column-counters live on top of each column. Messengers go to column-counters.
breed [ bricks brick ]          ;; when a messenger brings a square bricks that indicate events in histogram columns

messengers-own [ destination ] ;; destination is the top of the column that the messenger heads towards

column-counters-own
[
  my-column                     ;; what column it is in, with the left-most pycor being ""1""
  my-column-patches             ;; all patches that are in its column as an agentset
  num-messengers-pointing-to-me ;; how many messengers are about to move towards it
  my-ycor                       ;; its ycor, even if this ycor is out of bounds below the edge of the world
]

to setup
  ca
  set height world-height - 10
  set space-color white
  set max-y-histogram (min-pycor + height)  ;; bricks placed above this line cause
                                                    ;; all bricks to bump down
  create-histogram-space
  setup-column-counters
  set at-top? false
  set list-of-label-means []
end

to create-histogram-space  ;; this code supports a slider for sample-space (the slider does not exist now)
  ask patches
  [
    ifelse (pxcor < (min-pxcor + sample-space) )
            and (pycor < max-y-histogram)
    [ set pcolor space-color ]
    [ set pcolor white - 2 ]
  ]
end

to setup-column-counters  ;; column-counters show messengers where to take their bricks.
  ask patches with [ (pycor = min-pycor ) and pcolor = space-color ]
  [
    sprout 1
    [
      set breed column-counters
      ht
      set heading 0
      ;; each column-counter knows its column in the histogram
      set my-column floor (max-pxcor + pxcor + 1)
      ;; each column-counter knows its patches
      set my-column-patches patches with [ pxcor = [pxcor] of myself ]
      set my-ycor ycor
    ]
  ]
end

to go ;; forever button
  if at-top? and (not bump-down?) [ stop ]
  place-messengers-and-choose-random-values
  ask messengers [point-to-your-column]
  ask column-counters [count-num-messengers-pointing-to-you]
  if bump-down? [ bump-down ]
  move-messengers
  tick
  histogram-labels
  histogram-label-means
  ask messengers [ die ]
end

to place-messengers-and-choose-random-values
  ;; each messenger is born and gets a random value from the sample space
  ;; messengers are centered over the middle of the space and equally distributed across it
  let increment ( sample-space / num-messengers )
  let it round (min-pxcor +  increment / 2)

  repeat num-messengers
  [
    ask patch round (it + counter * increment) (max-y-histogram + 4)
    [
      sprout 1
      [
        set breed messengers
        set shape ""messenger""
        ht
        set color 3 + 10 * counter
        set heading 180
        set size world-height - height + 2
        set label 1 + random sample-space
      ]
     ]
   set counter counter + 1
  ]
  set counter 0
  ask messengers [st]
end

to point-to-your-column ;; turtle procedures. Each messenger points towards the top of its column
    set destination one-of column-counters with [ my-column = [label] of myself ]
    face destination  ;; messenger heads to column top
end

;; Each column-counter figures out how many messengers point at it
to count-num-messengers-pointing-to-you  ;; turtle procedure
  set num-messengers-pointing-to-me count messengers with [destination = myself]
end

to move-messengers
  ;; Each messenger goes to the top of the column of its value
  while [any? messengers with [distance destination > 3] ] [
    ask messengers with [distance destination > 3] [  ;; messenger will stop when it appears on top of its destination
      face destination ;; this is a precaution in case the column-counter has gone up
      fd 1
    ]
    display
  ]
  ask messengers [ lay-your-brick ]
end

to lay-your-brick ;; when messenger has arrived, the column-counter builds a brick and moves above it
    ask destination
    [
      ifelse my-ycor < min-pycor
      [
        set my-ycor my-ycor + 1
      ]
      [
         create-brick
         fd 1
         if (ycor = max-y-histogram) [ set at-top? true ]
         set my-ycor ycor
      ]
    ]

    ht
end

to create-brick ;; turtle procedure  ;; its patch creates the square brick
  ask patch-here
  [
    sprout 1
    [
      set breed bricks
      set shape ""brick""
      set color black
    ]
  ]
end

to histogram-labels
  set list-of-labels ( sentence list-of-labels [label] of messengers )
  set-current-plot ""All Values From Messengers""
  histogram list-of-labels
end

to histogram-label-means
  ;; the histogram displays the mean values from the batches of messengers over all runs.
  ;; for even numbered sample spaces, mean values that fall in between the center columns
  ;; are assigned randomly either to the left-side column or to the right-side column
  let mean-num ( mean [ label ] of messengers )
  ifelse ( mean-num - (int mean-num) ) = .5
     [
       if random 2 = 0 [ set mean-num round mean-num ]
     ]
     [
       set mean-num round mean-num
     ]
  set list-of-label-means ( sentence mean-num list-of-label-means )
  set-current-plot ""Mean Values of Batches of Messengers""
  histogram list-of-label-means
end

to bump-down ;; when columns have reached the top of the space, they all go down by one brick
  ;; first, we determine how far above the max line we would go if we didn't bump down (it might zero)
  let expected-max-height ( max [ my-ycor + num-messengers-pointing-to-me ] of column-counters )
  let num-over-the-top ( expected-max-height - max-y-histogram )
  if num-over-the-top <= 0 [stop]

  repeat num-over-the-top
  [
     ask column-counters [
        ifelse my-ycor <= min-pycor
           [ set my-ycor my-ycor - 1 ]
           [ (set heading 180) (fd 1) (ask bricks-here [die]) (set heading 0) (set my-ycor ycor)]
     ]
  ]
end

to-report max-diff  ;; difference in height between tallest and shortest columns;
                    ;; ""short"" can be below the bottom of the world)
  report max [my-ycor] of column-counters - min [my-ycor] of column-counters
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2004 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Abrahamson, D. and Wilensky, U. (2004). NetLogo Random Basic Advanced model.
; http://ccl.northwestern.edu/netlogo/models/RandomBasicAdvanced.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2004 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/RandomBasicAdvanced
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
Random Basic Advanced explores the effect of sample size on the distribution of sample mean.

At each run, a sample of random values is selected and displayed on ""messengers,"" who each carry a brick to the top of a corresponding column in a bar chart.  (So a messenger with ""5"" will carry the brick to the top of the fifth column from the left.) The values are also added into a histogram (below the view). The mean value from each batch of messenger is added to yet another histogram (at the bottom of the interface).

The larger the sample size, the smaller the variance of the distribution. That is, the sample space does not change, but extreme values become more and more rare as the sample size increases.  Combinatorial analysis helps understand this relation.

This model is a part of the ProbLab curriculum. The ProbLab curriculum is currently under development at the CCL. For more information about the ProbLab curriculum please refer to http://ccl.northwestern.edu/curriculum/ProbLab/.


HOW IT WORKS
------------
At every trial (sampling), random values are assigned to as many ""messengers"" as you choose. The messengers each carry a brick. They go to a column according to their value and lay the brick at the top of that column. The mean value of the batch of messengers is plotted in a histogram.


HOW TO USE IT
-------------
Buttons:
SETUP - prepares the model for running with your sample-space parameter setting.

GO - runs the model with the current settings.

Sliders:
SAMPLE-SIZE -- set the total number of integer values, beginning from 1, that can be randomly assigned to the messengers

Switches:
BUMP-DOWN? -- when set to ""on,"" the columns in the view will all go down by one step to anticipate the columns reaching the top of the space.

Monitors:
BIGGEST-DIFFERENCE -- show the vertical difference between the tallest column and the shortest column. Note that columns can be so short that they are below min-pycor.

STD DEV -- standard deviation of the sample-mean distribution. This is a measure of shape the distribution tends towards. A lower standard deviation implies a narrower distribution.

Plots:
ALL VALUES FROM MESSENGERS-- plots all of the randomly assigned values in the messenger labels.

MEAN VALUES OF BATCHES OF MESSENGERS -- plots the mean of all the randomly-assigned values in the messenger labels.


THINGS TO NOTICE
----------------
Each messenger ""carries"" a little brick. It swoops down to the highest point in a brick tower. It goes to the brick tower that is as far from the left wall as is the messenger's number. So a messenger with ""7"" will go to the seventh column from the left.

When the bricks are about to hit the top of the space, all the columns ""bump down"" to make space for the new bricks. But the monitor ""ALL VALUES"" keeps a record of all the bricks that have been laid. So, sometimes a column of bricks will be empty, because it is not tall enough to make it into the view, yet its corresponding column in the the plot will still be there.


THINGS TO TRY
-------------
Run the model with NUM-MESSENGERS = 1. Compare the histogram in the plot to the towers in the graphic windows. What do you see? Now setup and run the model with NUM-MESSENGERS = 2. Is the histogram any different from before? Repeat this for values of NUM-MESSENGERS 10, 20, and 30. For a sample size of 1, the raw data (the bricks in the towers) are exactly the same as the histogram. For a sample size of 2, we begin to see a certain shallow bump in the middle of the distribution. For larger sample sizes, this bump becomes more and more acute.  For a sample size of 30, the distribution is narrow.

Another comparison is to do with the likelihood of getting a low value, say ""1,"" in different settings of NUM-MESSENGERS. Run the model 100 trial for different values of NUM-MESSENGERS and see if there is a pattern to this comparison.

What is the standard deviation dependent on? For a fixed number of messengers, would a larger sample space change the standard deviation? If so, why? For a fixed sample space, should a change in the number of messengers affect the standard deviation? If so, why? Can you determine a relation between these three values (NUM-MESSENGERS, SAMPLE-SPACE, and STD-DEV)? One way to begin would be to use NetLogo's BehaviorSpace.

Once the model has run for many trials, should the BIGGEST-DIFFERENCE increase or decrease? On the one hand, individual columns have ""opportunities"" to get very tall, but on the other hand, all columns have the same opportunities. Is this a paradox?


PEDAGOGICAL NOTE
---------------
Why are we getting this pattern? Let's think about the case of NUM-MESSENGERS = 2 to understand the bump in the distribution plot:

The only way to get a value of ""1,"" is if both the messengers have a value of ""1,"" but to get a value of, say, ""2,"" either both messengers have ""2,"" or one has ""1"" and the other ""3"" or vice versa. So there are three different ways of getting ""2."" How about getting a ""3?"" There are more than three ways of getting ""3"": [3,3]; [2,4]; [4,2]; [1,5]; [5,1]. So there are five ways of getting ""3."" You can see that the nearer the value is to the middle (50), there are more and more ways of getting that value as a mean of two values. Because these values are random, over many runs we will get more means that are closer to the middle, so we get the bump.

This way of finding all the different possible compound events is called combinatorial analysis -- determining all the combinations for a given set of variables each with a set of possible values. Once we know all the combinations, we can group them so as to predict the chances of getting any outcome from each group. For instance, if we know that there are triple as many ways for two messengers to form a mean of ""2"" than to form a mean of ""1,"" then we can predict that we will get a ""2"" three times as much as we get a ""1,"" if we run the simulation long enough. That is where combinatorial analysis (theoretical probability) meets experimental simulations (empirical probability).

Can we extend this way of thinking in order to understand the difference between the distribution we get for NUM-MESSENGERS = 2 as compared to the distribution we get for NUM-MESSENGERS = 3? For NUM-MESSENGERS = 3, we get an even narrower distribution. Why? Extending our previous way of thinking, we can expect that with three messengers the number of combinations for getting mean values of 1, 2, 3 etc. rises even more sharply than for NUM-MESSENGERS = 2. Let's see: for ""1"" there is only one combination: [1,1,1], just like for NUM-MESSENGERS = 2. But for ""2"" there are more than just three as in the previous example. Look: [2,2,2]; [1,2,3]; [1,3,2]; [2,3,1]; [2,1,3]; [3,1,2]; [3,2,1]; [1,1,4]; [1,4,1]; [4,1,1], for a total of ten combinations.

You might notice that the more messengers in a batch (the higher the setting of NUM-MESSENGERS), the less likely it is to get a low mean sample value, say ""1."" For NUM-MESSENGERS = 10, you would get a ""1"" only if all the messengers chose ""1"" randomly at the same time. That happens once every 100^10, which is ""1"" with 1000 zeros after it. That's pretty rare...


EXTENDING THE MODEL
-------------------
In the model, the bricks laid by the messengers are NetLogo ""turtles"".  However, in NetLogo, the more turtles are visible, the longer it takes to update the display. Thus, the closer the display gets to being full of bricks, the slower the model runs.  To eliminate this problem, one may want to use colored NetLogo ""patches"", rather than ""turtles"", to represent the bricks in the display histogram.

Currently, the brick columns in the display show the absolute height of each column -- not the proportionate height of the columns.  This means that once a column is considerably taller than other columns, these other columns may be shown as empty.  They are not tall enough to enter the display -- they are ""under water.""  We have chosen this design option, because we think it helps users ""get into"" the model when they first start working with it. But you might want to change this or add an option that gives you the proportionate height of the columns.  For a clue on how to make this work, take a look at the code of the Rugby model.


NETLOGO FEATURES
----------------
The DISPLAY command is used to make the motion of the messengers animate.


RELATED MODELS
--------------
See the ProbLab model Random Basic. In that model, there is only a single messenger. This model extends Random Basic in that we now have compound events, that is, we look to understand the chances of two or more independent events occurring simultaneously.


CREDITS AND REFERENCES
----------------------
This model is a part of the ProbLab curriculum. The ProbLab Curriculum is currently under development at Northwestern's Center for Connected Learning and Computer-Based Modeling. . For more information about the ProbLab Curriculum please refer to http://ccl.northwestern.edu/curriculum/ProbLab/.

To refer to this model in academic publications, please use:  Abrahamson, D. and Wilensky, U. (2004).  NetLogo Random Basic Advanced model.  http://ccl.northwestern.edu/netlogo/models/RandomBasicAdvanced.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2004 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/RandomBasicAdvanced for terms of use.
"
Dice,/models/Sample Models/Mathematics/Probability/ProbLab/Unverified,"globals [
          patches-in-set-block     ;; agent-set of patches where you set the dice
          patches-in-guess-block   ;; agent-set of patches where the computer guesses the dice
          dice-list            ;; list of shape names of all six dice
          instructions         ;; the user instructions that appear in the monitor on the top left

     ;; Booleans to preempt run-time errors and/or user confusions
          am-I-set-up?
          combi-exists?
          abort-pick-dice?
          stop?
          got-single-success?
          permis-success?
          revealed?

     ;; Booleans used in identifying favored events amongst all outcomes
          all-combi-match?     ;; used to mark whether an outcome is the same as the original combination
          all-permis-match?  ;; used to mark whether an outcome is the same as the original combination
                             ;; or its permutation

     ;; variables that record the dice set by the user
          dice-choices ;; list of dice face values of the combination that the user set

     ;; variables and Lists that record different interpretations of the outcomes
          count-steps                           ;; counts the number of outcomes in the current sample
          #combi-successes-per-sample-list      ;; list of outcomes per sample that were exactly like
                                                ;; the original combination
          #permis-successes-per-sample-list   ;; list of outcomes per sample that are the original combination
                                              ;; or its permutation
          samples-counter                       ;; how many sample have elapsed in an experiment
          count-combi-successes       ;; counts up hits under the combi condition
          count-permis-successes      ;; counts up hits under the permutation condition
          mean-combi-per-sample       ;; mean number of same-order outcomes per sample
          mean-permis-per-sample      ;; mean number of either-order outcomes per sample

     ;; Boolean associated with the Hide/Reveal button
          hide?
        ]

breed [ frames frame ] ;; turtles that are the black outlines around the two dice patches
breed [ dice a-die]   ;; turtles that are the dice face values

patches-own [ my-guess-block-buddy ] ;; each die in the set-block has a buddy die in the guess-block

dice-own [
          my-shape               ;; there are six different shapes that are the 1-thru-6 dice faces
          my-set-number          ;; the numerical value associated with the dice face you pick
          my-current-number      ;; the numerical value associated with the dice face the model guessed
         ]

to startup
    initialize
    ask patches [ set pcolor white ]
    set instructions ""Hi! Please read the Information tab to learn about this model, or just press Setup.""
end

to initialize
  ca
  set dice-list [ ""one"" ""two"" ""three"" ""four"" ""five"" ""six"" ]
  set all-combi-match? false
  set all-permis-match?  false
  set combi-exists? false
  set am-I-set-up? false
  set stop? false
  set got-single-success? false
  set revealed? false
  set bars? true
  set abort-pick-dice? false
  set hide? true
  set dice-choices []
  set #combi-successes-per-sample-list []
  set #permis-successes-per-sample-list []
end

to setup
  set-default-shape frames ""frame""
  initialize
  create-set-block   ;; the set-block is the group of patches to be used in setting the combination
  create-guess-block ;; the set-block is the group of patches to be used in guessing the combination
  ask patches-in-set-block [ setup-frames ]
  ask patches-in-guess-block [ setup-frames ]
  set instructions ""OK. Now press Pick Dice to set the combination of dice faces.""
  set am-I-set-up? true
end

to create-set-block
  set patches-in-set-block patches with [ pycor = 1 and pxcor > -1 ]
  ask patches-in-set-block [ set pcolor green ]
  ask patches with [ pcolor != green ] [ set pcolor white ]
end

;; To create the guess-block of patches, each patch in the set-block assigns a value to
;; a patch 3 patches lower down.  The patch variable my-color is used in this context
;; even though it is not a color context, to save an agentset variable
to create-guess-block
  ask patches-in-set-block [
    set my-guess-block-buddy patch-at 0 -2
    ask my-guess-block-buddy [ set my-guess-block-buddy ""buddy"" ]
  ]
  set patches-in-guess-block patches with [ my-guess-block-buddy = ""buddy"" ]
end

to setup-frames  ;;patches procedure
  sprout 1 [
    set breed frames
    set color black
  ]
end

to pick-dice
  if abort-pick-dice? [ stop]
  if not am-I-set-up? [ alert-setup stop ]
  set instructions (word ""Click on the green squares to create your combination. ""
                         ""It goes from 1 to 6 and over again. ""
                         "" Next, unpress Pick Dice."")
  assign-face
  set dice-choices []

  ;; permis-choice is a list of the dice face-values;
  ;; This list will serve us later in the ""check-permis"" procedure,
  ;; where we compare between what the model guesses and what we picked
  set dice-choices [ 1 +  position shape dice-list ] of dice with [ pycor > 0 ]
  set combi-exists? true
end

;; Every time you click on a die face,
;; the procedure identifies the die's current face value, moves one step
;; forward in the list of 6 face-value options and assigns this new value to the current die.
to assign-face
  if mouse-down? [
    ask patches-in-set-block with [ ( pxcor = round mouse-xcor ) and ( pycor = round mouse-ycor ) ] [
      ifelse not any? dice-here [
        make-dice
      ] [
        ;; loops through the list of dice
        ask dice-here [set shape ( item ((1 + position shape dice-list) mod 6) dice-list ) ]
      ]
      wait 0.3  ;; this wait gives the user a chance to lift the finger after clicking so
                ;; that the procedure doesn't go again
    ]
  ]
  ask patches-in-set-block
    [ask dice-here [ set my-shape shape ] ]
  ask patches-in-set-block [
    ask my-guess-block-buddy [
      if not any? dice-here [ make-dice ]
      ask dice-here [ ht ]
    ]
  ]
end

to make-dice ;; patch procedure
  sprout 1 [
    set breed dice
    set color black
    set shape ""one""
  ]
end

;; the core super-procedure for generating random dice and searching for matches with the dice you picked
to search
  if samples-counter = total-samples [stop]
  if ( count dice with [ pycor > 0 ] ) < 2 [ alert-not-2-dice stop ]
  ;; managing the user-code interface
  if not am-I-set-up? or not combi-exists? [ alert-setup stop ]
  set abort-pick-dice? true
  set instructions word ""The program guesses combinations randomly and tracks ""
                        ""the number of times it discovers the dice you picked.""

  ;; These two Boolean variables track whether a search is successful. The logic is that by default the search is
  ;; considered a success until proved otherwise.
  set all-combi-match? true
  set all-permis-match? true
  ask patches-in-set-block [ guess ]
  ask patches-in-set-block [ check ]
  check-permis
  set count-steps count-steps + 1

  if all-combi-match?
    [ set count-combi-successes count-combi-successes + 1  ]

  if all-permis-match?
     [ set count-permis-successes count-permis-successes + 1 ]

  ;; for 'single-success?' true, we want the program to stop after matching dice were found
  if single-success? [
    ifelse Analysis-Type = ""Both"" [
      if all-combi-match? [
        congratulate-combi
        stop
      ]
      if all-permis-match? [
        congratulate-permi
        stop
      ]
    ] [
      ifelse Analysis-Type = ""Combination"" [
        if all-combi-match? [
          congratulate-combi
          stop
        ]
      ] [
        if  all-permis-match? [
          congratulate-permi
          stop
        ]
      ]
    ]
  ]
  if count-steps = sample-size [ plot-sample ]
end

;; if a non-correspondence was found between the guessed and original combi,
;; this specific search trial is registered as failed
to check  ;; patches-in-set-block procedure
  let my-shape-help [my-shape] of one-of dice-here
  ask my-guess-block-buddy
    [ ask dice-here [ if shape != my-shape-help [ set all-combi-match? false ] ] ]
end

to check-permis
  ;; checking to see whether the current dice pair is the same as the original pair or a permutation on it
  ;; the face-values of the dice are compared both to the original pair [A; B] and to its reverse order [B; A]
  let current-dice ( [ my-current-number ] of dice with [ pycor < 0 ] )
  ifelse ( current-dice = dice-choices ) or
         ( current-dice = reverse dice-choices )
    [ set all-permis-match? true ]
    [ set all-permis-match? false ]
end

to congratulate-combi
  let calc-combi-help  ( length #combi-successes-per-sample-list  * sample-size ) + count-steps
  set instructions (word ""Congratulations! ""
                         ""You discovered the hidden combination in "" calc-combi-help
                         "" steps. You can press Search again."")
  little-setup
end

to congratulate-permi
  let calc-permis-help  ( length #permis-successes-per-sample-list  * sample-size ) + count-steps
  set instructions (word ""Congratulations!  You discovered a permutation of the hidden combination in ""
                         calc-permis-help "" steps. You can press Search again."")
  wait 1
  little-setup
end

to little-setup
  set count-steps 0
  set count-combi-successes 0
  set #combi-successes-per-sample-list []
  set count-permis-successes 0
  set #permis-successes-per-sample-list []
end

;; the model guesses random dice
to guess  ;; patches-in-set-block procedure
  ask my-guess-block-buddy
  [
     ask dice-here
     [
       set shape item ( random 6 ) dice-list
       set my-current-number ( 1 +  position shape dice-list )
       st
     ]
  ]
end

;; toggles between hiding and revealing the patches-in-set-block
to hide/reveal
  ifelse hide?
    [ hide-set-block ]
    [ reveal-set-block ]
end

to hide-set-block
  ask patches-in-set-block [ ask dice-here [ ht ] ]
  ask patches-in-set-block [ set pcolor gray - 2 ]
  set hide? false
end

;; procedure that re-assigns to patches-in-set-block the appearance properties of the dice you picked
to reveal-set-block
 ask dice with [ pycor > 0 ] [ set pcolor green st ]
 set hide? true
end

;; ALERTS FOR THE USER

to alert-setup
   set instructions ""Please work this way: Press Setup and then Pick Dice""
end

to alert-not-2-dice
  set stop? true
  user-message word ""To run the experiment, you must create two dice: ""
                    ""To start over, press 'OK' then Setup.""
end

;; PLOTTING CODE

to plot-sample
  set samples-counter samples-counter + 1
  set #combi-successes-per-sample-list fput count-combi-successes #combi-successes-per-sample-list
  set #permis-successes-per-sample-list fput count-permis-successes #permis-successes-per-sample-list
  set-current-plot ""Successes-per-Sample Distributions""
  ifelse Analysis-Type = ""Both""
  [
    ;; this line regulates the appearance of the plot -- it centers the two histograms
    set-plot-x-range 0  max ( list ( round 1.5 * ceiling ( mean  #permis-successes-per-sample-list ) )
                                  ( 1 + max #permis-successes-per-sample-list ) .1 )
  ]
  [
    ifelse Analysis-Type = ""Combination""
      [set-plot-x-range 0 max ( list ( 2 * ceiling ( mean  #combi-successes-per-sample-list ) )
                                    ( 1 + max #combi-successes-per-sample-list ) .1 ) ]
      [set-plot-x-range 0 max (list ( 2 * ceiling ( mean  #permis-successes-per-sample-list ) )
                                    ( 1 + max #permis-successes-per-sample-list ) .1 ) ]
  ]

  ;; In order to collapse two procedures into one, we use (below) the do-plot procedure.
  ;; Here, we assign values for this procedure according to the two conditions of search (combi and permis).
  if Analysis-Type != ""Permutations""
    [ do-plot #combi-successes-per-sample-list ""Combination"" ]
  if Analysis-Type != ""Combination""
    [ do-plot #permis-successes-per-sample-list ""Permutations"" ]
end

;; plotting procedure
to do-plot [ event-list current-pen-name ]
  if Analysis-Type = ""Combination"" [ set-current-plot-pen ""Combination"" plot-pen-reset ]
  if Analysis-Type = ""Permutations""  [ set-current-plot-pen ""Permutations"" plot-pen-reset ]
  set-current-plot-pen current-pen-name
  ifelse bars? [ set-plot-pen-mode 1 ] [ set-plot-pen-mode 0 ]
  histogram event-list
  set count-steps 0
  set count-permis-successes 0
  set count-combi-successes 0
end

to-report ratio
  ;; we want the ratio to be rounded after two decimal points
  let ratio-help precision ( mean #permis-successes-per-sample-list / mean #combi-successes-per-sample-list ) 2
  report word ""1 : "" ratio-help
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2004 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Abrahamson, D. and Wilensky, U. (2004). NetLogo Dice model.
; http://ccl.northwestern.edu/netlogo/models/Dice.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2004 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Dice
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
""Dice"" is a virtual laboratory for learning about probability through conducting and analyzing experiments. You use two dice in the view to perform the experiments. You set up an experiment by choosing a combination consisting of a face for each die, for instance 3 and 4 (we will use this example throughout). Then you ""roll"" these dice repeatedly and study how often the dice match your chosen combination.

The dice can match your initial combination in several different ways: they can show the same numbers in the same order; they can show the same numbers regardless of order; or the sum of both dice can match.  The model collects statistics on all of these kinds of matches.  It also keeps track of how often you get each of the 11 possible dice sums.  The different plots and monitors in the model give you different perspectives on the accumulated data.

This model is a part of the ProbLab curriculum. The ProbLab curriculum is currently under development at the CCL. For more information about the ProbLab Curriculum please refer to http://ccl.northwestern.edu/curriculum/ProbLab/.


PEDAGOGICAL NOTE
----------------
This model introduces tools, concepts, representations, and vocabulary for describing random events.  Among the concepts introduced are ""sampling"" and ""distribution"".

The various ProbLab models use virtual computer-based ""objects"" to teach probability.  In this model, the computer-based objects are ""virtual"" dice, modeled on the familiar physical ones. By using familiar objects, we hope to help learners form a ""bridge"" from their everyday experience to more abstract concepts. Other ProbLab models use virtual ""objects"" that are less familiar. Using dice first helps prepare students for that.

Facilitators are encouraged to introduce this model as an enhancement of experiments with real dice. The model has several advantages over real dice. Virtual dice roll faster, and the computer can record the results instantly and accurately from multiple perspectives simultaneously.

The model attempts to involve the learner by allowing them to choose a combination before running the experiment.


HOW TO USE IT
-------------
Press SETUP, then press PICK DICE.  By clicking on the green squares, you set a pair, for instance [3; 4].  Press SEARCH to begin the experiment, in which the computer generates random dice faces. If you set the SINGLE-SUCCESS? switch to 'On,' the experiment will stop the moment the combination you had created is discovered. If this switch is set to 'Off,' the experiment will keep running as many times as you have set the values of the SAMPLE-SIZE and TOTAL-SAMPLES sliders. In the plot window, one or two histograms start stacking up, showing how many times the model has discovered your pair in its original order (""Combinations"") and how many times it has discovered you pair in any order (""Permutation""). Are there always more permutations than combinations?

Buttons:
SETUP -- begins new experiment
PICK DICE -- allows you to use the mouse to click on squares so as to pick dice for.  Clicking repeatedly on the same square loops the die-faces / colors through an option cycle that has as many options as the value you set for the HOW-MANY-CHOICES slider.  For instance, if the slider is set to '3' and you are working with colors, clicking repeatedly on a single square will give the colors green, blue, pink, green, blue, pink, green, etc.
HIDE/REVEAL -- toggles between hiding and revealing the dice you picked. This function is useful when you pose a riddle to a friend and you do not want them to know what dice you chose.
SEARCH - activates the random search. The program generates random dice-faces and matches the outcome against the combination you had created.

Switches:
SINGLE-SUCCESS? -- stops the search after the combination has been matched once.
BARS?  -- toggles between two graphing options: ""On"" is a histogram, and ""Off"" gives a line graph.

Choices:
Analysis-Type --
- ""Permutations"" - That is, order does not matter, so '1 2 3' is considered the same as its permutation '3 2 1' (it is registered as a favored event)
-  ""Combination"" - That is, order matters, so '1 2 3' is not accepted as the same as its permutation '3 2 1' (it is not registered as a favored event)
-  ""Both"" - That is, the experiment will analyze outcomes from both the ""Permutations"" and ""Combination"" perspectives, and each will be represented in the plot.

Sliders:
SAMPLE-SIZE -- the number of dice rolls in a sample
TOTAL-SAMPLES -- the number of sample you are taking all in all in an experiment.

Monitors:
#SAMPLES -- shows how many samples have been taken up to this point in this experiment
+ OUTCOMES -- shows how many single outcomes have occurred within the current sample.
COMBINATION -- shows how many successes (hit guesses) the program has performed in this sample according to the conditions that order matters
PERMUTATIONS -- shows how many successes (hit guesses) the program has performed in this sample according to the conditions that order does not matter
MEAN-COMBINATIONS -- the sample mean of favored events according to the 'combination' interpretation, by which a favored event is only the exact combination you created.
MEAN-PERMUTATIONS -- the sample mean of favored events according to the 'permutations' interpretation, by which a favored event is either the exact combination you created or its reverse
COMBI : PERMIS -- shows the ratio between the mean values of the sample outcome distributions corresponding to the conditions 'combination' and 'permutation,' respectively. This monitor updates each time a sample has been completed.

Plots:
SUCCESSES-PER-SAMPLE DISTRIBUTION -- displays the count of the number of favored events (successes) per sample over all samples you have taken. For instance, if on the first five samples you have taken, the combination was matched 3 times, 2 times, 4 times, 7 times, and 4 times, then the ""Combinations"" histogram will be the same height over 2, 3, and 7, but it will be twice as higher over the 4, because 4 occurred twice.


THINGS TO NOTICE
----------------
As the experiment runs, the distributions of outcomes in the plots gradually take on a bell-shaped curve.

As the search procedure is running, look at the monitor #STEPS IN THIS SAMPLES. See how it is updating much faster than the monitor to its left, #SAMPLES.  The number in #SAMPLES increases by 1 each time #STEPS IN THIS SAMPLES reaches the number that is set in the slider SAMPLE SIZE.

As the search procedure is running, watch the monitors COMBINATION and PERMUTATIONS. Note whether or not they are updating their values at the same pace. For most combinations that you set, PERMUTATIONS updates much faster. This is because PERMUTATIONS registers a success each time the model hits on the set of colors / dice-faces you selected even if they appear in a different order form what you had selected.

As the search procedure is running, watch the monitor COMBI : PERMI ratio. At first, it changes rapidly, and then it changes less and less. Eventually, it seems to stabilize on some value. Why is this so?

Unless the red histogram ('Permutations') covers the black histogram ('Combination') entirely, you will see that the 'Permutations' histogram always becomes both wider and shorter than the 'combinations' histogram. Also, the 'Permutations' histogram (red) typically stretches over a greater range of values as compared to the 'combination' histogram (black).  We say of the wider histogram that it has a greater 'variance' as compared to the narrower histogram. Try to explain why the Permutations distribution has greater variance than the Combinations distribution.

Also, you may notice that the 'permutations' and 'combinations' histograms cover the same area. That is because the total area of each histogram, irrespective of their location along the horizontal axis and irrespective of their shape, indicates the number of samples they represent. We know that the two histograms represent the same number of samples. Therefore, they have the same area.


THINGS TO TRY
-------------
Run an experiment with a sample size of 20 and then run it with the same settings but with a sample size of 100 or more. In each case, look at the distribution of the SUCCESSES-PER-SAMPLE DISTRIBUTIONN. See how the experiment with the small sample resulted in half-a-bell curve, whereas the experiment with the larger sample results in a whole-bell curve. Why is this so?

Pressing HIDE/REVEAL after you create a combination allows you to setup an experiment for a friend to run. Your friend will not know what the combination is and will have to analyze the graphs and monitors to make an informed guess. You may find that some combinations are harder to guess than others. Why is this so? For instance, compare the case of the combination [1; 1] and [3; 4]. Is there any good way to figure out if we are dealing with a double or not? This question is also related to the following thing to try.

For certain dice you pick, if you run the search under the ""Both"" option of the ANALYSIS-TYPE choice, you will see only a single histogram in the SUCCESSES-PER-SAMPLE DISTRIBUTION plot. Try to pick dice that produce a single histogram, then try to find others. What do these dice pairs have in common? Why do you think you observe only a single histogram? Where is the other histogram? How do the monitors behave when you have a single histogram?

When the Combination and Permutations histograms do not overlap, we can speak of the distance between their means along the x-axis. Which element in the model can affect this distance between them? For instance, what should you do in order to get a bigger distance between these histograms? What makes for narrow histograms? Are they really narrower, or is it just because the maximum x-axis value is greater and so the histograms are ""crowded?""

Set the SAMPLE-SIZE at 360 and TOTAL-SAMPLES at its maximum value. Pick the dice [3; 4], and run the experiment. You will get a mean of about 10 for the Combination condition (in which order matters, so only [3; 4] is considered a favored event), and you will get a mean of about 20 for the Permutations condition (where the order does not matter, so both [3; 4] and [4; 3] are considered favored events). Why 10 and 20? There are 6*6=36 different dice pairs when we care for the order: [1; 1] [1; 2] [1; 3] [1; 4] [1; 5] ... [6; 4] [6; 5] [6; 6]. So samples of 36 rolls have on average a single occurrence of [3; 4] and a single occurrence of [4; 3]. Thus, samples of 360 have 10 times that: 10 occurrences of [3; 4] and 10 of [4; 3], on average.


EXTENDING THE MODEL
-------------------
A challenge: Add a 7th die face. Then you can run experiments with 7-sided dice!

Add a plot of the ratio between Combinations and Permutations.

Is the program searching for the dice you picked in the most efficient way? Think of more efficient search procedures and implement them in this model.

It should be interesting to track how long it takes the model from one success to another. Add code, monitors, and a plot to do so.

Following is an extension idea for applying this model towards thinking about search algorithms. Currently, the program guesses combinations randomly. This could be improved upon so that the program finds the combination in less guesses. For instance, the moment one of the squares has the correct die face, the program would continue guessing only the other die. Another idea might be to create a systematic search procedure.


RELATED MODELS
--------------
The ProbLab model Random Combinations and Permutations builds on Dice. There, you can work with more than just 2 dice at a time. Also, you can work with colors instead of dice faces.


NETLOGO FEATURES
----------------
An interesting feature of ""Dice,"" that does not appear in many other models, is the procedure for selecting a die's face value. To you, it is obvious that three dots means ""3,"" but the program doesn't ""know"" this unless you ""tell"" it. Each time you click on a die, Look in the Shapes Editor that is in the Tools dropdown menu. You will find six die shapes: 1, 2, 3, 4, 5, and 6. The names of these shapes form a list: [""one"" ""two"" ""three"" ""four"" ""five"" ""six""]. Each time you click on a die, a procedure maps between each name and the numerical value corresponding to it.


CREDITS AND REFERENCES
----------------------
This model is a part of the ProbLab curriculum. The ProbLab Curriculum is currently under development at Northwestern's Center for Connected Learning and Computer-Based Modeling. . For more information about the ProbLab Curriculum please refer to http://ccl.northwestern.edu/curriculum/ProbLab/.

To refer to this model in academic publications, please use:  Abrahamson, D. and Wilensky, U. (2004).  NetLogo Dice model.  http://ccl.northwestern.edu/netlogo/models/Dice.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2004 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Dice for terms of use.
"
Central Limit Theorem,/models/Sample Models/Mathematics/Probability/ProbLab/Unverified,"globals [
  sample-mean-list  ;; list of means of sample taken from the population
  sample-sum-list   ;; list of sums of sample totals
  regular-color     ;; color of specimens in the population
  chosen-color      ;; color of sampled specimens
  ranger            ;; holds value of range so that the range slider can be used for guessing
]

to setup
  ca
  set regular-color red + 3
  set chosen-color green
  set sample-mean-list []
  set sample-sum-list []
  ask patches [ set pcolor white - 2 ]
  create-x-line-labels
end

;; the View shows a ""picture bar chart."" Bottom patches display the 'x value"" of this chart
to create-x-line-labels
  ask patches with [pycor = min-pycor]
    [
      set plabel-color black
      ;; to avoid congestion of labels, we ask only every other patch to display a label
      if pxcor mod 2 = 1 [ set plabel ( pxcor + max-pxcor ) ]
    ]
end

to create-population ;; CREATE-RANDOM-PEOPLE
  setup
  set ranger range + 1

  ;; colors patches in the range white, others gray
  ask patches
  [
    ifelse pxcor <= ranger + min-pxcor - 1
      [ set pcolor white ]
      [ set pcolor white - 2 ]
  ]

  ;; creates for each column of patches, beginning from the left and moving to the end of the range,
  ;; a random number of specimens (""people""). These are stacked up.
  let counter min-pxcor
  let column-help 0

  ;; ranger is 1 more than range. We add 1 to the range, because the first ""x value"" is 0
  repeat ranger
  [
    set column-help random-pycor
    ask patches with [ (pxcor = counter) and (pycor > min-pycor)]
      [
        if pycor < column-help
          [ sprout-person ]
      ]
    set counter counter + 1
  ]
end

to sprout-person
   sprout 1 [
    set shape ""face neutral""
    set color regular-color ]
end

;; procedure allowing users to select columns where new specimens are created
to draw-your-own-people  ;; CREATE-MY-OWN-PEOPLE button
  ask patches [ set pcolor white]
  create-x-line-labels
  set ranger range + 1

  ;; we use a temp-mouse-xcor to avoid confusion when the user moves the mouse rapidly
  let temp-mouse-xcor ""N/A""
  ;; each column has a ""top-patch."" It will be the lowest patch that does not have a person turtle in it
  let top-patch ""N/A""

  ;; if there still is room for a new person in the column, a new person will appear just above the highest person there
  if mouse-down? [
      if not ( round mouse-ycor = min-pxcor ) [
      set temp-mouse-xcor mouse-xcor
      ;; locates the top-most patch, in the column where you click, that has a person in it, and assigns the patch above it
      ;; If there are no persons in the column, the top-patch is the bottom patch in the column
      ifelse any? patches with [ ( any? turtles-here ) and ( pxcor = round temp-mouse-xcor) ]
        [
          set top-patch patch (round temp-mouse-xcor)
            ;; we do not want to assign top-patch a pycor of a patch outside the world
             min list ( max-pycor )
                     (1 + max [ pycor ] of patches with [ ( any? turtles-here ) and ( pxcor = round temp-mouse-xcor) ] )
        ]
        [
          set top-patch patch (round temp-mouse-xcor) (1 + min-pycor)
        ]  ;; there is a possibility that the very top patch is already occupied, so in that case we do not create a new turtle
        ask top-patch [ if not any? turtles-here [ sprout-person ] ]
      ]
    ]
end

to go
  reset-turtles

  ;; we check to make sure that there are enough turtles to sample
  ifelse sample-size <= count turtles
  [
    ask n-of sample-size turtles
    [
      set shape ""face happy""
      set color chosen-color
    ]
  ]
  [
    user-message word ""There are not enough people to take a sample of this size.""
                      ""\n\nEither create more people or choose a smaller sample size""
    stop
  ]
  tick
  calculate-and-plot-sample-stuff
end

to reset-turtles
  ask turtles
  [
    set shape ""face neutral""
    set color regular-color
  ]
end

to calculate-and-plot-sample-stuff
  ;; gets the mean and the sum of the sample, then plots these
  ;; we add max-pxcor to compensate for the negative values of xcor
  let temp-mean mean [ xcor + max-pxcor ] of turtles with [ color = chosen-color ]
  set sample-mean-list ( lput temp-mean sample-mean-list )
  let temp-sum sum [ xcor + max-pxcor ] of turtles with [ color = chosen-color ]
  set sample-sum-list ( lput temp-sum sample-sum-list )

  ifelse also-sums?
  [
    ;; adjusts the range of the plot to include all the values from the sums list
    ;; There is a possibility that the maximum sum is less than the range, so we include it, too
    set-plot-x-range 0 (1 + max sentence sample-sum-list (ranger - 1) )
    set-current-plot-pen ""sums""
    histogram sample-sum-list
    ;; plots the histogram of the sums of sample means
    set-current-plot-pen ""sums-mean""
    plot-pen-reset
    plot-pen-up
    plotxy (mean sample-sum-list) 0
    plot-pen-down
    plotxy (mean sample-sum-list) plot-y-max
  ]
  [
    ;; clears the sums histogram and mean, then adjusts the range of the plot
    set-current-plot-pen ""sums""
    plot-pen-reset
    set-current-plot-pen ""sums-mean""
    plot-pen-reset
    set-plot-x-range 0 ranger
  ]

  ;; plots the histogram of the means of sample means as well as their mean
  set-current-plot-pen ""means""
  histogram sample-mean-list
  set-current-plot-pen ""means-mean""
  plot-pen-reset
  plot-pen-up
  plotxy (mean sample-mean-list) 0
  plot-pen-down
  plotxy (mean sample-mean-list) plot-y-max
end

;; the presets are suggested population distributions
to preset-setup
  setup
  set range 30
  set ranger range + 1
  ask patches [ set pcolor white]
end

to preset1
  preset-setup
  ask patches with [ (pycor > 0 + min-pycor) and (pycor < 0) ] [ sprout-person ]
end

to preset2
  preset-setup
  ask patches with [ (pycor > 0 + min-pycor) and
                     (pycor < min-pxcor + abs pxcor ) ] [ sprout-person ]
end

to preset3
  preset-setup
  ask patches with [ (pycor > 0 + min-pycor) and (pxcor mod 2 = 1) ] [ sprout-person ]
end

to preset4
  preset-setup
  ask patches with [ (pycor > 0 + min-pycor) and (abs pxcor = max-pxcor) ] [ sprout-person ]
end

to preset5
  preset-setup
  ask patches with [ (pycor > 0 + min-pycor) and (pycor < 2 + (- abs pxcor)) ] [ sprout-person ]
end

to preset6
  preset-setup
  ask patches with [ (pycor > 0 + min-pycor) and (pycor <  1 + pxcor) ] [ sprout-person ]
end

to-report std-dev-sums
  ifelse also-sums?
  [ report standard-deviation sample-sum-list ]
  [ report ""N/A"" ]
end

to-report expected-value
  ;; from each column of patches, we get the number of turtles multiplied by the patch's ""x-value""
  ;; Next, we calculate the mean of this list, to get the expected value of the population
  let columns-list [ ( count turtles with [ xcor = [pxcor] of myself ] ) * ( pxcor + max-pxcor ) ] of patches with [pycor = max-pycor]

  if show-EV? [ report (sum columns-list) / (count turtles ) ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2004 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Abrahamson, D. and Wilensky, U. (2004). NetLogo Central Limit Theorem model.
; http://ccl.northwestern.edu/netlogo/models/CentralLimitTheorem.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2004 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/CentralLimitTheorem
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This demonstrates relations between population distributions and their sample mean distributions as well as the affect of sample size on this relation. In this model, a population is distributed by some variable, for instance by their total assets in thousands of dollars. The population is distributed randomly -- not necessarily 'normally' -- but sample means from this population nevertheless accumulate in a distribution that approaches a normal curve. The program allows for repeated sampling of individual specimens in the population.

This model is a part of the ProbLab curriculum. The ProbLab curriculum is currently under development at the CCL. For more information about the ProbLab Curriculum please refer to http://ccl.northwestern.edu/curriculum/ProbLab/.


HOW IT WORKS
------------
Either the program or the user creates a population that ranges along some dimension, such as total assets. In the View, we see this population arranged in a ""picture bar chart."" For instance, poorer people are farther to the left, and richer people are farther to the right. Next, a group of individual specimens from this population is selected as a sample (these sampled people are painted in a different color). The program calculates the mean value of this sample -- their average assets -- and plots this mean in the histogram below the view. We can set the program to sample repeatedly, and we can observe the emergence of the distribution of sample means. We can also look at the corresponding histogram of the sums of the samples. This allows us to study the relation between the sums and the means in terms of properties of their distributions.


HOW TO USE IT
-------------
Press SETUP, and then press either CREATE RANDOM PEOPLE or CREATE MY OWN PEOPLE or just press one of the PRESET buttons. If you've created random people or if you have pressed one of the presets, you are now ready to press either GO ONCE or GO. But if you've pressed CREATE MY OWN PEOPLE, you now need to click on the View to create these people. Only then you should press either GO ONCE or GO. You can also vary the setting of the sliders. Watch results in the plot and explore relations between the settings and the results. If you'd like to guess the mean value of the sample means before you begin sampling, you can use the RANGE slider to indicate the location of this mean.

Buttons:
SETUP -- initialize variables
CREATE RANDOM PEOPLE -- activates SETUP and then creates a random population in the View
CREATE MY OWN PEOPLE -- allows the user to create persons by clicking on the View
PRESET 1 - PRESET 6 -- creates populations with special patterns of possible interest
GO ONCE -- marks a sample in the population and calculates and plot their mean value.
GO -- repeats GO ONCE indefinitely.

Sliders:
SAMPLER SIZE -- determines the number of specimens sampled at each run through the Go procedure
RANGE -- determines the range of values the members of the population can take.

Switches:
ALSO-SUMS? -- if set to ""On,"" the sums of the samples (and the means of these sums) is plotted as well as the means of the samples (and the mean of these means). If set to ""Off,"" only the means are plotted.
SHOW-EV? -- if set to ""On,"" the EXPECTED VALUE (EV) monitor will display a value

Monitors:
NUM-SAMPLES -- shows the total number of samples taken this the last 'setup.'
EXPECTED VALUE -- calculates the mean x-value of the population. For each column, the program calculates the product of the number of turtles and the x-value of that column. Next, all these products are summed up and divided by the total number of turtles.
STD-DEV-MEANS -- shows the standard deviation of the histogram of sample means. This is an index of how ""diffuse"" the distribution is. The smaller the number, the tighter (narrower, more clustered) is the distribution of sample means.
STD-DEV-MEANS -- shows the standard deviation of the histogram of sample sums.

Plots:
SAMPLE-MEAN DISTRIBUTION -- distribution of the mean values of all samples taken and the mean sum of all samples taken.


THINGS TO NOTICE
----------------
The property we are looking at is indexed by the ""x-value"" of the people in the bar chart that is in the View. A person's x-value can be seen in the numerical label at the bottom of its column in the view. For instance, the x-value of people in the left-most column is 0. There could, in principle, be no person with the x-value ""0,"" there could be a single person with that value, or there could be two or more. They all share the same value, because they are all in the same column.

Members of the population that turn green when you press GO or GO ONCE are the 'sample.' Their mean x-value, for instance, their savings, is plotted in the histogram below the view. For example, if a sample of three people is taken and their x-values are 7, 8, and 12, then the histogram column ""9"" will bump up by one unit, because 9 is the mean of 7, 8, and 12.

For some settings of the population, the more samples you take the more likely you are to get a rare sample. So the distribution you get after only a few samples is not necessarily reflective of all possible mean values.


THINGS TO TRY
-------------
Can you see any connections between the distribution of the population (in the graphics display window) and the mean value of the histogram (in the plot window)? For instance, if there happen to be more population specimens (""people"") on the left side of the range, where do you expect to see most of the sample means?

Try running the model with a SAMPLE-SIZE of just 1. What do you get. Now try with a SAMPLE-SIZE of 2. Has anything changed? How about a larger sample size?

Are there any connections between SAMPLE SIZE, RANGE, and STD-DEV? One way to explore this question is to keep two of these variables constant and examine what happens when you change the third variable. You may want to take an equal number of samples for each of these trials.

If you set the model to a sample size that is larger than the total size of the population, you will receive a message telling you cannot do this. However, you may set a sample size that is larger than most columns. This means that the entire sample cannot fit into those columns. Is this a problem? What does this do to the distribution of sample means?

Using the CREATE MY OWN PEOPLE option, build some ""unusual"" populations. Some of these have already been put into the PRESET buttons. For instance, you could create people only in one or two columns, or you could make the population ""U-shaped"" (more on the outside and less and less as you go towards the middle). What are your findings?

Again, using the CREATE MY OWN PEOPLE option, build one very tall column off on the right side of the view (about at x-value 8) and build a few very short columns. Set the SAMPLE-SIZE to 10. Press GO ONCE. What can you say about the number of persons that happened to be chosen from the tall column? Try this again and then press GO. Look at the plot. Do you see any connection between the chance of getting samples from the tall column and the location of the mean in the plot?

Set ALSO-SUMS? to ""On,"" and activate the program. Can you explain the similarities and differences between the two histograms you get? For instance, you can look at their range, the total area they cover, their height, and their shape. Try to explain the transformation between the two histograms. For instance, why is the histogram on the left taller than the histogram on the right? Look at the standard deviation of the means and of the sums. What is the ratio between these two values? Does this ratio relate to any other value in the settings of this model?

Relating to the two histograms, can you find a case in which the two histograms converge to a single histogram?

Press SETUP, press CREATE MY OWN PEOPLE and make 6 columns of the height 2 (two persons), set the sample size to 2, and set the ALSO-SUMS? to ""On."" Now press GO. It is interesting to compare between this statistics activity and a probability activity in which you are rolling a pair of dice. For instance, how many possible columns are there in the sums histogram? In fact, such a comparison can help us think through similarities and differences between statistics and probability.

What is the relation between the number of samples you take, the size of each sample, and the resulting distribution of sample means? For instance, if you have a budge to sample 1,000 people, should you take 10 samples of size 100 each or 100 samples of size 10 each? What do you gain and what do you, perhaps, lose, in each of these choices? For instance, in terms of confidence or in terms of information about the population you are sampling from. To explore this question, you may want to extend the range of the sample size. You may also want to resize the view so as to allow for more specimens in your population. Finally, it may be helpful to have a slider and corresponding code for controlling the total number of samples you are taking.


PEDAGOGICAL NOTE
----------------
The first thing to remember is that in reality we do not know the distribution of the population from which we are sampling. We only have the plot, so to speak. So as you are interacting with this model, you should recall that in applied statistics the Graphic Display does not exist. In this model, however, we are simulating the population -- as if we do know its distribution -- in order to understand the relation between population metrics and their sample means distributions.

You may have noticed that, almost regardless of the shape of your population, the histogram always eventually takes on a certain shape. This shape is called a ""normal curve"" or ""bell curve"" or ""bell-shaped curve."" We say that the histogram ""approaches"" the normal curve as one takes more and more samples. For special population distributions, we may get special cases of this curve. For instance, if you have created a population that has all the people in the same column, your histogram will be an extreme case of a bell curve -- it itself will consist only of a single column.

Often, people say that, ""a population is distributed...etc,"" but it could be that, sometimes, what they actually mean to say is that, ""the sample-means of the population are distributed...etc."" This does not imply that the second figure of speech is necessarily preferable, but only that we should understand the difference between these two ideas. In this model, the view shows how the population itself is distributed, whereas the plot shows how the sample means are distributed. Working with this model, one may be struck by the contrast between these two distributions.

The plot shows both the distribution of the sample means and the mean of these means. This mean of means converges on the expected value of sampling from this population. It can be calculated as the average x-value. That is, multiply the x and y values of each column, add these products, and divide the sum by the total number of data points (""persons""). For instance, if there are 3 persons over the 0 value, 2 persons over the 1 value, and 5 persons over the 2 value, the sum of the three x and y products is:
3*0 + 2*1 + 5*2 = 12. We now divide 12 by 10 (the total number of persons).
12 : 10 = 1.2. So if we sample from this population, the mean of the sample means will converge on 1.2. Try this. You can use the above example or any other example you invent.

The biggest challenge is to use this model so as to come up with an explanation of why, we almost always get a bell curve when we take enough samples.

Please note the following point of potential confusion. In order to enable close examination of the sampling process, the populations in this model contains fewer specimens than most populations that are commonly studied by researchers using statistical analysis. For instance, there might be no more than 5 individual specimens in a population who share the same x-value (that is, who are all in the same column). Therefore, a sample that is larger in size than the number of specimens in that column, say a sample of size 8, can never include specimens exclusively from that column. In ""real life,"" it could theoretically happen that an entire random sample is taken from a single column. This means that if you use large sample sizes you should expect to get narrower sample-mean distributions than what one would otherwise expect. For instance, if the left-most column is not tall enough to contain the entire sample, you will never receive a sample mean that is equal in value to the x-value of that column. This is because some of the sample will ""spill over"" to the right of that column, resulting in a greater sample mean. Because the same logic holds for samples taken from the far right, the sample mean values will be closer to the center than they would be for small samples sizes.


EXTENDING THE MODEL
-------------------
The current version of the model allows for repeated sampling of individual specimens. That means that if a person was selected randomly in the first sample, it can be sampled again in the second sample, etc. If we did not allow this repeated sampling, would the sample-mean distribution be affected at all? If so, how? Add code that allows the repeated sampling only as an option and compare the outcomes between the two options.

How do medians behave? The same way as means? Add an option to see the median of both the population and the sample data.

Add a monitor that shows the ratio between the two standard deviations represented in this model.

This model shows means and sums of sampled data. It may be interesting to look at other analyses of the samples. For instance, the product of all values of sampled people as well as the n-th root of this product (for a sample of size n).

How does the standard deviation change as we collect more and more samples? To examine this, you can add a plot of the standard deviation over ""time"" (over samples).


NETLOGO FEATURES
----------------
In the procedure TO DRAW we used a temporary variable, ""temp-mouse-xcor."" This variable assures that the program won't become ""confused."" Without this variable, the program might enter a clause in the IFELSE code that no longer satisfies what the user actually meant when s/he clicked with the mouse. This could occur, because the user is moving the mouse rapidly. So the program selects the IFELSE clause that is correct at that moment, but meanwhile the mouse click would already be some place else, and so the clause selection would no longer be suitable. The temporary variable avoids this by going through with the instructions as though the mouse were still clicked down where it had been a moment ago.

In the current version, you can create the population, but you cannot experiment with the sampling. Build a procedure that allows you to take your own samples.


RELATED MODELS
--------------
Several ProbLab models look at the emergence of bell-shaped curves through the accumulation of sample means. See, for example, Prob Graphs Basic and Random Basic Advanced. To look closer at the idea of expected value, see the models Expected Value and Expected Value Advanced.


CREDITS AND REFERENCES
----------------------
This model is a part of the ProbLab curriculum. The ProbLab Curriculum is currently under development at Northwestern's Center for Connected Learning and Computer-Based Modeling. . For more information about the ProbLab Curriculum please refer to http://ccl.northwestern.edu/curriculum/ProbLab/.

To refer to this model in academic publications, please use:  Abrahamson, D. and Wilensky, U. (2004).  NetLogo Central Limit Theorem model.  http://ccl.northwestern.edu/netlogo/models/CentralLimitTheorem.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2004 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/CentralLimitTheorem for terms of use.
"
Expected Value,/models/Sample Models/Mathematics/Probability/ProbLab/Unverified,"globals [
  ratio-list ; list of ratio-unit sliders
  my-sample-size ; keeps track of the original sample-size
  #patches ;; keeps the number of patches, so don't have to recalculate all the time

  ;; outputs that will be printed in the monitors
  expected-value-calculation
  expected-value
  ratio-monitor-list ; the ""% in Population"" monitors pick items from ratio-monitor-list

  the-little-guy ; wanders around picking tiles to turn over

  all-totals ; list of the totals from each run

  colors ; list of the colors given for each number of marbles

  target-color ; the default base color of the display

  little-guy-color ; the color of the little-guy
]

patches-own [ value index ] ; how many marbles are under the tile

breed [ outlines outline ]
breed [ little-guys little-guy ]

little-guys-own [ values ] ; list of numbers in the running total of the sample

to startup
  set expected-value-calculation """"
end

to setup
  ca
  set expected-value-calculation """"
  setup-misc-globals ; collects ratio-unit sliders, etc.
  ;;checks for all 0s
  if sum ratio-list = 0 [ user-message ""Cannot set all ratio-units sliders to 0""  stop ]
  setup-patches ; sets the values and colors of the patches
  setup-little-guy
  setup-monitors ; sets the global variables the monitors display
  setup-plots
end

to go
  clear-selection
  ask little-guys
  [
    get-ready-for-next-sample
    repeat my-sample-size
    [
      set values ( lput value values )
      select-patch
      let prev-heading heading
      fd 1
      rt one-of [ -90 0 90 ]
    ]
  ]
  set all-totals lput ( [sum values] of the-little-guy ) all-totals
  tick
  update-plots
end

;; collects ratio-unit sliders, sets colors, etc.
to setup-misc-globals
  set ratio-list ( list ratio-0-units
                        ratio-1-units
                        ratio-2-units
                        ratio-3-units
                        ratio-4-units
                        ratio-5-units
                        ratio-6-units )

  set my-sample-size sample-size
  set #patches count patches

  set all-totals []

  set little-guy-color 94

  ;; sets the range of patch colors from dark to light
  set target-color green
  set colors ( list (target-color - 4.5)
                    (target-color - 3)
                    (target-color - 1.5)
                     target-color
                    (target-color + 1.5)
                    (target-color + 3)
                    (target-color + 4.5) )
end

;; sets the values and colors of the patches
to setup-patches
  ;;makes all patches have no value
  ask patches [ set value -1 ]
  let cur-val 0

  ;;finds the number of patches of each type that need to be printed:
  ;;makes the percentages, multiplies them by the number of patches
  let list-of-nums map [? / (sum ratio-list) * #patches] ratio-list
  ;;rounds the numbers of patches with a specific value
  let r-list-of-nums map [round ?] list-of-nums

  ;;tweaks the values, either in the positive or in the negative direction,
  ;;for the sum to equal to the number of patches on the display
  let nums setup-patches-polish list-of-nums r-list-of-nums

  ;;prints out the values on random patches that are not already taken
  foreach nums
  [
    ask n-of ? patches with [ value = -1 ]
    [ set value cur-val ]
    set cur-val cur-val + 1
  ]

  ;;if population to be shown, shows in block, then scrambles
  ifelse setup-apart?
  [
    print-out nums
    wait 2
    repeat (#patches / 4) [ disperse ]
    ask patches [ set value position pcolor colors ]
  ]
  ;;colors the patches from their given values
  [ recolor-patches ]
end

;;tweaks the values so that they add up to the number of patches
;;(in the positive or negative direction)
to-report setup-patches-polish [ list-of-nums r-list-of-nums ]
  ;;tweaks the values, either in the positive or in the negative direction,
  ;;for the sum to equal to the number of patches on the display:
  ;;if the sum is below the number of patches, then searches for the highest remainder to round up
  while [sum r-list-of-nums < #patches]
  [
    let remainders map [remainder (? * #patches) #patches] list-of-nums
    ;;finds the position of the maximum remainder
    let pos-of-max position (max remainders) remainders
    ;;updates the list of numbers of each type of patch
    set r-list-of-nums (replace-item pos-of-max r-list-of-nums ((item pos-of-max r-list-of-nums) + 1))
    set list-of-nums (replace-item pos-of-max list-of-nums (floor (item pos-of-max list-of-nums) + 1))
  ]
  ;;if the sum is above the number of patches, then searches for the lowest remainder to round up
  ;;to prevent a bug that would make 0 always be the minimum remainder, all the 0's are changed
  ;;to large numbers, for them to not become negative
  while [sum r-list-of-nums > #patches]
  [
    let remainders map [remainder (? * #patches) #patches ] list-of-nums
    ;;remainders1 makes sure that the 0 is not deemed the minimum remainder, but
    ;;looks for minimum remainder above 0
    let remainders1 []
    foreach remainders
    [
      ifelse ? = 0
      [ set remainders1 (lput #patches remainders1) ]
      [ set remainders1 (lput ? remainders1) ]
    ]
    ;;finds the position of the minimum remainder
    let pos-of-min position (min remainders1) remainders1
    ;;updates the list of numbers of each type of patch
    set r-list-of-nums (replace-item pos-of-min r-list-of-nums ((item pos-of-min r-list-of-nums) - 1))
    set list-of-nums (replace-item pos-of-min list-of-nums (floor (item pos-of-min list-of-nums)))
  ]
  report r-list-of-nums
end

;;shows the populations separately
to print-out [ list-of-nums ]
  ;;indexes the patches (from left to right, down to up), if had not already done so
  ask patches [ set index ((pxcor + max-pxcor) * (max-pxcor * 2 + 1) + (pycor + max-pycor)) ]

  ;;shows the separated populations
  let patch-now 0
  let temp 0
  foreach list-of-nums
  [
    repeat ?
    [
      ask patches with [index = patch-now] [ set pcolor item temp colors ]
      set patch-now patch-now + 1
    ]
    set temp temp + 1
  ]
end

;;asks all the patches to switch its color with one of its neighbors
to disperse
  ask patches
  [
    let other-patch one-of neighbors4
    let temp-color pcolor
    set pcolor [pcolor] of other-patch
    ask other-patch [ set pcolor temp-color ]
  ]
end

;;colors the patches according to their value
to recolor-patches
  ifelse black-out? [ ask patches [ set pcolor 0 ] ] [ ask patches [ set pcolor item value colors ] ]
end

to setup-little-guy
  create-little-guys 1 [
    hide-turtle
    set color little-guy-color
    set shape ""person""
    move-to one-of patches
    face one-of neighbors4
    set values []
    show-turtle
  ]
  set the-little-guy one-of little-guys
end

;; sets the global variables the monitors display
to setup-monitors
  ;; the ""% in Population"" monitors pick items from ratio-monitor-list
  set ratio-monitor-list map [(word ? ""/"" (sum ratio-list) "" = ""
                                    precision (100 * ? / (sum ratio-list)) 1
                                    ""%"")]
                             ratio-list
  set expected-value  my-sample-size * sum map [ ? * item ? ratio-list / (sum ratio-list) ]
                                           [ 0 1 2 3 4 5 6 ]
  set expected-value-calculation word my-sample-size "" * (""
  foreach [ 0 1 2 3 4 5 ] [
    set expected-value-calculation (word expected-value-calculation
                                         ? "" * "" item ? ratio-list ""/"" (sum ratio-list) "" + "")
  ]
  ;; we separated out the ""6 case"" because we don't add a ""+"", but we do add a "") =""
  set expected-value-calculation (word expected-value-calculation
                                       6 "" * "" item 6 ratio-list ""/"" (sum ratio-list) "") = "")
end

to setup-plots
  ;; makes a line on the graph, signifying the theoretical expected value
  set-current-plot ""Cumulative Mean""
  set-plot-y-range round expected-value - 10  round expected-value + 10
  set-current-plot-pen ""Expected Value""
  plotxy plot-x-min expected-value
  plotxy plot-x-max expected-value
  set-current-plot ""Sample Totals""
  set-current-plot-pen ""Expected Value""
  plot-vert-line expected-value
end

;; clears the red from the patches chosen before
to clear-selection
  recolor-patches
  ask turtles with [ breed = outlines ] [ die ]
end

to get-ready-for-next-sample ;; little-guy procedure
  slide-to-random-patch
  face one-of neighbors4
  set values []
end

to slide-to-random-patch ;; little-guy procedure
  let random-patch one-of patches
  while [ patch-here != random-patch ] [
    face random-patch
    fd 1
  ]
  setxy pxcor pycor
end

;; highlights the point given to it
to select-patch ;; little-guy procedure
  let shapes-list (list ""outline""
                        ""outline1""
                        ""outline2""
                        ""outline3""
                        ""outline4""
                        ""outline5""
                        ""outline6"")
  ask patch-here
  [
    set pcolor item value colors
    sprout 1
    [
      set breed outlines
      ;; set the shape and label correctly.
      ifelse die-nums?
      [
        ;; if die-nums? the shape holds the value and there are no labels
        set shape (item value shapes-list)
      ]
      [
        ;; if not die-nums? the shape doesn't hold the label, so set the label
        set shape ""outline""
        ;; sets label color to be opposite color in the list of colors
        set label-color item ((value + 2) mod length colors) colors
        ;; the "" "" on the end pushes the label into the middle of the patch
        set label word value "" ""
      ]
    ]
  ]
end

;; plots the different sample totals and the average sample total
to update-plots
  ;; plots the sample totals
  set-current-plot ""Sample Totals""
  ;; changes range
  if length all-totals > 0 and length all-totals mod 20 = 0
  [
    set-plot-x-range min all-totals max all-totals + 1
  ]
  set-current-plot-pen ""Sample Count""
  plot-pen-reset
  histogram all-totals
  ;;plots the ""average"" line
  set-current-plot-pen ""Mean""
  plot-pen-reset
  plot-vert-line ((sum all-totals) / (length all-totals))
  ;;plots the expected value
  set-current-plot-pen ""Expected Value""
  plot-pen-reset
  plot-vert-line expected-value

  ;; plots the mean, continuing the ""expected value"" line
  set-current-plot ""Cumulative Mean""
  set-current-plot-pen ""Average""
  plot sum all-totals / length all-totals
  set-current-plot-pen ""Expected Value""
  if length all-totals > 10 [ plot expected-value ]
end

to plot-vert-line [ x-coord ]
  plotxy x-coord plot-y-min
  plot-pen-down
  plotxy x-coord plot-y-max
  plot-pen-up
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2004 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Abrahamson, D. and Wilensky, U. (2004). NetLogo Expected Value model.
; http://ccl.northwestern.edu/netlogo/models/ExpectedValue.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2004 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/ExpectedValue
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
In this model you run experiments that demonstrate the mathematical idea ""expected value"" (sometimes called ""expectation value""). There is a set of different possible outcomes, and each of these outcomes has a different value. The model predicts the expected value based on the probabilities of each of these outcomes. The user can then take samples from the population and compare them to the values predicted by the model.

This model is a part of the ProbLab curriculum. The ProbLab Curriculum is currently under development at the CCL. For more information about the ProbLab Curriculum please refer to http://ccl.northwestern.edu/curriculum/ProbLab/.


PEDAGOGICAL NOTE
----------------
Expected-value analyses look at the 'value' of outcomes in probability experiments in terms of some utilitarian framework, such as money or points. As in life, some events are more significant to us, not just because they happen rarely or often. In that sense, expected-value simulations go beyond looking just at chance -- they introduces a 'worth' factor (weight, coefficient) associated with each type of experimental outcome. That is, these simulations examine not only the issue of what I should expect, but also, what it would be worth for me.  For instance, if I draw 12 coins randomly from a sack containing an equal number of pennies, nickels, dimes, and quarters, we could talk about which 12 'coins' I could expect to get (a nominal classification) -- 3 'pennies,' 3 'nickels,' 3 'dimes,' and 3 'quarters,' on average. But we could extend the discussion to how much money I would get, that is, what would be the 'value' of my draw. To do this, we'd have to multiply the expected frequency of each type of coin by its value:
3 * 1 + 3 * 5 + 3 * 10 + 3 * 25 = 123 cents.

A more general way of putting this all together -- the sample size (12), the probabilities of each coin (1/4 for each of them), and the value of each coin (1, 5, 10, and 25) -- is:
12 * (1 * 1/4 + 5 * 1/4 + 10 * 1/4 + 25 * 1/4) = 123 cents.

Thus, the term 'expected value' may be defined as the sum of the products of the value of each possible event and the probability of that possible event.


HOW IT WORKS
------------
The analogy utilized for the model is one of a tiled playground, with a certain number of marbles beneath each tile (0, 1, 2, 3, 4, 5 or 6 marbles).  A wandering kid flips up some tiles at every go and counts up the marbles found beneath the tiles. That's a ""sample.""  The kid cannot see the color of the tiles -- the colors are for us.

The idea of 'expected value' is that if we know how many tiles have 0, 1, 2,... or 6 marbles beneath them, then we can formulate an educated guess of how many marbles the wandering kid will find, on average. It's similar to asking, 'How many marbles are there on average under each tile?' We need to somehow take into account the chance of getting each one of the marble sets.

In the setting-up phase of using this model, you get to set up the relative number of tiles hiding 0 marbles, 1 marble, 2 marbles, ... and 6 marbles. We set the ratio between the number of tiles hiding each set of marbles. The computer program will do much of the calculations for us, but here's the gist of what it does:

Let's say that we set the sliders to the following ratio units: 0 : 1 : 6 : 5 : 0 : 4 : 0.

The number '5,' for example, indicates our value setting for marble sets of exactly 3 marbles. You can see immediately that the chance of getting a '2' (6 ratio units) is greater than the chance of getting a '3' (5 ratio units). But in order to determine just how big the chance is of getting each marble set, we need to state the ratio units relative to each other. We need a common denominator. In this particular setting, there is a total of 16 'ratio units': 0 + 1 + 6 + 5 + 0 + 4 + 0 = 16.  Now we can say, for instance, that there is a 4/16 chance of getting a 5-marble set. That is a 25% chance of striking upon a tile that has exactly 5 marbles beneath it. We can also say that these sets of 5 marbles contribute .25 * 5, that is, 1.25 marbles, to the overall average marble-value of a single tile in the playground. Similarly, we can say there is a 5/16 chance of getting a set of 3, a 0/16 chance of getting 6-marble set, etc. If we sum up all pairs of 'value' and 'probability,' we get:
(0 * 0/16) + (1 * 1/16) + (2 * 6/16) + (3 * 5/16) + (4 * 0/16) + (5 * 4/16) + (6 * 0/16) = 48/16 = 3 marbles per tile.

This tells us that on any single pick within these settings, you should expect to find, on average, 3 marbles. ""3"" is our expected value. Thus, if you were to flip over 10 tiles, you should expect to find a total of 30 marbles.


HOW TO USE IT
-------------
Begin by choosing ratios of marble sets (or just use the default settings). Click SETUP, and watch the information updated in the view. Below are more features of the models that will let you change the way it looks and runs.

Sliders:
RATIO-0-UNITS, RATIO-1-UNITS, RATIO-2-UNITS, RATIO-3-UNITS, RATIO-4-UNITS, RATIO-5-UNITS, RATIO-6-UNITS -- settings for the distribution of 'marble sets' (= 'points'). Note that the ratios are set in proportion to each other (See 'THINGS TO TRY'). (The labels under the sliders let the user know that the highest value is the lightest tile color, while the lowest value is the darkest tile color.)

SAMPLE-SIZE -- sets the number of tiles selected by the wandering kid at each run.  Note that the kid can turn over the same tile more than once. This won't be visible in the view.

Switches:
SETUP-APART? -- if 'On,' when SETUP is pressed, the display initially separates the population by point value, to illustrate the relative number of patches of different values.  After a 3 second pause, the model scrambles the populations, producing a randomized display.

DIE-NUMS? -- if 'On,' you will see the marbles and not only colors, when the tiles are flipped over; if 'Off,' you'll see the colors and the numerical value assigned to them.

BLACK-OUT? -- if 'On,' you will only see the tiles the kid selected in the present sample; if 'Off,' you will always see all the tiles. In any case, the kid does not see the colors. The 'black-out' feature makes this model more coherent with S.A.M.P.L.E.R., a participatory simulation in ProbLab.

Buttons:
SETUP -- initializes variables, re-colors the tiles, and resets the monitors and the graphs.

GO ONCE -- picks a starting point randomly among the tiles in the view, sends the kid for a single run over random tiles, counts up the total number of marbles found, and graphs this total, that is, 'bumps up' the histogram at the corresponding value.

CLEAR SELECTION -- re-covers the tiles that have been flipped (does not re-initialize variables).

GO -- does everything that the GO ONCE button does, but over and over, until turned off, that is, until you press on it again.

Monitors:
% IN POPULATION -- shows the distribution percentage of each marble-set in the population, including the calculation that illustrates how that percentage was obtained. For instance, if the RATIO-3-UNITS's % IN POPULATION monitor is at 50%, then roughly half of all the tiles will have exactly 3 marbles beneath them.

EXPECTATION VALUE CALCULATION -- This monitor shows the calculation of the expected number of marbles that the kid will find beneath all the tiles the kid flips in a sample. The calculation first determines the value of the 'average tile' and then multiplies this value by the number of tiles in the kid's sample (how many tiles the kid flips). Thus, 'average value' * 'sample-size' = total expected value of sample. The formula for the expectation calculation is:
sample-size * (0 * (ratio-0-units / ratios-total) + 1 * (ratio-1-units / ratios-total) + 2 * (ratio-2-units / ratios-total) + 3 * (ratio-3-units / ratios-total) + 4 * (ratio-4-units / ratios-total) + 5 * (ratio-5-units / ratios-total) + 6 * (ratio-6-units / ratios-total))

EXPECTED VALUE -- shows the result of the EXPECTED VALUE CALCULATION

MEAN OF SAMPLES-- monitors the cumulative average number of points obtained in a sample (so it keeps updating for each sample).

# OF RUNS -- monitors the number of times the tiles were selected and counted as a sample.

POINT TOTAL -- monitors the total number of marbles in the current sample. (updates the total as each tile is selected).

Plots:
SAMPLE TOTALS -- plots the frequency of each point-total of a run.  The green vertical line represents the average sample total, while the red vertical line represents the expected sample total.

CUMULATIVE MEAN -- plots the average number of points obtained in a single run in black against the expected value in red.


THINGS TO NOTICE
----------------
If the model is slowed down, using the bar on top of the display, one may see that the sample total is added on every time that the wandering kid selects another tile. Thus, one may monitor the running total for the current run of the kid.

A feature of this model is that the wandering kid may resample the same tiles during a single run. While the kid cannot go back to a tile it just selected, it can potentially go in a circle and come back to such a tile. This may skew the average away from the expected value, which does not account for such re-sampling (see 'EXTENDING THE MODEL,' below).


THINGS TO TRY
-------------
Run the model under different setting of the three switches.  Why does DIE-NUMS? help
one visualize the model better in some situations and under some settings, while not
in others?

The relative ratios of the various marble sets are determined by relative values of all of the sliders on the left.  In other words, if one sets RATIO-0-UNIT : RATIO-2-UNITS : ..., : RATIO-6-UNITS to 1 : 1 : 1 : 1 : 1 : 1 : 1, it is going to mean the same to the computer as the setting of 2 : 2 : 2 : 2 : 2 : 2 : 2 or 5 : 5 : 5 : 5 : 5 : 5 : 5.  The sliders are designed to allow an exploration of a rich range of proportions of the different marble sets.  Try extending the maximum value of the RATIO sliders, to obtain a richer range of proportions of marble sets.

Change the target-color to some color other than green. Change the 'little-guy-color,' which alters the color of the wandering kid.

Set the ratio-0-units to 0. Set all the other ratio sliders to some value, for instance 2. (It doesn't matter which, as long as they are the same.) Press SETUP. The model now simulates the sample space of dice, which do not have a '0,' and for which each 1-thru-6 value is equally likely to occur.

Set the ratios of the 0 and 1 to some non-zero value. Set the ratios of 2, 3, 4, 5 and 6 to 0. Press SETUP. This produces a sample space of a Boolean type ('true' or 'false'). This sample space would be coherent with the S.A.M.P.L.E.R. model of ProbLab, where tiles are either green (true) or blue (false), without in-between values.

Set the ratios of 5 and 6 to 0. Set the other ratios to non-zero values. Press SETUP. The model produces a sample space that could be seen as a tessellation of '4-blocks,' which appear in the 9-Block Stalagmite model of ProbLab. In that model, blocks have either 0, 1, 2, 3, or all 4 squares with the target-color.


EXTENDING THE MODEL
-------------------
Add and change code so that the wandering kid cannot re-sample within a single sample.

Add and change code so that the wandering kid cannot re-sample within a single run of many samples.

Add a monitor that show the % difference between the expected value and the mean of samples.

Add another unit-value slider. It could for 7, so you'd need to create a die shape with 7 dots on it and integrate that die shape and its name into the lists in the code. You could possibly create a 'negative value,' which could be interpreted as an added expense, like owing marbles.


RELATED MODELS
--------------
This model is closely related to a variety of models in the ProbLab curriculum. As described in the 'THINGS TO TRY' section, one may set the ratios up so that they mirror the sample population of other models in the curriculum, including 9-Block Stalagmite and S.A.M.P.L.E.R. For instance, if one sets BLACK-OUT? to 'On,' this model would produce an effect that is similar to that of S.A.M.P.L.E.R., where one chooses a certain number of tiles and doesn't see any of the other tiles in the population.


CREDITS AND REFERENCES
----------------------
This model is a part of the ProbLab curriculum. The ProbLab Curriculum is currently under development at Northwestern's Center for Connected Learning and Computer-Based Modeling. . For more information about the ProbLab Curriculum please refer to http://ccl.northwestern.edu/curriculum/ProbLab/.

To refer to this model in academic publications, please use:  Abrahamson, D. and Wilensky, U. (2004).  NetLogo Expected Value model.  http://ccl.northwestern.edu/netlogo/models/ExpectedValue.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2004 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/ExpectedValue for terms of use.
"
Equidistant Probability,/models/Sample Models/Mathematics/Probability/ProbLab/Unverified,"breed [ wanderers wanderer ]    ;; turtles in Equidistant-Point that walk out from green patches
breed [ darts dart ]           ;; turtles in Epicenter: They all emerge from the middle

globals
[
  num-squares                  ;; number of selected squares (patches) from which wanderers emerge
  attempts                     ;; number of times the wanderers have attempted to convene on the same patch since the previous success
  attempts-list                ;; list of how many attempts it took until a success
  successes-per-this-sample    ;; how many successes occurred in the current sample of attempts
  successes-per-sample-list    ;; list of how many successes occurred in all samples up to the current moment
  successful-attempt?          ;; Boolean variable that is true if an attempt was successful
]

patches-own
[
  counter      ;; in Epicenter, this variable keeps track of how many times darts have visited the patch
  pmy-color    ;; ""reminds"" patches of their color from before it is temporarily changed
  conventions  ;; how many times all the wanderers meet in the patch
]

;; SETTING UP THE MODEL

to setup
  ca
  set attempts-list []
  set successes-per-sample-list []
  set successful-attempt? false
  checker
end

;; creates the 9-by-9 ""chess-board"" appearance of the view with a blue perimeter
to checker
  ask patches
  [
    ;; even patches and odd patches
    ifelse ( pxcor mod 2  = pycor mod 2 )
    [ set pcolor 3 ]
    [ set pcolor 7 ]
    if count neighbors != 8 [ set pcolor 104 ]
    set pmy-color pcolor
  ]
end

;; user uses mouse to paint squares red
to select-squares
  if mouse-down?
  [
    ask patch round mouse-xcor round mouse-ycor
    [
      if pcolor = 104 [ stop ]
      ifelse pcolor = red
      [ set pcolor pmy-color ]
      [ set pcolor red ]
    ]
    wait .2 ;; to give the user a chance to retract his/her clicking finger
    set num-squares count patches with [ pcolor = red ]
  ]
end

;; some preset suggestions for setting up the squares
to preset1 ;; two abutters
  setup
  ask patch 0 1 [ set pcolor red ]
  ask patch 0 -1 [ set pcolor red ]
  set num-squares 2
end

to preset2 ;; two corners
  setup
  ask patch -1 1 [ set pcolor red ]
  ask patch 1 -1 [ set pcolor red ]
  set num-squares 2
end

to preset3 ;; three abutters -- mean #attempt to success will be 1/ (6*6*6) =1/216
  setup
  ask patch 1 0 [ set pcolor red ]
  ask patch 0 -1 [ set pcolor red ]
  ask patch -1 0 [ set pcolor red ]
  set num-squares 3
end

to preset4 ;; two abutters, one corner -- mean #attempt to success will be 1/ (6*6*12) =1/432
  setup
  ask patch 1 0 [ set pcolor red ]
  ask patch 0 -1 [ set pcolor red ]
  ask patch -1 1 [ set pcolor red ]
  set num-squares 3
end

to preset5 ;; one abutter, two corners -- mean #attempt to success will be 1/ (6*12*12) =1/864
  setup
  ask patch 1 0 [ set pcolor red ]
  ask patch -1 -1 [ set pcolor red ]
  ask patch -1 1 [ set pcolor red ]
  set num-squares 3
end

to preset6 ;; three corners -- mean #attempt to success will be 1/ (12*12*12) =1/1728
  setup
  ask patch 1 -1 [ set pcolor red ]
  ask patch -1 -1 [ set pcolor red ]
  ask patch -1 1 [ set pcolor red ]
  set num-squares 3
end

;; RUNNING THE MODEL

;; from every red square a wanderer emerges, heads off randomly, and steps forward one step
to find-equidistant-point
  if num-squares < 2 [ stop ]
  if single-success? and successful-attempt? [ set successful-attempt? false stop ]
  set attempts attempts + 1
  birth-wanderers
  sprint-straight
  update-sampling-data
end

to birth-wanderers
ask patches with [pcolor = red]
  [
    sprout-wanderers 1
    [
      set color magenta
    ]
  ]
end

;; if there are as many turtles on the same patch as there are red squares, then that means that all
;; our wanderers have convened together. This patch is equidistant from all red squares because
;; all wanderers have traveled as far over the same time.
to sprint-straight
  if not any? wanderers [ stop ]
  ask wanderers [ fd 1 ]
  if any? patches with [ ( pcolor != 104 ) and ( count wanderers-here = num-squares ) ]
  [
    set successful-attempt? true
    ask patches with [ ( pcolor != 104 ) and ( count wanderers-here = num-squares ) ]
      [set conventions conventions + 1]
    update-labels
    do-plots
  ]
  ask wanderers [ die ] ;; because we need to start a new attempt now
end

to update-labels
  ask patches with [ conventions != 0 ]
  [
    set pcolor green
    set plabel word precision ( 100 * conventions / ( sum attempts-list + attempts ) ) 2 ""%""
  ]
end

to do-plots
  set attempts-list ( fput attempts attempts-list )
  set-current-plot ""Attempts Until Success""
  set-plot-x-range 0 ( max attempts-list + 1 )
  set-current-plot-pen ""attempts until success""
  histogram attempts-list
  set-current-plot-pen ""mean attempts""
  plot-pen-reset
  plotxy (mean attempts-list) plot-y-min
  plotxy (mean attempts-list) plot-y-max
  set attempts 0
end

;; updates each time a sample has ended running
to update-sampling-data
  if ( sum attempts-list + attempts ) mod sample-size = 0 ;; if the number of attempts is a multiple of sample size
  [
    ;; finds increment in successes since last sampling point.
    ;; note that the length of a list here is in effect how many times the list
    ;; was updated, that is, how many times whatever it is listing actually happened
    set successes-per-this-sample ( length attempts-list - sum successes-per-sample-list )
    set successes-per-sample-list ( fput successes-per-this-sample successes-per-sample-list )
    set-current-plot ""#Successes Per Sample""
    if not empty? ( remove 0 successes-per-sample-list )
      [ set-plot-x-range 0 ( max successes-per-sample-list + 1 ) ]
    set-current-plot-pen ""#Successes Per Sample""
    histogram successes-per-sample-list
    set-current-plot-pen ""mean-successes-per-sample""
    plot-pen-reset
    plotxy ( mean successes-per-sample-list ) plot-y-min
    plotxy ( mean successes-per-sample-list ) plot-y-max
  ]
end

to-report cumulative-frequency
  let cum-probab precision (100 * (length attempts-list / (sum attempts-list + attempts))) 2
  report word cum-probab "" %""
end

to-report samples-count
  let total-attempts ( sum attempts-list + attempts )
  let total-samples floor ( total-attempts / sample-size )
  report (word total-samples "" samples + ""
               ( total-attempts - total-samples * sample-size )
               "" attempts this sample"")
end

to epicenter
  setup ; same setup as used in Equidistant-Point
  ask patch 0 0 [ if pcolor != red [ set pcolor red ] ]
  birth-darts
  move-dart
  ask darts [ die ]
  label-results
end

to birth-darts
  create-darts 10000
    [ set size .5 ]
end

to move-dart ;; the patches keep track of their visits
  ask darts [ fd 1 ]
  ask patches [ set counter counter + count turtles-here ]
end

to label-results
  let helper sum [ counter ] of patches
  ask patches with [ ( pcolor != 104 ) and ( pcolor != red ) ]
  [
    set plabel-color pcolor + 5
    ifelse Display-Results = ""by-%""
      [ set plabel word precision ( 100 * counter / helper) 2 ""%"" ]
      [ set plabel precision counter 0 ]
  ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2004 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Abrahamson, D. and Wilensky, U. (2004). NetLogo Equidistant Probability model.
; http://ccl.northwestern.edu/netlogo/models/EquidistantProbability.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2004 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/EquidistantProbability
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
Equidistant Probability connects between probability and geometry. You select two or more squares, and the model searches randomly for squares that are equally distant from the squares you selected. To do this random search, creatures pop out of each one of your selected squares and simultaneously step forward one step in some random direction. If they all land in the same square, that's a hit. Can you guess how often this will happen?

This model is a part of the ProbLab curriculum. The ProbLab curriculum is currently under development at the CCL. For more information about the ProbLab curriculum please refer to http://ccl.northwestern.edu/curriculum/ProbLab/.


HOW IT WORKS
------------
The user sets up an experiment by selecting some squares on the view. When the model runs, from each of these selected squares emerges a creature, headed in a random direction, and then all these creatures step forward at the same moment. Because there are exactly as many creatures as there are selected squares, and because they all step forward at the same moment, if all the creatures arrive at the same square at the same moment, then that square is ""equidistant"" (equally far away) from all the selected squares. In that case, the square where they all landed becomes green and keeps a count of how often, out of all their ""attempts,"" the creatures met there. Note that the creatures don't need to land on the exact same spot in the view (the same pixel) -- it's enough that they land in the same square.

There is a procedure in this model, ""Epicenter,"" that helps think about how often a single creature might land in its neighboring squares. If we knew that, we might be able to figure out how often two or more creatures might land on the same square at the same time. For instance, if one creature has a 1-in-2 chance of landing on some square, and another creature has a 1-in-3 chance of landing on that same square, then there's a 1-in-6 chance that they will land on that square at the same moment. In this procedure, 10,000 creatures pop out of the middle square and take a step forward in some random direction. The other eight squares count up how many creatures landed on them, and these values are shown either as totals or as percentages.



HOW TO USE IT
-------------
Here is a quick way to get familiar with the model. Press ""PRESET1,"" slow down the model (using the slider on the top-left corner of the view), make sure SINGLE-SUCCESS? is at ""Off,"" then press FIND EQUIDISTANT POINT. Watch how two creatures first emerge, each from its red square, and then step one step forward in some random direction. Once you understand this, speed up the model gradually. Quite soon, the creatures will land on the same square at the same time, that square will become green, and it will display a percentage, for instance 5.00% (that is, 1/20). That would mean that it took 20 attempts to find that square. Also, the plot ATTEMPTS UNTIL SUCCESS will show a histogram bar at ""20,"" and the average that is, simply, ""20"" at this time. Also, the monitor below the plot, MEAN ATTEMPTS TO SUCCESS, will show ""20."" Now press FIND EQUIDISTANT POINT again. It could be that a different square will be found this time. The plot and monitor will update, again. If you switch the SINGLE-SUCCESS switch to ""Off"" and press FIND EQUIDISTANT POINT, the model will keep searching and finding. Watch the monitor SAMPLES TAKEN UP TO NOW to see how many attempts have been taken towards completing a sample (the default setting of SAMPLE-SIZE is 1,000). Once a sample has been completed, the plot #SUCCESSES PER SAMPLE will show how many successful attempts there were in that sample.

Buttons:
SETUP -- initialize variables
SELECT SQUARE -- once you press this, you can click on the view to choose squares that become red. If you click again on a red square, it will be un-selected. When you are through with selecting, un-press the button so as not to make further selections by mistake while the model is running.
FIND EQUIDISTANT POINT -- sets off the search procedures. From every red square, dart-like creatures pop up, each headed at some random direction, and then they step forward.
PRESET 1 through 6 -- each 'Preset' button sets the model up with a pre-selected configuration of red squares.
EPICENTER -- activates a procedure in which 10,000 turtles emerge from the center square at random orientations, and all step forward a single step. Pressing this causes you to lose all data from an experiment that you may have been running.

Switches:
SINGLE-SUCCESS -- when ""On"", the procedure FIND EQUIDISTANT POINT will stop the moment a square has been found that is equally distant from the red squares. When ""Off"", the procedure will continue again and again, until you un-press FIND EQUIDISTANT POINT.

Monitors:
#SUCCESSES -- shows how many successes you have had in this experiment, that is, how many times all the creatures landed at the same time in one and the same square.
#ATTEMPTS  -- shows how many attempts you have had in this experiment, that is, how many times all the creatures have ""tried"" to land at the same time in one and the same square.
FREQUENCY -- how many successes there have been out of the total number of attempts, expressed as a percentage. This can never be larger than 100 because there cannot be more successes than there are attempts.
SAMPLES TAKEN UP TO NOW -- shows how many samples have been completed, for instance of 1,000 attempts each, and how many attempts have been taken in the current sample.

Plots:
ATTEMPTS UNTIL SUCCESS -- a histogram that updates each time an equidistant square is found, to show how many attempts were needed to find that square.

SUCCESSES PER SAMPLE -- a histogram that updates each time a sample has been completed, for instance of 1,000 attempts, to show how many successes there were in that sample.


Choice:
DISPLAY RESULTS (relates to the 'Epicenter' button)
'by-total' -- squares show the number of creatures that landed on them.
'by-%' -- squares show the percentage of creatures that landed on them out of all landings.


THINGS TO NOTICE
----------------
The creatures' steps are equal in length to the side of a square. If a creature has just emerged in the middle of a square and is heading at 90 degrees, then the step forward will land it at exactly the middle of the square to its right. But if it's headed at 45 degrees, then the step forward will put it in the square that is diagonally neighboring it on the top right, short of the middle of that square.

The values of 'Frequency' and 'Mean #Attempts to Success' are reciprocal:
- Frequency is what you get when you divide #Successes by #Attempts
- Mean #Attempts to Success is what you get by dividing #Attempts by #Successes.
So if you multiply these values, you get 1 (or 100, if you ignore the ""%"" sign).

For Presets 1 and 2, the creatures will find more than a single square that is equally distant from the red squares. But for Presents 3, 4, 5, and 6, they will only find one such square.

When you press EPICENTER with the choice set at ""by-%,"" the percentages you get are such that the North/West/South/East squares each has roughly 1/6 of the creatures (16.7%), and the cornering patches each has 1/12 of the creature (8.33%).


THINGS TO TRY
-------------
Set the model with Preset1 and run the model with SINGLE-SUCCESS? set to ""Off."" Note that the middle square will register four times as many successes as compared to the center-left square and as compared to the center-right square. Try to come up with a logical explanation for this.

Set the model with Preset3 and run the model with SINGLE-SUCCESS? set to ""Off."" Track the values you get in the monitor MEAN #ATTEMPTS TO SUCCESS. Try to find a different selection of squares that gives the same value. What does this selection have in common with the Preset3 selection? Repeat this for the preset conditions 4, 5, and 6.

A very big challenge: The experiments in this model are all based on random choices. After enough attempts, the results begin to stabilize around certain values. Can you determine what these numbers will be before you run an experiment? For instance, can you anticipate the value of MEAN #ATTEMPTS TO SUCCESS on the basis of the configuration of squares that you have selected? To do this, you could think about the information you get from the ""Epicenter"" procedure. Also, you may want to analyze this problem using pencil and paper.


EXTENDING THE MODEL
-------------------
Add a plot for the cumulative ratio of '#Successes' to '#Attempts.' The plot should update at every attempt.

Edit the size of the view so as to include more squares. You will be able to create configurations that you could not create before.

For the ""Epicenter"" procedure, increase the number of squares in the view. Add interface widgets and code that allow for broader experimentation, such as variety in the number of steps the creatures take and the size of these steps.


RELATED MODELS
--------------
The three different ways of looking at the data in this model are the same as in Prob Graphs Basic: cumulative ratio, attempts until success (""waiting time""), and sampling.


CREDITS AND REFERENCES
----------------------
This model is a part of the ProbLab curriculum. The ProbLab Curriculum is currently under development at Northwestern's Center for Connected Learning and Computer-Based Modeling. . For more information about the ProbLab Curriculum please refer to http://ccl.northwestern.edu/curriculum/ProbLab/.

Additional reading:
Abrahamson, D. & Wilensky, U.  (2003).  The quest of the bell curve: A constructionist approach to learning statistics through designing computer-based probability experiments. Proceedings of the Third Conference of the European Society for Research in Mathematics Education, Bellaria, Italy, Feb. 28 - March 3, 2003.
Available for download at http://ccl.northwestern.edu/ps/papers/Probability/BellCurve.html

To refer to this model in academic publications, please use:  Abrahamson, D. and Wilensky, U. (2004).  NetLogo Equidistant Probability model.  http://ccl.northwestern.edu/netlogo/models/EquidistantProbability.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2004 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/EquidistantProbability for terms of use.
"
Expected Value Advanced,/models/Sample Models/Mathematics/Probability/ProbLab/Unverified,"globals
[
  ;;current coordinates of the picked point
  picked-x picked-y

  ;;bounds (measures how many patches away from the picked point)
  ;;area = (dimension-left + dimension-right + 1) * (dimension-top + dimension-bottom + 1)
  dimension-left dimension-bottom dimension-right dimension-top

  ;;the list of all of the totals per sample (value)
  all-totals
  ;;the list of all of the ""number of fish"" per sample (number)
  all-numbers

  ;;the total in the current viewing area
  current-total

  ;;list of the colors given for each number of marbles
  colors

  ;;true if clicked before last clearing
  just-down?

  ;;stores values at setup for easier use in procedures
  ratio-list   #fish

  ;;this is a mathematical combination of slider settings to compare
  ;;against the current combination of slider settings to see if any of them had been changed
  setup-constant

  ;;for moving red lines at setup
  prev-exp-val  prev-squares
]

breed [ fish a-fish]

;;orig-color holds the fish's given color
;;selected? is true when the fush is currently selected
fish-own [ orig-color selected? ]

;;blue-color holds the patch's given color
patches-own [ index  blue-color ]

to startup
  setup
end

;;creates the fish, initializes variables and graphs
to setup
  ca

  setup-misc-globals
  setup-dimensions
  setup-plots

  ;;makes background light blue
  ask patches [ set pcolor blue + 1 + random 3  set blue-color pcolor ]

  ;;creates the fish (# of fish = # of patches) and colors them
  create-fish #fish
  [
    pick-random-place
    setxy picked-x picked-y
    set size .75
    set selected? false
  ]
  setup-fish-color
  clear
end

;;sets the global variables to their initial values
to setup-misc-globals
  set-default-shape fish ""fish-eye-fin""
  set all-totals []
  set all-numbers []
  set just-down? false

  set ratio-list (list $1-fish $2-fish $3-fish $4-fish $5-fish)
  let setup-values (sentence ratio-list height-of-sample width-of-sample)
  ;;calculates the setup-constant -- a combination of slider settings to compare against the current constant
  ;;it is a faster way of checking whether any slider settings have been changed
  set setup-constant sum (map [?1 ^ ?2] setup-values [1.21 1.22 1.23 1.24 1.25 1.26 1.27])
  set #fish count patches

  set prev-exp-val monitor-exp-val
  set prev-squares (width-of-sample * height-of-sample)

  ;;sets the colors to what they need to be (to show the value) [lighter = more valuable]
  let c-color green
  set colors (list (c-color - 3) (c-color - 1.5) c-color (c-color + 1.5) (c-color + 3))
end

;;sets up the plots
to setup-plots
  ;;sets the range of the numbers plot and draws square line
  set-current-plot ""Number per Sample""
  clear-plot
  set-plot-x-range 0 ((ceiling (((width-of-sample * height-of-sample) * 2) / 5)) * 5)
  set-current-plot-pen ""Squ""
  plot-vert-line height-of-sample * width-of-sample

  ;;sets the range of the value plot and prints the expected-value line
  set-current-plot ""Mean Value Over Time""
  clear-plot
  set-plot-y-range (ceiling (monitor-exp-val / 5)) * 5 - 10  (ceiling (monitor-exp-val / 5)) * 5 + 10
  set-current-plot-pen ""ExpVal""
  plotxy plot-x-min monitor-exp-val
  plotxy plot-x-max monitor-exp-val

  ;;draws the expected value line, sets range
  set-current-plot ""Value per Sample""
  clear-plot
  set-plot-x-range (ceiling (monitor-exp-val / 5)) * 5 - 10  (ceiling (monitor-exp-val / 5)) * 5 + 10
  set-current-plot-pen ""ExpVal""
  plot-vert-line monitor-exp-val
end

;;if pressed, looks for a mouse-click in the view;
;;when clicked, selects area of the sample and
;;counts up the value and number of fish in the sample
to click-select
  ifelse mouse-down?
  [
    set just-down? true

    ;;sets the 'previous' variables
    let prev-x picked-x
    let prev-y picked-y

    ;sets currently-picked variables
    set picked-x [pxcor] of patch mouse-xcor mouse-ycor
    set picked-y [pycor] of patch mouse-xcor mouse-ycor

    ;;checks so point is different than one before
    ;;-- no holding mouse down and getting more than one selection
    if not (prev-x = picked-x and prev-y = picked-y)
    [
      ;;clears the view from previous click
      clear
      ;;appends the numbers for average, selects area in the view
      select-area
      set all-numbers lput (count fish with [ selected? = true ]) all-numbers
      set all-totals lput current-total all-totals
      ;;updates the histogram and plot
      plot-graphs
    ]
  ]
  ;;clear if no click and haven't cleared yet
  [
    if just-down? [ clear  set picked-x -1000 ]
  ]
end

;;randomly selects coordinates and runs the simulation
;;it is the computer's click-select, randomly choosing the picked point
to random-select
  ;;choose a random patch location
  set picked-x random-pxcor
  set picked-y random-pycor

  ;;selects the area and updates the numbers for average and plots
  select-area
  set all-numbers lput (count fish with [ selected? = true ]) all-numbers
  set all-totals lput current-total all-totals

  tick
  ;;updates the histogram and plot
  plot-graphs
  ;;clears the view from previous selection
  clear
  display
end

;;picks a random point in the valid bounds
to pick-random-place
  set picked-x random-xcor
  set picked-y random-ycor
end

;;re-sets the patches and fish to original state
to clear
  ;;re-colors patches to lake color
  ask patches [ set pcolor blue-color ]

  ;;re-sets fish to original state
  ask fish [ set selected? false ]
  if show-val?
    [ ask fish [ set label """" ] ]
  ifelse not blind?
    [ ask fish [ set hidden? false ] ]
    [ ask fish [ set hidden? true ]  ]
end

;;selects the area, highlighting the patches with yellow
;;puts the fish's value as the label, if show-val? is 'On'
to select-area
  ;;re-sets current-total
  set current-total 0
  ;;colors patches gray
  ask patches [ set pcolor gray - 1 ]

  ;;loop that selects the area, using dimension-top, bottom, right, left
  ;;wrapping around is allowed
  let cur-y (- dimension-bottom)
  let cur-x (- dimension-left)
  ask patch picked-x picked-y
  [
    while [cur-y <= dimension-top]
    [
      set cur-x (- dimension-left)
      while [cur-x <= dimension-right]
      [
        ask (fish-at cur-x cur-y)
        [
          ;adds this fish's value to total
          set current-total current-total + position color colors + 1
          ;;shows the fishs value, if show-val? is set to 'On'
          if show-val?
          [
            set label-color red
            set label position color colors + 1
          ]
          set selected? true
          set hidden? false
        ]
        ask patch-at cur-x cur-y [ set pcolor yellow ]
        set cur-x cur-x + 1
      ]
      set cur-y cur-y + 1
    ]
  ]
  ;;hide turtles which are not selected
  ask fish with [ selected? = false ] [ set hidden? true ]
end

;;sets the colors of the fish
to setup-fish-color
  ;;makes all fish have no value
  ask fish [ set orig-color -1 ]
  let cur-val 0

  ;;finds the number of fish of each type that need to be colored:
  ;;makes the percentages, multiplies them by the number of fish
  let list-of-nums map [? / (sum ratio-list) * #fish] ratio-list
  ;;rounds the numbers of fish with a specific value
  let r-list-of-nums map [round ?] list-of-nums

  ;;tweaks the values, either in the positive or in the negative direction,
  ;;for the sum to equal to the number of fish on the display
  let nums setup-fish-color-polish list-of-nums r-list-of-nums

  ifelse not setup-apart?
  [
    ;;prints out the values on random fish that are not already taken
    foreach nums
    [
      ask n-of ? fish with [ orig-color = -1 ]
      [ set orig-color item cur-val colors ]
      set cur-val cur-val + 1
    ]
    ask fish [ set color orig-color ]
  ]
  [
    ;;shows fish apart, then moves them to new, random location
    histogram-patches nums
    ask fish [ die ]
    ask patches
    [
      sprout-fish 1 [ set size .75  set selected? false
                      set orig-color pcolor  set color pcolor ]
      set pcolor gray - 1
    ]
    display  wait 3
    ask patches [ set pcolor blue-color ]
    ;;disperses the fish
    swim-to-new
  ]
end

;;tweaks the values so that they add up to the number of fish
;;(in the positive or negative direction)
to-report setup-fish-color-polish [ list-of-nums r-list-of-nums ]
  ;;tweaks the values, either in the positive or in the negative direction,
  ;;for the sum to equal to the number of fish on the display:
  ;;if the sum is below the number of fish, then searches for the highest remainder to round up
  while [sum r-list-of-nums < #fish]
  [
    let remainders map [remainder (? * #fish) #fish] list-of-nums
    ;;finds the position of the maximum remainder
    let pos-of-max position (max remainders) remainders
    ;;updates the list of numbers of each type of fish
    set r-list-of-nums (replace-item pos-of-max r-list-of-nums ((item pos-of-max r-list-of-nums) + 1))
    set list-of-nums (replace-item pos-of-max list-of-nums (floor (item pos-of-max list-of-nums) + 1))
  ]
  ;;if the sum is above the number of fish, then searches for the lowest remainder to round up
  ;;to prevent a bug that would make 0 always be the minimum remainder, all the 0's are changed
  ;;to large numbers, for them to not become negative
  while [sum r-list-of-nums > #fish]
  [
    let remainders map [remainder (? * #fish) #fish ] list-of-nums
    ;;remainders1 makes sure that the 0 is not deemed the minimum remainder, but
    ;;looks for minimum remainder above 0
    let remainders1 []
    foreach remainders
    [
      ifelse ? = 0
      [ set remainders1 (lput #fish remainders1) ]
      [ set remainders1 (lput ? remainders1) ]
    ]
    ;;finds the position of the minimum remainder
    let pos-of-min position (min remainders1) remainders1
    ;;updates the list of numbers of each type of fish
    set r-list-of-nums (replace-item pos-of-min r-list-of-nums ((item pos-of-min r-list-of-nums) - 1))
    set list-of-nums (replace-item pos-of-min list-of-nums (floor (item pos-of-min list-of-nums)))
  ]
  report r-list-of-nums
end

;;sets the selecting area variables, given height and width
to setup-dimensions
  let h height-of-sample - 1
  let w width-of-sample - 1
  set dimension-left floor (w / 2)        ;sets how many patches on left
  set dimension-right floor (w / 2)       ;sets how many patches on bottom
  if (w mod 2 != 0) [ set dimension-right dimension-right + 1 ]
  set dimension-bottom floor (h / 2)      ;sets how many patches on right
  set dimension-top floor (h / 2)         ;sets how many patches on top
  if (h mod 2 != 0) [ set dimension-bottom dimension-bottom + 1 ]
end

;;fish method run by the [Wander] button
;;makes fish wander around aimlessly, if not currently selected
to wander-around
  every .5
  [
    if not selected?
    [
      ;;moves one, changes direction
      fd 1
      rt random 360
    ]
  ]
end

;;updates the histogram
to plot-graphs
  set-current-plot ""Value per Sample""
  set-current-plot-pen ""Count""
  ;;changes range
  if length all-totals > 5 and length all-totals mod 10 = 0
  [ set-plot-x-range (floor (min all-totals / 5)) * 5 (ceiling ((max all-totals + 1) / 5)) * 5 ]
  plot-pen-reset
  histogram all-totals
  ;;plots the ""average"" line
  set-current-plot-pen ""Mean""
  plot-pen-reset
  plot-vert-line ((sum all-totals) / (length all-totals))
  ;;plots the expected value
  set-current-plot-pen ""ExpVal""
  plot-pen-reset
  plot-vert-line monitor-exp-val

  set-current-plot ""Number per Sample""
  set-current-plot-pen ""default""
  if length all-numbers > 5 and length all-numbers mod 10 = 0
  [ set-plot-x-range (floor (min all-numbers / 5)) * 5 (ceiling ((max all-numbers + 1) / 5)) * 5 ]
  plot-pen-reset
  histogram all-numbers
  ;;plots the ""average"" line
  set-current-plot-pen ""Mean""
  plot-pen-reset
  plot-vert-line ((sum all-numbers) / (length all-numbers))
  ;;plots the number of squares in the selection
  set-current-plot-pen ""Squ""
  plot-pen-reset
  plot-vert-line height-of-sample * width-of-sample

  set-current-plot ""Mean Value Over Time""
  set-current-plot-pen ""Mean""
  plot sum all-totals / length all-totals
  set-current-plot-pen ""ExpVal""
  if length all-totals > 10 [ plot monitor-exp-val ]
  if plot-y-min < 0 [ set-plot-y-range 0 plot-y-max ]
end

;;generates the expected value calculation for the monitor
to-report monitor-exp-val-calculation
  let my-ratio-list 0

  set my-ratio-list ratio-list

  ;; the ""% in Population"" monitors pick items from ratio-monitor-list
  let ratio-monitor-list map [ (word ? ""/"" (sum my-ratio-list) "" = ""
                                     precision (100 * ? / (sum my-ratio-list)) 1
                                     ""%"") ]
                             my-ratio-list
  let exp-val-calc word (width-of-sample * height-of-sample) "" * (""
  foreach [ 1 2 3 4 ]
  [
    set exp-val-calc (word exp-val-calc
                           ? "" * ""
                           item (? - 1) my-ratio-list
                           ""/""
                           (sum my-ratio-list)
                           "" + "")
  ]
  ;; we separated out the ""5 case"" because we don't add a ""+"", but we do add a "") =""
  set exp-val-calc (word exp-val-calc 5 "" * ""
                         item 4 my-ratio-list
                         ""/"" (sum my-ratio-list) "") = "")

  report exp-val-calc
end

;;generates the expected value for the monitor
to-report monitor-exp-val
  let my-ratio-list 0

  set my-ratio-list ratio-list

  report (width-of-sample * height-of-sample)
         * sum map [ ? * item (? - 1) my-ratio-list / (sum my-ratio-list) ] [ 1 2 3 4 5 ]
end

;;shows the populations separately
to histogram-patches [ list-of-nums ]
  ;;indexes the patches (from left to right, down to up), if had not already done so
  ask patches [ set index ((pxcor + max-pxcor) * (max-pxcor * 2 + 1) + (pycor + max-pycor)) ]

  ;;shows the separated populations
  let patch-now 0
  let temp 0
  foreach list-of-nums
  [
    repeat ?
    [
      ask patches with [index = patch-now] [ set pcolor item temp colors ]
      set patch-now patch-now + 1
    ]
    set temp temp + 1
  ]
end

;;disperses fish population
to swim-to-new
  let list-of-moves []
  let steps (round (#fish / 4))
  ;;finds the movement amount of each fish per step, changes heading
  ask fish
  [
    pick-random-place
    set list-of-moves (lput (distancexy picked-x picked-y  / steps) list-of-moves)
    facexy picked-x picked-y
  ]
  ;;moves the fish
  repeat steps [ ask fish [ fd (item who list-of-moves) wait .05] ]
end

;;plots a vertical line at x-coord
to plot-vert-line [ x-coord ]
  plotxy x-coord plot-y-min
  plot-pen-down
  plotxy x-coord plot-y-max
  plot-pen-up
end

;;reports the output for the % in Population monitors, given the $index
;;also checks if changes were made to the current ratios slider from the
;;original setup position
to-report monitor-%-in-pop [ which ]
  let ratios (list $1-fish $2-fish $3-fish $4-fish $5-fish)
  report (word item (which - 1) ratios
               ""/"" sum ratios "" = ""
               precision (100 * item (which - 1) ratios / sum ratios) 1
               ""%"")
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2004 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Abrahamson, D. and Wilensky, U. (2004). NetLogo Expected Value Advanced model.
; http://ccl.northwestern.edu/netlogo/models/ExpectedValueAdvanced.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2004 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/ExpectedValueAdvanced
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
Expected Value Advanced illustrates expected-value analysis under the special condition that the sample size varies.  This model extends the ProbLab model Expected Value, where the sample size is fixed.

Expected-value analyses look at the 'value' of outcomes in probability experiments in terms of some utilitarian framework, such as money or points. As in life, some events are more significant to us -- they are ""worth"" more for our endeavors. In that sense, expected-value simulations go beyond looking just at chance -- how often or how rarely something happens -- they introduce a ""worth"" factor (weight, coefficient) associated with experimental outcomes. Value and worth are not synonymous; sometimes a low value has a high worth. For instance, in golf, the lowest value has the highest worth. These simulations examine not only the issue of what I should expect from a phenomenon involving random behavior, but also, what it would be worth for me.  For instance, if I draw 12 coins randomly from a sack containing an equal number of pennies, nickels, dimes, and quarters, we could talk about which 12 'coins' I could expect to get (a nominal classification) -- 3 'pennies,' 3 'nickels,' 3 'dimes,' and 3 'quarters,' on average. But we could extend the discussion to how much money I would get, that is, what would be the 'value' of my draw. To do this, we'd have to multiply the expected frequency of each type of coin by its value:
|                3 * 1 + 3 * 5 + 3 * 10 + 3 * 25 = 123 cents.
A more general way of putting this all together -- the sample size (12), the probabilities of each coin (1/4 for each of them), and the value of each coin (1, 5, 10, and 25) -- is:
|                12 * (1/4 * 1 + 1/4 * 5 + 1/4 * 10 + 1/4 * 25) = 123 cents.
Thus, the term 'expected value' may be defined as the sum of the products of the probability of each possible event and the value of that event multiplied by the sample size.

This model is a part of the ProbLab curriculum.  The ProbLab curriculum is currently under development at the CCL.  For more information about the ProbLab curriculum please refer to http://ccl.northwestern.edu/curriculum/ProbLab/.


HOW IT WORKS
------------
The analogy in the model is a lake with fish swimming around.  Each type of fish is worth a certain number of dollars (1, 2, 3, 4 or 5) [other currencies or point systems apply just as well]. The distribution of types of fish by amount-of-worth -- how many $1-fish, $2-fish, ..., or $5-fish there are in the pond -- is set by the sliders on the left. With the sliders, we can set the distribution of fish by type and, therefore, the chance of catching each type of fish. That is, the higher you have set a given slider as compared to other sliders (see the % IN POPULATION monitors), the higher the chance of catching a fish with that worth. For instance, the more $2-fish there are, the higher is the chance of catching a $2-fish in a random sample.  Note that the more valuable the fish, the lighter its body color. You can press CLICK SELECTION and then click in the view to ""catch"" a random sample, or press RANDOM SELECTION to have the choosing done for you. The computer selects randomly. You, too, can select ""blindly,"" if you turn on the BLIND? switch.

Note that the sampling in this model is of arrays, e.g., a 2-by-3 array of 6 squares. There are as many fish in this model as there are squares. One might expect to catch 6 fish when one samples from 6 squares. However, when the WANDER button is pressed, the fish wander randomly, and so sometimes 6 squares have more than 6 fish and sometimes they have less. You can think of each selection as a fishing net that is dipped into the lake -- the fisher doesn't know how many fish will be in the net. This feature of the model creates variation in sample size. Thus, one idea that this model explores is that even under variation in sample size, we still receive outcomes that correspond to the expected value that we calculate before taking samples.


PEDAGOGICAL NOTE
-------------
The idea of 'expected value' is that we can formulate an educated guess of the dollar worth of the fish we catch. It's similar to asking, ""How much does the average fish cost?"" We need to somehow take into account both the chance of getting each type of fish and its dollar value. The computer program will do much of the calculations for us, but here's the gist of what it does:

Let's say that the ratio units we set up for $1, $2, $3, $4 and $5 fish were, respectively,
|    1 : 6 : 5 : 0 : 4.
The number '6,' for example, indicates our ratio setting for fish worth 2 dollars. You can immediately see that the chance of getting a $2-fish is greater than the chance of getting a $3-fish, because the chance of getting a $2-fish (6 units) has more ratio units than the $3-fish (5 units). But in order to determine precisely the chance is of getting each type of fish, we need to state the ratio units relative to each other. We need a common denominator. In this particular setting, there is a total of 16 'ratio units':
|    1 + 6 + 5 + 0 + 4 = 16.
Now we can say that if we catch a fish, there is, for instance, a 4-in-16 chance that it is a $5-fish. That is a 25% chance of catching a fish that is worth exactly 5 dollars. We can also say that this relative proportion of $5-fish in the lake contributes .25 * 5, that is, $1.25, to the mean value of a single fish in the lake. Similarly, we can say there is a 5-in-16 chance of getting a $3-fish, a 6-in-16 chance of getting a $2-fish, etc. If we sum up all products of 'value' and 'probability,' we get the expected value per single fish:

|  (1 * 1/16) + (2 * 6/16) + (3 * 5/16) + (4 * 0/16) + (5 * 4/16)
|     = 48/16 = 3 dollars per fish.

This tells us that if you pick any single fish under these settings, you should expect to get a value of 3 dollars.  If you were to select a sample of 6 fish, then you would expect to pocket 18 dollars (6 fish * 3 dollars-per-fish).


HOW TO USE IT
-------------
Begin by setting fish-value ratios (or just use the default settings). Click SETUP and watch the information updated in the view. Below are more features of the model that will let you change the way it looks and runs.

If you change any of the sliders you will have to press SETUP for the changes to take effect.

Sliders:
$1-FISH, $2-FISH, $3-FISH, $4-FISH, $5-FISH -- ratio-unit settings for the distribution of fish by value.  Note that the ratios are set in proportion to each other. The labels under the sliders indicate that the higher-valued fish have the lighter fish body color.

HEIGHT-OF-SAMPLE -- sets the height of the sample selection.

WIDTH-OF-SAMPLE -- sets the width of the sample selection.

The two previous sliders determine the selection area (width x height).

Switches:
SETUP-APART? -- when set to 'On,' and the SETUP button is pressed, the fish populations group by value, wait 3 seconds, and then swim to a random locations in the display.

BLIND? -- if 'On,' you will only see the fish you caught in the currently-selected sample; if 'Off,' you will always see all of the fish.

SHOW-VAL? -- when set to 'On,' selected fish display their monetary value (worth).

Buttons:
SETUP -- initializes variables, re-colors the fish, and resets monitors and graphs.

CLICK SELECTION -- waits for the user to select an area in the pool, counts up the total number of fish in that area as well as their values, calculates, and graphs totals of these values.

RANDOM SELECTION-- randomly chooses sample areas in the pool.

WANDER -- moves all fish in random directions.

Monitors:
% IN POPULATION -- shows the percentage of each type of fish in the population. For instance, if the % IN POPULATION monitor for $3-FISH is at 50%, then half of all the fish in the lake will have a value of exactly 3 dollars.

EXPECTED VALUE CALCULATION -- This monitor reports the calculation of the expected number of dollars per sample. The calculation first determines the value of the 'average fish, ' given the $-unit slider settings for the population distribution by value, and then multiplies this value by the number of fish in an average sample of size 'height * width.' Thus, 'average value' * 'sample-size' = total is the expected value of sample.

EXPECTED VALUE -- shows the result of the expected-value calculation (see above).

MEAN VALUE PER SAMPLE -- shows the cumulative mean value of samples over all samples taken.

CURRENT SAMPLE VALUE -- shows the total value of the current sample selection.

CURRENT NUMBER OF FISH -- shows the number of fish in the current sample selection.

AVERAGE NUMBER OF FISH PER SAMPLE -- shows the average number of fish over all samples taken.

SQUARES -- monitors the number of squares in the selection area. The value of SQUARES is the product of HEIGHT-OF-SAMPLE and WIDTH-OF-SAMPLE

RUNS -- monitors the number of times that the user or computer sampled from the pool.

Plots:
VALUE PER SAMPLE -- plots the number of occurrences of specific value totals in the samples.  For instance, it shows how many times your sample was worth exactly $4. It also plots the expected value (in red) and the mean value per sample (in green),

NUMBER PER SAMPLE -- plots the number of fish in the samples.  It also plots the average number of fish per sample (in green) as well as the number of squares, that is, the expected average number of fish in samples (in red).

MEAN VALUE OVER TIME -- plots, over time, the values of each sample (in black), as well as the expected value (in red), which does not change after Setup.


THINGS TO NOTICE
----------------
In NetLogo, the location of a turtle in terms of the world coordinate system is determined by the location of the center of its shape. So when one selects an area in this model, a fish may be sampled even though it is not completely inside the selected area (for instance, its tail might be sticking out of that area).

Fish may be unevenly distributed throughout the 'lake.'  This feature distinguishes the Expected Value Advanced model from the Expected Value model, where the elements (tiles) are evenly distributed (1 tile per patch).  The model monitors the number of fish per sample in the NUMBER PER SAMPLE plot.

The SQUARES monitor changes with the HEIGHT-OF-SAMPLE and WIDTH-OF-SAMPLE sliders to show the size of the selection array of squares (NetLogo ""patches"").  Because in this version of the model there are exactly as many fish as there are squares, SQUARES shows the expected average number of fish per sample. It is only ""expected"" and not fixed, both because the fish are not distributed uniformly in the view when you setup and because the fish may optionally move (if you have pressed WANDER).

For equal HEIGHT-OF-SAMPLE and WIDTH-OF-SAMPLE settings, mouse clicks are in the center of the sample array. For other settings, the click in not in the center.

At setup, the distribution of fish by value in the sample space is often an approximation and not completely accurate. The program sets the probabilities according to the ratios, but it still produces a very small error. There are a fixed number of patches and fish (in the default setting of the model there are 121 squares and 121 fish). This number cannot precisely accommodate all the different possible ratio settings. For instance, we cannot have two equal halves. That is, there will be settings where the program will make approximations. These approximations will lead to some minor degree of experimental error.

Look at the plot MEAN VALUE OVER TIME. The more samples you take, the closer the red line gets to the black line. Can you explain this?


THINGS TO TRY
-------------
Run the model under different setting of the switches. Does it take longer for the model to converge on the expected values when you are not working entirely randomly?

Change the height and width of the selection area.  Run the experiment, looking at the MEAN VALUE OVER TIME plot. Does this plot behave differently for different height and width settings?

As noted above, the relative ratios of the $1-fish, $2-fish, etc. in the lake are determined by relative values of all of the sliders on the left.  In other words, if you set the ratio units to 1 : 1 : 1 : 1 : 1, it is going to mean the same to the computer as the setting of 2 : 2 : 2 : 2 : 2 or 5 : 5 : 5 : 5 : 5.  The sliders are designed to allow an exploration of a rich range of proportions of the different fish.  Try extending the maximum value of the ratio sliders, to obtain an even richer range of proportions of fish populations.
In the Procedures tab, go to the 'setup-misc-globals' procedure and change the color value assigned to the 'c-color' local variable.  This will change the fish base color.


EXTENDING THE MODEL
----------------
Currently, samples wrap around the view. Edit the code in the 'select-area' procedure so the selection does not wrap around.  One way to go about this may be to shift the selected area. For instance, if the user clicks near the right side of the window, a procedure could translate the location of the mouse-click as many patches to the left as necessary.

Add another ratio-unit slider, either for 0 value or beyond 5. It could also be a decimal value between 1 and 5, such as 1.7. It could even be a 'negative value,' which could be interpreted as an added expense, like catching a whale that breaks your fishing rod.


NETLOGO FEATURES
-----------------
This utilizes the mouse-clicking capabilities of NetLogo.  Note that in order to use the mouse-clicking functionality a forever button must be running, so that there are active procedures to ""catch"" your clicks.


RELATED MODELS
--------------
This model is considered more advanced than Expected Value. Both models utilize the idea of 'expected value,' but Expected Value Advanced supplements this with variation in sample size.

The SETUP-APART? functionality arranges the raw data (the fish themselves) in ""histograms"" as in 9-Block Stalagmite. Also, the BLIND? functionality produces an effect that is similar to that in Computer HubNet S.A.M.P.L.E.R., where the population is hidden and only the sample is visible.


CREDITS AND REFERENCES
----------------------
This model is a part of the ProbLab curriculum. The ProbLab Curriculum is currently under development at Northwestern's Center for Connected Learning and Computer-Based Modeling. . For more information about the ProbLab Curriculum please refer to http://ccl.northwestern.edu/curriculum/ProbLab/.

To refer to this model in academic publications, please use:  Abrahamson, D. and Wilensky, U. (2004).  NetLogo Expected Value Advanced model.  http://ccl.northwestern.edu/netlogo/models/ExpectedValueAdvanced.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2004 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/ExpectedValueAdvanced for terms of use.
"
Dice Stalagmite,/models/Sample Models/Mathematics/Probability/ProbLab,"globals [
  generators        ;; agentset of two patches where the dice first appear
  top-row           ;; agentset of just the top row of patches
  single-outcomes   ;; list of single dice values
  pair-outcomes     ;; list of dice pair sums
]

patches-own [
  column            ;; what number (single die or sum of pair) this column of patches is for
]

breed [paired-dice paired-die]   ;; dice considered as part of pairs
breed [single-dice single-die]   ;; dice considered singly
breed [stacked-dice stacked-die] ;; dice that have stopped moving

;; all three breeds have this variable
turtles-own [
  die-value        ;; 1 through 6
]

paired-dice-own [
  pair-sum         ;; 2 through 12
]

to setup
  clear-all
  set single-outcomes []
  set pair-outcomes []
  ;; assign outcomes to columns
  ask patches with [pxcor > 4] [
    set column floor ((pxcor - 1) / 2)
  ]
  ask patches with [pxcor < -4] [
    set column pxcor - min-pxcor  + 1
  ]
  ;; color patches
  ask patches [ set pcolor gray + 3 ]
  ask patches with [column != 0] [
    ifelse column mod 2 = 0
      [ set pcolor gray ]
      [ set pcolor brown - 1 ]
  ]
  ;; set up agentsets
  set top-row patches with [pycor = max-pycor]
  set generators top-row with [pxcor = -1 or pxcor = 0]
end

to go
  if stop-at-top? and any? turtles-on top-row [
    user-message ""The top has been reached. Turn STOP-AT-TOP? off to keep going.""
    stop
  ]
  if not stop-at-top? [
    bump-down stacked-dice with [pxcor < 0]
    bump-down stacked-dice with [pxcor > 0]
  ]
  roll-dice
  while [any? single-dice or any? paired-dice] [
    move-paired-dice
    move-single-dice
    display    ;; force the view to update, so we see the dice move smoothly
  ]
  tick
  update-plots
end

;; creates a new pair of dice (both singles and pairs)
to roll-dice
  ;; ask each generator patch to create two paired dice
  ask generators [
    sprout-paired-dice 1 [
      set color white
      set die-value 1 + random 6
      set shape word ""die "" die-value
      set heading 90
    ]
  ]
  ;; clone the paired dice to make the single dice
  ask paired-dice [
    hatch-single-dice 1 [
      set heading 270
      ;; changing breeds resets our shape, so we must explicitly adopt
      ;; our parent's shape
      set shape [shape] of myself
    ]
  ]
  ;; set the sum variable of the pairs
  let total sum [die-value] of paired-dice
  ask paired-dice [ set pair-sum total ]
  ;; add to outcomes lists
  set pair-outcomes lput total pair-outcomes
  ask single-dice [ set single-outcomes lput die-value single-outcomes ]
end

to move-paired-dice
  ;; if either of the two dice isn't at the right column yet,
  ;; both dice move
  ifelse any? paired-dice with [pair-sum != column]
    [ ask paired-dice [ fd 1 ] ]
    ;; otherwise both dice fall
    [ ask paired-dice [
        ;; if at the bottom of the view, check if we should go ""underwater""
        if pycor = min-pycor [ paired-die-check-visible ]
        fall
      ]
    ]
end

to move-single-dice
  ;; two single dice may be falling in the same column, so we have
  ;; to make sure that the bottom one moves before the top one,
  ;; otherwise they could get confused
  let how-many count single-dice
  if how-many > 0 [
    ask min-one-of single-dice [pycor] [ move-single-die ]
  ]
  if how-many > 1 [
    ask max-one-of single-dice [pycor] [ move-single-die ]
  ]
end

to move-single-die  ;; single-die procedure
  ifelse die-value != column
    [ fd 1 ]
    [ ;; if at the bottom of the view, check if we should go ""underwater""
      if pycor = min-pycor [ single-die-check-visible ]
      fall
    ]
end

to fall  ;; single-die or paired-die procedure
  set heading 180
  ifelse (pycor > min-pycor) and (not any? stacked-dice-on patch-ahead 1)
    [ fd 1 ]
    ;; stop falling
    [ ;; changing breeds resets our shape, so we have to remember our old shape
      let old-shape shape
      set breed stacked-dice
      set shape old-shape
    ]
end

;; determines if my column is tall enough to be seen
to single-die-check-visible  ;; single-die procedure
  if single-outcomes = [] [ stop ]
  let mode first modes single-outcomes
  let height-of-tallest-column length filter [? = mode] single-outcomes
  let height-of-my-column length filter [? = die-value] single-outcomes
  if (height-of-tallest-column - height-of-my-column) >= world-height - 2 [ die ]
end

;; determines if my column is tall enough to be seen
to paired-die-check-visible  ;; paired-die procedure
  if pair-outcomes = [] [ stop ]
  let mode first modes pair-outcomes
  let height-of-tallest-column length filter [? = mode] pair-outcomes
  let height-of-my-column length filter [? = pair-sum] pair-outcomes
  if (height-of-tallest-column - height-of-my-column) >= world-height - 2 [ die ]
end

to bump-down [candidates]
  while [any? candidates with [pycor = max-pycor - 2]] [
    ask candidates [
      if pycor = min-pycor [ die ]
      fd 1
    ]
  ]
end

to update-plots
  set-current-plot ""Single Dice""
  histogram single-outcomes
  set-current-plot ""Pair Sums""
  histogram pair-outcomes
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2004 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Abrahamson, D. and Wilensky, U. (2004). NetLogo Dice Stalagmite model.
; http://ccl.northwestern.edu/netlogo/models/DiceStalagmite.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2004 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/DiceStalagmite
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
Dice Stalagmite is a model for thinking about the relations between independent and dependent random events.  Pairs of dice are rolled, then the dice fall into columns in two bar charts.  One of these charts records the dice as two independent outcomes, and the other, as a single compound event (sum) of these two outcomes.  Because the columns grow from the bottom up, we call this a ""stalagmite.""

Different distributions emerge: the independent-event bar chart is flat (equally distributed) whereas the dependent-event bar chart is peaked.  (It does not quite approach a normal distribution, because there are only two compound outcomes.)

This model is a part of the ProbLab curriculum.  The ProbLab curriculum is currently under development at the CCL.  For more information about the ProbLab curriculum please refer to http://ccl.northwestern.edu/curriculum/ProbLab/.


HOW IT WORKS
------------
The outcomes from rolling the two dice are represented in two different ways.

On the left, they are plotted as individual events.  This representation treats the dice individually, not as pairs.  Each die is stacked in its respective column, one through six, in the resulting histogram.

On the right, you see a second histogram with the same dice stacked in pairs according to their sum.  There are eleven columns, 2 through 12, since those are the possible sums of two dice.

When the model is run, the right chart never reaches the top before the left chart.  (Why?)  The left bar chart is ""bumped"" down by one row so as to leave more room for the bars to grow.  This allows for the bar chart on the right to grow further and take on its typical (peaked) shape.


HOW TO USE IT
-------------
Switches:
STOP-AT-TOP? -- if 'On', stops the model when the right side of the display bar chart (the dice totals) has reached the top.  If 'Off', then both stacks ""bump"" down one row when a column hits the top.  (The plots on either side of the view are always scaled to show all of the data, even if the view is only showing the top portion.)

Buttons:
SETUP -- prepares the model for running.

GO -- runs the model.  In a single run of GO, a random pair of dice appears, is copied, and then the copies fall into their stacks.  Also, the plots are updated.

Plots:
SINGLE DICE -- plots the number of occurrences of each die-number (1-6).
PAIR SUMS -- plots the number of occurrences of each die-total (2-12).
The plots show the same information as the view, except that the plots always show all of the data, while if the STOP-AT-TOP? switch is off, the view only shows the tops of the stacks.


PEDAGOGICAL NOTE
------------
As in other ProbLab activities, here we are interested in exploring relations between the anticipated frequency distribution (the relative probabilities), which we determine through combinatorial analysis, and the outcome distribution we receive in computer-based simulations of probability experiments.  To facilitate the exploration of the relationship between such theoretical and empirical work, we build tools that bridge between them.  These bridging tools have characteristics of both the theoretical and empirical work.  Specifically, we structure our combinatorial spaces in formats that resemble outcome distributions, and structure our experiments so as to sustain the raw data (not just graphs representing the data).  The ""picture bar chart"" of the combinatorial space of dice-pair totals can be found with the ProbLab materials.

Beside each bar chart -- the 'dependent' and the 'independent' -- there is a histogram that represents the data correspondingly.  Whereas the bar charts stack the outcomes so as to sustain the images of the discrete events (the ""raw data"" themselves), the histograms grow in continuous columns (without partition lines).  Twinning each picture bar chart with its respective histogram may help students both to understand the histograms and to shift from additive interpretation of the columns in the picture bar chart (focusing on differences between heights of columns) to a multiplicative interpretation of the bar chart (focusing on the proportions of the column heights).

In a classroom, students should work with the triangular combinatorial space they created (not the one from the model, but one with all 36 different possible outcomes of a dice pair that are arranged in a bar chart).  Discussion should focus on the relation between the theoretical and empirical distribution, that is, between the combinatorial space and the distribution of random outcomes.  Why is it that they are similar?


THINGS TO NOTICE
----------------
Note the shape of the outcomes in the right-hand bar chart.  The top is triangular.  What does this mean? Specifically, if each event is random and independent, why are we getting a shape that is not random (always the same shape)?  How can randomness and determinism coexist like this?  The bar chart on the left hones this discussion, because, from run to run, it is basically a ""flat"" distribution -- for instance, you can never predict, with certainty, which die column will be first to reach the top.

If the model runs long enough and if STOP-AT-TOP? is set to 'Off,' you will notice that some columns in the picture bar chart on the left vanish.  That is, you will see a die descending to the bottom of its column and ""going below sea level"" so it is no longer visible.  What happens is that this die's column is now too short to appear in the display.  It might grow tall enough later to come back in, or it might not.  Meanwhile, the histogram in the plot keeps all of its columns, so you can keep comparing between them.


THINGS TO TRY
-------------
How many pairs are needed until the dice-pair bar chart reaches the top?  Is this number constant?  How much does it vary?

What is the biggest vertical gap between columns in the single-die bar chart?  Does the gap get larger or smaller the more you run the model?  Does any particular column win more often than others?

Which column in the dice-pair bar chart gets to the top first most often?


EXTENDING THE MODEL
-------------------
Currently, the model sums two dice.  An interesting idea would be to extend this model to have a sum of three or more dice.  There would be more columns for the different dice-totals.  How many?  How would this change affect the dice-total distribution?

Currently the model puts all pairs of dice that sum to the same number in the same column.  What would happen if you added additional columns so that different combinations were in different columns, for example, so that 2+5 and 5+2 were considered different?  Would this change the shape of the dice-total distribution?


NETLOGO FEATURES
----------------
In this model, the origin (patch 0,0) is placed between the single and pair bar charts rather than in the center, which makes computations simpler and extending the model easier.


RELATED MODELS
--------------
Dice Stalagmite uses the same basic metaphor as the ProbLab model 9-Block Stalagmite.  In that model, a random 9-block or 4-block is selected from a sample space.  Then, the block finds is correct column, according to the number of green squares in the block, and stacks up in that column.

The idea of juxtaposing two or more different representations of the same running data is used in several ProbLab models, such as Prob Graphs Basic or Random Combinations and Permutations.

Dice are also used in the ProbLab model Dice for generating a distribution of random outcomes.

The Galton Box model also features raw data that descend and stack up in columns.


CREDITS AND REFERENCES
----------------------
This model is a part of the ProbLab curriculum.  The ProbLab curriculum is currently under development at Northwestern's Center for Connected Learning and Computer-Based Modeling.  For more information about the ProbLab curriculum please refer to http://ccl.northwestern.edu/curriculum/ProbLab/.

Thanks to Josh Unterman for building the original version of this model.  Thanks to Steve Gorodetskiy for his contribution to the design of this model.

To refer to this model in academic publications, please use:  Abrahamson, D. and Wilensky, U. (2004).  NetLogo Dice Stalagmite model.  http://ccl.northwestern.edu/netlogo/models/DiceStalagmite.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2004 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/DiceStalagmite for terms of use.
"
Stochastic Patchwork,/models/Sample Models/Mathematics/Probability/ProbLab,"globals [target-color other-color background-color patches-in-block %-target-color-list]
patches-own [my-color]

breed [ frames frame ]

to startup
  initialize
  checker
end

to initialize
  ca
  set-colors
  set %-target-color-list []
  set patches-in-block []
end

;; We used color variables and not just colors so that you could change the color values
;; to suit you. For instance, perhaps you would want to change the green to violet?
to set-colors
  set target-color green
  set other-color blue
  set background-color 44
end

;; This procedure checkers the patches.
;; This procedure's function is (a) to give the user a sense of the layout of the land
;; (b) aesthetic. You can copy this basic code to your own models.
to checker
  ask patches
  [
    ifelse  ( ( pxcor / 2  = int (pxcor / 2) ) and ( pycor / 2  = int (pycor / 2) ) ) or
    ( ( pxcor / 2 != int (pxcor / 2) ) and ( pycor / 2 != int (pycor / 2) ) )

      [set pcolor target-color]
      [set pcolor other-color]
  ]
end

to setup
  initialize
  create-block
  setup-frames
end

to create-block ;; creates a block of all patches-in-block
  ask patch 0 0
  [set patches-in-block ( in-rectangle patches ((block-side - 1) / 2)
        ((block-side - 1) / 2) ) ]
  ask patches [set pcolor brown]
  ask patches-in-block [set pcolor background-color]
end

;; report the agentset within a box that has a width = (half-width * 2) + 1
;; and a height = (half-height * 2) + 1 and is centered on the calling agent
to-report in-rectangle [patchset half-width half-height]
  report patchset with
  [
    pxcor <= ([pxcor] of myself + half-width) and pxcor >= ([pxcor] of myself - half-width) and
    pycor <= ([pycor] of myself + half-height) and pycor >= ([pycor] of myself - half-height)
  ]
end

to setup-frames ;; each individual patch in the block is framed, creating an overall effect
  ;; of a grid that helps distinguish individual patches in the block
  set-default-shape frames ""frame""
  ask patches-in-block
  [
    sprout-frames 1
      [ set color black ]
  ]
end

to go
  if target-color = 0 [stop]
  ask patches-in-block
  [
    ifelse random-float 100 < %-target-color
      [set pcolor target-color ] [set pcolor other-color]
  ]

  ;; We multiply by 100 in order to convert a probability, e.g., .23, into a percent -- 23.
  set %-target-color-list fput ( 100 * ( count patches-in-block with [pcolor = target-color] )
      / count patches-in-block )
  %-target-color-list
  tick
  plot-color-distribution
end

to plot-color-distribution
  set-current-plot ""Color Distribution""
  set-current-plot-pen ""%-target-color""
  histogram %-target-color-list
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2004 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Abrahamson, D. and Wilensky, U. (2004). NetLogo Stochastic Patchwork model.
; http://ccl.northwestern.edu/netlogo/models/StochasticPatchwork.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2004 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/StochasticPatchwork
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
Stochastic Patchwork is a simple model for thinking about a profound idea in the domain of probability: the relation between, on the one hand, the independent chance of  elements to take on the value of a favored event, and on the other hand, the distribution of means of grouped outcomes, that is 'samples.'  Should the distribution of sample means reflect the independent probability?  If so, why?  In this dynamic model, a histogram representing the accumulating distribution of sample means grows before our eyes.

This model is a part of the ProbLab curriculum.  The ProbLab curriculum is currently under development at the CCL.  For more information about the ProbLab curriculum please refer to http://ccl.northwestern.edu/curriculum/ProbLab/.


HOW IT WORKS
------------
Squares that participate in the sample are those that are in the block you have set up. For instance, for a block-side of 3 you get a ""9-block."" At every run through GO, each square in the block ""rolls a die"" to decide whether it should be green (the favored event) or blue. This ""die"" works as follows: The square chooses a random number between 0 and 100. Next, the square checks to see whether this number is smaller or larger than the value you set for the ""%-target-color"" slider. If, for instance, the random number was 75 and the slider value was 85, then the square will become green, but if -- say on the immediately consecutive run through Go -- the random number happened to be 95 (and you have not changed the slider value from 85), then the square will be blue on this run. At every run through Go, the overall value of the population's ""green-ness"" is calculated as the number of green squares in the block divided by the total number of squares in the block. This calculated value is added to a growing list that thus grows in length from trial to trial. The entire list is plotted as a histogram at each run.

Over many runs, the histogram begins to form a bell-shaped curve with your chosen %-target-color as the mode.

Note that for this model, different possible permutations of a given block that all have the same number of green squares in them are considered the same (compound) 'event' and are thus clumped in the same histogram bar.

Note also the ambiguity of the statistic 'greenness.' If 21/25 squares in a block are green, we can say that the greenness of this sample block is 84%. But we also can say that in this sample block, each square is on average .84 green. That is the sample mean. Now, .84 green possibly does not make much sense here, because each square is either completely green or not green at all. But in terms of prediction, one can speak of being .84 sure that a square in the population is totally green.


HOW TO USE IT
-------------
Buttons:
'Setup' - prepares the size of population according to the block-side slider value.
'Go'  - activates the procedures. It is set to work ""forever,"" that is, repeatedly until you press it again.

Sliders:
'block-side' - the larger the value you set here, the larger the size of your square sample. If the block-side is X, then the block will be of dimensions X^2. For example, a block-side of 3 will give a sample of 9 square squares.
'%-target-color' - Use this slider to control the average probability that each square will be green in each iteration through Go.

Monitors:
'# target color' - shows how many squares in the block are green. (Note that the plot window shows a histogram of the percent of green squares, and not of the number of green squares.)

Set the sliders to the values of your choice, press Setup, and then press Go.


THINGS TO NOTICE
----------------
The larger your block, the more possible sample means there are for samples, so the histogram becomes denser (but check the cases of 0% and 100%). For instance, for a sample of 9 squares (block-side = 3) there are 10 different events: 0 out of 9 are green, 1 out of 9 are green, 2 out of 9 are green, 3/9 are green, 4/9, 5/9, 6/9, 7/9, 8/9, and 9/9. But for a sample of 25 squares (block-side = 5) there are 26 different outcomes: 0/25, 1/25, 2/25...24/25, 25/25. Try running the model under the settings block-side 3 and then 5 to appreciate this difference. Interestingly, if you were working with a line graph and not a histogram, you would never see this difference. To try this, you can edit the plot by selecting it and clicking the EDIT button in the Toolbar. Now change the plot pen's mode from 'Bar' to 'Line,' and run the model again. Another way to notice the difference between small and large samples is to see how many different sample means are accumulating into the list of all sample means. Run the model with a block-side 3 for about 10 seconds, and then, in the command center, write ""show %-target-color-list."" Notice how there are 9 different outcomes. You can also type in:

|          show length remove-duplicates %-target-color-list

This will report the number of different outcomes in the list. Compare this to a sample of block-side 5.


THINGS TO TRY
-------------
OK, so we know that a sample of 9 squares gives 10 different events (see previous section). But what happens if you change the %-target-color value? Surely that should change the number of different possible events! Or does it?... How many samples do we need to take to check our answer? Can we ever be sure of our answer? If you have an opportunity, run this model overnight and track for any changes in the distribution range. Otherwise, you should consult an expert on this issue.

How long does it take for the histogram to start taking its typical bell shape? How is this duration of time related, if at all, to the size of the sample?

How is the shape of the curve related to the %-target-color value? Choose a largish block-side value, then set the %-target-color slider to an extremely high value, such as 98%. Let the model run until it begins to take some distinctive shape. Now, stop the model by pressing the Go button again. Then, without pressing Setup, re-set the %-target-color slider to, say, 70% and let it run again. Repeat this several times for smaller and smaller percentages, ending with another extreme percentage, say 2%. You will have a set of curves. Are they all bell shaped? -- If not, why not?

When the block-side is 3 and we run the model, then pretty soon -- that is, after a few thousand trials -- we have 10 bars. That means we have had each of the 10 possible events at least once. So the distribution of outcomes ranges from 0 to 100. How about the case of block-side 7? Will we get the same distribution range?

Ask a friend to set up the %-target-color value for you without your looking. Now, cover the left-hand side of the NetLogo Window (so that you see only the view). You can also do that by asking your friend to shift the entire NetLogo window to the left so that the left-hand side of the window is hidden off screen.(Or, move the slider out of sight and type in the command center ""set %-target-color random 101"") Next, run the model. Looking at the flashing colors on the sample block, try to guess the percentage of green. Practice this, then switch roles with your friend. Who is better at this task? Discuss your strategies. (see 'Experts' in the EXTENDING section.)


NETLOGO FEATURES
----------------
Look in the code at the procedure 'to create-block' and the reporter procedure 'in-rectangle' immediately below it. Note how adjustments need to be made in order to get the code to produce a block of squares with the 'block-side' the user sets. You may wish to familiarize yourself with what might seem at first confusing: Even though the squares create a grid-like structure, this grid is offset from the underlying coordinate system that gives squares their names. This real coordinate system runs through the squares' centers and not along their perimeters. For instance, the location of ""patch 0 0"" is precisely that -- [0 0] -- because its center, that is, its pxcor and pycor, is on the origin. But in fact, the patch 0 0 extends from -0.5 to +0.5 along both the x and the y axes.


EXTENDING THE MODEL
-------------------
A first jab at programming is to change the two focal colors from green and blue to whatever you like. In the Procedures tab, find the ""set-colors"" procedures and replace the existing colors with others. You may wish to consult the NetLogo manual (in the ""Help"" drop-down menu) to find out which colors can be named and which have to be numbered. Also, you can use a combination such as ""violet + 3"".

A bigger challenge, that would involve some NetLogo programming, is to find and represent interesting patterns in the data that is currently displayed in the existing plot, COLOR DISTRIBUTION. What other variables could be interesting to monitor? For instance, you can monitor how many trials you have had. For this, you want a monitor that will show the length of the list that keeps all the samples. Also, you can add a monitor that shows the average probability, or the occurrence of a particular value, such as 0%. Create monitors that keep track of the distribution range (maximum - minimum). You could create another plot that graphs the average sample mean as it changes over time. What do you expect that graph would look like - initially, later? How, if at all, would the shape of that graph be related to the settings of the slider values?

Experts (continued from above section): Try extending the model so as to be able to improve your guesstimation strategies. You can even create interactive procedures that will enable you to track your friend's and your progress. For instance, you could modify the model to assign random values to the %-target-color slider without showing you the value. Perhaps it is worthwhile to find ways to make your ""guesstimations"" more precise. What could such techniques be? How are they related to what scientists call ""doing statistics""? Finally, what can we learn about our perceptual mechanism (the way our eyes and brain work together) from this exercise?


CREDITS AND REFERENCES
----------------------
This model is a part of the ProbLab curriculum. The ProbLab Curriculum is currently under development at Northwestern's Center for Connected Learning and Computer-Based Modeling. . For more information about the ProbLab Curriculum please refer to http://ccl.northwestern.edu/curriculum/ProbLab/.

To refer to this model in academic publications, please use:  Abrahamson, D. and Wilensky, U. (2004).  NetLogo Stochastic Patchwork model.  http://ccl.northwestern.edu/netlogo/models/StochasticPatchwork.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2004 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/StochasticPatchwork for terms of use.
"
Random Walk Left Right,/models/Sample Models/Mathematics/Probability/Unverified,";;;;;;;;;;;;;;;;;;;;;;;;;;;
;; variable declarations ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

globals
[
  sum-right-turns  ;; the sum of turtles that turned right for the entire run
  sum-left-turns   ;; the sum of turtles that turned left for the entire run
]

;;;;;;;;;;;;;;;;;;;;;;
;; setup procedures ;;
;;;;;;;;;;;;;;;;;;;;;;

;; sets up the patches and creates turtles
to setup
  ca
  ask patches [ set pcolor gray + 3 ]
  draw-line-up-middle
  setup-turtles
  init-vars
  setup-plot
end

;; draw a line up the middle
to draw-line-up-middle
  crt 1
  [
    set heading 0
    set pen-size 3
    set pcolor 8
    pd
    fd world-height
    die
  ]
end

;; determines the number of turtles and their color
;; if turtle-trails? is on, the turtles' pens should be down,
;; otherwise they should be up
to setup-turtles
  ;; the origin is at the bottom of the view so there is no need
  ;; to relocate the turtles upon creation
  crt number-of-turtles
  [
    set color black
    set pen-size 3
    ifelse turtle-trails?
      [ pd ]  ;; have the turtles put down their pens
      [ pu ]  ;; have the turtles pick up their pens
    set heading 0
  ]
end

;; counts the number of right and left turns and paces of the turtles
to init-vars
  set sum-right-turns 0
  set sum-left-turns 0
end

;; setup the plot which measures the turtles' movement during the run
to setup-plot
  set-current-plot ""Steps Each Direction""
  set-plot-y-range 0 (count turtles * .75)
  set-plot-x-range 0 (world-height)
  draw-plot 0 0
end

;;;;;;;;;;;;;;;;;;;;;;;;
;; runtime procedures ;;
;;;;;;;;;;;;;;;;;;;;;;;;

;; have the turtles randomly pick either right or left and
;; have them move in that direction
;; if one turtle cannot move, then stop
to go

  let num-turtles-right 0  ;; the number of turtles turning right currently
  let num-turtles-left 0   ;; the number of turtles turning left currently

  ;; if one turtles cannot move because it is at the edge of the world, then stop
  if any? turtles with
       [ patch-at 0 number-of-steps = nobody or
         patch-at (- number-of-steps) 0 = nobody or
         patch-at number-of-steps 0 = nobody ]
    [ stop ]

  ask turtles
  [
    ifelse ((random 2) = 0)
    [
      go-left
      set num-turtles-left (num-turtles-left + 1)
    ]
    [
      go-right
      set num-turtles-right (num-turtles-right + 1)
    ]

    ;; set the color of the turtles to give a rough idea of how many turtles
    ;; are at each location -- the lighter the color, the greater the number
    ;; of turtles
    set color scale-color blue (count turtles-here) (number-of-turtles / 5) 0
  ]

  tick

  ;; do plotting
  draw-plot num-turtles-right num-turtles-left

  ;; update the sums of right and left turns
  set sum-right-turns (sum-right-turns + num-turtles-right)
  set sum-left-turns (sum-left-turns + num-turtles-left)
end

;; turn left and go one-pace
to go-left  ;; turtle procedure
  lt 90
  one-pace
end

;; go forward number-of-steps, turn upwards and go forward number-of-steps
to one-pace  ;; turtle procedure
  fd number-of-steps
  set heading 0
  fd number-of-steps
end

;; turn right and go one-pace
to go-right  ;; turtle procedure
  rt 90
  one-pace
end

;; update the plot
to draw-plot [ num-right num-left ]
  set-current-plot-pen ""Turned Right""
  plot num-right
  set-current-plot-pen ""Turned Left""
  plot num-left
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2002.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Random Walk Left Right model.
; http://ccl.northwestern.edu/netlogo/models/RandomWalkLeftRight.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/RandomWalkLeftRight
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This is a model to simulate a random walk.  In this simulation, all turtles walk to the left and forward or they walk to the right and forward.  The turtles randomly choose between either direction each time they move.

The path traced out by the turtles moving in this pattern is called a lattice.

As the simulation continues, one can expect the turtles to become more spread out.  Observe the kinds of patterns that develop as the turtles move.

Shading of turtles is representative of how many turtles share that location. Dark shades imply more turtles.  Light shades imply fewer turtles.

For purposes of this simulation, ""forward"" will mean moving toward the top of the view, ""left"" will mean moving toward the left edge of the view, and ""right"" will mean moving toward the right edge of the view.


HOW TO USE IT
-------------
Use the NUMBER-OF-TURTLES slider to select how many turtles will participate in the random walk.

Use the NUMBER-OF-STEPS slider to decide how many steps a turtle will take on each turn.

How steps are implemented:
- If NUMBER-OF-STEPS is set to 1 and a turtle is going left, it will go left one step and then go forward one step. (Imagine a turtle walking along the bottom and left edge of a 1 x 1 square.)
- If NUMBER-OF-STEPS is set to 4 and a turtle is going left, it will go left four steps and then go forward four steps. (Imagine a turtle walking along the bottom and left edge of a 4 x 4 square.)
- Each of the above movements would be considered a single ""pace.""

The CLOCK monitor displays how many paces the turtles have taken.

Use the TURTLE-TRAILS? switch to have the turtles put their pens down to trace their paths and show the part of the lattice they are covering.  This switch must be set before the SETUP button is pressed.

All sliders except NUMBER-OF-TURTLES may be changed during a simulation.

Press the SETUP when all of the above selections have been made. This will create the selected number of turtles at the bottom center of the world.

Press GO ONCE button to make the turtles move one pace.

Press the GO button to make the turtles move until one of the turtles cannot complete its number of steps.  When one turtle reaches this point, all the other turtles will stop even if they can complete the step.

To stop the simulation while it is running, press the GO button again.

The gray bar in the middle of the world is at xcor = 0.  This is where all the turtles start.


THINGS TO TRY
-------------
Try to answer the questions below before running the simulations.

Record your predictions.  Compare your predicted results with the actual results.
- What reasoning led you to correct predictions?
- What assumptions that you made need to be revised?

Try different numbers of turtles while keeping all other slider values the same.

Try different numbers of steps while keeping all other slider values the same.


THINGS TO NOTICE
----------------
Think about how you would define an ""average"" turtle and an ""average"" walk.

Where would you expect an average turtle to end up at the end of the simulation?  Why?

How many paces would you expect there to be in an average walk?  Why?

What kinds of calculations or measurements would you use in trying to answer these questions?

How do your answers to the above questions compare to the average of the x coordinates of all the turtles?


EXTENDING THE MODEL
-------------------
As the model stands, it plots two lines (right and left) over time. Another way to look at this simulation is to plot the distribution of turtles.  Create a histogram to show this type of data.

The turtles will stop if they come up to an obstacle (cannot move forward or to the right/left), give the turtles the ability to think ahead and choose a different step/direction.

Give the turtles the ability to walk backwards.

Create a three dimensional lattice.


NETLOGO FEATURES
----------------
Since turtles in this model only move in the positive direction and they start at the bottom the origin is relocated to be at the bottom of the view also, so there are no patches with negative pycor.


RELATED MODELS
--------------
Random Walk 360, Galton Box, Binomial Rabbits


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Random Walk Left Right model.  http://ccl.northwestern.edu/netlogo/models/RandomWalkLeftRight.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/RandomWalkLeftRight for terms of use.
"
Binomial Rabbits,/models/Sample Models/Mathematics/Probability,";; The procedures for this model have been kept largely intact from
;; the original code written by the student. With advances in the
;; language, this code is no longer at all an optimal way of writing
;; this model. We have kept the original code for research purposes --
;; please do not use it as an example of good NetLogo coding.

turtles-own [ random-no total-ratio step x-zoom x-ave ]
patches-own [ turtle-quant turtle-bottom ]

globals  [
  x-ave-glob
  x-scale kx
  y-scale ky
  y-scale-distr ky-distr
  step1 step2 step3 step4 step5 steps
  ratio1 ratio2 ratio3 ratio4 ratio5 ratios total-ratios
]

;; x-zoom: intermediate variable for zooming
;; x-ave: intermediate variable for average line
;; x-ave-glob: intermediate variable for average line
;; kx: x axis scaling factor = 2 ^ x_scale
;; ky: normalization factor for the original line
;; ky-distr: normalization factor for the distribution line
;; step1 to step5: step sizes
;; ratio1 to ratio5: probability ratio corresponding to steps
;; turtle-quant: number of turtles on each patch
;; turtle-bottom: number of turtles on each patch of the bottom line


to setup
  ca
  set steps sentence hop-1 list hop-2 hop-3
  set ratios sentence ratio-1 list ratio-2 ratio-3
  crt number [
    set x-zoom  0
    set x-ave  0
    setxy 0  0
    set color red
    set shape ""rabbit""
    set heading  90
  ]
  set kx  x-scaling

;; below is the y-scale factor to ensure that the height of the original line and
;; average line are always about the same height, 90% of the world-height.
  set ky  (number / (world-height - 1)) / 0.9
  set y-scale-distr  (world-width - 1) * ky
  set y-scale  0
  set x-scale  (world-width - 1) * kx
  set ky-distr  0
  ask patches [ plot-green ]
  define-steps
  define-ratios
end

to go-one-hop
  hopping
  plot-violet
  plot-yellow
  tick
end

to go
   if hops = ticks [ stop ]
   go-one-hop
end

to hopping
  set kx  x-scaling
  set x-scale  (world-width - 1) * kx
  ask turtles  [
    ht
    set-step
    set x-zoom  (x-zoom + step)
    set x-ave  (x-zoom / ky)
    setxy (x-zoom / kx)  ycor
    st
  ]
end

to set-step  ;; turtle procedure
  set total-ratio  (ratio1 + ratio2 + ratio3 + ratio4 + ratio5)
  set random-no  (random-float total-ratio)
  if random-no <= ratio1
    [ set step step1 ]
  if (random-no > ratio1) and (random-no <= ratio1 + ratio2)
    [ set step step2 ]
  if (random-no > ratio1 + ratio2) and (random-no <= ratio1 + ratio2 + ratio3)
    [ set step step3 ]
  if (random-no > ratio1 + ratio2 + ratio3)
     and (random-no <= ratio1 + ratio2 + ratio3 + ratio4)
    [ set step step4 ]
  if random-no > ratio1 + ratio2 + ratio3 + ratio4
    [ set step step5 ]
end

to plot-yellow
  ask patches  [
    unplot-yellow
    set turtle-quant (count turtles-here)
  ]

  let most-turtles  max [ turtle-quant ] of patches
  ask patches [
    set ky-distr  (most-turtles / ky / int (.80 * world-height))
    set y-scale  (100 * ky-distr * ky)
    set turtle-bottom  [turtle-quant] of patch pxcor 0
    if pycor < turtle-bottom / (ky * ky-distr)
      [ set pcolor yellow ]
  ]
end

to plot-violet
  ask patches [ unplot-violet ]
  set x-ave-glob (((sum [ x-ave ] of turtles) * ky) / number)
  ask patches [
   if   ((pxcor = round  (x-ave-glob / kx))
         or  (pxcor = (round  ((x-ave-glob / kx) - world-width)))
         or  (pxcor = (round  ((x-ave-glob / kx) - (2 * world-width)))))
        and  (pycor <= (number / ky) )
       [ set pcolor  violet ]
  ]
end

to plot-green   ;; patch procedure
  if (pxcor = 0) and (pycor <= (number / ky))
    [ set pcolor green ]
end

to define-steps
  if not empty? steps  [
    set step1 first steps
    set steps butfirst steps
  ]
  if not empty? steps  [
    set step2 first steps
    set steps butfirst steps
  ]
  if not empty? steps  [
     set step3 first steps
    set steps butfirst steps
  ]
  if not empty? steps  [
    set step4 first steps
    set steps butfirst steps
  ]
  if not empty? steps  [
    set step5 first steps
    set steps butfirst steps
  ]
end

to define-ratios
  set total-ratios 0
  if not empty? ratios  [
    set ratio1 first ratios
    set ratios butfirst ratios
  ]
  if not empty? ratios  [
    set ratio2 first ratios
    set ratios butfirst ratios
  ]
  if not empty? ratios  [
    set ratio3 first ratios
    set ratios butfirst ratios
  ]
  if not empty? ratios  [
    set ratio4 first ratios
    set ratios butfirst ratios
  ]
  if not empty? ratios  [
    set ratio5 first ratios
    set ratios butfirst ratios
  ]
end

to unplot-yellow   ;; patch procedure
  if pcolor = yellow
    [ set pcolor black ]
end

to unplot-violet   ;; patch procedure
  if pcolor = violet
    [ set pcolor black ]
  plot-green
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Binomial Rabbits model.
; http://ccl.northwestern.edu/netlogo/models/BinomialRabbits.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/BinomialRabbits
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model simulates a binomial probability distribution or (in the limit) normal distribution.

This model was created by a student in an effort to make sense of normal distributions.  In particular, he sought to understand  why height is distributed normally in human populations. For a detailed account of this case, see: Wilensky, U. (1997). What is Normal Anyway? Therapy for Epistemological Anxiety.  Educational Studies in Mathematics. Volume 33, No. 2. pp. 171-202. http://ccl.northwestern.edu/cm/papers/normal/.

The procedures for this model have been kept largely intact from the original code written by the student. With advances in the language, this code is no longer at all an optimal way of writing this model. We have kept the original code for research purposes -- please do not use it as an example of good NetLogo coding.

The model works by analogizing height variations to rabbit hops.

A number of rabbits are placed at the center of the bottom of the world.  A move pattern determines the way a rabbit moves.  Each rabbit can choose to hop right or left a certain hop-size. The likelihood of a rabbit following each move pattern is given in terms of ratios.  Each rabbit may have up to five different move patterns.


HOW TO USE IT
-------------
Setup

Method one (sliders setup): Press SETUP button. This creates the number of rabbits from the NUMBER slider and up to three hops and associated probability ratios from the six sliders above the NUMBER slider.  Each time a rabbit hops, it chooses one of the three moves -- hop-1, hop-2, or hop-3 -- with a likelihood in the ratio of ratio-1, ratio-2, and ratio-3 to each other.  For example, if ratio-1 = 2, ratio-2 = 4, and ratio-3 = 6, the rabbit has a 2-in-12 chance of making the hop-1 move, a 4-in-12 chance of making the hop-2 move, and a 6-in-12 chance of making the hop-3 move.

Method two (manual setup): In the Command Center, type ""setup [number] [list of hops [list of probability ratios]"" to initialize the rabbits (e.g. ""setup 4000 [1 -1] [1 2]"" will set up 4000 rabbits hopping either one unit to the right(1) or one unit to the left (-1) with a chance of hopping to the left being twice as much as that to the right.)  Up to five steps and corresponding probability ratios can be used.

The GO-ONE-HOP button makes each rabbit hop once.

The GO button tells the rabbits to hop the number of times set by the HOPS slider. For example, if HOPS is set to 10, the GO button makes each rabbit hop 10 times.  To stop the rabbits from hopping once they've started, press the GO button again.

There are two scale monitors and one scale slider in the Interface Window.  X-SCALING is used to magnify the width of the world to facilitate more hops. It is manually set by users with the X-SCALING slider. The setting can be changed as the model runs.  Y-SCALE is used to regulate the vertical scale -- to ensure that the highest yellow distribution bar is always 80% of the height of the world. This is done at each hop.

The figure inside the ""y-scale"" monitor is the number of rabbits a yellow line the height of the world represents.  The figure inside the ""x-scale"" monitor is the number of steps represented by a full view. (The rabbits wrap around the left and right edges, so if they get to the edge, you should increase the x-scale.)

The following formulae can be used to evaluate the actual numbers of rabbits or steps hopped:

Actual Number of Rabbits for a Yellow Line = height of line * ( y-scale / 100 )

Cumulative Number of Steps Hopped so far = X-coordinate of a line * ( x-scale / 100 )

To find out exactly how many rabbits are represented by a line, control-click (Mac) or right-click (other) anywhere on the line and choose inspect patch from the menu that appears.  The inspector will have a variable ""turtle-bottom"" which will tell you how many turtles (rabbits) are at the bottom of the line.)



THINGS TO NOTICE
----------------
The purple average line shows where an average rabbit would be. Observe the movement of this line -- both its position and velocity -- and try to relate these to the settings.

Play with the NUMBER slider to see if what you predict is what you see when the number of rabbits is small. For what numbers of rabbits are your predictions the most accurate?


THINGS TO TRY
-------------
Try different values for list of steps. What happens to the distribution?

Try different values for probability ratios.  What happens to the distribution?

Is the distribution always symmetric? What would you expect?


EXTENDING THE MODEL
-------------------
Create a plot for 'hopping'. First decide what to plot, and then implement the proper NetLogo plot functions.
Rewrite the model so rabbits take list variables. Are there now new capabilities you can give the rabbits?


NETLOGO FEATURES
----------------
The limitation on the number of turtles constrains the limits of the ""number"" slider. You can make the corresponding change to the NUMBER slider - select the slider by clicking and dragging the mouse button over it.  Then click on the edit button and change 'Maximum' to the new number. Having more rabbits to jump can be useful for certain statistical simulations.

You can also change the settings to have a bigger world to fit more hops or show very fine distribution diagrams.

Note that since turtles could not have list variables in earlier versions of the language, the global lists steps and ratios are used to hold the movement patterns and ratios. The turtles access these globals to know how to move. (if we were writing this model now, we would not code it this way as turtles in NetLogo can have list variables). The procedures 'define-steps' and 'define-ratios' use the primitives 'first' and 'butfirst'. Both of these are list operators - that is, they operate on lists of things. The 'first' of a list is simply its first element. Likewise, the 'butfirst' of a list is a list of all elements except for the first.


RELATED MODELS
--------------
Galton Box, Random Walk Left Right


CREDITS AND REFERENCES
----------------------
See: Wilensky, U. (1997). What is Normal Anyway? Therapy for Epistemological Anxiety.  Educational Studies in Mathematics. Volume 33, No. 2. pp. 171-202. http://ccl.northwestern.edu/cm/papers/normal/

To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Binomial Rabbits model.  http://ccl.northwestern.edu/netlogo/models/BinomialRabbits.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/BinomialRabbits for terms of use.
"
PANDA BEAR Solo,/models/Sample Models/Mathematics/Unverified,";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Variable and Breed declarations ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

globals [
  red-vertex          ;; the red vertex
]

breed [ vertices vertex ]

;; vertices keep track of who is next in line
;; because the area calculation requires it.
vertices-own [ next-vertex ]

;;
;; Setup Procedures
;;

;; Initializes the display, and creates a list that contains the names of the shapes
;; used by turtles in this activity.  Also initializes the data lists.
to setup
  ca
  setup-plot
  set-default-shape vertices ""circle""
  create-vertices number-vertices [
    setup-vertex-vars
  ]
  ;; one of the vertices is specially controlled by the
  ;; controls in the interface, designate it here.
  ask one-of vertices [
    set color red
    set shape ""monster""
    set red-vertex self
  ]
  ;; make the polygon
  ask one-of vertices [ edgify ]
  ;; update the data in the display
  display-angles-and-lengths
  update-plots
end

;; initialize the plot
to setup-plot
  set-current-plot ""PANDA""
  clear-plot
end

;; sets the turtle variables to appropriate initial values
to setup-vertex-vars  ;; vertex procedure
  set color brown
  setxy random-xcor random-ycor
  set heading 0
  set label-color white
  set next-vertex nobody
end

;; recursive procedure that links all the vertices together
;; one at a time.
to edgify
  ;; each vertex is linked to once and then, in turn links to
  ;; another vertex that has not yet been linked, when we
  ;; run out of vertices we've made a line and we just need
  ;; to close the polygon by linking back to the beginning
  let candidates other vertices with [ not any? link-neighbors ]
  ifelse any? candidates
  [
    set next-vertex one-of candidates
    create-link
    ask next-vertex [ edgify ]
  ]
  [
    set next-vertex one-of other vertices with [ count link-neighbors = 1 ]
    create-link
  ]
end

to create-link
  create-link-with next-vertex [
    set color white
    set label-color white
  ]
end

;;
;; Runtime Procedures
;;

to go
  if mouse-down? [
    ;; clicking ""picks up"" the closest vertex
    ask min-one-of vertices [ distancexy mouse-xcor mouse-ycor ] [
      ;; if the mouse is more than 1 patch away from any
      ;; vertex just ignore the click.
      if distancexy mouse-xcor mouse-ycor < 1
      [
        while [mouse-down?] [
          ;; use EVERY to limit how much data we end up plotting
          every 0.05 [
            ;; don't move vertices directly on top of one another
            if all? other vertices [ xcor != mouse-xcor or ycor != mouse-ycor ] [
              setxy mouse-xcor mouse-ycor
              display-angles-and-lengths
              update-plots
            ]
          ]
        ]
      ]
    ]
  ]
end

to display-angles-and-lengths
  ask links [
    set label less-precise link-length
  ]
  ask vertices [
    ;; make sure the angle is positive
    let my-neighbors sort link-neighbors
    let angle (subtract-headings towards first my-neighbors towards last my-neighbors) mod 360
    ;; make sure the angle is the interior angle
    if angle > 180 [ set angle 360 - angle ]
    set label less-precise angle
  ]
end

;;; called when a vertex moves
to update-plots
  set-current-plot ""PANDA""
  set-current-plot-pen ""perimeter""
  plot perimeter
  set-current-plot-pen ""area""
  plot area
end

;;; used to keep the labels from having too much cluttering detail
to-report less-precise [ precise-num ]
  report precision precise-num 1
end

to-report perimeter
  report sum [link-length] of links
end

;; this area calculation is based on the formula found here:
;; http://mathworld.wolfram.com/PolygonArea.html
to-report area
  let result 0
  ask vertices [
    let addend ((xcor * [ycor] of next-vertex) -
        (ycor * [xcor] of next-vertex))
    set result result + addend
  ]
  report abs (result / 2)
end


;; red-vertex commands

to move-fd
  ask red-vertex [
    ;; pre-check that no other vertices are on the point we're headed to
    let new-xcor (xcor + step-size * dx)
    let new-ycor (ycor + step-size * dy)
    if all? vertices [xcor != new-xcor or ycor != new-ycor] [
      fd step-size
      ;; always update the perimeters and areas
      display-angles-and-lengths
      update-plots
    ]
  ]
end

to move-bk
  ask red-vertex [
    ;; pre-check that no other vertices are on the point we're headed to
    let new-xcor (xcor + step-size * (- dx))
    let new-ycor (ycor + step-size * (- dy))
    if all? vertices [xcor != new-xcor or ycor != new-ycor] [
      bk step-size
      ;; always update the perimeters and areas
      display-angles-and-lengths
      update-plots
    ]
  ]
end

to turn-right
  ask red-vertex [
    rt turn-amount
  ]
end

to turn-left
  ask red-vertex [
    lt turn-amount
  ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2007 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Unterman, J. and Wilensky, U. (2007). NetLogo PANDA BEAR Solo model.
; http://ccl.northwestern.edu/netlogo/models/PANDABEARSolo.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2007 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/PANDABEARSolo
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This is a Solo version of the HubNet activity called Perimeters and Areas by Embodied Agent Reasoning, or PANDA BEAR. PANDA BEAR Solo can be used as a standalone activity or as an introduction to PANDA BEAR.

PANDA BEAR is a microworld for mathematics learning that lies at the intersection of dynamic geometry environments and participatory simulation activities. Whereas PANDA BEAR involves many people controlling individual vertices of a shared, group-polygon, in PANDA BEAR Solo, an individual user controls all of the vertices of a polygon. The measures of perimeter and area of the polygon are foregrounded in the environment. The model user can be given challenges regarding the polygon's perimeter and area as suggested in the THINGS TO TRY section.


HOW TO USE IT
-------------
SETUP initializes the model to create a polygon containing NUMBER-VERTICES vertices. GO allows the user to move the vertices around with the mouse. The PERIMETER and AREA monitors update automatically as the vertices move around. The PANDA plot shows both of those measures over time as a record of the user's actions as they work towards a goal. SETUP-PLOT resets the plot to start a new challenge with the same polygon. The MOVE-FD, MOVE-BK, TURN-RIGHT, and TURN-RIGHT buttons change the red vertex's location and heading. The STEP-SIZE and TURN-AMOUNT input boxes control the amount of movement of the MOVE-FD, MOVE-BK, TURN-RIGHT, and TURN-RIGHT buttons.


THINGS TO NOTICE
----------------
In a triangle, for an individual vertex, moving ""between"" the other two vertices minimizes the perimeter for a given area.

In a triangle, when all three vertices attempt to form an isosceles triangle, and equilateral triangle is formed.

Strategies that work for challenges at the triangle level often work at the square level as well.

As the number of vertices is increased, the polygon that maximizes the area given a perimeter and minimizes the perimeter given an area gets closer and closer to a circle.


THINGS TO TRY
-------------
With three vertices, make the area as big as possible while keeping the perimeter at or below 25.

With three vertices, make the perimeter as small as possible while keeping the area at or above 25.

Increase the number of vertices in the polygon from three to four (and beyond - approaching a circle) and do the above.

Modify the challenges in a patterned way. For example, with four vertices, doubling the allowed perimeter should quadruple the maximum area.


EXTENDING THE MODEL
-------------------
Add different methods of movement. For example, instead of turning and going forward and backward, the user could be allowed to move the red vertex in the 4 cardinal directions.

Allow the user to give the vertices movement rules to follow over and over so that the group-polygon ""dances"".


NETLOGO FEATURES
----------------
This model uses links to form the sides of the polygon, each vertex is linked to exactly two other vertices.  The sum of the lengths of all the links is the perimeter of the polygon.

The area calculation is based on information found here: http://mathworld.wolfram.com/PolygonArea.html


RELATED MODELS
--------------
PANDA BEAR


CREDITS AND REFERENCES
----------------------
Thanks to Josh Unterman for his work on this model.


To refer to this model in academic publications, please use:  Unterman, J. and Wilensky, U. (2007).  NetLogo PANDA BEAR Solo model.  http://ccl.northwestern.edu/netlogo/models/PANDABEARSolo.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2007 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/PANDABEARSolo for terms of use.
"
Surface Walking 2D,/models/Sample Models/Mathematics/Unverified,";; =========================== Main Procedures ===============================

to setup
  clear-all
  if surface-shape = ""circle"" [ draw-big-circle ]
  if surface-shape = ""square"" [ draw-square     ]
  if surface-shape = ""mouse""  [ draw-mouse      ]
  ask n-of number-of-turtles patches with [any? different-colored-neighbors]
    [ sprout 1
       [ set size 5
         set pen-size 2
         set color one-of remove violet base-colors ] ]
end

to go
  ask turtles [ sfd step-size ]
  tick
end

;; =========================== Surface Walking ===============================

to sfd [how-far]  ;; turtle procedure
  face-chosen-neighbor
  fd how-far
end

to face-chosen-neighbor  ;; turtle procedure
  ;; turtle faces the patch that requires the least change in
  ;; heading to face
  let closest-border-patch min-one-of different-colored-neighbors [abs turn-amount]
  rt [turn-amount / 2] of closest-border-patch
end

;; computes the turn the calling turtle would have to make to face this patch
to-report turn-amount  ;; patch procedure
  let this-patch self
  report [subtract-headings (towards this-patch) heading] of myself
end

;; ======================= Other Surface Procedures ==========================

to draw-surface
  while [mouse-down?] [
    create-turtles 1 [
      setxy mouse-xcor mouse-ycor
      ask patches in-radius 3 [ set pcolor violet ]
      die
    ]
    display
  ]
end

to-report different-colored-neighbors  ;; patch procedure
  ;; report neighbors that are a different color than me
  report neighbors with [pcolor != [pcolor] of myself]
end

;; =========================== Surface Drawing ===============================

to draw-big-circle
  draw-circle 0 0 (world-width * 0.45)
end

to draw-square
  ask patches with [pxcor > world-width * -0.45 and
                    pxcor < world-width *  0.45 and
                    pycor > world-width * -0.45 and
                    pycor < world-width *  0.45]
    [ set pcolor violet ]
end

to draw-mouse
  draw-circle 0                    (world-width * -0.1 ) (world-width * 0.35)
  draw-circle (world-width *  0.3) (world-width *  0.25) (world-width * 0.17)
  draw-circle (world-width * -0.3) (world-width *  0.25) (world-width * 0.17)
end

to draw-circle [x y radius]
  ask patches with [distancexy x y < radius]
    [ set pcolor violet ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2007 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilkerson, M. and Wilensky, U. (2007). NetLogo Surface Walking 2D model.
; http://ccl.northwestern.edu/netlogo/models/SurfaceWalking2D.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2007 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/SurfaceWalking2D
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model is a 2D version of a surface-walking algorithm used in ""Surface Walking 3D"". Turtles approximate a user-defined surface using a simple algorithm that considers the turtle's current position relative to neighboring surface patches.


HOW IT WORKS
------------
Turtles exist in a world that consists of two different kinds of patches: surface and non-surface. Turtles follow two basic rules in order to walk along the patch-defined surface:

1) Look for opposite neighboring patches. If the turtle is currently on a surface patch, it will look for a non-surface one, and vice versa.
2) Of those neighboring patches of opposite type, identify the one that requires the smallest change in turtle heading for the turtle to face.
3) Turn halfway to that patch that requires the smallest change in heading to face and take a step.

Why does this algorithm work? Consider any perturbation along a flat surface (in the case of 2D, a curve or angle along an otherwise straight line). In order to traverse the perturbation and remain on the surface, a turtle needs to find and remain on the 'edge' of the surface, and maintain its direction while travelling along this edge. Since turtles in NetLogo always report being on only one patch (the one that the center of their body is over), we maintain the turtle's position along the edge by having it search for a patch that is of opposite type to the patch it is positioned over (Rule 1).

Rule 2 enables the turtles to travel along that edge while maintaining their current direction. Consider a surface in 2d: turtles are able to travel along that surface in one of two opposite directions (for example, they can walk along a circle in either a clockwise or counterclockwise direction). If a surface is flat, a turtle needs not change its heading at all to continue to travel in the same direction along that surface. But, if the surface is curved or has an angle, then in order to continue to stay along the edge of the surface the turtle must change its heading. If it changes its heading exactly 180 degrees, it will reverse its direction of travel. But whether the angle is concave or convex, it will be of some measure between 0 and 360 degrees (non-inclusive). Then the heading change required to continue along the surface without reversing the direction of travel will be less than that required to reverse direction.

Finally, Rule 3 reduces the 'weaving' effects produced by turtles moving toward surface and non-surface patches in order to remain close to the edge by having turtles actually point only halfway to the patch of interest.


HOW TO USE IT
-------------
NUMBER-OF-TURTLES: Allows the user to adjust the number of turtles that will appear along the shape surface when SETUP is pressed.
STEP-SIZE: Allows the user to adjust how far each turtle moves forward during each step.
SURFACE-SHAPE: Allows the user to select the surface shape to appear when SETUP is pressed.
COLORED-SURFACE?: Allows user to toggle whether the surface on which turtles will walk is colored red, or is invisible.
DRAW-SURFACE: Allows the user to add mouse-drawn components to an existing surface by pressing the button and then clicking and dragging anywhere in the view. The area surrounding patches identified by the mouse will be set to behave as a surface, and if the COLORED-SURFACE? switch is on, the area will also turn red.
TRACE: Asks one of the turtles to draw a trail as it moves.
SETUP: Sets up the environment by creating a surface and placing turtles along the surface.
GO: Runs the model by asking turtles to walk along the surface.


THINGS TO NOTICE
----------------
Try adjusting STEP-SIZE while the model is running. What happens to the motion of the turtles? What happens to their speed?

Do turtles behave differently on different types of surfaces? Try using the SURFACE-SHAPE chooser to test different shapes. Then, try drawing your own by clicking on DRAW-SURFACE and clicking and dragging your mouse in the view.


THINGS TO TRY
-------------
What might happen if the STEP-SIZE is set to 1 or larger? Currently, turtles turn half of the way to the edge-patch they identify. What happens if they turn the whole way?

Select ""Mickey Mouse"" from the SURFACE-SHAPE chooser. SETUP and tell the model to GO. What happens to turtles when they pass over the acute angles where Mickey's ears meet his head? Try adjusting the STEP-SIZE slider while the model is running to investigate.

When does the surface-walking algorithm fail? Why? Use the DRAW-SURFACE button to test different shapes and angles. Does changing the resolution of the world's grid of patches affect turtle motion?


EXTENDING THE MODEL
-------------------
Currently, turtles seek the surface edge by seeking patches that are classified in certain ways. Find and implement another way that patches can be identified or that turtles can identify edge patches.

Try using STAMP to trace the trajectory of a turtle over different kinds of surfaces. How might one describe surface-walking accuracy?

The surface-walking algorithm used in this model fails for surfaces (or gaps in surfaces) that are only one patch wide. Why? How might this be fixed?


NETLOGO FEATURES
----------------
Note the use of TOWARDS to compute headings and MIN-ONE-OF to make a choice between competing patches.


RELATED MODELS
--------------
See Surface Walking 3D (NetLogo 3D) and Virus on a Surface 3D (NetLogo 3D).

Wall Following Example is a simpler version of this example.  It is entirely grid-based; the turtles move from patch center to center.  The code for this is much less complicated and the turtles are always able to follow the wall perfectly correctly.


CREDITS AND REFERENCES
----------------------
Thanks to Michelle Wilkerson for her work on this model.

To refer to this model in academic publications, please use:  Wilkerson, M. and Wilensky, U. (2007).  NetLogo Surface Walking 2D model.  http://ccl.northwestern.edu/netlogo/models/SurfaceWalking2D.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2007 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/SurfaceWalking2D for terms of use.
"
Turtles Circling,/models/Sample Models/Mathematics,"to setup
  setup-circle radius number
  setup-plot
end

to setup-circle [r n]
  clear-all
  set-default-shape turtles ""circle""
  ;; turtles should be evenly spaced around the circle
  create-ordered-turtles n [
    set size 2  ;; easier to see
    fd r
    rt 90
  ]
end

to setup-plot
  set-current-plot ""Distance from the origin""
  set-plot-y-range 0 max-pxcor
end

to all-circle
  circle radius
  display
end

to circle [r]
  ask turtles [ move-along-circle r ]
  if plot? [ plot [distancexy 0 0] of turtle 0 ]
end

to move-along-circle [r]
  fd (pi * r / 180) * (speed / 50)
  rt speed / 50
end

to zero-circle
  ask turtle 0
    [ pen-down
      move-along-circle radius ]
  display
end

to draw-circle
  clear-drawing
  create-turtles 1
    [ set color gray - 3
      set size 2 * draw-radius
      set shape ""circle""
      stamp
      die ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1997 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1997).  NetLogo Turtles Circling model.
; http://ccl.northwestern.edu/netlogo/models/TurtlesCircling.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1997 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/TurtlesCircling
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This is a new kind of mathematical investigation -- we are investigating the emergent shape created by the movement of many turtles moving independently in simple ways. Each turtle is moving so as to create a circle of a fixed radius (set by the RADIUS slider).  What happens if the radius they are all circling at is changed in mid-action? Guess before you try it.


HOW IT WORKS
------------
The turtles create their circles by moving forward a little and turning right a little so as to end up with a circle of the specified radius. We start all the turtles on a circle of that radius so they move around the circle.


HOW TO USE IT
-------------
The NUMBER slider determines the number of turtles circling.

The RADIUS slider determines the size of the circle each turtle moves on.

The SPEED slider determines how large a step each turtle take at each clock tick -- it determines the speed of circling.

The SETUP button creates NUMBER turtles on a circle of radius RADIUS centered at the point (0 0). The turtles are all headed so as to move around the circle.

The ALL-CIRCLE button starts the turtles circling. They are each drawing their own circle of radius RADIUS.

Change the value of the RADIUS slider while the turtles are circling.  *Before* you do it, what is your guess as to what will happen when you change the RADIUS?


THINGS TO NOTICE
----------------
What is happening to the shape described by the turtles?

How far out do the turtles go?

How far in do they come?


THINGS TO TRY
-------------
Try different values of both starting radius and changed radius.

You can also do further investigations with the following controls:

The ZERO-CIRCLE button lets you just focus on turtle zero's movement -- all the rest are stopped.

The DRAW-CIRCLE button lets you draw a circle on the patches with a radius equal to DRAW-RAD. This way you can track the movement of the turtles.

If the PLOT? switch is on, the plot will show a plot of turtle zero's distance from the origin as the turtles circle.

Try the command  LT 50  while the turtles are circling. Is this the same behavior as you observed when changing the radius?

In the Command Center, get a single (or several) turtles to trace their path using the command PEN-DOWN (PD).  This may help to show the relationship between the circles of individual turtles and the circle you see as they all move together.


EXTENDING THE MODEL
-------------------
What tools can you build to help visualize what is going on?


NETLOGO FEATURES
----------------
The DISPLAY command is used for smooth animation.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1997).  NetLogo Turtles Circling model.  http://ccl.northwestern.edu/netlogo/models/TurtlesCircling.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1997 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/TurtlesCircling for terms of use.
"
Color Fractions,/models/Sample Models/Mathematics,"patches-own [ column-number ]

to setup
  clear-all
  ask patches
    [ set plabel-color black
      set column-number pxcor + max-pxcor ]
  go
end

to go
  let n numerator
  ;; go through every patch one at a time in order,
  ;; (left to right, top to bottom)
  foreach sort patches
    [ ask ?
        [ ifelse column-number >= width
            ;; patches outside the given width are black
            [ set plabel """"
              set pcolor black ]
            ;; other patches get a color and label
            [ ;; perform the division
              set plabel floor (n / denominator)
              ifelse plabel = 0
                [ set pcolor gray + 1.5 ]          ;; 0 is gray
                [ set pcolor plabel * 10 + 6 ]     ;; other digits get colors
              ;; compute the new numerator
              set n 10 * remainder n denominator
            ] ] ]
  ;; put a decimal point after the number in the
  ;; upper left corner patch
  ask patch min-pxcor max-pycor
    [ set plabel word plabel ""."" ]
  display
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2005 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2005).  NetLogo Color Fractions model.
; http://ccl.northwestern.edu/netlogo/models/ColorFractions.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2005 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/ColorFractions
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
Color Fractions displays the decimal form of a fraction as a pattern of colors.  This lets you investigate how the resulting patterns relate to the original fraction.


HOW IT WORKS
------------
The program computes the digits of the decimal the same way you would do it using long division on paper.

It takes the numerator and divides it by the denominator; the result is a digit.  The remainder of the division, we multiply by 10 and take as the new numerator, then repeat.

For example these would be the steps for computing 1/7:
- 7 goes into 1  0 times; 10 times remainder is 10
- 7 goes into 10 1 time ; 10 times remainder is 30
- 7 goes into 30 4 times; 10 times remainder is 20
- 7 goes into 20 2 times; 10 times remainder is 60
- 7 goes into 60 8 times; 10 times remainder is 40
And so on forever.  Thus the result is 0.1428...

To make the pattern of colors, each digit, 0 through 9, is shown in its own color.  For example 0 is gray, 1 is light red, 2 is orange, etc.


HOW TO USE IT
-------------
Press the SETUP button, then press GO.

Now adjust the numerator and denominator sliders to make any fraction.

You can also use the WIDTH slider to change the total number of digits per row.  Changing the width can make patterns easier or harder to see.


THINGS TO NOTICE
----------------
The same fraction always gives the same pattern.

Some patterns stop after a few digits, while others repeat forever.  (Do all fractions repeat?)

Do two fractions ever give the same pattern?


THINGS TO TRY
-------------
What kinds of patterns can you generate with fractions? Can you create a checkerboard?  Can you make vertical stripes?

What happens if you try different numerators with the same denominator?  What do the patterns you get have in common?  Try this experiment with several different denominators.

The ""period"" of a fraction is how many digits repeat to make the pattern.  For example, 1/3 is 0.33333... which repeats the same single digit over and over again, so the period is 1.  Look at the pattern for the fraction 1/7; the period is 6.  And so on.

How is the period of a fraction 1/n related to n?  How are the periods of the fractions family 1/7, 2/7, ... related?

How many fractions can you find that have the same number of repeating digits?

What fraction best approximates pi (3.141592...)?


EXTENDING THE MODEL
-------------------
Change the colors so odd numbers are all one color and even numbers are another color.

Change the colors so you only use one color, but vary the lightness/darkness.

Modify the program so you can visualize square roots and pi.

Extend the program so you can have a full fraction Calculator such as the one in the references http://tapor1.mcmaster.ca/~sgs/cgi-bin/Maths/maths.cgi?theme=none&lang=en&do=activity&activity=calc&level=0.


NETLOGO FEATURES
----------------
Patch labels are used to show the digits.

You can use the SORT primitive to created a list of patches sorted left-to-right, top-to-bottom.  That is necessary in this model because we need the patches to execute in the same order at every tick, rather than a different random order every tick as would happen if we just said ""ask patches"".


RELATED MODELS
--------------
Division


CREDITS AND REFERENCES
----------------------
This model is adapted from:
Color Calculator Information for teachers:
http://tapor1.mcmaster.ca/~sgs/cgi-bin/Maths/maths.cgi?theme=none&lang=en&do=asides&activity=calc
and
Color Calculator:
http://tapor1.mcmaster.ca/~sgs/cgi-bin/Maths/maths.cgi?theme=none&lang=en&do=activity&activity=calc&level=0

This model implements activities originally published in:
Nathalie Sinclair, Rina Zazkis and Peter Liljedahl.  Number Worlds: Visual and Experimental Access to Elementary Number Theory Concepts.  International Journal of Computers for Mathematical Learning, Volume 8, Number 3, pages 235 - 263, January 2003.

To refer to this model in academic publications, please use:  Wilensky, U. (2005).  NetLogo Color Fractions model.  http://ccl.northwestern.edu/netlogo/models/ColorFractions.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2005 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/ColorFractions for terms of use.
"
Conic Sections 1,/models/Sample Models/Mathematics,"turtles-own [dist           ;; distance from 'goal' in current state
             diff           ;; modified distance to x and y intercepts in current state
             old-diff]      ;; modified distance to x and y intercepts in last state

globals [cx                 ;; x-cor of the circle's center
         cy                 ;; y-cor of the circle's center
         f0x                ;; x-cor of focus 0 (for ellipse)
         f0y                ;; y-cor of focus 0 (for ellipse)
         f1x                ;; x-cor of focus 1 (for ellipse)
         f1y                ;; y-cor of focus 1 (for ellipse)
         state]             ;; flag to alternate which focus user is moving


to setup
  clear-all
  ask patch 0 0 [ set pcolor white ]
  crt num-turtles [
    set color green
    setxy random-xcor random-ycor
  ]
end

to watch-mouse-1  ;; turns focus white where mouse is clicked
  if mouse-down? [
    clear-patches
    set cx round mouse-xcor
    set cy round mouse-ycor
    ask patch cx cy [ set pcolor white ]
  ]
end

to watch-mouse-2  ;; turns two foci white
  if not mouse-down? [ stop ]
  let mousex (round mouse-xcor)
  let mousey (round mouse-ycor)
  if [pcolor] of patch mousex mousey = white [ stop ]
  ask patches [ set pcolor black ]
  ifelse (state = 0)
    [set f0x (round mouse-xcor)
     set f0y (round mouse-ycor)
     set state 1]
    [set f1x (round mouse-xcor)
     set f1y (round mouse-ycor)
     set state 0]
  ask patch f0x f0y [ set pcolor white ]
  ask patch f1x f1y [ set pcolor white ]
end

to go
  ifelse mouse-down? [
    ifelse not second-focus?
      [watch-mouse-1]
      [watch-mouse-2]
  ]
  [ ask turtles [ move-turtles ] ]
  tick
end

to move-turtles ; turtle procedure
  let old-dist dist
  ifelse not second-focus?
    [set dist (distancexy cx cy)]
    [set dist ((distancexy f0x f0y) + (distancexy f1x f1y)) / 2]
  ifelse ((round dist) = constant)
   [stop]
   [ifelse ((dist < old-dist) and (dist > constant))
     [fd 1]
     [ifelse ((dist > old-dist) and (dist < constant))
       [fd 1]
       [rt random-float 360 fd 1]]]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Conic Sections 1 model.
; http://ccl.northwestern.edu/netlogo/models/ConicSections1.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/ConicSections1
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
The model displays two basic conic sections: circles and ellipses. The figures are generated behaviorally as opposed to algebraically -- the turtles attempt to behave like points on the specified shape.


HOW IT WORKS
------------
A circle is the set of all points at a certain distance (radius) from a central point.  An ellipse is the set of points such that the sum of the distances to two points is constant.  These two points are called foci. The CONSTANT slider corresponds to the radius for circles and to the sum of distances to the foci for each turtle.

As an illustration of this, imagine a string loosely looped around two nails, each representing a focus.  If you pull the string tight with a pencil point and move the pencil point around the foci, you will draw an ellipse.

The ancient Greeks discovered that each conic section can be found by taking a cross section of one or two cones with their points pointing toward each other.  A circle results from taking a slice that is perpendicular to the axis, while an ellipse results from taking a slice of one cone that is not perpendicular to the axis. Similarly, a parabola results from a cross section that passes through one cone in a vertical fashion, such that the plane of the cut is parallel to one face. A hyperbola results from a vertical section that passes through both cones.

The turtles use feedback to make decisions about how they behave. They set out in random directions, and then they receive information as to whether or not they are getting closer to where they want to be. If they are getting closer, they continue moving forward in the direction they are going. If they are moving farther away, they set out in a new random direction. This process is akin to the children's game of ""Hot & Cold"", in which players are told whether they are getting ""hotter"" or ""colder"" in relation to a hidden goal.


HOW TO USE IT
-------------
*Circles:
-Select the number of turtles with the TURTLES slider.
-Press SETUP.
-Make sure the SECOND-FOCUS switch is set to OFF.
-Press the MOVE-TURTLES button. Adjust the radius of the circle with the CONSTANT slider. The turtles will automatically correct themselves as you change both CONSTANT and the location of the center. You can change the circle's center by clicking on a new point.

*Ellipses:
-Select the number of turtles with the TURTLES slider.
-Press SETUP.
-Make sure the SECOND-FOCUS switch is set to ON.
-Press the MOVE-TURTLES button. As for a circle, the size of the ellipse can be modified with CONSTANT, and new foci can be picked by clicking the mouse.


THINGS TO NOTICE
----------------
When forming a circle, turtles try to attain a distance of CONSTANT (a value determined by the user with a slider) from a center that the user determines by pointing and clicking (as explained above).

When forming an ellipse, turtles try to attain a combined distance of 2 * CONSTANT from the two foci, again determined by the user's points and clicks.  If the foci are too far apart, there be no way to satisfy this condition.  What do the turtles do then?


THINGS TO TRY
-------------
You may be able to get a better feeling for the turtles' behavior if only a few turtles are alive one time. Try setting num-turtles to a small value (like 16 or 1) and watching the turtles.

Both of these conic sections can be observed by shining a flashlight at a cone and looking at its shadow.  Can you figure out at what angles the cone must be held?


EXTENDING THE MODEL
-------------------
If you have access to StarLogoT (NetLogo's Macintosh-only predecessor), look at the StarLogoT model 'emergent-circle'. Watch how the turtles react with each other- something that is missing from 'Conic Sections'. Implement this emergent behavior for one or both of the conics in this project.


NETLOGO FEATURES
-----------------
The mouse primitives are used for handling interaction with the user.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Conic Sections 1 model.  http://ccl.northwestern.edu/netlogo/models/ConicSections1.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/ConicSections1 for terms of use.
"
Mousetraps,/models/Sample Models/Mathematics,"globals [traps-triggered]  ;; how many traps have been sprung?

to setup
  ca
  set traps-triggered 0
  ;; an untriggered mousetrap is light blue
  ask patches
    [ set pcolor blue + 3 ]
  set-default-shape turtles ""circle""
  ;; make the first ball
  crt 1
    [ set color white
      set size 1.5 ]  ;; easier to see
  do-plots
end

to go
  if not any? turtles
    [ stop ]
  ask turtles
    [ ;; if we hit the wall or land on a triggered mousetrap,
      ;; then stop
      ifelse pcolor = red
        [ die ]
        ;; triggered traps are red
        [ set pcolor red
          set traps-triggered traps-triggered + 1
          ;; send another ball flying off
          hatch 1
            [ move ]
          ;; also bounce ourselves
      move ] ]
  tick
  do-plots
end

to move  ;; turtle procedure
  rt random-float 360
  fd random-float max-distance
end

to do-plots
  set-current-plot ""Traps triggered""
  plot traps-triggered
  set-current-plot ""Balls in the air""
  plot count turtles
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2002 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2002).  NetLogo Mousetraps model.
; http://ccl.northwestern.edu/netlogo/models/Mousetraps.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2002 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Mousetraps
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
Imagine a gymnasium full of mousetraps.  On each mousetrap is a ping pong ball.  Now throw a single ping pong ball into the middle of the room. The ball lands on a trap, the trap triggers, and a second ball flies into the air.  The first ball also bounces into the air again, so now there are two balls in the air.  Each of those two balls triggers another trap, so there's four balls in the air. And so on...

This experiment is a well-known metaphor for nuclear fission.  In nuclear fission, atoms of fissionable material such as uranium are the ""mousetraps"", and neutrons are the ping pong balls.


HOW IT WORKS
------------
Light blue squares represent untriggered mousetraps.  Red squares represent triggered mousetraps.

When a ball lands on a light blue square, the square turns red, a new ball appears, and both balls travel a random distance in a random direction.


HOW TO USE IT
-------------
Press SETUP to set up all the mousetraps and suspend a single ping pong ball over the center.  Press GO to release the ping pong ball.

If you want to see the reaction progress in slow motion, use the GO ONCE button to advance a step at a time.

To vary the maximum distance a ping pong ball can travel when it is released or bounces, use the MAX-DISTANCE slider.


THINGS TO NOTICE
----------------
Sometimes the reaction fizzles out almost immediately.  Why do you think that happens?

Even if a sustained chain reaction occurs, not every mousetrap gets triggered.  Why?

What shape is the ""Traps triggered"" plot?  Why do you think it's shaped that way?

What shape is the ""Balls in the air"" plot?  Why do you think it's shaped that way?

Suppose the gymnasium was infinitely large.  What would the two plots look like?  What kind of equation would produce such plots?


THINGS TO TRY
-------------
Play around with varying the MAX-DISTANCE slider.  How big does MAX-DISTANCE need to be in order to get a chain reaction every time?  Most of the time?


EXTENDING THE MODEL
-------------------
There are various ways in which this model could be more physically realistic.  For example:

- Currently both a released ball and a bouncing ball travel the same maximum distance, but in reality the mousetrap would likely send the released ball much farther.  Change the model so these different distances are controlled by two different sliders.

- Currently the balls travel to their new positions instantly -- in reality it would take time proportional to the distance traveled.  (Does it make a difference if you take into account that the balls move in a parabola through the air, not a straight line?)  Change the model to take this into account.


NETLOGO FEATURES
----------------
Note the use of HATCH to cause the ping pong balls to ""multiply"".

When a turtle tries to move off the edge of the world it cannot, it hits the wall, and lands on the same mousetrap it triggered in the last step, it dies.


RELATED MODELS
--------------
Rumor Mill is very similar to this model in mechanism and results, even though the domain is completely different (people and rumors instead of mousetraps and ping pong balls).  (What other processes in nature or society does this model resemble...?)

Reactor X-Section and Reactor Top Down are two different views of nuclear fission happening inside a nuclear reactor.  They both include ways of limiting the rate of fission so the ""mousetraps"" don't all start triggering uncontrollably.


CREDITS AND REFERENCES
----------------------
This model is based on the ""Mousetrap"" demo included with the Swarm agent-based modeling toolkit (http://www.swarm.org/).  See http://acoma.santafe.edu/projects/swarm/examples/mousetrap/.  Note that this model and that demo differ in various details.

To refer to this model in academic publications, please use:  Wilensky, U. (2002).  NetLogo Mousetraps model.  http://ccl.northwestern.edu/netlogo/models/Mousetraps.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2002 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Mousetraps for terms of use.
"
Mandelbrot,/models/Sample Models/Mathematics/Fractals,"turtles-own
[
  previous-count  ; the patch color of the previous patch- used in the turtles' movement
]

patches-own
[
  c-real       ; real portion of the constant complex number c
  c-imaginary  ; imaginary portion of the constant complex number c
  z-real       ; real portion of the complex number z
  z-imaginary  ; imaginary portion of the complex number z
  counter      ; keeps track of the color that the patch is supposed to be
]

;;; Initialization Procedures

to setup
  clear-all
  setup-turtles
  setup-patches
end

to setup-turtles
  crt num-turtles
  [
    set color green
    setxy random-xcor random-ycor
    set size 3  ;; easier to see
  ]
end

to setup-patches
  ask patches
  [
    ; set the real portion of c to be the x coordinate of the patch
    set c-real (pxcor / scale-factor)
    ; set the imaginary portion of c to be the y coordinate of the patch
    set c-imaginary (pycor / scale-factor)
    ; have the initial value of z be 0 + 0i
    set z-real 0
    set z-imaginary 0
    set counter 0
  ]
end

;;; Run-Time Procedures

to go
  mandelbrot-calc-and-color
  step
  wiggle
  climb
  tick
end

; calculate the equation of the mandelbrot fractal for each patch with a turtle on it and change
; its color to be an appropriate color.
to mandelbrot-calc-and-color
  ; if the distance of a patch's z from the origin (0,0) is less than 2 and its counter is less
  ; than 256 perform another iteration the equation f(z) = z^2 + c.
  ask turtles with [(modulus z-real z-imaginary <= 2.0) and (counter < 256)]
  [
    let temp-z-real z-real
    set z-real c-real + (rmult z-real z-imaginary z-real z-imaginary)
    set z-imaginary c-imaginary + (imult temp-z-real z-imaginary temp-z-real z-imaginary)
    set counter counter + 1
    set pcolor counter
  ]
end

;ask each turtle to move forward by 1
to step
  ask turtles
  [ ifelse can-move? 1
    [ fd 1 ]
    [ setxy random-xcor random-ycor ] ]
end

;ask each turtle to change its direction slightly
to wiggle
  ask turtles
  [
    rt random 10
    lt random 10
  ]
end

;ask the turtles to climb up the counter gradient
to climb
  ask turtles
  [
    ifelse counter >= previous-count
    [
      set previous-count counter
      set color yellow
      jump throw
    ]
    [
      set previous-count counter
      set color blue
      rt 180
    ]
  ]
end

;;; Real and Imaginary Arithmetic Operators

to-report rmult [real1 imaginary1 real2 imaginary2]
  report real1 * real2 - imaginary1 * imaginary2
end

to-report imult [real1 imaginary1 real2 imaginary2]
  report real1 * imaginary2 + real2 * imaginary1
end

to-report modulus [real imaginary]
  report sqrt (real ^ 2 + imaginary ^ 2)
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Mandelbrot model.
; http://ccl.northwestern.edu/netlogo/models/Mandelbrot.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Mandelbrot
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model draws a mathematical object called the Mandelbrot set, named after its discoverer, Benoit Mandelbrot.  It demonstrates an interesting technique for generating the design as well as providing a nice example of hill climbing.

A number of fractal generation turtles do a random walk across a complex plane, computing one additional iteration of F(Z) = Z^2 + C each time they cross a patch, where C is the coordinates of the patch, and Z is a complex number from the result of the last iteration.  A count is maintained of the number of iterations computed at each patch before the complex number at that patch reaches a maximum.  This count is then translated into a color, giving the Mandelbrot set it's distinctive look.

An interesting way to view the emerging set is that you are looking straight down on one of the Hawaiian Islands.  The center is extremely high (infinitely so, in fact), simply because no fixed number of iterations at these points will cause the associated complex number to reach a pre-determined maximum.  The edges of the set are steeply sloped, and the ""sea"" around the set is very shallow.

HOW IT WORKS
------------
In case you are not familiar with complex numbers, here as an introduction to what they are and how to calculate with them.

In this model, the world becomes a complex plane.  This plane is similar to the real or Cartesian plane that people who have taken an algebra course in middle school or high school should be familiar with.  The real plane is the combination of two real lines placed perpendicularly to each other.  Each point on the real plane can be described by a pair of numbers such as (0,0) or (12,-6).  The complex plane is slightly different from the real plane in that there is no such thing as a complex number line.  Each point on a complex plane can still be thought of as a pair of numbers, but the pair has a different meaning.  Before we describe this meaning, let us describe what a complex number looks like and how it differs from a real one.

As you may know, a complex number is made up of two parts, a real number and an imaginary number.  Traditionally, a complex number is written as 4 + 6i or -7 - 17i.  Sometimes, a complex number can be written in the form of a pair, (4,6) or (-7,-17).  In general, a complex number could be written as a + bi or (a,b) in the other way of writing complex numbers, where both a and b are real numbers.  So, basically a complex number is two real numbers added together with one of them multiplied by i.  You are probably asking yourself, what is this i?  i is called the imaginary number and is a constant equivalent to the square root of -1.

Getting back to the complex plane, it is now easier to see, if we use the paired version of writing complex numbers described above, that we let the real part of the complex number be the horizontal coordinate (x coordinate) and the imaginary part be the vertical coordinate (y coordinate).  Thus, the complex number 5 - 3i would be located at (5,-3) on the complex plane.  Thus, since the patches make up a complex plane, in each patch, the pxcor corresponds to the real part and the pycor corresponds to the imaginary part of a complex number.  A quick word on complex arithmetic and you will be set to understand this model completely.

Two complex numbers are added or subtracted by combining the real portions and then combining the imaginary portions.  For example, if we were to add the two complex numbers 4 + 9i and -3 + 11i, we would get 1 + 20i, since 4 - 3 = 1 and 9 + 11 = 20.  If we were to subtract the first number from the second number, we would get -7 + 2i, since -3 - 4 = -7 and 11 - 9 = 2.  Multiplication is a bit harder to do.  Just remember three things.  First, remember that i * i = -1.  Second, be sure to follow the addition and subtraction rules supplied above.  Third, remember this scheme First Outside Inside Last or FOIL for short.  In other words, you multiply the first parts of each number, add this to the product of the outside two parts of each number, add this to the product of the inside two parts of each number, and add this to the product of the last two parts of each number.  In general, this means given two complex numbers a + bi and c + di, we would multiply the numbers in the following manner:

(a * c) + (a * di) + (bi * c) + (bi * di) = ( (a * c) - (b * d) ) + ( (a * d) + (b * c) )i

If we were to multiply the same two numbers from above, we would get -12 + 44i - 27i - 99 = -111 + 17i, since 4 * -3 = -12,  4 * 11i = 44i, 9i * -3 = -27i, and 9i * 11i = -99.


HOW TO USE IT
-------------
Click on SETUP to create NUM-TURTLES fractal generation turtles, place them in the middle of the world (at complex coordinate (0,0)), and scale the 101,101 world to approx -1 to 1 on both the real and complex planes.

To start the calculation, start the slider THROW at 0, press the GO button. Note that the system seems to stall, with each turtle ""stuck"" on a local maximum hill.

Changing THROW to 7 will ""throw"" each turtle a distance of 7 each time they reach the top of a hill, essentially giving them a second chance to climb an even greater hill.  The classic Mandelbrot shape will begin to appear fairly quickly.

The slider SCALE-FACTOR scales the fractal so that you can see more or less of it.  The higher the value, the less of the entire fractal you will see.  Be aware that you sacrifice resolution for the price of being able to see more of the fractal.


THINGS TO NOTICE
----------------
Notice that the ""aura"" around the Mandelbrot set begins to appear first, then the details along the edges become more and more crisply defined.  Finally, the center fills out and slowly changes to black.

Notice how different values for THROW change the speed and precision of the project. Also, try running the model with different values for NUM-TURTLES.


THINGS TO TRY
-------------
It's fairly easy to hack at the NetLogo code to change the scale factor- it's set as the global variable FACTOR.  You might also think about adjusting the viewport in the plane, to allow for a larger picture (although the smaller sized picture might look better and emerge quicker.)

You might also play with the colors to experiment with different visual effects.

Notice also what happens when you turn off climbing and/or wiggling.


EXTENDING THE MODEL
-------------------
Try to produce some of the other complex sets- the Julia set for instance.  There are many other fractals commonly known today.  Just about any book on them will have several nice pictures you can try to duplicate.


NETLOGO FEATURES
----------------
To accomplish the hill climbing, the code uses CURRENT-COUNT and PREVIOUS-COUNT turtle variables, comparing them to one another to establish a gradient to guide turtle movement.  The goal of each turtle is to move up the emerging gradient, ""booting itself up"" to the ever growing center of the set.

Note that there is no complex arithmetic in NetLogo, so the basic operations needed to be provided as NetLogo routines at the end of the code. These complex arithmetic routines are also used in other fractal calculations and can be tailored to your own explorations.


CREDITS AND REFERENCES
----------------------
You may find more information on fractals in the following locations:
This site offers an introduction to fractals.
http://www.cs.wpi.edu/~matt/courses/cs563/talks/cbyrd/pres1.html

An introduction to complex mathematics and the Mandelbrot set.
http://www.olympus.net/personal/dewey/mandelbrot.html

An introductory online textbook for Complex Analysis.
(Note: This is a college level text, but the first chapter or so should be accessible to people with only some algebra background.)
http://www.math.gatech.edu/~cain/winter99/complex.html

The Fractal Geometry of Nature by Benoit Mandelbrot

To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Mandelbrot model.  http://ccl.northwestern.edu/netlogo/models/Mandelbrot.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Mandelbrot for terms of use.
"
Tree Simple,/models/Sample Models/Mathematics/Fractals,"turtles-own
[ new? ]

; setup the initial turtle and its properties
to setup
  ca
  crt 1
  [
    set shape ""line""
    set color init-color
    setxy init-x init-y
    set heading 0
    pd
  ]
end

; have all non-new turtles draw an iteration of the tree
to go
  ask turtles
  [
    set new? false
    pd
  ]
; here are the commands to draw the tree
  ask turtles with [ not new? ]
  [
    fd 4
    rt 15
    fd 8
    hatch 1 [ set new? true ]
    set color (color + color-inc)
    rt 180
    jump 8
    rt 180
    lt 15
    fd 4
    lt 15
    hatch 1 [ set new? true ]
    set color (color + color-inc)
    fd 8
    die
  ]
  tick
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2001 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2001).  NetLogo Tree Simple model.
; http://ccl.northwestern.edu/netlogo/models/TreeSimple.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2001 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/TreeSimple
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This program draws special types of pictures called fractals.  A fractal is a shape that is self-similar - that is, it looks the same no matter how closely you zoom in or out.  For instance, a tree can be thought of as a fractal since if you look at the tree as a whole, you see a stick, that is to say the trunk, with branches coming out of it.  Then if you look at a smaller portion of it, say a branch, you see a similar thing, namely, a stick with branches coming out of it.


HOW TO USE IT
-------------
Perhaps the best way to start with this program is by looking at an example of a fractal.  In the ""Interface"" tab, press the SETUP button to set up a fractal that draws a tree. Then press the GO button and watch it draw.

You can also have the fractal drawn one step a time.  Once you click the SETUP button, instead of clicking the GO button, click on the GO ONCE button.  This draws the fractal by drawing one iteration of the fractal per click as opposed to continuously, like the GO button.

If you don't like the location of the fractal you can change it by modifying the value of the following sliders:
The INIT-X slider sets the initial x coordinate of the first turtle.  It changes the horizontal starting location of the original turtle.
The INIT-Y slider sets the initial y coordinate of the first turtle.  It changes the vertical starting location of the original turtle.

If you don't like the color scheme of the fractal you can change it by modifying the value of the following sliders:
The INIT-COLOR slider sets the initial color of the first turtle.
The value of the COLOR-INC slider is added to the turtles color anytime a new turtle hatches.

The NUM TURTLES monitor indicates how many turtles are currently alive.

Be aware that due to the varying systems that NetLogo runs on, it might be best to limit the number of iterations to about 8 or 9 of any particular fractal.  If you go much more than that, you might have trouble with memory problems.


THINGS TO NOTICE
----------------
Notice the self-similarity of the fractal at each iteration.  What if one were to perform an infinite number of iterations?  Would looking at any piece up close look any different than looking at the whole?  Also notice how the number of turtles in each of the example is multiplied by some number at each iteration.  Does this make sense?  Try to figure out the number of turtles at some arbitrary step n.


THINGS TO TRY
-------------
Now that you have played around with settings for the example provided, why not try making your own tree fractals.  Use NetLogo commands to make your own fractals that look like trees.  Then change the initial color and color increment values to make the fractal more interesting to look at.


EXTENDING THE MODEL
-------------------
Try adding switches or sliders such as max-increment-random-length or min-increment-random-degree or random-length that could impose a random factor to the movement of the turtles.  The use of these plus the NetLogo primitive random would increase the realism in a fractal.  This would be especially useful in drawing realistic trees since branches are not spaced uniformly on a tree nor do they all branch from the trunk at the same angle.

Pick up a book on fractals or search on the internet to find fractals that are interesting and try to create them.  Also try to find different types of fractals such as L-System Fractals.  You may find some resources below.

Try starting with more than just one turtle, in a different location or heading, and see how that can affect the fractals that you have made.  Does it ruin them or does it make them more interesting and complex?

Try to make a realistic forest.  Does this require vastly different commands from making a realistic tree?


NETLOGO FEATURES
----------------
Notice the use of agentsets to make some of the commands only affect certain turtles. For example, the reporter WITH is used to isolate non-new turtles and have the rules only affect them.  Also notice how the fractals are formed using several agents following the same rules through the use of the ""hatch"" primitive which makes it so simple to generate fractals like a tree.


RELATED MODELS
--------------
L-System Fractals


CREDITS AND REFERENCES
----------------------
This site offers an introduction to fractals, including L-system fractals as well as others.
http://www.cs.wpi.edu/~matt/courses/cs563/talks/cbyrd/pres1.html

The Fractal Geometry of Nature by Benoit Mandelbrot

To refer to this model in academic publications, please use:  Wilensky, U. (2001).  NetLogo Tree Simple model.  http://ccl.northwestern.edu/netlogo/models/TreeSimple.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2001 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/TreeSimple for terms of use.
"
Koch Curve,/models/Sample Models/Mathematics/Fractals,";; We use the built-in turtle variable SIZE to make the line
;; segment have the appropriate length.  Because the ""segment""
;; shape extends from the center of the turtle to its edge,
;; rather than from edge to edge, we need to set the size
;; to twice the segment length in order for the turtles to
;; appear the right size.  This is why we multiple or divide
;; by two in several places in the following code.

to setup
  ca
  set-default-shape turtles ""segment""
  create-turtles 1
    [ setxy min-pxcor       ;; start turtle in lower left corner
            min-pycor
      set heading 90                ;; facing right
      set color blue
      set size world-width * 2 ]
  update-plot
end

to step
  ask turtles [ iterate ]
  tick
  update-plot
end

to iterate
  set size size / 3
  hatch 1
  fd size / 2
  lt 60
  hatch 1
  fd size / 2
  rt 120
  hatch 1
  fd size / 2
  lt 60
end

to update-plot
  plot sum [size / 2] of turtles
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2002.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Koch Curve model.
; http://ccl.northwestern.edu/netlogo/models/KochCurve.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/KochCurve
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
Helge von Koch was a Swedish mathematician who, in 1904, introduced what is now called the Koch curve.

Here is a simple geometric construction of the Koch curve.  Begin with a straight line.  This initial object is also called the ""initiator.""  Partition it into three equal parts.  Then replace the middle third by an equilateral triangle and take away its base.  This completes the basic construction step.  A reduction of this figure, made of four parts, will be used in the following stages.  It is called the ""generator.""  Thus, we now repeat, taking each of the resulting line segments and partitioning them into three equal parts, and so on.  The figure below illustrates this iterative process.


|     ________________________     Step 0: ""Initiator""
|
|                /\
|               /  \
|              /    \
|             /      \
|     _______/        \_______     Step 1: ""Generator""
|
|                /\
|             __/  \__
|             \      /
|             /      \
|     ___/\__/        \__/\___     Step 2

Self-similarity is built into the construction process.  Each part of the four parts in the k-th step is again a version scaled down by the factor of 3 of the entire curve in the previous (k-1)-st step.

The Koch curve is as difficult to understand as the Cantor set or the Sierpinski tree.  However the problems with it are of a different nature.  First of all -- as the name already expresses -- it is a curve, but this is not clear from the construction.  Secondly, this curve contains no straight lines which are smooth in the sense that we could see them as a carefully bent line.   Rather this curve has much of the complexity which we could see in a natural coastline: folds within folds within folds and so on.

Actually Koch's motivation for finding this curve was to provide another example for the discovery made by the German mathematician Karl Weierstrass, who in 1872 had precipitated a minor crisis in mathematics.  He had described a curve that could not be differentiated (did not have a tangent) at any of its points.  The ability to differentiate is central to differential calculus and for a long time it was assumed that curves have tangent lines almost everywhere.

Let us now discuss the length of the Koch curve.  After the first iteration we have a curve which is made of four line segments of the same length, after the second iteration we will have each of the four segments broken into four more segments i.e. sixteen segments and so on.  After each iteration we increase the number of segments by the factor of four.  If we denote the number of segments after k-steps by S(k) then mathematically:

|             k
|     S(k) = 4

Now if the initial segment had length L the length of each of the four segments obtained after the first stage would be L/3.  After the second step the length of each of the sixteen segments is (L/3)/3 or L/9.  Denoting the length of each segment during the k-th iteration by L(k) we may write:

|                k
|     L(k) = L/(3 )

Multiplying the number of segments by the length of each segment we get the following expression for the length of the Koch curve after k steps of construction:

|            k
|     L*(4/3)


Clearly the length grows exponentially with the number of iterations so in fact the length of the entire Koch curve is infinite as is the arc length between any of its two points.  It therefore might come as a surprise that the area enclosed by the Koch curve is finite; the proof of this we leave as an exercise for the reader.


HOW TO USE IT
-------------
Reset the program by pushing the SETUP button.  This will clear the world, create the initiator and initialize the globals.  Press repeatedly on the STEP button.  Each time you press this button the construction algorithm is iterated and you will see successive approximations of the Koch curve.


THINGS TO NOTICE
----------------
What happens to the total length of the curve as the iteration progresses?


THINGS TO TRY
-------------
Try running the model through several iterations. Can you see how the recursive design is changing from one iteration to another? Note that each successive iteration takes longer to compute. Depending on the speed of your machine, high-numbered iterations could take a long time!


EXTENDING THE MODEL
--------------------
You can combine three copies of the Koch curve to form a closed curve called the Koch snowflake. Try to write a program that draws this curve.

Can you think of other initiators and generators? Try and implement a few. Can you characterize which initiators and generators lead to ""interesting shapes""?


NETLOGO FEATURES
----------------
Notice how the curves are made out of many turtles, all following the same rules.  Also, take note of the use of the HATCH command to create all of the turtles by repeated ""cloning"" from a single seed turtle.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Koch Curve model.  http://ccl.northwestern.edu/netlogo/models/KochCurve.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/KochCurve for terms of use.
"
L-System Fractals,/models/Sample Models/Mathematics/Fractals,"turtles-own
[ new? ]

globals
[
  len
  swirl?
  ball?
  tree1?
  tree2?
  sierpinski?
  koch?
  figureEight?
]

to setup
  ca
  crt 1
  ask turtles
  [
    set shape ""line""
    set color init-color
    setxy init-x init-y
    set heading 0
    pd
  ]
  set len 64
  set swirl? false
  set ball? false
  set tree1? false
  set tree2? false
  set sierpinski? false
  set koch? false
  set figureEight? false
end

to go
  ask turtles
  [
    set new? false
    pd
  ]
  ifelse (swirl?)
  [ swirl ]
  [
    ifelse (ball?)
    [ ball ]
    [
      ifelse (tree1?)
      [ tree1 ]
      [
        ifelse (tree2?)
        [ tree2 ]
        [
          ifelse (sierpinski?)
          [ sierpinskiTree ]
          [
            ifelse (koch?)
            [ kochSnowflake ]
            [
              ifelse (figureEight?)
              [ figureEightCovering ]
              [ applyRules ]
            ]
          ]
        ]
      ]
    ]
  ]
  tick
end

;write your own rules for the l-system fractal here.  for commands either read the documentation in this file or
;follow the directions found in the information file.  briefly,
;    ""t"" causes every non-new turtle to create a new turtle with the same heading
;    ""r <number>"" causes every non-new turtle to turn to the right by number degrees
;    ""l <number>"" causes every non-new turtle to turn to the left by number degrees
;    ""ahead <number>"" causes every non-new turtle to draw a line of length number in the direction each is heading
;    ""f"" causes every non-new turtle to draw line of length 1 in the direction each is heading
;    ""skip <number>"" causes every non-new turtle to move forward by number in the direction each is heading without drawing
;    ""s"" causes every non-new turtle to move forward by 1 in the direction each is heading without drawing
to applyRules
;enter your rules here
  f f f r 15 t f f f l 30 f f f
;stop entering in rules
end

;hatch a new turtle for all the turtles that are not new to the current iteration and set new? to be true
;further for all those turtles that do create another turtle, change their color by adding to color color-inc
to t
  ask turtles with [not new?] [hatch 1 [set new? true] set color color + color-inc ]
end

;turn each turtle that wasn't created during the current iteration to the right by degree degrees
to r [degree]
  ask turtles with [not new?] [rt degree]
end

;turn each turtle that wasn't created during the current iteration to the left by degree degrees
to l [degree]
  ask turtles with [not new?] [lt degree]
end

;move each turtle that wasn't created during the current iteration forward by steps
to ahead [steps]
  ask turtles with [not new?] [fd steps]
end

;move each turtle that wasn't created during the current iteration forward by 1
to f
  ask turtles with [not new?] [fd 1]
end

;move each turtle that wasn't created during the current iteration forward by 1 but do not draw
to s
  ask turtles with [not new?] [pu fd 1 pd]
end

;move each turtle that wasn't created during the current iteration forward by steps but do not draw
to skip [steps]
  ask turtles with [not new?] [pu fd steps pd]
end

;destroys all non-new turtles
to d
  ask turtles with [not new?] [die]
end

;-----------------------------
;        example buttons
;-----------------------------

to swirlSetup
  ca
  crt 1
  set color-inc 9.0
  set init-color 9.0
  ask turtles
  [
    set shape ""line""
    set color init-color
    setxy 0 0
    set heading 0
    pd
  ]
  set len 50
  set swirl? true
  set ball? false
  set tree1? false
  set tree2? false
  set sierpinski? false
  set koch? false
  set figureEight? false
end

to swirl
  ask turtles [set new? false pd]
  f f f r 10 t s s s l 60 ahead 5
end

to ballSetup
  ca
  crt 1
  set color-inc 9.0
  set init-color 9.0
  ask turtles
  [
    set shape ""line""
    set color init-color
    setxy 0 0
    set heading 0
    pd
  ]
  set len 50
  set swirl? false
  set ball? true
  set tree1? false
  set tree2? false
  set sierpinski? false
  set koch? false
  set figureEight? false
end

to ball
  ask turtles [set new? false pd]
  f f r 45 t s s s l 45 f f f l 45
end

to tree1Setup
  ca
  crt 1
  set color-inc 9.0
  set init-color 9.0
  ask turtles
  [
    set shape ""line""
    set color init-color
    setxy 0 -10
    set heading 0
    pd
  ]
  set len 50
  set swirl? false
  set ball? false
  set tree1? true
  set tree2? false
  set sierpinski? false
  set koch? false
  set figureEight? false
end

to tree1
  ask turtles [set new? false pd]
  ahead 4 r 15 ahead 8 t r 180 skip 8 r 180 l 15 ahead 4 l 15 t ahead 8 d
end

to tree2Setup
  ca
  crt 1
  set color-inc 9.0
  set init-color 9.0
  ask turtles
  [
    set shape ""line""
    set color init-color
    setxy 0 -50
    set heading 0
    pd
  ]
  set len 50
  set swirl? false
  set ball? false
  set tree1? false
  set tree2? true
  set sierpinski? false
  set koch? false
  set figureEight? false
end

to tree2
  ask turtles [set new? false pd]
  ahead 10 r 30 ahead 5 t skip -5 l 60 ahead 5 t skip -5 r 30 skip -10
end

to sierpinskiSetup
  ca
  crt 1
  set color-inc 3.0
  set init-color 9.0
  ask turtles
  [
    set shape ""line""
    set color init-color
    setxy 0 -25
    set heading 0
    pd
  ]
  set len 55
  set swirl? false
  set ball? false
  set tree1? false
  set tree2? false
  set sierpinski? true
  set koch? false
  set figureEight? false
end

to sierpinskiTree
  ask turtles [set new? false pd]
  repeat 3
  [
    ahead len
    t
    r 180
    skip len
    r 180
    r 120
  ]
  set len (len / 2)
  d
end

to figureEightSetup
  ca
  crt 1
  set color-inc 9.0
  set init-color 9.0
  ask turtles
  [
    set shape ""line""
    set color init-color
    setxy 0 0
    set heading 0
    pd
  ]
  set len 50
  set swirl? false
  set ball? false
  set tree1? false
  set tree2? false
  set sierpinski? false
  set koch? false
  set figureEight? true
end

to figureEightCovering
  ask turtles [set new? false pd]
  repeat 4
  [
    ahead len t r 180 skip len l 90
  ]
  set len (len / 2)
  d
end

to kochSetup
  ca
  crt 1
  set color-inc 5.0
  set init-color 9.0
  ask turtles
  [
    set shape ""line""
    set color init-color
    setxy -47 -82
    set heading 0
    pd
  ]
  set len 55
  set swirl? false
  set ball? false
  set tree1? false
  set tree2? false
  set sierpinski? false
  set koch? true
  set figureEight? false
end

to kochSnowflake
  ask turtles [set new? false pd]
  ifelse ticks = 0
  [
    repeat 3  ; we do these rules three times so that we can get the snowflake shape
    [
      t ahead len l 60 t ahead len r 120 t ahead len l 60 t ahead len r 120
    ]
  ]
  [  ; notice these are the same rules as above, except that we only do them once
    t ahead len l 60 t ahead len r 120 t ahead len l 60 t ahead len r 120
  ]
  set len (len / 3)
  d
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2001 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2001).  NetLogo L-System Fractals model.
; http://ccl.northwestern.edu/netlogo/models/L-SystemFractals.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2001 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/L-SystemFractals
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This program draws special types of pictures called fractals.  A fractal is a shape that is self-similar - that is, it looks the same no matter how closely you zoom in or out  For instance, a tree can be thought of as a fractal since if you look at the tree as a whole, you see a stick, that is to say the trunk, with branches coming out of it.  Then if you look at a smaller portion of it, say a branch, you see a similar thing, namely, a stick with branches coming out of it.

This model allows you to draw and look at one class of fractals, called L-system fractals.  L-System fractals are made by following a set of rules over and over.  The rules can be few, but a fascinating and complicated fractal can still form.  These rules tell the turtles what to do.  In the beginning, there will be only one turtle for any fractal.  This turtle can do things such as draw a line, or turn to the right or left.  This turtle can also split itself into two turtles. Each new turtle follows the same rules as the original turtle, and draws its own ""branch"" of the emerging fractal design.

By using different sets of rules, you can create a wide variety of different fractal designs.


HOW TO USE IT
-------------
Perhaps the best way to start with this program is by looking at examples of some L-system fractals.  In the ""Interface"" tab, you will find a series of buttons: ""Swirl"", ""Ball"", etc.  Each button sets up a different fractal. Some of these examples are famous fractals, such as Sierpinski's tree and Koch's snowflake.  To view these examples, simply click on one of the example buttons and then press the GO button.

Please be patient while the fractal draws.  Some of these fractals take about 30 seconds to completely draw.  You know that a fractal is done drawing when the button that you clicked, changes back to its original color, a light gray.

You can also have the fractals drawn one step a time.  Once you click an example setup button, instead of clicking the GO button, click on the GO ONCE button.  This draws the fractal by doing the set of rules only one time per click as opposed to continuously, like the GO button.  A final example of a fern or leafy branch can be found by clicking on the SETUP button followed by either the GO ONCE or GO buttons.

If you don't like the location of the fractal in the world you can change it by modifying the value of the following sliders:
The INIT-X slider sets the initial x coordinate of the first turtle.  It changes the horizontal starting location of  the original turtle.
The INIT-Y slider sets the initial y coordinate of the first turtle.  It changes the vertical starting location of  the original turtle.

If you don't like the color scheme of the fractal you can change it by modifying the value of the following sliders:
The INIT-COLOR slider sets the initial color of the first turtle.
The value of the COLOR-INC slider is added to the turtles color anytime a new turtle hatches.

The example buttons and the SETUP button sets up the world to draw a fractal.  Each of the example buttons sets up the world to draw the fractal of the same name.  The SETUP button sets up the world for drawing the rules found in the applyRules procedure in the ""Procedures"" tab.


THINGS TO NOTICE
----------------
Notice the self-similarity of the fractals at each iteration.  What if one were to perform an infinite number of iterations?  Would looking at any piece up close look any different than looking at the whole?  Also notice how the number of turtles in each of the example is multiplied by some number at each iteration.  Does this make sense?  Try to figure out the number of turtles at some arbitrary step n for one or more of the examples.


THINGS TO TRY
-------------
Now that you have played around with settings for the examples provided, why not try making your own fractals.  You can do this by writing a set the following commands in the applyRules function in the ""Procedures"" tab:
- ""t"" causes every non-new turtle to create a new turtle with the same heading
- ""r <number>"" causes every non-new turtle to turn to the right by number degrees
- ""l <number>"" causes every non-new turtle to turn to the left by number degrees
- ""ahead <number>"" causes every non-new turtle to draw a line of length number in the direction each is heading
- ""f"" causes every non-new turtle to draw line of length 1 in the direction each is heading
- ""skip <number>"" causes every non-new turtle to move forward by number in the direction each is heading without drawing
- ""s"" causes every non-new turtle to move forward by 1 in the direction each is heading without drawing
- ""d"" causes all non-new turtles to be destroyed

To make your fractals, you must write a series of these commands into the applyRules function, in between the lines:

;enter your rules here
...
;stop entering in rules

For example, if you wanted to see what kind of a fractal the set of rules
|    ahead 5 t r 45 ahead -2 skip 7 l 30
would generate, you would just type them into the applyRules procedure as seen below.
|    to applyRules
|    ;enter your rules here
|      ahead 5 t r 45 ahead -2 skip 7 l 30
|    ;stop entering in rules
|    end

Use the commands above to make your own fractals.  Then change the initial color and color increment values to make the fractal more interesting to look at.


EXTENDING THE MODEL
-------------------
Try adding switches such as increment-by-random-length or decrement-by-random-degree that could impose a random factor to the movement of the turtles.  Then add to the forward and turning functions, for example, a random value to the number of steps and degrees.  This would increase the realism in a fractal.

Pick up a book on fractals or search on the internet to find fractals that are interesting and try to create them using the rules of L-system fractals.  You may find some resources below.

Try extending the set of rules so that there are more than the basic ones included in this model.  Then use these rules to make new fractals.

Try starting with more than just one turtle, in a different location or heading, and see how that can affect the fractals that you have made.  Does it ruin them or does it make them more interesting and complex?


NETLOGO FEATURES
----------------
Notice the use of agentsets to make some of the commands affect only certain turtles. For example, the reporter WITH is used to isolate non-new turtles and have the rules affect only them.  Also notice how the fractals are formed using several agents following the same rules through the use of the ""hatch"" primitive, which makes it simple to generate fractals like Sierpinski's tree.


CREDITS AND REFERENCES
----------------------
You may find more information on L-System fractals in the following locations:

This site offers a nice history and explanation of L-system fractals as well as quit a few classic examples of L-systems.
http://spanky.triumf.ca/www/fractint/LSYS/tutor.html

This site offers an introduction to fractals, including L-system fractals as well as others.
http://www.cs.wpi.edu/~matt/courses/cs563/talks/cbyrd/pres1.html

The Fractal Geometry of Nature by Benoit Mandelbrot

To refer to this model in academic publications, please use:  Wilensky, U. (2001).  NetLogo L-System Fractals model.  http://ccl.northwestern.edu/netlogo/models/L-SystemFractals.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2001 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/L-SystemFractals for terms of use.
"
Star Fractal,/models/Sample Models/Mathematics/Fractals,"turtles-own [
  moves         ;; how many sides the turtles has drawn so far
  star-side     ;; The length of the side that the turtle is drawing
  generation    ;; How many generations of turtles have come before it.  So,
]               ;; if the turtle was hatched from a turtle that was hatched
                ;; by another turtle, it's generation is 2

to setup
  clear-all
  crt 1 [
    set size 8                    ;; so turtles are easy to see
    set ycor max-pycor * 0.9      ;; place near top of world
    set star-side ycor * 1.97538  ;; length of the sides of the star it will draw
    pen-down
    set heading 180 + 18
    recolor
  ]
  plot count turtles
end

to go
  if not any? turtles [ stop ]
  ask turtles [
    fd star-side
    rt 180 + 36
    if generation < fractal-level [      ;; If it's not drawing at the deepest level of the figure,
      hatch 1 [                          ;;  hatch a new turtle to draw at a lower level
        set generation generation + 1
        set star-side star-side / 2
        recolor
        set moves 0
        rt 18
      ]
    ]
    set moves moves + 1
    if moves > 5 [ die ]        ;; When the turtle has completed its star, it's done
  ]
  tick
  plot count turtles
end

to recolor  ;; turtle procedure
  set color scale-color red (fractal-level - generation) -1 (fractal-level + 1)
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1999 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1999).  NetLogo Star Fractal model.
; http://ccl.northwestern.edu/netlogo/models/StarFractal.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1999 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/StarFractal
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model creates a fractal-like structure consisting of stars drawn at various scales, the number of which is specified by the user.  The structure is drawn by generations of turtles that draw stars at a given scale and hatch successive generations to draw new ones at smaller scales.


HOW TO USE IT
-------------
The FRACTAL-LEVEL slider controls the number of levels the structure is drawn in.  For instance, a fractal level of 0 results in a single star, while a fractal level of 1 draws a star with smaller stars that begin at each of its 5 corners.  This pattern is repeated as the level increases.

Click the SETUP button to initialize the structure and GO to begin drawing it.


THINGS TO NOTICE
----------------
The figure drawn embodies the most important fractal quality: self-similar structure at smaller scales.  This means that no matter how far you ""zoom in"" to it, you will still see the same shape (namely, a star).  The fractal level determines to how small a scale this property holds, so the greater the level the more you can ""zoom in"" and still see stars.

Notice that at a fractal level greater than 1, the model begins with one turtle, which hatches new turtles at each corner, and these turtles similarly hatch new ones at each of their corners as well. This behavior is made possible by a powerful mathematical technique called recursion.  A process is called recursive when its workings involve ""performing itself"".  In this case, the process performed by each turtle at each step is to draw a new side of its star and then create new turtles to perform the very same process.  A helpful property of recursive processes is that the instructions are often short, because each performer is executing the same instructions. Hence the brevity of Star Fractal's procedures.

The ideas behind fractal scaling (the property of self-similar structures at different scales) and recursion are essentially the same.  This is suggested by the fact that a recursive process is able to generate a fractal-like structure, as in this model.  One way to think about it is that recursion applies these ideas to processes (like NetLogo programs), and fractal scaling applies them to physical or mathematical structures (like the figure drawn by Star Fractal).


THINGS TO TRY
-------------
Edit GO so that it's not a forever button, and/or use the speed slider to slow the model down, and note what happens during each tick.  Notice that what begins as a single drawing multiplies into many drawings, each of which is at a smaller scale but proceeds exactly like the larger one that spawned it.  Thus, recursion begets self-sameness at different scales.

Try the model initially with small fractal levels and work your way up to higher ones.  Try to figure out how many more stars are incorporated into the figure each time the level increases by one.  What kind of general rule you can come up with? That is, given a generation of turtles g, how many turtles will be in the generation g + 1?  Start from g = 0.  (This is a recursive rule.)


EXTENDING THE MODEL
-------------------
In increasing order of difficulty:

Change the color scaling so that the smaller stars are brighter than the larger ones.

Change the model so that it draws shapes other than stars.  Will any shape work?

The structure that this model draws is only ""fractal-like"", because even when you ""zoom in"" and look at smaller scales, the smaller stars aren't actually part of the larger ones; they're just connected to them at a vertex. An important property of fractals is that the larger structures are composed of the smaller ones, something which clearly doesn't hold here.  For a tougher exercise, try changing the model so that the smaller stars (or whatever shapes are being drawn) are actually part of the larger ones, for instance by drawing them in the middle of their sides.  Such a figure will be a lot less ""noisy"" than this one, in terms of how difficult it is to discern individual stars, and it will have different properties when you zoom in.


NETLOGO FEATURES
-----------------
This model makes use of an important NetLogo command: HATCH.  HATCH allows one turtle to create a new one on the same patch and give it some initial instructions.  In this case, the parent turtle sets the length of the star its offspring will draw, its initial heading, and several other variables.  Notice that the new turtle uses the values of its parent turtle's variables in the body of the hatch procedure.

Another useful primitive this model uses is SCALE-COLOR.  It is used to make the brightness of the color the turtles are drawing inversely proportional to the turtle's generation, so that larger stars are brighter than smaller ones (this was done to make the larger ones more visible).  This code:
|   scale-color red (fractal-level - generation) -1 (fractal-level + 1)
works as follows: Subtract the value of GENERATION from that of FRACTAL-LEVEL.  The higher that resulting value is on the scale from -1 to (FRACTAL-LEVEL + 1), the darker the shade of red the turtle will draw with.

This model uses continuous updates rather than tick-based updates so if you slow the model down with the speed slider, you can watch the motion of the turtles.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1999).  NetLogo Star Fractal model.  http://ccl.northwestern.edu/netlogo/models/StarFractal.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1999 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/StarFractal for terms of use.
"
Sierpinski Simple,/models/Sample Models/Mathematics/Fractals,"turtles-own [ modulus ]

; create a turtle and set its initial location and modulus
to setup
  clear-all
  crt 1
  [
    set heading 0
    setxy 0 -3
    set modulus 0.5 * max-pycor
    pd
  ]
end

; ask the turtles to go forward by modulus, create a new turtle to
; draw the next iteration of sierpinski's tree, and return to its place
to grow
  hatch 1
    [ fd modulus
      set modulus (0.5 * modulus) ]  ; new turtle's modulus is half its parent's
end

; draw the sierpinski tree
to go
  ask turtles
  [
    repeat 3
    [
      grow
      right 120  ; turn counter-clockwise to draw more legs
    ]
    die  ; kill all the living turtles
  ]
  tick
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Sierpinski Simple model.
; http://ccl.northwestern.edu/netlogo/models/SierpinskiSimple.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/SierpinskiSimple
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
The fractal that this model produces was discovered by the great Polish mathematician Waclaw Sierpinski in 1916.  Sierpinski was a professor at Lvov and Warsaw.  He was one of the most influential mathematicians of his time in Poland and had a worldwide reputation.  In fact, one of the moon's craters is named after him.

The basic geometric construction of the Sierpinski tree goes as follows.  We begin with a single point on the plane and then apply a repetitive scheme of operations to it.  Grow a ""spider"" centered at this point by drawing three equal line segments directed to the vertices of an equilateral triangle.  Then at each vertex of the triangle repeat the construction -- grow a similar ""spider"" only scale it down by the factor of two.

|            .               Step 0: Start with a point

|            |
|            |
|            |               Step 1: Grow a spider
|           / \
|          /   \
|         /     \

|            |
|            |
|           /|\
|          / | \
|            |               Step 2: Repeat step 1
|           / \
|        | /   \ |
|        |/     \|
|       / \     / \
|      /   \   /   \

The Sierpinski tree is closely related to the class of fractals called Sierpinski Carpets which includes the famous Sierpinski Triangle or as it is usually called The Sierpinski Gasket.

The features that characterize the Sierpinski tree are self-similarity and connectedness.  It is not always easy to determine if a fractal is connected.  It took almost a decade to prove the connectedness of the famous Mandelbrot set.  However connectedness is apparent from the way Sierpinski tree is generated; at each iteration the set is connected.


HOW TO USE IT
-------------
Push the SETUP button to clear the world and initialize globals.  Press repeatedly on the GO ONCE button to perform iterations of the Sierpinski algorithm.


THINGS TO NOTICE
----------------
Notice the use of ""hatch"" primitive which makes it so simple to generate fractals like Sierpinski tree.


THINGS TO TRY
-------------
Try to write a program that draws other self-similar shapes.  For instance try the rule below

|                   .               Step 0

|
|                   |
|                   |
|                   |
|            ______________         Step 1
|                   |
|                   |
|                   |

|                   |
|                 __|__
|                   |
|                   |
|           __|___________|__       Step 2
|             |     |     |
|                   |
|                 __|__
|                   |

The resulting fractal is known in Algebraic Topology as a Universal Covering of the Figure Eight.



NETLOGO FEATURES
----------------
Notice how the curves are formed using several agents following the same rules.  Also, take note of the use of the hatch command.


RELATED MODELS
--------------
L-System Fractals


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Sierpinski Simple model.  http://ccl.northwestern.edu/netlogo/models/SierpinskiSimple.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/SierpinskiSimple for terms of use.
"
Voronoi,/models/Sample Models/Mathematics,"globals [
  available-colors      ;; list of colors that will be assigned to points
  current-point         ;; the point the user is currently moving
]

breed [points point]    ;; these are the little circles in the middle of the polygons

;; The next two breeds are used only when we're updating the polygons
;; when the user moves the points with the mouse.  See below for further
;; details.
breed [spawners spawner]
breed [updaters updater]

;;;
;;; CORE PROCEDURES
;;; These are the only procedures necessary to draw the diagram
;;; initially, without moving points.
;;;

to setup
  clear-all
  ;; too dark and too light are hard to distinguish from each other,
  ;; so only use 13-17, 23-27, ..., 133-137
  set available-colors shuffle filter [(? mod 10 >= 3) and (? mod 10 <= 7)]
                                      n-values 140 [?]
  set-default-shape points ""circle 3""
  ask n-of number patches [ make-point ]
  ask patches [ recolor ]
  set current-point nobody
end

to make-point ; patch procedure
  sprout-points 1 [
    set size 5
    set color first available-colors
    set available-colors butfirst available-colors
  ]
end

to recolor  ;; can be patch or turtle procedure
  set pcolor [color] of min-one-of points [distance myself]
end

;;;
;;; OTHER PROCEDURES
;;; The rest of the procedures are used for efficiently updating
;;; the diagram when the user moves the points around.
;;;

to go
  obey-mouse
  ask spawners [ spawn ]
  ask updaters [ update ]
end

to obey-mouse
  ;; first handle the case where the user has released the mouse button
  ;; (or hasn't pressed it yet)
  if not mouse-down? [
    set current-point nobody
    stop
  ]
  ;; if the mouse button is down, get the mouse position
  let x round mouse-xcor
  let y round mouse-ycor
  ;; if we don't have a point yet, pick the closest one
  if current-point = nobody [
    set current-point min-one-of points [distancexy x y]
  ]
  ;; check if the point needs to move
  if x != [xcor] of current-point or y != [ycor] of current-point [
    ;; move the point
    ask current-point [ setxy x y ]
    ;; the point has moved, so we need to recolor all patches, so we kill off
    ;; the old turtles that were doing the recoloring and make new ones
    ask spawners [ die ]
    ask updaters [ die ]
    ask current-point [ ask patch-here [ make-spawners ] ]
  ]
end

;; Here's how we use turtles to update the patches in a growing
;; square pattern.  We use two breeds of turtles, spawners and updaters.
;; Spawners are at the corners of the square and move diagonally.  Each
;; time a spawner moves, it spawns two new updaters.  The updaters move
;; vertically or horizontally, and every time an updater lands on a patch,
;; it recolors it.  When a spawner or an updater hits the edge of the world,
;; it dies.  Together, these rules are enough to make the growing square!

to make-spawners  ;; patch procedure
  let counter 0
  sprout-spawners 4 [
    ;; give the four headings of NE, SE, SW, and NE
    set heading 45 + counter * 90
    set counter counter + 1
    set color gray
    if not show-updates? [ hide-turtle ]
  ]
end

to spawn  ;; spawner procedure
  hatch-updaters 1 [ rt 45 ]
  hatch-updaters 1 [ lt 45 ]
  if not can-move? 1 [ die ]
  ;; Moving diagonally is a little tricky.  Moving forward 1 isn't enough by
  ;; itself, since that doesn't take us all the way to the center of the
  ;; diagonally next patch.  So after moving forward, we use SETXY to move
  ;; to the exact center of the new patch.
  fd 1
  setxy pxcor pycor
end

to update  ;; updater procedure
  recolor
  if not can-move? 1 [ die ]
  fd 1
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2006 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2006).  NetLogo Voronoi model.
; http://ccl.northwestern.edu/netlogo/models/Voronoi.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2006 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Voronoi
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model draws a Voronoi diagram of polygons around a set of points.  These diagrams resemble many phenomena in the world including cells, forest canopies, territories of animals, fur and shell patterns, crystal growth and grain growth, cracks in dried mud and other geological phenomena, road networks, and so on.  Voronoi diagrams are useful in computer graphics, vision and path planning for robots, marketing, and other applications.


HOW IT WORKS
------------
First the points are placed randomly.  Then the polygons are drawn according to the following rules.  Each point is enclosed inside exactly one polygon.  All of the points inside the polygon are closer to that point than they are to any of the other points.

Instead of calculating the mathematically exact coordinates of the polygons, this model constructs an approximation using a grid.  Each grid cell (each ""patch"", in NetLogo terminology) is colored according to which point it is closest to.


HOW TO USE IT
-------------
Use the NUMBER slider to choose how many points you want, then press SETUP.  The model will place the points and draw the polygons.

If you want to play with moving the points around yourself, press the GO button.  Now you can drag the points around with the mouse.  As you move a point, the model redraws the polygon.  This takes time, so it redraws them starting near the mouse and proceeding outward.  If you want to see the boundary of the updated region, turn on the SHOW-UPDATES? switch.


THINGS TO NOTICE
----------------
The line segment separating two points is exactly midway between them.

How many sides do the polygons typically have?  (You may want to ignore the polygons around the edges.)

Where different colors touch, there is usually a ""Y"".  When do you get a ""T"" or an ""X"" instead?


THINGS TO TRY
-------------
Experiment with the effect of moving the points around.  Moving the points slowly is best.  (If you move them too fast, the model will have trouble keeping up and it won't be easy to see what's going on.)

Align two points so they have the exact same x coordinate or y coordinate.  Is the line between them always perfectly smooth?  (To see the effect, you may have to move the points closer or farther away from each other.  Look closely.)  Also try putting two points exactly on top of each other.  What happens?  Both effects occur because when a grid square (""patch"") is equally distant from two differently colored points, NetLogo resolves the tie randomly.


EXTENDING THE MODEL
-------------------
Instead of placing the points completely randomly, have them move away from each other until they are roughly equidistant from each other.  This makes all the polygons roughly the same size.

Edit the view and turn wrapping on in both directions, and click SETUP.  The model may seem to be working, but there is a problem.  If you turn on SHOW-UPDATES?, you can see that the update rectangle keeps going forever, continually refreshing the grid colors.  Fix the model to work with wrapping, so that update stops as soon as the whole screen has been redrawn.

Instead of using the patches to display Voronoi polygons, find the boundaries by using turtles.  Create a large batch of turtles at each point (colored the same color as the point), each turtle facing a different angle.  Have the turtles walk outward from their points at a uniform rate.  Stop the turtles when they run into a turtle of a different color.

Instead of using a patch-based approximation, calculate the exact positions of the sides of the polygons.  (There are numerous published algorithms for calculating this information.)  Then display the polygons using turtles with the ""line"" shape.


NETLOGO FEATURES
----------------
The core procedure for drawing the polygons is called ""recolor""; it is only one line long!  It puts the MIN-ONE-OF and DISTANCE reporters to good use.

The MOUSE-DOWN?, MOUSE-XCOR, and MOUSE-YCOR primitives are used so the user can interact with the model.

Because the number of patches is so large, it takes a while to update them all when a point moves.  So we use moving turtles to recolor the patches; the moving turtles start where the mouse is, and move outwards in a square, since near the mouse is where the user will be looking first.  See the Procedures tab for the details on how it works.


RELATED MODELS
--------------
MaterialSim Grain Growth
Fur
Honeycomb
Scatter


CREDITS AND REFERENCES
----------------------
For more information on Voronoi diagrams, see http://en.wikipedia.org/wiki/Voronoi.  (There are also many other sites on this topic on the web.)

Thanks to John Jungck from Beloit College for inspiring this model with his talk at Northwestern University about Voronoi structures in nature.

Thanks to Josh Unterman and Seth Tisue for their work on this model.

To refer to this model in academic publications, please use:  Wilensky, U. (2006).  NetLogo Voronoi model.  http://ccl.northwestern.edu/netlogo/models/Voronoi.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2006 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Voronoi for terms of use.
"
Pursuit,/models/Sample Models/Mathematics,"breed [ leaders leader ]
breed [ followers follower ]

globals [ choice the-leader ]

;;;;;;;;;;;;;;;;;;;;;;;;
;;; Setup Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;
to setup [n]
  ca
  set choice n
  setup-axes
  setup-leader
  setup-followers
end

to setup-axes
  ;; draw x-axis & y-axis as light gray
  ask patches with [pxcor = 0 or pycor = 0]
    [ set pcolor gray - 3 ]
end

to setup-leader
  create-leaders 1
    [ set the-leader self
      set color gray + 2
      set size 3
      set shape ""circle""
      set xcor min-pxcor
      if not show-leader? [ ht ]
      update-leader-ycor ]
end

to setup-followers
  create-followers num-followers
  [ ;; if there are exactly 4 follower turtles, set them up in the four corners of the world
    ;; otherwise, make the followers' locations random
    set color color + 10
    ifelse num-followers = 4
    [ ask turtle 1 [ setxy max-pxcor max-pycor ]
      ask turtle 2 [ setxy max-pxcor min-pycor ]
      ask turtle 3 [ setxy min-pxcor max-pycor ]
      ask turtle 4 [ setxy min-pxcor min-pycor ]
    ]
    [ setxy ((random (2 * max-pxcor)) + min-pxcor)
            ((random (2 * max-pxcor)) + min-pxcor)
    ]
    set shape ""circle""
    set size 2
    set pen-size 2
    pd
  ]
end

to reveal
  let old-value-of-show-trail? show-trail?
  set show-trail? true
  ask the-leader
    [ set xcor 0
      while [xcor < max-pxcor]
        [ move-leader ]
      st ]
  set show-trail? old-value-of-show-trail?
end


;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Runtime Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;
to go
  ;; stop if the lead turtle is about to go out of the world
  if [patch-at 1 0] of the-leader = nobody [ stop ]
  every slowdown * 0.01 [ go-once ]
end

to go-once
  move-leader
  move-followers
  tick
end

to move-followers
  ask followers
  [ face the-leader
    ;; if we're about to catch up with the leader, don't pass the
    ;; leader, only pull even with it
    ifelse distance the-leader > step-size
      [ fd step-size ]
      [ move-to the-leader ]
  ]
end

to move-leader
  ask the-leader
  [ update-leader-ycor
    if show-trail?
      [ set size 1
        stamp
        set size 3 ]
    set xcor xcor + 1
  ]
end

to update-leader-ycor  ;; leader procedure
  if (choice = 0)  [ linear      ]  ;;  y = x
  if (choice = 1)  [ quad-up     ]  ;;  y = x^2
  if (choice = 2)  [ quad-down   ]  ;;  y = -x^2
  if (choice = 3)  [ cubic       ]  ;;  y = x^3
  if (choice = 4)  [ logarithm   ]  ;;  y = ln x
  if (choice = 5)  [ exponential ]  ;;  y = a^x
  if (choice = 6)  [ sine        ]  ;;  y = sin x
  if (choice = 7)  [ cosine      ]  ;;  y = cos x
  if (choice = 8)  [ hyperbolic  ]  ;;  y = 1/x
  if (choice = 9)  [ horizontal  ]  ;;  y = 0
end

to linear  ;; leader procedure
  set ycor xcor
end

to quad-up  ;; leader procedure
  set ycor ((xcor ^ 2) / max-pycor)
end

to quad-down  ;; leader procedure
  set ycor ((- (xcor ^ 2)) / max-pycor)
end

to cubic  ;; leader procedure
  set ycor ((xcor ^ 3) / (max-pycor ^ 2))
end

to logarithm  ;; leader procedure
  if (xcor <= 0)
  [ set xcor 1 ]
  set ycor ((ln (xcor / 10)) * 10)
end

to exponential  ;; leader procedure
  let scale-factor ((1.1 ^ max-pxcor) / max-pycor)
  set ycor ((1.1 ^ xcor) / scale-factor)
end

to sine  ;; leader procedure
  set ycor (max-pycor * (sin (xcor * 4)))
end

to cosine  ;; leader procedure
  set ycor (max-pycor * (cos (xcor * 4)))
end

to hyperbolic  ;; leader procedure
  ifelse (xcor = 0)
    [ set ycor 0 ]
    [ set ycor (max-pycor / xcor) ]
end

to horizontal  ;; leader procedure
  set ycor 0
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Pursuit model.
; http://ccl.northwestern.edu/netlogo/models/Pursuit.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Pursuit
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
In this model there is one leader turtle and a group of follower turtles.  Have a little fun -- hide the leader and try to guess the path it's moving along.  Watching the followers gives you clues to the leader's path.


HOW IT WORKS
------------
The leader moves along a path according to a preselected formula, such as y = x ^ 2.

The leader starts at the left edge of the world.

The leader always moves from left to right by one unit increments along the x-axis.  Be aware, for several functions, however, the function is scaled by some factor so that its shape fits well within the world.

The leader's y coordinate is based on the selected formula and the current x coordinate.  For example, if the current formula is y = x^2 and the leader's current xcor value is -3, the ycor value will be set to 9.

Each follower turns to face the leader, then moves forward by a fixed amount.


HOW TO USE IT
-------------
Use the NUM-FOLLOWERS slider to select how many followers will pursue the leader.  If exactly four followers are selected, they will be placed at the four corners of the world.  If a different number is selected, the followers will be placed at random locations in the world.

Use the STEP-SIZE slider to decide how far from its current location a follower will move after each step of the leader.

When you press SETUP, the light gray lines that appear are the x-axis and the y-axis.

Leader Switches:
SHOW-LEADER? makes the leader shown or hidden.  This switch must be set before SETUP is pressed.
When the switch is set to on, the leader will be visible.
When the switch is set to off, the leader will be hidden.

SHOW-TRAIL?, when turned on, causes the leader to leave a mark at each location determined by its formula.  This switch may be turned on and off at any time during the pursuit.
When the switch is set to on, the trail will be visible.
When the switch is set to off, the trail will be hidden.

Press RANDOM or any of the function buttons when all of the above selections have been made.  This will create the leader and the selected number of followers.

RANDOM chooses a random function for the leader to follow, and is best used with SHOW-LEADER? and SHOW-TRAIL? turned off so that the function can be guessed based on the movements of the followers.

The other buttons choose a specific function for the leader to follow.

Press GO-ONCE to make the leader increment its xcor value by one and to make the followers take one step toward the leader.

Press GO to make the leader and followers move continuously.
To stop them, press the GO button again.

The SLOWDOWN slider controls how fast all of the turtles move.

Press REVEAL after the model is done to see what the path of the leader was if SHOW-TRAIL? was turned off.  You can use this to check your guess as to what the function was.


HOW TO USE IT
-------------
Try starting with 4 followers with a step size of 1.  Do not show the leader or the leader's trail.

Use settings so that the world is square.

Press RANDOM then press GO.

See if you can guess the formula the leader is using by observing the path of each follower.

For each of the next questions, consider the follow-up questions ""Why or why not?"" and ""How can you tell?""

Does the speed of the leader seem to change over time?

Does the speed of a follower seem to change over time?

Do all followers travel at the same speed?

What can you tell about the leader's formula based on the path of each follower?

What traits of each follower's path give you information about the leader's formula?  Which of these traits do you find most helpful?  Why?

To change the formula for the leader:
A number of formulas have been stored in the procedures for this model.  To explicitly make a given formula active, choose the button for the formula you want instead of RANDOM.

See the EXTENDING THE MODEL section for instructions on how to add your own formulas to the model.


THINGS TO NOTICE
----------------
There are several characteristics of each follower's path and the leader's trail that are worth noting.

Follower Path Slope:
What does it mean if the slope of the path is increasing?
What does it mean if the slope of the path is decreasing?
What does it mean if one section of the path has a steeper slope than another part?
What does it mean if the slope of the path is constant?

To think about the slope of a path, consider whether the path appears to be going 'uphill' or 'downhill' and consider whether the 'hill' is steep or flat.

Follower Path Concavity:
What does it mean if the path has a section that is concave up?
What does it mean if the path has a section that is concave down?
What does it mean if the path has sections of both of these types?
What does it mean if the path has neither concave up nor concave down sections?

A path that is concave up will be shaped like part of an upright coffee cup.
A path that is concave down will be shaped like part of an upside down coffee cup.

Relationships Between Paths:
Do the paths have any symmetry?  Would you expect them to?  Why or why not?

Distances Between the Leader and a Follower:
Once you have determined the formula for the leader, run a simulation with the leader's trail turned on.  (Note that there are other suggestions to verify your answer in the THINGS TO TRY section.  Make sure you have tried at least some of these before you show the trail.  If you show the trail before you are really sure you are right, you might end up spoiling all your fun- there's no going back once you have seen the trail of the leader!)

Find a path where a follower seems to get close to the leader only to have the leader appear to speed up and escape from the follower.

Why does this happen?  What kinds of generalizations can you make about the formulas or relationships for which this happens?

How do the distances between the leader's trail marks relate to the perceived speed of the leader?


Leader Mark Proximity:
Depending on the path that the leader is following, the leader's trail marks may not be evenly spaced.

What does it mean when the steps are evenly spaced?
What does it mean when the steps are not evenly spaced?
What does it mean when the marks are closer together?
What does it mean when the marks are further apart?


THINGS TO TRY
-------------
Try moving followers to specific locations after SETUP has been pressed but before GO has been pressed. Make predictions about how different locations would be helpful.

What can you learn if a follower starts in any of the following locations?
- along the right edge of the world
- along the left edge of the world
- along the top edge of the world
- along the bottom edge of the world
- along the x-axis
- along the y-axis
- at the origin

What is the most helpful first location for a follower?  (The location on top of the leader is, of course, out of the question!)

What is the most helpful follow-up location for a single follower or for a group of followers?

Come up with a strategy for placing followers so that you can determine the path of the leader fairly quickly.  Describe your strategy.

You may use the command center, or the turtle window to move a follower.  The leader is turtle 0, the followers are all turtles with who > 0.


Try increasing the number of followers.
(Even if you think you have the formula figured out, try using larger NUM-FOLLOWERS values before you show the leader or the leader's trail. )
Why does using a larger NUM-FOLLOWERS value make it easier to guess the leader's formula?


Try increasing the STEP-SIZE of the followers.
(Even if you think you have the formula figured out, try using larger STEP-SIZE values before you show the leader or the leader's trail. )
Why does using a larger STEP-SIZE value make it easier to guess the leader's formula?


The above discussions all involve trying to guess the path of the leader.  Alternately, you can know the formula of the leader and try to guess the paths of the followers.

If you know a leader's formula and are trying to guess the pattern of the followers' paths, make sure to record you guess before you run the simulation.  Compare your predicted results with the actual results.
- What reasoning led you to correct predictions?
- What assumptions that you made need to be revised?


EXTENDING THE MODEL
-------------------
To add your own formulas, you need to add a new Leader Procedure to the model (the others are declared at the bottom of the procedures tab.

Add your formula to the current list.
- Within the set of commands you may need to scale the y-axis to keep the leader from wrapping.  (See for example, the cubic function.)
- You must restrict the domain of the leader if your formula has values for which it would be undefined.  (See, for example, the logarithm function.)
- Add formula-name to the MOVE-LEADER procedure and add a button for the choice.
- Increment the number after 'random' in the RANDOM button code to add your function to the list of possible functions that RANDOM will choose.

In this simulation, the leader uses only integer x coordinates.  For which formulas might the results be different if the leader moved along smaller intervals?

What would happen if the STEP-SIZE of the followers was always set to equal the distance the leader traveled during its most recent step?

Adjust the procedures so that rectangular worlds do not cause unexpected wrapping.

Do any of these changes impact answers to any of the questions asked above?

Create leader functions and pick a follower location to get the following shapes in the follower's path:
- a straight line with positive slope
- a straight line with negative slope
- a horizontal line
- a loop
- a circle
- a curve with one ""hump""
- a curve with two ""humps""
- a curve with three ""humps""
- a curve with n ""humps""


NETLOGO FEATURES
----------------
Turtle pens are used to draw the followers' paths.

The STAMP command is used to draw the leader's path.

The TOWARDS-NOWRAP reporter is used to orient the followers.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Pursuit model.  http://ccl.northwestern.edu/netlogo/models/Pursuit.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Pursuit for terms of use.
"
3D Surface,/models/Sample Models/Mathematics,"turtles-own [ x-cor y-cor z-cor ]

to setup
  ca
  set-default-shape turtles ""circle""
  crt number [
    ;; randomly distribute the turtles over the xy plane
    set x-cor random-float 100 - 50
    set z-cor random-float 100 - 50
    set y-cor 0
    move
    render
  ]
end

to go
  ask turtles [
    move
    render
  ]
  tick
end

to move ; turtle procedure
  set y-cor ( 5 * cos ( 5 * ( ticks + x-cor ) ) )
            + ( 5 * cos ( 5 * ( ticks + z-cor ) ) )
end

to render ; turtle procedure
  ; convert 3D-space coordinates to NetLogo coordinates
  setxy (x-cor + ( z-cor / 2 ))   (y-cor + ( z-cor / 2 ))
  ; make lightness/darkness proportional to height, for added 3D effect
  set color scale-color blue y-cor -12 10
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo 3D Surface model.
; http://ccl.northwestern.edu/netlogo/models/3DSurface.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/3DSurface
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model maps turtles between Cartesian and spherical 3-dimensional coordinates.  To create the appearance of a curved 3D surface, the program generates turtles with random x- and z-coordinates, then computes each turtle's y-coordinate based on x and z, and time.  The cosine function is used in the formula to produce a curved surface.  Varying the y coordinate based on time produces motion.

To render the surface in the NetLogo view, it maps from 3D to 2D coordinates as follows:
|  view x = turtle x + (turtle z) / 2
|  view y = turtle y + (turtle z) / 2

In other words, increasing z causes the turtle's apparent position to move both up and to the right.


HOW TO USE IT
-------------
Click the SETUP button to generate the turtles and place them on the surface.  Click the GO (forever) button to run the model, which continuously varies the turtles' y-coordinates to generate a wavelike motion.

The NUM-TURTLES slider determines the number of turtles that make up the surface.


THINGS TO NOTICE
----------------
Notice that as the turtles move down (y-coordinate decreases) they become darker in color, and when they move up (y-coordinate increases) they become lighter.


THINGS TO TRY
-------------
Experiment with the NUM-TURTLES slider.  How many turtles are needed to produce a realistic effect?  Why doesn't it keep getting better-looking indefinitely as you add more turtles?

In the ""move"" procedure, try other numbers besides 5 in front of and inside the cosine function.  Explain the new behavior!

|  to move ; turtle procedure
|    set y-cor ( 5 * cos ( 5 * ( time + x-cor ) ) )
|              + ( 5 * cos ( 5 * ( time + z-cor ) ) )
|  end


EXTENDING THE MODEL
-------------------
Try changing the formula used to compute the y-coordinate to produce differently shaped surfaces.

See if you can draw not just a surface, but a three dimensional shape such as a cone or a sphere.


NETLOGO FEATURES
----------------
Notice the use of SCALE-COLOR to change a turtle's color based on its y-coordinate. Also see the model ""Wave Machine"" for a version that uses patches rather than turtles to make a 3-D membrane.


RELATED MODELS
--------------
3D Solids
Wave Machine


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo 3D Surface model.  http://ccl.northwestern.edu/netlogo/models/3DSurface.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/3DSurface for terms of use.
"
Conic Sections 2,/models/Sample Models/Mathematics,"globals [
  f0x    ;; xcor of focus 0 (for hyperbola)
  f0y    ;; ycor of focus 0 (for hyperbola)
  f1x    ;; xcor of focus 1 (for hyperbola)
  f1y    ;; ycor of focus 1 (for hyperbola)
  state  ;; flag to alternate between different values in mouse code
]

turtles-own [
  dist     ;; distance from 'goal' in current state
  diff     ;; modified distance to x and y intercepts in current state
]

to setup
  clear-all
  set f0x 0
  set f0y 0
  set f1x 0
  set f1y 0
  set state 0
  crt num-turtles
  [
    set color green
    fd random-float 100
  ]
  move-focus-directrix 0 0
end

to go
   ifelse mouse-down?
   [ move-focus-directrix round mouse-xcor round mouse-ycor  ]
   [
     ask turtles [ move-turtles ]
     set state (state + 1) mod 2
   ]
  tick
end

to move-turtles
  ifelse directrix?
    [ parab ]
    [ hyperb ]
end

to hyperb  ;;turtle procedure
  let old-dist dist
  ;;distance between two foci at const
  set dist abs ((distancexy f0x f0y) - (distancexy f1x f1y))

  ;;find location to stop
  if round dist = const [ stop ]
  ifelse (dist < old-dist) and (dist > const)
  [ fd 1 ]
  [
    ifelse (dist > old-dist) and (dist < const)
    [ fd 1 ]
    [
      rt random-float 360
      fd 1
    ]
  ]
end

to parab   ;; turtle procedure
  let old-diff diff
  set dist distancexy f0x f0y
  let intx xcor
  let inty f1y
  ;;distance from directrix
  set diff (distancexy intx inty) - dist

  ;; locate position to stop
  if (abs diff) < 1 [ stop ]
  if (abs diff) > (abs old-diff)
    [ rt random-float 360 ]
  if not can-move? 1
    [ rt 180 ]
  fd 1
end

to move-focus-directrix [ x y ]
  ifelse state = 0
  [
   set f0x x
   set f0y y
  ]
  [
   set f1x x
   set f1y y
  ]
  clear-patches
  ask patch f0x f0y [ set pcolor white ]
  ifelse directrix?
    [ ask patches with [pycor = f1y] [ set pcolor white ] ]
    [ ask patch f1x f1y [ set pcolor white ] ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Conic Sections 2 model.
; http://ccl.northwestern.edu/netlogo/models/ConicSections2.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/ConicSections2
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
The model displays two basic conic sections: hyperbolas and parabolas.  The figures are generated behaviorally as opposed to algebraically - the turtles attempt to behave like points on the specified shape. The partner to this model is called ""Conic Sections 1"".

A parabola is the set of all points that are the same distance from a point (focus) and a line (directrix).  A hyperbola is based on the same idea as is a parabola except that it is reflected over the directrix.

The ancient Greeks discovered that each conic section can be found by taking a cross section of one or two cones with their points pointing toward each other.  A circle results from taking a slice that is perpendicular to the axis, while an ellipse results from taking a slice of one cone that is not perpendicular to the axis. Similarly, a parabola results from a cross section that passes through one cone in a vertical fashion, such that the plane of the cut is parallel to one face. A hyperbola results from a vertical section that passes through both cones.

The turtles use feedback to make decisions about how they behave. They set out in random directions, and then they receive information as to whether or not they are getting closer to where they want to be. If they are getting closer, they continue moving forward in the direction they are going. If they are moving farther away, they set out in a new random direction. This process is akin to the children's game of ""Hot & Cold"", in which players are told whether they are getting ""hotter"" or ""colder"" in relation to a hidden goal.

HOW TO USE IT
-------------
*Hyperbolas:
-Select the number of turtles with the NUM-TURTLES slider.
-Press SETUP.
-Make sure the DIRECTRIX? switch is set to OFF.
-Press GO
-click at two points in the view to set the foci
*Parabolas:
-Select the number of turtles with the NUM-TURTLES slider.
-Press SETUP.
-Make sure the DIRECTRIX? switch is set to TRUE.
-Press GO
-click at two different locations in the view to set the directrix and the focus.


THINGS TO NOTICE
----------------
When forming a hyperbola, turtles adjust their positions from two user-defined foci so that the difference between their distances from the foci attains a
value of CONSTANT.

When forming a parabola, turtles move to an equal distance from the directrix to the focus.


THINGS TO TRY
-------------
Adjust the slope of the parabola's directrix or the value of CONSTANT for the hyperbola while the turtles are still moving. See how they react to the changes in their environment.

You may be able to get a better feeling for the turtles' behavior if only a few turtles are in the world at one time.  Try setting num to a small value (like 16 or 1), and watching the turtles.

Both of these conic sections can be observed by shining a flashlight at a cone and looking at its shadow.  Can you figure out at what angles the cone must be held?


EXTENDING THE MODEL
-------------------
Look at the StarLogoT model 'emergent-circle'. Watch how the turtles react with each other- something that is missing from 'Conic Sections'. Implement this emergent behavior for one or all of the conics in this project.


NETLOGO FEATURES
----------------
Like more traditional programming languages (e.g. C++), NetLogo can have functions that report a value to the caller. The command used is called 'report' -- it has one input, the value to be reported. Look at the function 'pos'. It takes two inputs, x and y, and reports a boolean.

RELATED MODELS
--------------
Conic Sections 1


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Conic Sections 2 model.  http://ccl.northwestern.edu/netlogo/models/ConicSections2.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/ConicSections2 for terms of use.
"
Vector Fields,/models/Sample Models/Mathematics,"breed [ particles particle ]  ;; the things that are affected by the field
breed [ vectors vector ]    ;; the vectors that affect the particles


globals
[
  max-modulus  ;; the maximum modulus of all the vectors
  clicked?     ;; true if we have clicked the mouse button but have not yet placed a particle
  step-size    ;; the amount a particle moves forward
]

vectors-own
[
  modulus  ;; the length of the vector
]

;; set up the field, and create vectors
to setup
  ca
  set clicked? false

  ;; have particles move forward a small amount each time so that we
  ;; don't spiral too much but also so that the model doesn't run too slowly
  set step-size 0.0001

  ;; create vectors at regular intervals to see the effect of the force
  ;; at a particular place.
  ask patches
  [
    if (pxcor mod 13 = 0) and (pycor mod 13 = 0)
    [
      sprout-vectors 1
      [ setup-vector ]
    ]
  ]
  ;; draw vector field
  set max-modulus (max [modulus] of vectors)
  ask vectors
  [ show-vector ]
end

;; make the turtle become a vector and initialize the vector's variables
to setup-vector  ;; turtle procedure
  set color green
  pendown
  if (force-x != 0) or (force-y != 0)
    [ set heading atan force-x force-y ]
  set modulus distancexy 0 0
end

;; particles update their orientation according to the vector-field force
;; operating on the patch where they are at
to go
  let stop? false
  ask particles
  [
    ;; calculate the heading based on the force where this turtle is
    if force-x != 0 or force-y != 0
      [ set heading (atan force-x force-y) ]

    forward step-size * (distancexy 0 0)
  ]
  ;; 100 is an arbitrary factor used to produce a reasonable
  ;; frequency of view updates
  tick-advance 100 * step-size
  ;; if one of the particles was going to wrap around the world, stop.
  if stop?
  [ stop ]
end

;; report true if we will wrap around if we move forward by step-size
to-report going-to-wrap?  ;; turtle procedure
  let next-patch patch-ahead step-size
  report next-patch = nobody
end

;; place test particles
to place-particles
  if mouse-down?
  [ set clicked? true ]
  if (not mouse-down?) and clicked?
  [ place-particle mouse-xcor mouse-ycor
    display ]
end

;; create a particle at (x,y)
to place-particle [x y]
  create-particles 1
  [
    setxy x y
    set size 10
    set heading 0
    set color red
    pd  ;; put the pen down so that we can see where it has traveled
    if force-x != 0 or force-y != 0
      [ set heading (atan force-x force-y) ]
  ]
  set clicked? false
end

;; calculate the horizontal force where the turtle is located
to-report force-x  ;; turtle procedure
  report ycor
end

;; calculate the vertical force where the turtle is located
to-report force-y  ;; turtle procedure
  report (- xcor)
end

;; draw the vector using a turtle to display strength and direction of field
to show-vector  ;; turtle procedure
  set modulus (10 * modulus / max-modulus)
  forward modulus
  set color yellow
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2002.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Vector Fields model.
; http://ccl.northwestern.edu/netlogo/models/VectorFields.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/VectorFields
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This is a mathematical model that demonstrates abstract vector fields and integral curves.

Generally speaking, a field is a ""region in which a body experiences a force as the result of the presence of some other body or bodies.  A field is thus a method of representing the way in which bodies are able to influence each other.  For example, a body that has mass is surrounded by a region in which another body that has mass experiences a force tending to draw the two bodies together.... The strength of any field can be described as the ratio of the force experienced by a small appropriate specimen to the relevant property of that specimen, e.g. force/mass for the gravitational field""  (Oxford Minidictionary of Physics).

By 'abstract vector fields' we mean that this model is not committed to any specific type of force, such as gravity or magnetism.  Rather, it simulates a general field, in which some focal property of influence affects a ""small appropriate specimen"", or particle, placed in the field.

Normally, if you look at a field with bare eyes, you will not necessarily see the forces.  For instance, if you drop an apple it falls down, even though you cannot see the gravitational force.  The apple is an object in the gravitational field.  You saw how it behaved so you could guess that there is some force that made it go down.  Humans do not perceive (visually) forces of gravitation or electro-magnetic forces.  However, in a model, we can use little arrows (vectors) to show where, how forceful, and in which direction there are forces in this field.


HOW IT WORKS
------------
In this model, the field is plotted using vector graphics: green streaks are individual vectors with yellow turtles serving as arrowheads.  The length of each vector is roughly proportional to the magnitude of the vector field at each point.  In this model, it is just the distance from the origin: The further away from the origin, the larger the vector.  Also, all vectors are aimed clockwise along tangents to circles centered on the origin.

The vectors show you in what direction and how forcefully an appropriate specimen -- here, a 'particle' -- will be ""knocked about"" once it is placed the field.  Once the particle is ""knocked"" to a new location, it will be knocked yet again by the force there (represented by the vector).  Actually, it being ""knocked about"" continuously, but in this simulation, the ""knock"" occurs at discrete points in the field.  Since the particle does not use up the forces, it will keep being knocked about.  The path the particle takes is called its 'trajectory.'  You will be able to track this trajectory because the particle will leave a red trail behind it as it moves along its trajectory.  Trajectories in vector fields are called 'integral curves.'

Even though behavior of particles can be interesting and possibly unanticipated, owing to forces not being distributed uniformly in the field, or some other factor, we have chosen, for clarity, a vector field with a logical and consistent relation between location in space and size/orientation of the force.  The vector field chosen for this particular model is

|    - y d/dx  +  x d/dy

Ideally, in the particular force field modeled here, the particle trajectories should be concentric circles (that is, the particle should go round and round along the same circular trajectory).


HOW TO USE IT
-------------
SETUP: Clears the world and computes the vector field.
PLACE-PARTICLES: Puts the program into the mode in which you can position red test-particles by clicking anywhere in the View.
GO: Runs the simulation continuously to show the integral curves.


THINGS TO NOTICE
----------------
Notice that the vectors grow in length as you move away from the origin.  What effect do short vectors have on a particle?  Long vectors?

The way this model is programmed, each particle moves some finite amount before calculating its new heading.  Therefore, the particles do not turn as much as they would if their headings were continuously recalculated.  This causes their trajectories to spiral slowly outward.  (You have to let the model run for a while before this becomes apparent.)  We tried to minimize this by having the particles move forward only a very small amount at each time step (the variable STEP-SIZE).  We couldn't make this amount too small since the model would then run too slowly.  If you want the particles to spiral less, or you want the model to run faster, change this value.


THINGS TO TRY
-------------
Place particles in different parts of the world.  Does the particle's position have any effect on the trajectory?


EXTENDING THE MODEL
-------------------
Try a different vector field by changing it in the SETUP-VECTOR, FORCE-X, and FORCE-Y procedures.  For instance, if you choose

|    x d/dx - y d/dy

the integral curves will be hyperbolas.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Vector Fields model.  http://ccl.northwestern.edu/netlogo/models/VectorFields.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/VectorFields for terms of use.
"
Rugby,/models/Sample Models/Mathematics,"turtles-own [start-patch] ;; original position of ball on kick line
patches-own [score        ;; score for this position along the kick line
             left-angle   ;; angle towards left goal-post
             right-angle  ;; angle towards right goal-post
             goal-angle   ;; size of arc between left-angle and right-angle
             slope]       ;; slope of line from this patch towards a goal-post
globals [current-max      ;; the best patch-score so far
         col              ;; current color for our level-curves
         ang              ;; viewing angle of the current level curve
         best-dist        ;; distance from try-line of best kick
         analytic         ;; what the best distance should be, analytically
         try-line         ;; agentset containing only those patches on the try line
         histogram-area   ;; agentset containing only patches inside the histogram
         kicks            ;; total number of balls kicked
         goals]           ;; total number of goals scored

;; the origin of this model is set in the bottom left corner so
;; the y distance to the goal corresponds to the y-coordinate of the patch
;; this makes many of the calculations simpler.

to setup
  ca
  setup-field
  setup-balls
  set current-max 0
  set best-dist -1
  set kicks 0
  ask try-line [ set score 0 ]
  find-analytic-solution
  if show-level-curves? [ draw-level-curves ]
end

to setup-field
  ;; Draw lines for border, kick line, and goal line
  ask patches [
    if count neighbors != 8
     [set pcolor red ]
    if (pycor = min-pycor) and
       (pxcor >= goal-pos) and
       (pxcor < (goal-pos + goal-size))
     [set pcolor green]
  ]
  set try-line patches with [ pxcor = kick-line and pcolor = black ]
  ask try-line [ set pcolor yellow ]
  set histogram-area patches with [ pxcor < kick-line and pcolor = black ]
end

;; turtle procedure that resets all balls to kick line at end of each round
to setup-balls
  set-default-shape turtles ""circle""
  ask try-line
    [ sprout 1
        [ set color orange
          set start-patch patch-here
          set heading (random-float 90) + 90 ] ]
  plot-scores
end

to go
  while [any? turtles] [
    ask turtles [ move ]
    display
  ]
  set kicks kicks + count try-line
  set goals sum [score] of try-line
  setup-balls
  tick
end

;; turtle procedure that moves all balls
to move
  ;; for speed, only check success/failure once we're near the
  ;; edge of the playing field
  if pxcor >= max-pxcor - 1 or pycor >= min-pycor + 1
     [ ;; in this model we approximate continuous motion by making
       ;; the turtles jump forward a step at a time.  but this can
       ;; throw the results off a little because sometimes a ball
       ;; will jump over the corner of a patch.  so to get correct
       ;; results, we need to check two patches.  ""next-patch"" is
       ;; the patch we would hit if we actually moved continuously.
       ;; ""patch-ahead 1"" is the patch we're going to land on when
       ;; we make our discrete jump.
       check-patch next-patch
       check-patch patch-ahead 1 ]
  fd 1
end

to check-patch [the-patch]  ;; turtle procedure
  if ([pcolor] of the-patch = red)
    [ die ]       ;; the ball has hit the border wall
  if ([pcolor] of the-patch = green) ;; the ball has reached the goal
    [ ;; increment the number of times a goal has been scored from this point on the kick line
      ask start-patch
        [ set score score + 1 ]
      die ]
end

;; see Next Patch Example, in the Code Examples section of
;; the Models Library, for a discussion of this code.
to-report next-patch  ;; turtle procedure
  if heading < towardsxy (pxcor + 0.5) (pycor + 0.5)
    [ report patch-at 0 1 ]
  if heading < towardsxy (pxcor + 0.5) (pycor - 0.5)
    [ report patch-at 1 0 ]
  if heading < towardsxy (pxcor - 0.5) (pycor - 0.5)
    [ report patch-at 0 -1 ]
  if heading < towardsxy (pxcor - 0.5) (pycor + 0.5)
    [ report patch-at -1 0 ]
  report patch-at 0 1
end

;; do histogramming in the view
to plot-scores
  ;; set the maximum goals scored from any patch
  set current-max (max [score] of try-line)
  if current-max = 0
  [
    ask histogram-area [ set pcolor black ]
    stop  ; otherwise we'll get division-by-zero errors below
  ]
  ask try-line [
    ifelse score = current-max
      [ set best-dist pycor
        ask patch-at 2 0 [ set plabel pycor ] ]
      [ if pcolor != magenta
        [ ask patch-at 2 0 [ set plabel """" ] ] ]
  ]
  ask histogram-area
  [;; make the histogram bar
    ifelse  pxcor > (kick-line - (([score] of patch-at (kick-line - pxcor) 0) * (kick-line - min-pxcor) / current-max))
    ;; make the yellow histogram bars at the maximal locations
    [ifelse ([score] of patch-at (kick-line - pxcor) 0 = current-max)
      [set pcolor yellow]
      ;; other locations get blue bars
      [set pcolor blue] ]
    [set pcolor black]
  ]
end

to find-analytic-solution
  ask patches with [pycor > min-pycor]
    [ calc-goal-angle ]
  ;; calculate the analytic solution for best kicking point
  let winning-patch min-one-of try-line [goal-angle]
  ask winning-patch
  [ set pcolor magenta
    ask patch-at 2 0 [ set plabel pycor ] ]
  set analytic [ pycor ] of winning-patch
end

to draw-level-curves
  ask patches with [(pxcor > kick-line) and (pcolor < 10) ]
    [ if goal-angle > 270
      [ set pcolor (360 - goal-angle mod 10) * 0.8 ] ]
end

;; calculate angle between patch and goal
to calc-goal-angle
  set left-angle  towardsxy (goal-pos - 0.5)
                            (min-pycor + 0.5)
  set right-angle towardsxy (goal-pos + goal-size - 0.5)
                            (min-pycor + 0.5)
  set goal-angle (right-angle - left-angle) mod 360
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Rugby model.
; http://ccl.northwestern.edu/netlogo/models/Rugby.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Rugby
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
""In rugby, after a try has been scored, the scoring team has the opportunity to gain further points by 'kicking a conversion'. The kick can be taken from anywhere on an imaginary line that is perpendicular to the try line (aka the goal line) and goes through the location on the try line where the try was scored.  Where should the kick be taken from to maximize the chance of a score?""

Instead of trying to solve this problem with calculus or geometry, we'll take a probabilistic approach and use NetLogo turtles and patches. Essentially, we'll have a player stand on each patch along the imaginary kick line (the vertical yellow line), and kick many balls in random directions.  Players receive one 'point' for each conversion they score.  The idea is that since each kick-angle is randomly chosen, those players who score the most points must be standing in the best positions.

Note that this approach is quite different from the analytic approach. In the standard mathematical solution, one is expected to equate the best chance of scoring with the maximal angle from the kick line to the goal. In the probabilistic solution, this is not assumed. It emerges as the result if the playing field is assumed to be uniform. If, however, the model is extended to include wind or grass grain or decaying kick speeds, this solution adjusts gracefully in contrast to the brittle analytic solution.


HOW TO USE IT
-------------
We use three sliders to initialize the model:
- GOAL-SIZE determines the size of the goal.
- GOAL-POS is the x-coordinate of the left goal-post. It is placed GOAL-POS units away from the leftmost edge of the world.
- KICK-LINE determines the x-coordinate of the kick-line. The kick line is KICK-LINE units away from the leftmost edge of the world.

The left goal-post is at (GOAL-POS - 0.5, min-pycor - 0.5), and the right goal-post is at ( GOAL-POS + GOAL-SIZE - 0.5, min-pycor - 0.5). (0.5 is the horizontal or vertical distance between the center of the patch and its edge; this is needed because the goal posts are effectively in the corners of their patches.)

Note that the values of KICK-LINE, GOAL-SIZE, and GOAL-POS may need to be adjusted to fit your current world-width.

Press the SETUP button to initialize the model, after you've chosen appropriate values for the sliders. You'll see one rugby ball on each patch on the try line. When you're ready to star, press the GO forever-button. This will commence the kicking; rounds will be repeated and results accumulated until you stop the GO button. Two monitors show the distance of the winning player, and the distance the analytic solution says should be the winner. Two other monitors display how many balls have been kicked and how many resulted in goals.

Watch the left-hand side of the playing field as the model runs. A histogram is being plotted of total points scored from each position along the kick line. The best scores (to date) for each round are highlighted in yellow (and their distance fromm the goal-line is displayed just to their right)-- the others are drawn in blue.The patch that is theoretically calculated to have the best score is shown in magenta and its distance is also displayed alongside it to the right.

In addition to the sequence of rounds described above, if you turn on the SHOW-LEVEL-CURVES? slider and press SETUP, you will see the level-curves associated with the given set of slider settings. This allows you to visualize the field of solutions for the analytic case of a uniform field. Patches are colored according to how large the goal looks from that position. Along each connected curve of the same color, the goal appears to be the same size. From straight ahead, the goal appears maximally wide.  From a shallow angle, the goal looks smaller at the same distance along the try line.


THINGS TO NOTICE
----------------
Given a particular goal-line and kick-line, what are the best positions to kick from? Change the position and size of the goal. How do the 'best positions' change in relation to the goal's position? Then change the position of the kick line, and redo the trial. How does the performance compare when the kick line is farther away? Or closer?

Examine the histogram at the left side of the world. What do you notice about it? What shape does it have? What does it tell you about the best locations to kick from?

How does the experimental solution compare to the analytic solution? Given enough time, will the experimental solution converge to the analytic solution? If so, how long does it take?


THINGS TO TRY
-------------
Can you generalize the results given by the model? What are the relationships between the kick-line, the goal, and the best patch to kick from?

Re-read the problem description given in the first paragraph of ""What Is It?"" Do you think that this model adequately answers the question asked? Why or why not?  What alternative solutions could you provide?

It's important to understand that this NetLogo project isn't exactly the standard method for solving problems of this sort. (A more 'classical' approach would be to use techniques from geometry or calculus.) However, there are many advantages offered by the NetLogo method. Consider the following other variables that might affect the solution to the problem: wind speed, grass height, or the size/weight/skill of the player kicking. (Such a problem that considers 'real-world' parameters such as these may quickly become intractable under classical mathematics.) Try and think of how you'd solve the 'rugby' problem in its idealized version without using NetLogo. Then try and solve it, taking into account one or more of these extra features.

In general, what advantages does the NetLogo solution have over the other methods? What disadvantages does it have?


EXTENDING THE MODEL
-------------------
Implement some of the features descibed above under ""Things To Try""- e.g. wind speed, or the size of the player to kick the conversion from a particular position.

There are a variety of plots you could have 'rugby' draw in a plot. Implement plotting procedures for some or all of the following: the number of successful kicks compared to the overall kicks, the plot of both types of kicks over time, or the difference in histograms depending on the locations of the kick-line (i.e. the value of KICK-LINE) and the goal-posts (GOAL-POS and GOAL-SIZE).


NETLOGO FEATURES
----------------
We draw our histogram straight to the view, unlike most other NetLogo models where the histogram is drawn in a separate plot.

In order to make the actual patch coordinate system more consistent with the conceptual coordinate system (the distances used in the model). The origin is at the bottom left corner of the world, so all coordinates are positive.


CREDITS AND REFERENCES
----------------------
The problem is taken from a British mathematics textbook.

For a fuller discussion, see Wilensky, U. (1996). Modeling Rugby: Kick First, Generalize Later? International Journal of Computers for Mathematical Learning. Vol. 1,  No. 1. p. 124 - 131.   http://ccl.northwestern.edu/cm/papers/rugby/

To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Rugby model.  http://ccl.northwestern.edu/netlogo/models/Rugby.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Rugby for terms of use.
"
Wolf Sheep Predation (docked),/models/Sample Models/System Dynamics,";; Sheep and wolves are both breeds of turtle.
breed [sheep a-sheep]  ;; sheep is its own plural, so we use ""a-sheep"" as the singular.
breed [wolves wolf]
turtles-own [energy]       ;; both wolves and sheep have energy

to setup
  clear-all
  ask patches [ set pcolor green ]
  set-default-shape sheep ""sheep""
  create-sheep initial-number-sheep  ;; create the sheep, then initialize their variables
  [
    set color white
    set size 1.5  ;; easier to see
    set label-color blue - 2
    set energy 1 + random sheep-max-initial-energy
    setxy random-xcor random-ycor
  ]
  set-default-shape wolves ""wolf""
  create-wolves initial-number-wolves  ;; create the wolves, then initialize their variables
  [
    set color black
    set size 1.5  ;; easier to see
    set energy random (2 * wolf-gain-from-food)
    setxy random-xcor random-ycor
  ]
  display-labels
  update-plot
end

to go
  if not any? turtles [ stop ]
  ask sheep [
    move
    reproduce-sheep
    death
  ]
  ask wolves [
    move
    set energy energy - 1  ;; wolves lose energy as they move
    catch-sheep
    reproduce-wolves
    death
  ]
end

to move  ;; turtle procedure
  rt random 50
  lt random 50
  fd 1
end

to reproduce-sheep  ;; sheep procedure
  if random-float 100 < sheep-reproduce [  ;; throw ""dice"" to see if you will reproduce
    set energy (energy / 2)                ;; divide energy between parent and offspring
    hatch 1 [ rt random-float 360 fd 1 ]   ;; hatch an offspring and move it forward 1 step
  ]
end

to reproduce-wolves  ;; wolf procedure
  if random-float 100 < wolf-reproduce [  ;; throw ""dice"" to see if you will reproduce
    set energy (energy / 2)               ;; divide energy between parent and offspring
    hatch 1 [ rt random-float 360 fd 1 ]  ;; hatch an offspring and move it forward 1 step
  ]
end

to catch-sheep  ;; wolf procedure
  let prey one-of sheep-here                    ;; grab a random sheep
  if prey != nobody                             ;; did we get one?  if so,
    [ ask prey [ die ]                          ;; kill it
      set energy energy + wolf-gain-from-food ] ;; get energy from eating
end

to death  ;; turtle procedure
  ;; when energy dips below zero, die
  if energy < 0 [ die ]
end

to update-plot
  set-current-plot ""agent-populations""
  set-current-plot-pen ""sheep""
  plot count sheep
  set-current-plot-pen ""wolves""
  plot count wolves
end

to display-labels
  ask turtles [ set label """" ]
  if show-energy? [
    ask wolves [ set label round energy ]
  ]
end

to setup-aggregate
  set-current-plot ""populations""
  clear-plot
  ;; call procedure generated by aggregate modeler
  system-dynamics-setup
  system-dynamics-do-plot
end

to step-aggregate
  ;; each agent tick is DT=1
  repeat ( 1 / dt ) [ system-dynamics-go ]
end

to compare
  go
  step-aggregate
  set-current-plot ""populations""
  system-dynamics-do-plot
  update-plot
  display-labels
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2005 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2005).  NetLogo Wolf Sheep Predation (docked) model.
; http://ccl.northwestern.edu/netlogo/models/WolfSheepPredation(docked).
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2005 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/WolfSheepPredation(docked)
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model explores the relationship between two different models of predator-prey ecosystems: an agent-based model and a aggregate model.  Each of the models can be run separately, or docked side-by-side for comparison.

In the agent model, wolves and sheep wander randomly around the landscape, while the wolves look for sheep to prey on. Each step costs the wolves energy, and they must eat sheep in order to replenish their energy - when they run out of energy they die. To allow the population to continue, each wolf or sheep has a fixed probability of reproducing at each time step.

The aggregate model is a System Dynamics model of the relationship between populations our wolves and sheep.  It is based on a version of the famous Lotka-Volterra model of interactions between two species in an ecosystem.


HOW TO USE IT
-------------
1. Adjust the slider parameters (see below), or use the default settings.
3. Press the SETUP-COMPARISON button.
4. Press the COMPARE button to begin the simulation.
5. View the POPULATIONS and AGENT-POPULATIONS plots to watch the populations fluctuate     over time

Parameters shared between agent and aggregate models:
INITIAL-NUMBER-SHEEP: The initial size of sheep population
INITIAL-NUMBER-WOLVES: The initial size of wolf population
SHEEP-REPRODUCE: The probability of a sheep reproducing at each time step

Parameters for agent model:
SHEEP-MAX-INITIAL-ENERGY: At setup time, sheep are given an energy between 1 and this value
WOLF-GAIN-FROM-FOOD: The amount of energy wolves get for every sheep eaten
WOLF-REPRODUCE: The probability of a wolf reproducing at each time step

Parameters for aggregate model:
WOLVES-DEATH-RATE: The rate at which wolves die.
PREDATION-RATE: The rate at which wolves eat sheep.
PREDATOR-EFFICIENCY: The efficiency of the wolves in extracting energy to reproduce from the prey they eat.


THINGS TO NOTICE
----------------
Why do you suppose that some variations of the model might be stable while others are not?


THINGS TO TRY
-------------
Try adjusting the parameters under various settings. How sensitive is the stability of the model to the particular parameters?

Notice that under stable settings, the populations tend to fluctuate at a predictable pace. Can you find any parameters that will speed this up or slow it down?


EXTENDING THE MODEL
-------------------
There are a number ways to alter the model so that it will be stable with only wolves and sheep (no grass). Some will require new elements to be coded in or existing behaviors to be changed. Can you develop such a version?


NETLOGO FEATURES
----------------
Note the use of the System Dynamics Modeler to create the aggregate model.


RELATED MODELS
---------------
Look at the Wolf Sheep Predation model for an example of an agent model which can produce a stable model of predator-prey ecosystems.


CREDITS AND REFERENCES
----------------------
Lotka, A.J. (1956) Elements of Mathematical Biology.  New York: Dover.

Wilensky, U. & Reisman, K. (1999). Connected Science: Learning Biology through Constructing and Testing Computational Theories -- an Embodied Modeling Approach. International Journal of Complex Systems, M. 234, pp. 1 - 12. (This model is a slightly extended version of the model described in the paper.)

Wilensky, U. & Reisman, K. (in press). Thinking like a Wolf, a Sheep or a Firefly: Learning Biology through Constructing and Testing Computational Theories -- an Embodied Modeling Approach. Cognition & Instruction.

To refer to this model in academic publications, please use:  Wilensky, U. (2005).  NetLogo Wolf Sheep Predation (docked) model.  http://ccl.northwestern.edu/netlogo/models/WolfSheepPredation(docked).  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2005 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/WolfSheepPredation(docked) for terms of use.
"
Tabonuco Yagrumo,/models/Sample Models/System Dynamics/Unverified,";; To see the rest of this model, look in the System Dynamics Modeler
;; window.  (If the window isn't showing, you can open it from the
;; Tools menu.)

globals [ previous-carbon ]

to setup
  ca
  set previous-carbon 0
  system-dynamics-setup    ;; defined by the System Dynamics Modeler
  do-plot
end

to go
  system-dynamics-go       ;; defined by the System Dynamics Modeler
  do-plot
  set previous-carbon carbon
end

to do-plot
  set-current-plot ""output""
  set-current-plot-pen ""carbon""
  plotxy ticks carbon
  set-current-plot-pen ""nitrogen""
  plotxy ticks nitrogen
  set-current-plot ""productivity""
  set-current-plot-pen ""productivity""
  plotxy ticks productivity
  set-current-plot ""trees""
  system-dynamics-do-plot
 end

to-report pulse [volume initial interval]
  set interval abs interval
  let our-x ticks - initial
  let peak volume / dt
  let slope peak / ( dt / 2 )
  let offset abs our-x
  ;; if we have passed the initial pulse, then recalibrate
  ;; to the next pulse interval, if there IS an interval given
  if ( interval > 0 and our-x > ( dt / 2 ) )
    [ set offset  ( our-x mod interval )
      if ( offset > dt / 2 ) [ set offset 0 + offset - interval ]  ]
  ;; the down side of the pulse
  if ( offset >= 0 and offset <= dt / 2  )
     [ report peak - ( slope * offset ) ]
  ;; the upside of the pulse
  if ( offset < 0 and offset >= ( 0 - ( dt / 2 ) ) )
     [ report slope * min (list ( dt / 2 ) ( abs ( interval - offset ) ) ) ]
  report 0
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2006 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2006).  NetLogo Tabonuco Yagrumo model.
; http://ccl.northwestern.edu/netlogo/models/TabonucoYagrumo.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2006 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/TabonucoYagrumo
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This is a system dynamics model of a simple ecosystem.  Two species of trees -- tabonuco and yagrumo -- compete for space in a forest canopy.  This model illustrates the role of hurricane destruction in this ecosystem, as well as the resultant nitrogen and carbon produced by the ecosystem.


HOW IT WORKS
------------
The relations between the tree species and the amount of space into which they can grow are defined in the System Dynamics Modeler.  The TABONUCO and YAGRUMO stocks represent the population of the two tree species.  They can only grow in the gaps of the forest canopy.  These spaces are represented by the GAPS stock.  The rate at which the trees grow or die is represented by the TABONUCO-GROWS and YAGRUMO-GROWS flows.  The flows connect to the GAPS stock to the tree stocks.  If more trees grow, there are fewer gaps in the forest.  If trees die then there are more gaps.

Tabonuco trees grow slower than yagrumo trees, these rates are represented by the TABONUCO-GROWTH-RATE and YAGRUMO-GROWTH-RATE variables.  However, tabonuco trees outlive yagrumo trees.  This relationship is represented by the TABONUCO-OUTGROWS-YAGRUMO flow from the YAGRUMO stock to the TABONUCO stock.

The YAGRUMO-GROWS and TABONUCO-GROWS flows are also connected to the DISTURBANCE variable.  DISTURBANCE represents the destruction of trees by hurricanes.  The HURRICANE-STRENGTH and HURRICANE-FREQUENCY variables determine the timing and amount of disturbance, which can be controlled by sliders.

The model also tracks the amount of carbon and nitrogen produced by the trees.  The trees produce resources via photosynthesis.  The rest of the living things in the forest use these resources.  The CARBON and NITROGEN variables calculate how much of those chemicals are produced by the trees.


HOW TO USE IT
-------------
Press the SETUP button to initialize the model.

To run the model continuously, press GO.

To run the model for one time step, press STEP.

Alternatively, you can run only 250 steps by pressing the
SETUP REPEAT 250 [ GO ] button.

Adjust the USER-HURRICANE-FREQUENCY slider to determine how many time units occur between hurricanes.

Adjust the USER-HURRICANE-STRENGTH slider to determine how many trees are destroyed by the hurricanes


THINGS TO NOTICE
----------------
Hurricanes play an important role in the ecosystem.  The relative amount of each tree is highly sensitive to both the rate and strength of hurricanes.  Both species co-exist only within a certain range of hurricane frequency and strength.


THINGS TO TRY
-------------
Change the USER-HURRICANE-FREQUENCY slider, observe what happens to the YAGRUMO population, and the productivity.  Do the same with USER-HURRICANE-STRENGTH.

Use BehaviorSpace (on the Tools menu) to sweep the parameter space for the USER-HURRICANE-FREQUENCY and USER-HURRICANE-STRENGTH.  An experiment that does this is included.

Use the GLOBALS monitor to observe the value off stocks, constants, model time, and model dt.


EXTENDING THE MODEL
-------------------
Add a third species of tree to the model.

Model the competition for the shared GAP stock in a different manner.

Vary the strength of the hurricanes, randomly, across an interval.


NETLOGO FEATURES
----------------
This model uses the System Dynamics Modeler.

It includes a built-in BehaviorSpace experiment.


RELATED MODELS
--------------
Tabonuco Yagrumo Hybrid


CREDITS AND REFERENCES
----------------------
This model is based on the work of The Learning Partnership in the Journey to El Yunque project (PI's include Steven McGee, Jess Zimmerman, and Steven Croft). To view the original materials or to learn more about that project, go to URL http://elyunque.net/journey.html

To refer to this model in academic publications, please use:  Wilensky, U. (2006).  NetLogo Tabonuco Yagrumo model.  http://ccl.northwestern.edu/netlogo/models/TabonucoYagrumo.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2006 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/TabonucoYagrumo for terms of use.
"
Tabonuco Yagrumo Hybrid,/models/Sample Models/System Dynamics/Unverified,";; To see the rest of this model, look in the System Dynamics Modeler
;; window.  (If the window isn't showing, you can open it from the
;; Tools menu.)

globals [ previous-carbon
          tabonuco-growth
          yagrumo-growth
          tabonuco-death
          yagrumo-death
          converted-to-tabonuco ]

breed [ tabonucos tabonuco ]
breed [ yagrumos yagrumo ]


to setup
  ca
  set-default-shape yagrumos ""plant""
  set-default-shape tabonucos ""tree""
  set previous-carbon 0
  system-dynamics-setup             ;; defined by System Dynamics Modeler
  agent-setup
  do-plot
end

to go
  agent-go
  system-dynamics-go                ;; defined by System Dynamics Modeler
  do-plot
  set previous-carbon carbon
end

;; Agent-Based rule setup for model.
to agent-setup
  ask n-of tabonuco-stock patches [ sprout-tabonucos 1 [ set color sky ] ]
  ask n-of yagrumo-stock patches with [ not any? turtles-here ] [ sprout-yagrumos 1 [ set color pink ] ]
end


;; Agent-Based rules for the model
;; These are only run oncce per cycle of the model, and the order is important
;; Tabonuco trees get first shot at open patches.
to agent-go
  set yagrumo-growth agent-yagrumo-growth yagrumo-stock
  set tabonuco-growth agent-tabonuco-growth tabonuco-stock

  set tabonuco-death agent-tabonuco-death disturbance
  set yagrumo-death agent-yagrumo-death disturbance
  set converted-to-tabonuco agent-tabonuco-conversion tabonuco-outgrowth-rate
end

to-report empty-patches
  report patches with [ not any? turtles-here ]
end

;; Rules governing the conversion of yagrumo trees to tabonuco trees
;; Only yagrumo trees next to an existing tabonuco tree can be converted
;; and only tabonuco-outgrowth-rate are converted.
to-report agent-tabonuco-conversion [ rate ]
  let total-converted 0
  let convertables yagrumos with [ any? neighbors with [ any? tabonucos-here ] ]
  ask n-of (count convertables * rate) convertables
    [ set total-converted total-converted + 1
      set breed tabonucos set color sky ]
  report total-converted
end


;; Rules governing the growth of Tabonuco trees
;; only trees with an empty patch next to them get a chance to reproduce
;; and only tabonuco-growth-rate of those trees can reproduce
to-report agent-tabonuco-growth [ current ]
  let total-grown 0
  let growable tabonucos with [ not all? neighbors [ any? turtles-here ] ]
  ask n-of ( count growable * tabonuco-growth-rate ) growable
    [ let seedpatch one-of neighbors with [ not any? turtles-here ]
      if ( seedpatch != nobody )
        [ ask seedpatch
            [ sprout-tabonucos 1 [ set color sky ]
              set total-grown total-grown + 1
            ]
        ]
    ]
    report total-grown
end

;; Rules governing the growth of Yagrumo trees
;; only trees with an empty patch next to them get a chance to reproduce
;; and only tabonuco-growth-rate of those trees can reproduce
to-report agent-yagrumo-growth [ current ]
 let total-grown 0
  let growable yagrumos with [ not all? neighbors [ any? turtles-here ] ]
  ask n-of ( count growable  * yagrumo-growth-rate ) growable
    [ let seedpatch one-of neighbors with [ not any? turtles-here ]
      if ( seedpatch != nobody )
        [ ask seedpatch
            [ sprout-yagrumos 1 [ set color pink ]
              set total-grown total-grown + 1
            ]
        ]
    ]
    report total-grown
end


;; Rules governing destruction of Tabonuco trees
to-report agent-tabonuco-death [ dist ]
  let total-dead 0
  ask n-of min (list (count tabonucos) ( tabonuco-stock * dist ) ) tabonucos
    [ set total-dead total-dead + 1
      die
    ]
  report total-dead
end

;; Rules governing destruction of Yagrumo trees
to-report agent-yagrumo-death [ dist ]
  let total-dead 0
  ask n-of min (list (count yagrumos) ( yagrumo-stock * dist ) ) yagrumos
    [ set total-dead total-dead + 1
      die
    ]
  report total-dead
end


to do-plot
  set-current-plot ""output""
  set-current-plot-pen ""carbon""
  plotxy ticks carbon
  set-current-plot-pen ""nitrogen""
  plotxy ticks nitrogen
  set-current-plot ""productivity""
  set-current-plot-pen ""productivity""
  plotxy ticks productivity
  ;set-current-plot-pen ""disturbance""
  ;plotxy system-dynamics-t disturbance
  set-current-plot ""trees""
  set-current-plot-pen ""tabonuco""
  plotxy ticks amount-of-tabonuco
  set-current-plot-pen ""yagrumo""
  plotxy ticks amount-of-yagrumo
 ;; set-current-plot ""gaps""
 ;; set-current-plot-pen ""gaps""
 ;; plotxy system-dynamics-t gaps
end

to-report pulse [ volume initial interval ]
  set interval abs interval
  let our-x ticks - initial
  let peak volume / dt
  let slope peak / ( dt / 2 )
  let offset abs our-x
  ;; if we have passed the initial pulse, then recalibrate
  ;; to the next pulse interval, if there IS an interval given
  if ( interval > 0 and our-x > ( dt / 2 ) )
    [ set offset  ( our-x mod interval )
      if ( offset > dt / 2 ) [ set offset 0 + offset - interval ]  ]
  ;; the down side of the pulse
  if ( offset >= 0 and offset <= dt / 2  )
     [ report peak - ( slope * offset ) ]
  ;; the upside of the pulse
  if ( offset < 0 and offset >= ( 0 - ( dt / 2 ) ) )
     [ report slope * min (list ( dt / 2 ) ( abs ( interval - offset ) ) ) ]
  report 0
end

to test-pulse [ volume initial interval ]
  setup
  repeat 250 [
    let y pulse volume initial interval
    output-print y
    set-current-plot ""productivity""
    plotxy ticks y
    tick-advance dt ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2006 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2006).  NetLogo Tabonuco Yagrumo Hybrid model.
; http://ccl.northwestern.edu/netlogo/models/TabonucoYagrumoHybrid.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2006 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/TabonucoYagrumoHybrid
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This is a model of a simple ecosystem of two species of trees that compete for space in a forest canopy.  Tabonuco Yagrumo Hybrid is different from Tabonuco Yagrumo in that the competition for space is explicitly modeled using turtles and patches, as opposed to being modeled as a relationship between stocks in the System Dynamics Modeler.  It is intended to be a simple example of how the two approaches can be combined into a hybrid model, and its behavior is similar to the non-hybrid version.


HOW IT WORKS
------------
The TABONUCO and YAGRUMO stocks represent the population of the two tree species.  The rate at which the stocks of both trees grow or die is represented by the TABONUCO-GROWS and YAGRUMO-GROWS flows.  These values come from the agent-based part of the model, where the trees compete for open pace in the forest.  The forest is modeled using turtles and patches.  Each tree is a turtle and lives on a patch.  It can only grow into an open patch immediately next to it.  If more trees grow, there are fewer gaps in the forest.  If trees die then there are more gaps.

Tabonuco trees grow slower than yagrumo trees, these rates are represented by the TABONUCO-GROWTH-RATE and YAGRUMO-GROWTH-RATE variables.  In each tick of the model, the two tree species attempt to grow into the available spaces.  However, tabonuco trees outlive yagrumo trees.  This relationship is represented by the TABONUCO-OUTGROWS-YAGRUMO flow from the YAGRUMO stock to the TABONUCO stock.  To represent this in the agent-based portion of the model, yagrumo trees are turned into tabonuco trees in the forest.

The YAGRUMO-DIES and TABONUCO-DIES flows are connected to the DISTURBANCE variable.  This variable represents the destruction of trees by hurricanes.  The HURRICANE-STRENGTH and HURRICANE-FREQUENCY variables determine the timing and amount of disturbance, which can be controlled by sliders.

The model also tracks the amount of carbon and nitrogen produced by the trees.  The trees produce resources via photosynthesis.  The rest of the living things in the forest use these resources.  The CARBON and NITROGEN variables calculate how much of those chemicals are produced by the trees.


HOW TO USE IT
-------------
Press the SETUP button to initialize the model.

To run the model continuously, press GO.

To run the model for one time step, press STEP.

Alternatively, you can run only 250 steps by pressing the
SETUP REPEAT 250 [ GO ] button.

Adjust the USER-HURRICANE-FREQUENCY slider to determine how many time units occur between hurricanes.

Adjust the USER-HURRICANE-STRENGTH slider to determine how many trees are destroyed by the hurricanes


THINGS TO NOTICE
----------------
Hurricanes play an important role in the ecosystem.  The relative amount of each tree is highly sensitive to both the rate and strength of hurricanes.  Both species co-exist only within a certain range of hurricane frequency and strength.

The results of the model is different from Tabonuco Yagrumo in several ways.  First, the curves are not smooth, because they are not generated only by a function, but have have random events generating the results.  Second, the modeling of Tabonuco outgrowing Yagrumo in this model causes the Yagrumo to grow less, because the available spaces for it to grow into are reduced.

THINGS TO TRY
-------------
Change the USER-HURRICANE-FREQUENCY slider, observe what happens to the YAGRUMO population, and the productivity.  Do the same with USER-HURRICANE-STRENGTH.

Use the BehaviorSpace Tool to sweep the parameter space for the USER-HURRICANE-FREQUENCY and USER-HURRICANE-STRENGTH.

Use the GLOBALS monitor to observe the value of stocks, constants, model time, and model dt.


EXTENDING THE MODEL
-------------------
Experiment with trying different rules for competition for space.

Vary the strength of the hurricanes, randomly, across an interval.


NETLOGO FEATURES
----------------
This model provides a simple example of combining agent-based and system dynamics modeling.

RELATED MODELS
--------------
The Tabonuco Yagrumo model.

CREDITS AND REFERENCES
----------------------
The following model is based on the work of The Learning Partnership in the Journey to El Yunque project (PI's include Steven McGee, Jess Zimmerman, and Steven Croft). To view the original materials or to learn more about that project, go to URL http://elyunque.net/journey.html

To refer to this model in academic publications, please use:  Wilensky, U. (2006).  NetLogo Tabonuco Yagrumo Hybrid model.  http://ccl.northwestern.edu/netlogo/models/TabonucoYagrumoHybrid.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2006 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/TabonucoYagrumoHybrid for terms of use.
"
Logistic Growth,/models/Sample Models/System Dynamics,";; system-dynamics-setup, system-dynamics-do-plot, and system-dynamics-go are automatically
;; generated by the System Dynamics Modeler.  The code can be viewed in the
;; Procedures Tab of the System Dynamics Modeler.

to setup
  ca
  system-dynamics-setup
  system-dynamics-do-plot
end

to go
  system-dynamics-go
  system-dynamics-do-plot
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2005 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2005).  NetLogo Logistic Growth model.
; http://ccl.northwestern.edu/netlogo/models/LogisticGrowth.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2005 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/LogisticGrowth
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This is a model of a logistic growth curve using the System Dynamics Modeler.


HOW IT WORKS
------------
At each step the difference equations n * ( 1 - n ) is calculated and added to the stock.


HOW TO USE IT
-------------
1. Press the SETUP button.
2. Press the GO button to run the model.
3. View the STOCK monitor to see the current value of STOCK.
4. View the plot to observe the growth of STOCK over time.


THINGS TO NOTICE
----------------


THINGS TO TRY
-------------
What do you think might happen if the initial value of stock is larger than 1? less than zero?


NETLOGO FEATURES
----------------
This model uses the System Dynamics Modeler.


RELATED MODELS
--------------
System-Dynamics -> Exponential Growth


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (2005).  NetLogo Logistic Growth model.  http://ccl.northwestern.edu/netlogo/models/LogisticGrowth.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2005 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/LogisticGrowth for terms of use.
"
Wolf Sheep Predation (System Dynamics),/models/Sample Models/System Dynamics,";; system-dynamics-setup, system-dynamics-do-plot, and system-dynamics-go are automatically
;; generated by the System Dynamics Modeler.  The code can be viewed in the
;; Procedures Tab of the System Dynamics Modeler.

to setup
  ca
  system-dynamics-setup
  system-dynamics-do-plot
end

to go
  system-dynamics-go
  system-dynamics-do-plot
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2005 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2005).  NetLogo Wolf Sheep Predation (System Dynamics) model.
; http://ccl.northwestern.edu/netlogo/models/WolfSheepPredation(SystemDynamics).
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2005 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/WolfSheepPredation(SystemDynamics)
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This is a model of a simple predator-prey ecosystem. It uses the System Dynamics Modeler to implement the Lotka-Volterra equations.

The Lotka-Volterra equations are a pair of first order, non-linear, differential equations that describe the dynamics of biological systems in which two species interact.


HOW IT WORKS
------------
At each step, the value of the SHEEP-BIRTHS flow is added to SHEEP stock, and the value of the SHEEP-DEATHS flow is subtracted from the SHEEP stock.  The same is done for the WOLVES stock.  Each flow is calculated in terms of the variables, and stocks that are linked to it.


HOW TO USE IT
-------------
1. Press the SETUP button.
2. Press the GO button to run the model.
3. View the SHEEP and WOLVES monitors for the current value of those populations.
4. View the plot to observe the populations changing over time.


THINGS TO NOTICE
----------------
What happens when the sheep population increases? And the wolves? Why do you think this is the case?


THINGS TO TRY
-------------
Use the System Dynamics Modeler to change the values of the variables in the system, such as SHEEP-BIRTH-RATE and PREDATOR-EFFICIENCY.


NETLOGO FEATURES
----------------
This model uses the System Dynamics Modeler to simulate the Lotka-Volterra equations.


RELATED MODELS
--------------
Wolf-Sheep Predation
Wolf-Sheep Predation (docked)

CREDITS AND REFERENCES
----------------------
Lotka, A.J. (1956). Elements of Mathematical Biology.  New York: Dover.

""Lotka-Volterra equation"". From Wikipedia.  http://en.wikipedia.org/wiki/Lotka-Volterra_equation

Eric W. Weisstein. ""Lotka-Volterra Equations."" From MathWorld. http://mathworld.wolfram.com/Lotka-VolterraEquations.html

To refer to this model in academic publications, please use:  Wilensky, U. (2005).  NetLogo Wolf Sheep Predation (System Dynamics) model.  http://ccl.northwestern.edu/netlogo/models/WolfSheepPredation(SystemDynamics).  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2005 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/WolfSheepPredation(SystemDynamics) for terms of use.
"
Exponential Growth,/models/Sample Models/System Dynamics,";; system-dynamics-setup, system-dynamics-do-plot, and system-dynamics-go are automatically
;; generated by the System Dynamics Modeler.  The code can be viewed in the
;; Procedures Tab of the System Dynamics Modeler.

to setup
  ca
  system-dynamics-setup
  system-dynamics-do-plot
end

to go
  system-dynamics-go
  system-dynamics-do-plot
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2005 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2005).  NetLogo Exponential Growth model.
; http://ccl.northwestern.edu/netlogo/models/ExponentialGrowth.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2005 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/ExponentialGrowth
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This is a model of exponential growth using the System Dynamics Modeler.


HOW IT WORKS
------------
At each step, the value of INFLOW is added to STOCK.  The value of INFLOW is always the previous value of STOCK times a specified growth rate.


HOW TO USE IT
-------------
1. Press the SETUP button.
3. Press the GO button to run the model.
4. View the STOCK monitor to see the current value of STOCK.
5. View the plot to observe the growth of STOCK over time.


THINGS TO NOTICE
----------------


THINGS TO TRY
-------------
Use the System Dynamics Modeler to add an outflow.

Try different growth-rate values.

EXTENDING THE MODEL
-------------------
Create a new stock that grows linearly.  Try having the level of one stock influence the growth rate of the other.


NETLOGO FEATURES
----------------
This model uses the System Dynamics Modeler.


RELATED MODELS
--------------
System-Dynamics -> Logistic Growth


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (2005).  NetLogo Exponential Growth model.  http://ccl.northwestern.edu/netlogo/models/ExponentialGrowth.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2005 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/ExponentialGrowth for terms of use.
"
Voting,/models/Sample Models/Social Science,"patches-own
[
  vote   ;; my vote (0 or 1)
  total  ;; sum of votes around me
]

to setup
  ca
  ask patches
    [ set vote random 2
      recolor-patch ]
end

to go
  ask patches
    [ set total (sum [vote] of neighbors) ]
  ;; use two ask patches blocks so all patches compute ""total""
  ;; before any patches change their votes
  ask patches
    [ if total > 5 [ set vote 1 ]
      if total < 3 [ set vote 0 ]
      if total = 4
        [ if change-vote-if-tied?
          [ set vote (1 - vote) ] ]
      if total = 5
        [ ifelse award-close-calls-to-loser?
          [ set vote 0 ]
          [ set vote 1 ] ]
      if total = 3
        [ ifelse award-close-calls-to-loser?
          [ set vote 1 ]
          [ set vote 0 ] ]
      recolor-patch ]
  tick
end

to recolor-patch  ;; patch procedure
  ifelse vote = 0
    [ set pcolor green ]
    [ set pcolor blue ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Voting model.
; http://ccl.northwestern.edu/netlogo/models/Voting.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Voting
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model is a simple cellular automaton that simulates voting distribution by having each patch take a ""vote"" of its eight surrounding neighbors, then perhaps change its own vote according to the outcome.


HOW TO USE IT
-------------
Click the SETUP button to create an approximately equal but random distribution of blue and green patches.  Click GO to run the simulation.

When both switches are off, the central patch changes its color to match the majority vote, but if there is a 4-4 tie, then it does not change.

If the CHANGE-VOTE-IF-TIED? switch is on, then in the case of a tie, the central patch will always change its vote.

If the AWARD-CLOSE-CALLS-TO-LOSER? switch is on, then if the result is 5-3, the central patch votes with the losing side instead of the winning side.


THINGS TO NOTICE
----------------
Watch how any setup quickly settles to a static state when both switches are off.

Watch what happens when only the CHANGE-VOTE-IF-TIED? switch is on.  How is the result different?

Watch what happens when only the AWARD-CLOSE-CALLS-TO-LOSER? switch is on.  How is the result different?

What happens when both switches are on?


EXTENDING THE MODEL
-------------------
Try other voting rules.

Start with a nonrandom green-and-blue pattern. For example, one could make half of the world blue and half green.

Can you enhance the model to incorporate multiple colors and multiple votes?  One might interpret shades of color to represent the degree of a patch's opinion about an issue: strongly against, against, neutral, etc.  Each patch could have more than two choices and weighted votes: blue patches' vote could count twice, etc.


RELATED MODELS
--------------
Ising (a physics model, but the rules are very similar)


CREDITS AND REFERENCES
----------------------
This model is described in Rudy Rucker's ""Artificial Life Lab"", published in 1993 by Waite Group Press.

To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Voting model.  http://ccl.northwestern.edu/netlogo/models/Voting.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Voting for terms of use.
"
Traffic Basic,/models/Sample Models/Social Science,"globals [ sample-car ]
turtles-own [ speed speed-limit speed-min ]

to setup
  ca
  ask patches [ setup-road ]
  setup-cars
  watch sample-car
end

to setup-road  ;; patch procedure
  if ( pycor < 2 ) and ( pycor > -2 ) [ set pcolor white ]
end

to setup-cars
  if ( number-of-cars > world-width )
  [
    user-message (word ""There are too many cars for the amount of road.  Please decrease the NUMBER-OF-CARS slider to below ""
                       (world-width + 1)
                       "" and press the SETUP button again.  The setup has stopped."")
    stop
  ]

  set-default-shape turtles ""car""
  crt number-of-cars [
    set color blue
    setxy random-xcor 0
    set heading  90
    ;;; set initial speed to be in range 0.1 to 1.0
    set speed  0.1 + random-float .9
    set speed-limit  1
    set speed-min  0
    separate-cars
  ]
  set sample-car one-of turtles
  ask sample-car [ set color red ]
end

; this procedure is needed so when we click ""Setup"" we
; don't end up with any two cars on the same patch
to separate-cars  ;; turtle procedure
  if any? other turtles-here
    [ fd 1
      separate-cars ]
end

to go
   ;; if there is a car right ahead of you, match its speed then slow down
  ask turtles [
    ifelse any? turtles-at 1 0
      [ set speed ([speed] of one-of turtles-at 1 0)
        slow-down-car ]
      ;; otherwise, speed up
      [ speed-up-car ]
    ;;; don't slow down below speed minimum or speed up beyond speed limit
    if speed < speed-min  [ set speed speed-min ]
    if speed > speed-limit   [ set speed speed-limit ]
    fd speed ]
  tick
  plot-cars
end

to slow-down-car  ;; turtle procedure
  set speed speed - deceleration
end

to speed-up-car  ;; turtle procedure
  set speed speed + acceleration
end

to plot-cars
  set-current-plot ""Car Speed""
  set-current-plot-pen ""Red Car Speed""
  plot [speed] of sample-car
  set-current-plot-pen ""Min Speed""
  plot min [speed] of turtles
  set-current-plot-pen ""Max Speed""
  plot max [speed] of turtles
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1997 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1997).  NetLogo Traffic Basic model.
; http://ccl.northwestern.edu/netlogo/models/TrafficBasic.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1997 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/TrafficBasic
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model models the movement of cars on a highway. Each car follows a simple set of rules: it slows down (decelerates) if it sees a car close ahead, and speeds up (accelerates) if it doesn't see a car ahead.

The model demonstrates how traffic jams can form even without any accidents, broken bridges, or overturned trucks.  No ""centralized cause"" is needed for a traffic jam to form.


HOW TO USE IT
-------------
Click on the SETUP button to set up the cars. Set the NUMBER slider to change the number of cars on the road.

Click on DRIVE to start the cars moving.  Note that they wrap around the world as they move, so the road is like a continuous loop.

The ACCELERATION slider controls the rate at which cars accelerate (speed up) when there are no cars ahead.

When a car sees another car right in front, it matches that car's speed and then slows down a bit more.  How much slower it goes than the car in front of it is controlled by the DECELERATION slider.


THINGS TO NOTICE
----------------
Traffic jams can start from small ""seeds.""  These cars start with random positions and random speeds. If some cars are clustered together, they will move slowly, causing cars behind them to slow down, and a traffic jam forms.

Even though all of the cars are moving forward, the traffic jams tend to move backwards. This behavior is common in wave phenomena: the behavior of the group is often very different from the behavior of the individuals that make up the group.

The plot shows three values as the model runs:
- the fastest speed of any car (this doesn't exceed the speed limit!)
- the slowest speed of any car
- the speed of a single car (turtle 0), painted red so it can be watched.
Notice not only the maximum and minimum, but also the variability -- the ""jerkiness"" of one vehicle.

Notice that the default settings have cars decelerating much faster than they accelerate. This is typical of traffic flow models.

Even though both ACCELERATION and DECELERATION are very small, the cars can achieve high speeds as these values are added or subtracted at each tick.


THINGS TO TRY
--------------
In this model there are three variables that can affect the tendency to create traffic jams: the initial NUMBER of cars, ACCELERATION, and DECELERATION. Look for patterns in how the three settings affect the traffic flow.  Which variable has the greatest effect?  Do the patterns make sense?  Do they seem to be consistent with your driving experiences?

Set DECELERATION to zero.  What happens to the flow?  Gradually increase DECELERATION while the model runs.  At what point does the flow ""break down""?


EXTENDING THE MODEL
------------
Try other rules for speeding up and slowing down.  Is the rule presented here realistic?   Are there other rules that are more accurate or represent better driving strategies?

In reality, different vehicles may follow different rules. Try giving different rules or ACCELERATION/DECELERATION values to some of the cars.  Can one bad driver mess things up?

The asymmetry between acceleration and deceleration is a simplified representation of different driving habits and response times. Can you explicitly encode these into the model?

What could you change to minimize the chances of traffic jams forming?

What could you change to make traffic jams move forward rather than backward?

Make a model of two-lane traffic.


NETLOGO FEATURES
-----------------
The plot shows both global values and the value for a single turtle, which helps one watch overall patterns and individual behavior at the same time.

The WATCH command is used to make it easier to focus on the red car.


RELATED MODELS
---------------
""Traffic"" (in StarLogoT) adds graphics, trucks, and a radar trap.

""Gridlock"" (a HubNet model which can be run as a participatory simulation) models traffic in a grid with many intersections.


CREDITS AND REFERENCES
-----------------------

This model was developed at the MIT Media Lab.  See Resnick, M. (1994) ""Turtles, Termites and Traffic Jams: Explorations in Massively Parallel Microworlds.""  Cambridge, MA: MIT Press.  Adapted to StarLogoT, 1997, as part of the Connected Mathematics Project.  Adapted to NetLogo, 2001, as part of the Participatory Simulations Project.

To refer to this model in academic publications, please use:  Wilensky, U. (1997).  NetLogo Traffic Basic model.  http://ccl.northwestern.edu/netlogo/models/TrafficBasic.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1997 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/TrafficBasic for terms of use.
"
Rumor Mill,/models/Sample Models/Social Science,"globals [
  color-mode     ;; 0 = normal, 1 = when heard, 2 = times heard
  clique         ;; how many patches have heard the rumor
]

patches-own [
  times-heard    ;; tracks times the rumor has been heard
  first-heard    ;; clock tick when first heard the rumor
  just-heard?    ;; tracks whether rumor was heard this round -- resets each round
]

;;; setup procedures

to setup [seed-one?]
  ca
  set color-mode 0
  set clique 0
  ask patches
    [ set first-heard -1
      set times-heard 0
      set just-heard? false
      recolor ]
  ifelse seed-one?
    [ seed-one ]
    [ seed-random ]
  update
  do-plots
end

to seed-one
  ;; tell the center patch the rumor
  ask patch 0 0
    [ hear-rumor ]
end

to seed-random
  ;; seed with random number of rumor sources governed by init-clique slider
  ask patches with [times-heard = 0]
    [ if (random-float 100.0) < init-clique
        [ hear-rumor ] ]
end

to go
  if all? patches [times-heard > 0]
    [ stop ]
  ask patches
    [ if times-heard > 0
        [ spread-rumor ] ]
  update
  tick
  do-plots
end

to spread-rumor  ;; patch procedure
  let neighbor nobody
  ifelse eight-mode?
    [ set neighbor one-of neighbors ]
    [ set neighbor one-of neighbors4 ]
  ask neighbor [ set just-heard? true ]
end

to hear-rumor  ;; patch procedure
  if first-heard = -1
    [ set first-heard ticks
      set just-heard? true ]
  set times-heard times-heard + 1
  recolor
end

to update
  ask patches with [just-heard?]
    [ set just-heard? false
      hear-rumor ]
end

;;; coloring procedures

to recolor  ;; patch procedure
  ifelse color-mode = 0
    [ recolor-normal ]
    [ ifelse color-mode = 1
      [ recolor-by-when-heard ]
      [ recolor-by-times-heard ] ]
end

to recolor-normal  ;; patch procedure
  ifelse first-heard >= 0
    [ set pcolor red ]
    [ set pcolor blue ]
end

to recolor-by-when-heard  ;; patch procedure
  ifelse first-heard = -1
    [ set pcolor black ]
    [ set pcolor scale-color yellow first-heard world-width 0 ]
end

to recolor-by-times-heard   ;; patch procedure
  set pcolor scale-color green times-heard 0 world-width
end

;;; mouse handling

to spread-rumor-with-mouse
  if mouse-down?
    [ ask patch mouse-xcor mouse-ycor
        [ hear-rumor ]
        display ]
end

;;; plotting procedures

to setup-plots
  set-current-plot ""Successive Differences""
  set-plot-y-range 0 (count patches / 5)
end

to do-plots
  let new-clique count patches with [times-heard > 0]
  set-current-plot ""Rumor Spread""
  plot (new-clique / count patches) * 100
  set-current-plot ""Successive Ratios""
  ifelse clique = 0
    [ plot 1 ]
    [ plot new-clique / clique ]
  set-current-plot ""Successive Differences""
  plot new-clique - clique
  set clique new-clique
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Rumor Mill model.
; http://ccl.northwestern.edu/netlogo/models/RumorMill.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/RumorMill
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This program models the spread of a rumor.  The rumor spreads when a person who knows the rumor tells one of their neighbors.  In other words, spatial proximity is a determining factor as to how soon (and perhaps how often) a given individual will hear the rumor.

The neighbors can be defined as either the four adjacent people or the eight adjacent people.  At each time step, every person who knows the rumor randomly chooses a neighbor to tell the rumor to.  The simulation keeps track of who knows the rumor, how many people know the rumor, and how many ""repeated tellings"" of the rumor occur.


HOW TO USE IT
-------------
EIGHT-MODE? is a switch that determines whether at each time step the rumor spreads to one of four randomly chosen neighbors, or one of eight such neighbors.

As with any rumor, it has to start somewhere, with one or more individuals.  There are three ways to control the start of the rumor:

1) Single source: Press the SETUP-ONE button. This starts the rumor at one point in the center of the world.
2) Random source: Press the SETUP-RANDOM button with the INIT-CLIQUE slider set greater than 0. This ""seeds"" the rumor randomly by choosing a percentage of the population that knows the rumor initially.  This percentage is set using the INIT-CLIQUE slider.
3) Choose source with mouse: Press either SETUP-ONE or SETUP-RANDOM, then press the SPREAD-RUMOR-WITH-MOUSE button.  While this button is down, clicking the mouse button on a patch in the view will tell the rumor to that patch.

To run the model, you can either ""step"" through each time step using the STEP button or allow the model to simply run continuously using the GO button.  The model will stop when everyone in the population knows the rumor.

There are three plot windows associated with this rumor model.

RUMOR SPREAD - plots the percentage of people who know the rumor at each time step.
SUCCESSIVE DIFFERENCES - plots the number of new people who are hearing the rumor at each time step.
SUCCESSIVE RATIOS - plots the percentage of new people who are hearing the rumor at each time step.

The monitor CLIQUE% is the percentage of the patches that have heard the rumor.

The three coloring buttons to the right of the view give you topographic maps of the world.  The COLOR: WHEN HEARD button colors the patches different shades of YELLOW according to the first time that location heard the rumor.  The COLOR: TIMES HEARD button colors the patches different shades of GREEN according to the number of times that location has heard the rumor.


THINGS TO NOTICE
----------------
The most interesting models to run are those where only a small number of individuals who initially know the rumor.  Use the SPREAD-RUMOR-WITH-MOUSE button to make an initial setup where only three or four patches know the rumor, and all of these patches are in the left half of the world.  Run your model once with ""Wrap"" off and then again with ""Wrap"" on.  notice the difference in how the rumor is spread.  Which version seems more realistic to you?

Similarly, run the same model in eight-mode and then in four-mode.  Before you run the model, try to decide, will this make a difference in the spread of the rumor?  Why or why not?

An interesting thing to notice about the spread of the rumor is that the ""speed"" with which the rumor spreads slows down as more and more people know the rumor.  Why is that?  How is that related to the number of ""repeated"" or ""wasted"" tellings of the rumor?  How do the two ""differences"" plot windows help you to understand the dynamics of the rumor spread?


THINGS TO TRY
-------------
Change the shape of the world (by changing the wrap settings in edit World & View) and see how the spread of the rumor changes in a box or a cylinder.

Use SPREAD-RUMOR-WITH-MOUSE to place four ""seeds"" for the rumor centered in each of the four quadrants of the grid.  Notice the pattern of ""repeated tellings.""  Move the four ""seeds"" closer into the center of the grid.  How does the pattern or ""repeated tellings"" change?  Move the ""seeds"" away from the center of the grid.  How does the pattern of repeated tellings change?  How will it change if  you turn ""wrap"" on or off?

Explore other patterns of seeding the rumor and its impact on the pattern of repeated tellings.


EXTENDING THE MODEL
-------------------
Here are some suggestions for ways to extend the model.

- Introduce physical barriers into the simulation.  These spatial barriers would be obstacles around which the rumor would have to spread.  One could imagine a room where there was only a one cell entry.  How long would it take to reach the entire population in this case?  And how would that curve (the function of the number of people who know the rumor versus time) compare to the spread of the rumor when there was no such barrier?

- Assign a probability with which the rumor is told.  In the current model, each time a person meets his/her neighbor, s/he tells the neighbor the rumor.  How would the spread of the rumor change if the telling of the rumor took place only 50% of the time? or 30% of the time?

- Currently, person A might keep telling person B the rumor over and over again.  Does the rumor spread differently if no one tells the rumor to someone they've already told or someone who told them?

- Can you make a rumor model that does not spread the rumor through spatial proximity?


NETLOGO FEATURES
----------------
Note the use of the ""neighbors"" and ""neighbors4"" primitives to implement 8-mode and 4-mode, respectively.


RELATED MODELS
--------------
Virus, AIDS


CREDITS AND REFERENCES
----------------------
This model is itself an extension of a physical experiment where spatial proximity was not a factor in the spread of the rumor.  Contact Helen M. Doerr at hmdoerr@syr.edu regarding papers in preparation.  Thanks to Dr. Doerr for inspiration for this model.

To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Rumor Mill model.  http://ccl.northwestern.edu/netlogo/models/RumorMill.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/RumorMill for terms of use.
"
Altruism,/models/Sample Models/Social Science,"patches-own [
  benefit-out                 ;; 1 for altruists, 0 for selfish
  altruism-benefit
  fitness
  self-weight self-fitness
  alt-weight alt-fitness
  harsh-weight harsh-fitness
]

to setup
  clear-all
  ask patches [ initialize ]
  do-plots
end

to initialize  ;; patch procedure
  let ptype random-float 1.0
  ifelse (ptype < altruistic-probability) [
    set benefit-out 1
    set pcolor pink
  ] [
    set benefit-out 0
    ifelse (ptype < altruistic-probability + selfish-probability) [
      set pcolor green
    ] [
      set pcolor black
    ]
  ]
end

to go
  ;; if all altruistic and selfish patches are gone, stop
  if all? patches [pcolor != pink and pcolor != green]
    [ stop ]
  ask patches [
    set altruism-benefit   benefit-from-altruism * (benefit-out + sum [benefit-out] of neighbors4) / 5
  ]
  ask patches [
    perform-fitness-check
  ]
  lottery
  tick
  do-plots
end

to perform-fitness-check  ;; patch procedure
  if (pcolor = green) [
    set fitness (1 + altruism-benefit)
  ]
  if(pcolor = pink) [
    set fitness ((1 - cost-of-altruism) + altruism-benefit)
  ]
  if (pcolor = black) [
    set fitness harshness
  ]
end

to lottery
  ask patches [ record-neighbor-fitness ]
  ask patches [ find-lottery-weights ]
  ask patches [ next-generation ]
end

to record-neighbor-fitness  ;; patch procedure
  set alt-fitness 0
  set self-fitness 0
  set harsh-fitness 0
  if (pcolor = pink) [
    set alt-fitness fitness
  ]
  if (pcolor = green) [
    set self-fitness fitness
  ]
  if (pcolor = black) [
    set harsh-fitness fitness
  ]
  update-fitness-from-neighbor 1 0
  update-fitness-from-neighbor -1 0
  update-fitness-from-neighbor 0 1
  update-fitness-from-neighbor 0 -1
end

to update-fitness-from-neighbor [x y]  ;; patch procedure
  let neighbor-color [pcolor] of patch-at x y
  let neighbor-fitness [fitness] of patch-at x y
  if (neighbor-color = pink)
    [set alt-fitness (alt-fitness + neighbor-fitness)]
  if (neighbor-color = green)
    [set self-fitness (self-fitness + neighbor-fitness)]
  if(neighbor-color = black)
    [set harsh-fitness (harsh-fitness + neighbor-fitness)]
end

to find-lottery-weights ;; patch procedure
  let fitness-sum alt-fitness + self-fitness + harsh-fitness + disease
  ifelse (fitness-sum > 0) [
    set alt-weight (alt-fitness / fitness-sum)
    set self-weight (self-fitness / fitness-sum)
    set harsh-weight ((harsh-fitness + disease) / fitness-sum)
  ] [
    set alt-weight 0
    set self-weight 0
    set harsh-weight 0
  ]
end

to next-generation ;; patch procedure
  let breed-chance random-float 1.0
  ifelse (breed-chance < alt-weight) [
    set pcolor pink
    set benefit-out 1
  ] [
    ifelse (breed-chance < (alt-weight + self-weight))[
      set pcolor green
      set benefit-out 0
    ] [
      clear-patch
    ]
  ]
end

to clear-patch ;; patch procedure
  set pcolor black
  set altruism-benefit 0
  set fitness 0
  set alt-weight 0
  set self-weight 0
  set harsh-weight 0
  set alt-fitness 0
  set self-fitness 0
  set harsh-fitness 0
  set benefit-out 0
end

to do-plots
  set-current-plot ""Populations""
  set-current-plot-pen ""altruists""
  plot count patches with [pcolor = pink]
  set-current-plot-pen ""selfish""
  plot count patches with [pcolor = green]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Altruism model.
; http://ccl.northwestern.edu/netlogo/models/Altruism.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Altruism
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model (and Cooperation and Divide the Cake) are part of the EACH curriculum: ""Evolution of Altruistic and Cooperative Habits: Learning About Complexity in Evolution"".  See http://ccl.northwestern.edu/cm/EACH/ for more information.

This is an evolutionary biology model.  It models population genetics with respect to the fitness of traits that are affected by social and environmental conditions.  The model has two types of patch agents: altruistic agents and selfish agents.

The basic premise of the model is that the selfish agents and the altruistic agents are competing for each spot in the world by entering into a genetic lottery.  You can imagine these agents as plants who ""seed"" for a spot, and the dominant seed generally wins.  The details of the lottery are explained below in HOW IT WORKS.

Under normal (non-interfering) environmental conditions, the selfish agents win, and the altruistic population is driven to extinction.  However, as outlined in 'HOW TO USE IT', when the environmental conditions are made more harsh, the altruistic population is able to survive, and even dominate the selfish population.


HOW IT WORKS
------------
1. Patches live in five-cell, plus-sign-shaped neighborhoods.  Whenever a patch is calculating something about its fitness, it is the center of the neighborhood.  For another patch, when that patch is calculating, it becomes merely one of the neighbors.

2. Each patch is an agent that has a fitness.  Each patch is also the location of a lottery for its space.  The patch and the four surrounding patches put in ""seeds"" to try to get the patch turned to their type of patch, altruist or selfish. Being successful in the lottery is getting patches to turn to your type.  We're assuming here that the type (altruistic or selfish) is the important genetic trait.

3.  Each patch calculates its own fitness using equation:
if it is A (altruist): 1 - cost + (Number Altruists in Neighborhood / 5 * benefit from Altruists)
if it is S (selfish):  1 + (Number Altruists in Neighborhood / 5 * benefit from Altruists)

Thus, the fitness of the S patch will be higher than the fitness of the A's.  If the cost is 0.2 and benefit is 0.5, for an A surrounded by two S's and two A's, then the fitness of this spot is 1 - 0.2 + (3/5 * 0.5) = 1.1.

4.  After each patch has calculated its fitness, it looks to its four neighbors.  Each of the five patches, including itself, puts a weighted seed into a genetic lottery for this center spot.  So, for example, if the neighborhood is ASASA, each of the three A's register their fitness value, and each of the two S's put in their fitness.  The A's are added, and the S's are added.  Let us assume that the A's add up to 3.2 (this includes the A in the center spot), and the S's add up to 2.6.  These two numbers are the altruist weight and selfish weight respectively, in the lottery for the center spot.  Now, the larger number, whichever it is, is called the Major seed; it is divided by the sum of all the fitnesses.

Thus, 3.2/(3.2 + 2.6) = .552

This number is the Altruism seed in the lottery.  The minor seed is 2.6/(3.2 + 2.6) = .448. (Notice that the Altruism seed of the parent is 3/5 = .600, while the child's is .552.  Even though altruism is dominating, it is losing ground.)

5.  There are a number of ways of doing the lottery itself.  Currently, we choose a random number between 0 and 1.  Now, if the Number is below the Minor seed, the minor weight gets the spot, and if it is above the major seed, the major seed gets the spot.  So, in the example, if the random number is anywhere from .449 to 1, then the Major seed gets it. If it is between 0 and .448, the minor seed gets it.


HOW TO USE IT
-------------
SETUP button -- sets up the model by creating the agents.

GO button -- runs the model

ALTRUISTIC-PROBABILITY slider -- lets you determine the initial proportion of altruists

SELFISH-PROBABILITY slider -- determines the initial proportion of selfish agents.

ALTRUISM-COST slider -- determines the value of cost in the above fitness equations.

BENEFIT-FROM-ALTRUISM slider -- determines the value of benefit in the above fitness equations.

There are two sliders for controlling environmental variables:

HARSHNESS slider -- sets the value for the resistance of empty patch spots to being populated by agents.  The value for this slider determines a corresponding value in the lottery for each empty (black) spot on the grid; the higher this value, the more difficult it is to populate.

DISEASE slider -- sets the value for the possibility that the agents in occupied spots will die.  The value for this slider is factored into the genetic lottery, and determines the percentage chance that each agent will die out from their spot.


THINGS TO TRY
-------------
1.  At first, run the model with Harshness and Disease both at 0.  Notice that the selfish population quickly dominates the world, driving the altruistic population to extinction.  How do respective population sizes affect the outcome?

2.  Play with the values of cost and benefit.  What are realistic values for actual genetic competition?  How does initial population size effect the significance of these values?

3.  Increase the Harshness and Disease values, independently, and with respect to one another.  What are the effects of the Harshness Model?  of Disease?  How are the values dependent on one another?  At what values does the altruistic population begin to have greater success?

4.  Consider why the introduction of Harshness and Disease conditions affects the success of the altruistic population.  How does each population, run alone, respond to the Harshness and Disease conditions?  If you imagine the black spots as Voids (a third type of competing agent), what is the fitness relationship between Altruists and Voids?  Selfish agents and Voids?

5.  Can you find slider values that maximize the advantage of the altruistic agents?

6.  Try running BehaviorSpace on this model to explore the model's behavior under a range of initial conditions.


EXTENDING THE MODEL
-------------------
The model can be extended in a number of interesting directions, including adding new environmental variables, adding different types of agents, and changing the altruistic and selfish weighting under different environmental conditions.

This model does not address the behaviors of individuals, only the relative weights of genetic traits.  A next step in considering the evolution of altruism is to model altruistic behaviors.  (See the related model: Cooperation.)


NETLOGO FEATURES
----------------
This model uses patches as its basic agents. Can you design an ""equivalent"" model using turtles?  How would the model dynamics be affected?


RELATED MODELS
--------------
Cooperation


CREDITS AND REFERENCES
----------------------
This model and the Cooperation model are part of the curriculum ""Evolution of Altruistic and Cooperative Habits: Learning About Complexity in Evolution"".  See http://ccl.northwestern.edu/cm/EACH/ for more information.

This model is based on a paper by Mitteldorf and Wilson, in press, ""Population Viscosity and the Evolution of Altruism"", Journal of Theoretical Biology (2000), v.204, pp.481-496.

Thanks also to Damon Centola and Scott Styles.

To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Altruism model.  http://ccl.northwestern.edu/netlogo/models/Altruism.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Altruism for terms of use.
"
Wealth Distribution,/models/Sample Models/Social Science,"globals
[
  max-grain    ; maximum amount any patch can hold
]

patches-own
[
  grain-here      ; the current amount of grain on this patch
  max-grain-here  ; the maximum amount of grain this patch can hold
]

turtles-own
[
  age              ; how old a turtle is
  wealth           ; the amount of grain a turtle has
  life-expectancy  ; maximum age that a turtle can reach
  metabolism       ; how much grain a turtle eats each time
  vision           ; how many patches ahead a turtle can see
]

;;;
;;; SETUP AND HELPERS
;;;

to setup
  ca
  ;; set global variables to appropriate values
  set max-grain 50
  ;; call other procedures to set up various parts of the world
  setup-patches
  setup-turtles
  setup-plots
  ;; plot the initial state of the world
  update-plots
end

;; set up the initial amounts of grain each patch has
to setup-patches
  ;; give some patches the highest amount of grain possible --
  ;; these patches are the ""best land""
  ask patches
    [ set max-grain-here 0
      if (random-float 100.0) <= percent-best-land
        [ set max-grain-here max-grain
          set grain-here max-grain-here ] ]
  ;; spread that grain around the window a little and put a little back
  ;; into the patches that are the ""best land"" found above
  repeat 5
    [ ask patches with [max-grain-here != 0]
        [ set grain-here max-grain-here ]
      diffuse grain-here 0.25 ]
  repeat 10
    [ diffuse grain-here 0.25 ]          ;; spread the grain around some more
  ask patches
    [ set grain-here floor grain-here    ;; round grain levels to whole numbers
      set max-grain-here grain-here      ;; initial grain level is also maximum
      recolor-patch ]
end

to recolor-patch  ;; patch procedure -- use color to indicate grain level
  set pcolor scale-color yellow grain-here 0 max-grain
end

;; set up the initial values for the turtle variables
to setup-turtles
  set-default-shape turtles ""person""
  crt num-people
    [ move-to one-of patches  ;; put turtles on patch centers
      set size 1.5  ;; easier to see
      set-initial-turtle-vars
      set age random life-expectancy ]
  recolor-turtles
end

to set-initial-turtle-vars
  set age 0
  face one-of neighbors4
  set life-expectancy life-expectancy-min +
                        random (life-expectancy-max - life-expectancy-min + 1)
  set metabolism 1 + random metabolism-max
  set wealth metabolism + random 50
  set vision 1 + random max-vision
end

;; Set the class of the turtles -- if a turtle has less than a third
;; the wealth of the richest turtle, color it red.  If between one
;; and two thirds, color it green.  If over two thirds, color it blue.
to recolor-turtles
  let max-wealth max [wealth] of turtles
  ask turtles
    [ ifelse (wealth <= max-wealth / 3)
        [ set color red ]
        [ ifelse (wealth <= (max-wealth * 2 / 3))
            [ set color green ]
            [ set color blue ] ] ]
end

;;;
;;; GO AND HELPERS
;;;

to go
  ask turtles
    [ turn-towards-grain ]  ;; choose direction holding most grain within the turtle's vision
  harvest
  ask turtles
    [ move-eat-age-die ]
  recolor-turtles

  ;; grow grain every grain-growth-interval clock ticks
  if ticks mod grain-growth-interval = 0
    [ ask patches [ grow-grain ] ]

  tick
  update-plots
end

;; determine the direction which is most profitable for each turtle in
;; the surrounding patches within the turtles' vision
to turn-towards-grain  ;; turtle procedure
  set heading 0
  let best-direction 0
  let best-amount grain-ahead
  set heading 90
  if (grain-ahead > best-amount)
    [ set best-direction 90
      set best-amount grain-ahead ]
  set heading 180
  if (grain-ahead > best-amount)
    [ set best-direction 180
      set best-amount grain-ahead ]
  set heading 270
  if (grain-ahead > best-amount)
    [ set best-direction 270
      set best-amount grain-ahead ]
  set heading best-direction
end

to-report grain-ahead  ;; turtle procedure
  let total 0
  let how-far 1
  repeat vision
    [ set total total + [grain-here] of patch-ahead how-far
      set how-far how-far + 1 ]
  report total
end

to grow-grain  ;; patch procedure
  ;; if a patch does not have it's maximum amount of grain, add
  ;; num-grain-grown to its grain amount
  if (grain-here < max-grain-here)
    [ set grain-here grain-here + num-grain-grown
      ;; if the new amount of grain on a patch is over its maximum
      ;; capacity, set it to its maximum
      if (grain-here > max-grain-here)
        [ set grain-here max-grain-here ]
      recolor-patch ]
end

;; each turtle harvests the grain on its patch.  if there are multiple
;; turtles on a patch, divide the grain evenly among the turtles
to harvest
  ; have turtles harvest before any turtle sets the patch to 0
  ask turtles
    [ set wealth floor (wealth + (grain-here / (count turtles-here))) ]
  ;; now that the grain has been harvested, have the turtles make the
  ;; patches which they are on have no grain
  ask turtles
    [ set grain-here 0
      recolor-patch ]
end

to move-eat-age-die  ;; turtle procedure
  fd 1
  ;; consume some grain according to metabolism
  set wealth (wealth - metabolism)
  ;; grow older
  set age (age + 1)
  ;; check for death conditions: if you have no grain or
  ;; you're older than the life expectancy or if some random factor
  ;; holds, then you ""die"" and are ""reborn"" (in fact, your variables
  ;; are just reset to new random values)
  if (wealth < 0) or (age >= life-expectancy)
    [ set-initial-turtle-vars ]
end

;;;
;;; PLOTTING
;;;

to setup-plots
  set-current-plot ""Class Plot""
  set-plot-y-range 0 num-people
  set-current-plot ""Class Histogram""
  set-plot-y-range 0 num-people
end

to update-plots
  update-class-plot
  update-class-histogram
  update-lorenz-and-gini-plots
end

;; this does a line plot of the number of people of each class
to update-class-plot
  set-current-plot ""Class Plot""
  set-current-plot-pen ""low""
  plot count turtles with [color = red]
  set-current-plot-pen ""mid""
  plot count turtles with [color = green]
  set-current-plot-pen ""up""
  plot count turtles with [color = blue]
end

;; this does a histogram of the number of people of each class
to update-class-histogram
  set-current-plot ""Class Histogram""
  plot-pen-reset
  set-plot-pen-color red
  plot count turtles with [color = red]
  set-plot-pen-color green
  plot count turtles with [color = green]
  set-plot-pen-color blue
  plot count turtles with [color = blue]
end

to update-lorenz-and-gini-plots
  set-current-plot ""Lorenz Curve""
  clear-plot

  ;; draw a straight line from lower left to upper right
  set-current-plot-pen ""equal""
  plot 0
  plot 100

  set-current-plot-pen ""lorenz""
  set-plot-pen-interval 100 / num-people
  plot 0

  let sorted-wealths sort [wealth] of turtles
  let total-wealth sum sorted-wealths
  let wealth-sum-so-far 0
  let index 0
  let gini-index-reserve 0

  ;; now actually plot the Lorenz curve -- along the way, we also
  ;; calculate the Gini index
  repeat num-people [
    set wealth-sum-so-far (wealth-sum-so-far + item index sorted-wealths)
    plot (wealth-sum-so-far / total-wealth) * 100
    set index (index + 1)
    set gini-index-reserve
      gini-index-reserve +
      (index / num-people) -
      (wealth-sum-so-far / total-wealth)
  ]

  ;; plot Gini Index
  set-current-plot ""Gini-Index v. Time""
  plot (gini-index-reserve / num-people) / area-of-equality-triangle
end

to-report area-of-equality-triangle
  ;; not really necessary to compute this when num-people is large;
  ;; if num-people is large, could just use estimate of 0.5
  report (num-people * (num-people - 1) / 2) / (num-people ^ 2)
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Wealth Distribution model.
; http://ccl.northwestern.edu/netlogo/models/WealthDistribution.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/WealthDistribution
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model simulates the distribution of wealth.  ""The rich get richer and the poor get poorer"" is a familiar saying that expresses inequity in the distribution of wealth.  In this simulation, we see Pareto's law, in which there are a large number of ""poor"" or red people, fewer ""middle class"" or green people, and many fewer ""rich"" or blue people.


HOW IT WORKS
------------
This model is adapted from Epstein & Axtell's ""Sugarscape"" model. It uses grain instead of sugar.  Each patch has an amount of grain and a grain capacity (the amount of grain it can grow).  People collect grain from the patches, and eat the grain to survive.  How much grain each person accumulates is his or her wealth.

The model begins with a roughly equal wealth distribution.  The people then wander around the landscape gathering as much grain as they can.  Each person attempts to move in the direction where the most grain lies.  Each time tick, each person eats a certain amount of grain.  This amount is called their metabolism.  People also have a life expectancy.  When their lifespan runs out, or they run out of grain, they die and produce a single offspring.  The offspring has a random metabolism and a random amount of grain, ranging from the poorest person's amount of grain to the richest person's amount of grain.  (There is no inheritance of wealth.)

To observe the equity (or the inequity) of the distribution of wealth, a graphical tool called the Lorenz curve is utilized.  We rank the population by their wealth and then plot the percentage of the population that owns each percentage of the wealth (e.g. 30% of the wealth is owned by 50% of the population).  Hence the ranges on both axes are from 0% to 100%.

Another way to understand the Lorenz curve is to imagine that there are 100 dollars of wealth available in a society of 100 people.  Each individual is 1% of the population and each dollar is 1% of the wealth.  Rank the individuals in order of their wealth from greatest to least: the poorest individual would have the lowest ranking of 1 and so forth.  Then plot the proportion of the rank of an individual on the y-axis and the portion of wealth owned by this particular individual and all the individuals with lower rankings on the x-axis.  For example, individual Y with a ranking of 20 (20th poorest in society) would have a percentage ranking of 20% in a society of 100 people (or 100 rankings) -- this is the point on the y-axis.  The corresponding plot on the x-axis is the proportion of the wealth that this individual with ranking 20 owns along with the wealth owned by the all the individuals with lower rankings (from rankings 1 to 19).  A straight line with a 45 degree incline at the origin (or slope of 1) is a Lorenz curve that represents perfect equality -- everyone holds an equal part of the available wealth.  On the other hand, should only one family or one individual hold all of the wealth in the population (i.e. perfect inequity), then the Lorenz curve will be a backwards ""L"" where 100% of the wealth is owned by the last percentage proportion of the population.  In practice, the Lorenz curve actually falls somewhere between the straight 45 degree line and the backwards ""L"".

For a numerical measurement of the inequity in the distribution of wealth, the Gini index (or Gini coefficient) is derived from the Lorenz curve.  To calculate the Gini index, find the area between the 45 degree line of perfect equality and the Lorenz curve.  Divide this quantity by the total area under the 45 degree line of perfect equality (this number is always 0.5 -- the area of 45-45-90 triangle with sides of length 1).  If the Lorenz curve is the 45 degree line then the Gini index would be 0; there is no area between the Lorenz curve and the 45 degree line.  If, however, the Lorenz curve is a backwards ""L"", then the Gini-Index would be 1 -- the area between the Lorenz curve and the 45 degree line is 0.5; this quantity divided by 0.5 is 1.  Hence, equality in the distribution of wealth is measured on a scale of 0 to 1 -- more inequity as one travels up the scale.


HOW TO USE IT
-------------
The PERCENT-BEST-LAND slider determines the initial density of patches that are seeded with the maximum amount of grain.  This maximum is adjustable via the MAX-GRAIN variable in the SETUP procedure in the procedures window.  The GRAIN-GROWTH-INTERVAL slider determines how often grain grows.  The NUM-GRAIN-GROWN slider sets how much grain is grown each time GRAIN-GROWTH-INTERVAL allows grain to be grown.

The NUM-PEOPLE slider determines the initial number of people.  LIFE-EXPECTANCY-MIN is the shortest number of ticks that a person can possibly live.  LIFE-EXPECTANCY-MAX is the longest number of ticks that a person can possibly live.  The METABOLISM-MAX slider sets the highest possible amount of grain that a person could eat per clock tick.  The MAX-VISION slider is the furthest possible distance that any person could see.

GO starts the simulation.  The TIME ELAPSED monitor shows the total number of clock ticks since the last setup.  The CLASS PLOT shows a line plot of the number of people in each class over time.  The CLASS HISTOGRAM shows the same information in the form of a histogram.  The LORENZ CURVE plot shows the Lorenz curve of the population at a particular time as well as the 45 degree line of equality.  The GINI-INDEX V. TIME plot shows the Gini index at the time that the Lorenz curve is drawn.  The LORENZ CURVE and the GINI-INDEX V. TIME plots are updated every 5 passes through the GO procedure.


THINGS TO NOTICE
----------------
Notice the distribution of wealth.  Are the classes equal?

This model usually demonstrates Pareto's Law, in which most of the people are poor, fewer are middle class, and very few are rich.  Why does this happen?

Do poor families seem to stay poor?  What about the rich and the middle class people?

Watch the CLASS PLOT to see how long it takes for the classes to reach stable values.

As time passes, does the distribution get more equalized or more skewed?  (Hint: observe the Gini index plot.)

Try to find resources from the U.S. Government Census Bureau for the U.S.' Gini coefficient.  Are the Gini coefficients that you calculate from the model comparable to those of the Census Bureau?  Why or why not?

Is there a trend in the plotting of the Gini index with respect to time?  Does the plot oscillate?  Or does it stabilize to a certain number?


THINGS TO TRY
-------------
Are there any settings that do not result in a demonstration of Pareto's Law?

Play with the NUM-GRAIN-GROWN slider, and see how this affects the distribution of wealth.

How much does the LIFE-EXPECTANCY-MAX matter?

Change the value of the MAX-GRAIN variable (in the SETUP procedure in the procedures tab).  Do outcomes differ?

Experiment with the PERCENT-BEST-LAND and NUM-PEOPLE sliders.  How do these affect the outcome of the distribution of wealth?

Try having all the people start in one location. See what happens.

Try setting everyone's initial wealth as being equal.  Does the initial endowment of an individual still arrive at an unequal distribution in wealth?  Is it less so when setting random initial wealth for each individual?

Try setting all the individual's wealth and vision to being equal.  Do you still arrive at an unequal distribution of wealth?  Is it more equal in the measure of the Gini index than with random endowments of vision?


EXTENDING THE MODEL
-------------------
Have each newborn inherit a percentage of the wealth of its parent.

Add a switch or slider which has the patches grow back all or a percentage of their grain capacity, rather than just one unit of grain.

Allow the grain to give an advantage or disadvantage to its carrier, such as every time some grain is eaten or harvested, pollution is created.

Would this model be the same if the wealth were randomly distributed (as opposed to a gradient)?  Try different landscapes, making SETUP buttons for each new landscape.

Try allowing metabolism or vision or another characteristic to be inherited.  Will we see any sort of evolution?  Will the ""fittest"" survive?

Try adding in seasons into the model.  That is to say have the grain grow better in a section of the landscape during certain times and worse at others.

How could you change the model to achieve wealth equality?

The way the procedures are set up now, one person will sometimes follow another.  You can see this by setting the number of people relatively low, such as 50 or 100, and having a long life expectancy.  Why does this phenomenon happen?  Try adding code to prevent this from occurring.  (HINT: When and how do people check to see which direction they should move in?)


NETLOGO FEATURES
------------------
Examine how the landscape of color is created -- note the use of the ""scale-color"" reporter.  Each patch is given a value, and ""scale-color"" reports a color for each patch that is scaled according to its value.

Note the use of lists in drawing the Lorenz Curve and computing the Gini index.


CREDITS AND REFERENCES
----------------------
For an explanation of Pareto's Law, see http://www.xrefer.com/entry/445978.

This model is based on a model described in Epstein, J. & Axtell R. (1996). Growing Artificial Societies: Social Science from the Bottom Up. Washington, DC: Brookings Institution Press.

To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Wealth Distribution model.  http://ccl.northwestern.edu/netlogo/models/WealthDistribution.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/WealthDistribution for terms of use.
"
Bank Reserves,/models/Sample Models/Social Science/Unverified,"globals [
  bank-loans
  bank-reserves
  bank-deposits
  bank-to-loan
  x-max
  y-max
  rich
  poor
  middle-class
  rich-threshold
]


turtles-own [
  savings
  loans
  wallet
  temp-loan
  wealth
  customer
]


to setup
  clear-all
  initialize-variables
  ask patches [set pcolor black]
  set-default-shape turtles ""person""
  crt people [setup-turtles]
  setup-bank
  setup-plots
end


to setup-turtles  ;; turtle procedure
  set color blue
  setxy random-xcor random-ycor
  set wallet (random rich-threshold) + 1 ;;limit money to threshold
  set savings 0
  set loans 0
  set wealth 0
  set customer -1
end


to setup-bank ;;initialize bank
  set bank-loans 0
  set bank-reserves 0
  set bank-deposits 0
  set bank-to-loan 0
end


to setup-plots ;;initialize plots
  clear-all-plots
  set x-max 300
  set y-max 2 * money-total

  setup-plot1
  setup-plot2
  setup-plot3
  setup-histogram
end


to initialize-variables
  set rich 0
  set middle-class 0
  set poor 0
  set rich-threshold 10
end


to get-shape  ;;turtle procedure
  if (savings > 10)  [set color green]
  if (loans > 10) [set color red]
  set wealth (savings - loans)
end


to go
  ;;tabulates each distinct class population
  set rich (count turtles with [savings > rich-threshold])
  set poor (count turtles with [loans > 10])
  set middle-class (count turtles - (rich + poor))
  do-plots
  ask turtles [
    ifelse ticks mod 3 = 0
      [do-business] ;;first cycle, ""do business""
      [ifelse ticks mod 3 = 1  ;;second cycle, ""balance books"" and ""get shape""
         [balance-books
          get-shape]
         [bank-balance-sheet] ;;third cycle, ""bank balance sheet""
      ]
  ]
end


to do-business  ;;turtle procedure
  rt random-float 360
  fd 1

  if ((savings > 0) or (wallet > 0) or (bank-to-loan > 0))
    [set customer one-of other turtles-here
     if customer != nobody
     [if (random 2) = 0                      ;; 50% chance of trading with customer
           [ifelse (random 2) = 0            ;; 50% chance of trading $5 or $2
              [ask customer [set wallet wallet + 5] ;;give 5 to customer
               set wallet (wallet - 5) ] ;;take 5 from wallet
              [ask customer [set wallet wallet + 2] ;;give 2 to customer
               set wallet (wallet - 2) ] ;;take 2 from wallet
           ]
        ]
     ]
end



;; First checks balance of the turtle's wallet, and then either puts
;; a positive balance in savings, or tries to get a loan to cover
;; a negative balance.  If it cannot get a loan (if bank-to-loan < 0)
;; then it maintains the negative balance until the next round.  It
;; then checks if it has loans and money in savings, and if so, will
;; proceed to pay as much of that loan off as possible from the money
;; in savings.

to balance-books
  ifelse (wallet < 0)
    [ifelse (savings >= (- wallet))
       [withdraw-from-savings (- wallet)]
       [if (savings > 0)
          [withdraw-from-savings savings]

        set temp-loan bank-to-loan           ;;temp-loan = amount available to borrow
        ifelse (temp-loan >= (- wallet))
          [take-out-loan (- wallet)]
          [take-out-loan temp-loan]
       ]
     ]
    [deposit-to-savings wallet]

  if (loans > 0 and savings > 0)            ;; when there is money in savings to payoff loan
    [ifelse (savings >= loans)
       [withdraw-from-savings loans
        repay-a-loan loans]
       [withdraw-from-savings savings
        repay-a-loan wallet]
    ]
end


;; Sets aside required amount from liabilities into
;; reserves, regardless of outstanding loans.  This may
;; result in a negative bank-to-loan amount, which
;; means that the bank will be unable to loan money
;; until it can set enough aside to account for reserves.

to bank-balance-sheet ;;update monitors
  set bank-deposits sum [savings] of turtles
  set bank-loans sum [loans] of turtles
  set bank-reserves (reserves / 100) * bank-deposits
  set bank-to-loan bank-deposits - (bank-reserves + bank-loans)
end


to deposit-to-savings [amount] ;;fundamental procedures
  set wallet wallet - amount
  set savings savings + amount
end


to withdraw-from-savings [amount] ;;fundamental procedures
  set wallet (wallet + amount)
  set savings (savings - amount)
end


to repay-a-loan [amount] ;;fundamental procedures
  set loans (loans - amount)
  set wallet (wallet - amount)
  set bank-to-loan (bank-to-loan + amount)
end


to take-out-loan [amount] ;;fundamental procedures
  set loans (loans + amount)
  set wallet (wallet + amount)
  set bank-to-loan (bank-to-loan - amount)
end


to-report savings-total
  report sum [savings] of turtles
end


to-report loans-total
  report sum [loans] of turtles
end


to-report wallets-total
  report sum [wallet] of turtles
end


to-report money-total
  report sum [wallet + savings] of turtles
end


to setup-plot1
  set-current-plot ""Money & Loans""
  set-plot-x-range 0 x-max
  set-plot-y-range -50 y-max
end


to setup-plot2
  set-current-plot ""Savings & Wallets""
  set-plot-x-range 0 x-max
  set-plot-y-range -50 y-max
end


to setup-plot3
  set-current-plot ""Income Dist""
  set-plot-x-range 0 x-max
  set-plot-y-range 0 (count turtles)
end


to setup-histogram
  set-current-plot ""Wealth Distribution Histogram""
  set-plot-y-range 0 (count turtles)
end


to do-plots
  set-current-plot ""Money & Loans""
  set-current-plot-pen ""money""
  plot money-total
  set-current-plot-pen ""loans""
  plot loans-total

  set-current-plot ""Savings & Wallets""
  set-current-plot-pen ""savings""
  plot savings-total
  set-current-plot-pen ""wallets""
  plot wallets-total

  set-current-plot ""Income Dist""
  set-current-plot-pen ""rich""
  plot rich
  set-current-plot-pen ""middle""
  plot middle-class
  set-current-plot-pen ""poor""
  plot poor

  set-current-plot ""Wealth Distribution Histogram""
  if( ticks mod 10 = 1 ) [
    clear-plot
    let max-wealth max [wealth] of turtles
    let min-wealth min [wealth] of turtles
    let one-fifth-wealth 0.2 * (max-wealth - min-wealth)
    let num-bins 10
    let index 1
    let interval round ((plot-x-max - plot-x-min) / num-bins)
    plot-pen-reset

    repeat num-bins [
      plotxy ((index - 1) * interval + 0.002)
                 (count turtles with [
                      wealth < (min-wealth + index * one-fifth-wealth) and
                      wealth >= (min-wealth + (index - 1) * one-fifth-wealth)
                  ]
                 )

     plotxy  (index * interval)
                 (count turtles with [
                      wealth < (min-wealth + index * one-fifth-wealth) and
                      wealth >= (min-wealth + (index - 1) * one-fifth-wealth)
                  ]
                 )

     plotxy (index * interval + 0.001) 0
     set index index + 1
    ]
  ]
  tick
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Bank Reserves model.
; http://ccl.northwestern.edu/netlogo/models/BankReserves.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/BankReserves
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This program models the creation of money in an economy through a private banking system. As most of the money in the economy is kept in banks but only little of it needs to be used (i.e. in cash form) at any one time, the banks need only keep a small portion of their savings on-hand for those transactions. This portion of the total savings is known as the banks' reserves.

The banks are then able to loan out the rest of their savings. The government (the user in this case) sets a reserve ratio mandating how much of the banks' holdings must be kept in reserve at a given time. One 'super-bank' is used in this model to represent all banks in an economy. As this model demonstrates, the reserve ratio is the key determiner of how much money is created in the system.

In each round, people (represented by turtles) interact with each other to simulate everyday economic activity. Given a randomly selected number, when a person is on the same patch as someone else it will either give the person two or five dollars, or no money at all. After this, people must then sort out the balance of their wallet with the bank. People will put a positive wallet balance in savings, or pay off a negative balance from funds already in savings. If the savings account is empty and the wallet has a negative balance, a person will take out a loan from the bank if funds are available to borrow (if bank-to-loan > 0). Otherwise the person maintains the negative balance until the next round. Lastly, if someone has money in savings and money borrowed from the bank, that person will pay off as much of the loan as possible using the savings.


HOW TO USE IT
-------------
The RESERVES slider sets the banking reserve ratio (the percentage of money that a bank must keep in reserve at a given time). The PEOPLE slider sets the number of people that will be created in the model when the SETUP button is pressed. The SETUP button resets the model: it redistributes the patch colors, creates PEOPLE people and initializes all stored values. The GO button starts and stops the running of the model and the plotter.

There are numerous display windows in the interface to help the user see where money in the economy is concentrated at a given time. SAVINGS-TOTAL indicates the total amount of money currently being kept in savings (and thus, in the banking system). The bank must then allocate this money among three accounts: LOANS-TOTAL is the amount the bank has lent out, BANK-TO-LOAN is the amount that the bank has available for loan, and BANK-RESERVES is the amount the bank has been mandated to keep in reserve. When the bank must recall loans (i.e. after the reserve ratio has been raised) BANK-TO-LOAN will read a negative amount until enough of the lent money has been paid off. WALLETS-TOTAL gives an indication of the total amount of money kept in peoples' wallets. This figure may also be negative at times when the bank has no money to loan (the turtle will maintain at a negative wallet balance until a loan is possible). MONEY-TOTAL indicates the total-amount of money currently in the economy (SAVINGS-TOTAL + WALLETS-TOTAL).  Because WALLETS-TOTAL is generally kept at 0 in this model (we are assuming that everyone deposits all they can in savings), MONEY-TOTAL and SAVINGS TOTAL tend to be the the same.

A person's color tells us whether it has money in savings (green) or is in debt (red).


THINGS TO NOTICE
----------------
Note how much money is in MONEY-TOTAL after pressing SETUP, but before pressing GO. The total amount of money that can be created will be his figure (the initial money in the system) * (1 / RESERVES). If the RESERVES remains constant through the run of the model, notice how the plot levels off at this value. Why is this equation descriptive of the system?

Once the amount of money in the system has hit the maximum (as calculated be the above equation), watch what happens when the RESERVES slider is set to 100. Now try setting the RESERVES slider back. Why does this happen?

The three monitors on the left of the interface (LOANS-TOTAL, BANK-TO-LOAN and RESERVES) represent the distribution of the bank's money at a given time. Try and track this distribution against SAVINGS-TOTAL, WALLETS-TOTAL and MONEY-TOTAL to understand fluctuations of money in the  system as they happen.

What effect does an increase in RESERVES generally have on TOTAL-MONEY?

Why do SAVINGS-TOTAL (yellow), LOANS-TOTAL (red) and MONEY-TOTAL (green) tend to rise and fall proportionately on the plot?

What happens to TOTAL-MONEY when the reserve ratio is initially set to 100 percent? Why?


THINGS TO TRY
-------------
Vary the RESERVES rate as the model runs, and watch the effect this has on MONEY-TOTAL.

Set RESERVES initially to 100, and watch the effect on TOTAL-MONEY. Now try lowering RESERVES.

Try setting the reserve rate to 0. What would happen if this were done in a real economy?


EXTENDING THE MODEL
-------------------
Try extending the model to include payments of interest in the banking system. People with money deposited in savings should be credited with interest on their account (at a certain rate) from the bank from time to time. People with money on loan should make interest payments on their account to the bank from time to time.

This model has turtles interact in a very simple way to have money change hands (and create a need for loans). Try changing the model so that money moves around the system in a different way.


RELATED MODELS
---------------
Wealth Distribution looks at how the reserve ratio affects the distribution of wealth.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Bank Reserves model.  http://ccl.northwestern.edu/netlogo/models/BankReserves.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/BankReserves for terms of use.
"
PD Basic Evolutionary,/models/Sample Models/Social Science/Unverified/Prisoner's Dilemma,"patches-own [
  cooperate?       ;; patch will cooperate
  old-cooperate?   ;; patch has cooperated before
  score            ;; score resulting from interaction of neighboring patches
  color-class      ;; numeric value from 1= blue, 2= red, 3= green, 4= yellow.
]

to setup
  ca
  ask patches [
    ifelse random-float 1.0 < (initial-cooperation / 100)
      [setup-cooperation true]
      [setup-cooperation false]
    establish-color
  ]
  update-plot
end

to setup-cooperation [value]
  set cooperate? value
  set old-cooperate? value
end

to go
  ask patches [interact]          ;; to play with a neighboring patch
  ask patches [select-strategy]   ;; adopt the strategy of the neighbor (who had the highest score)
  tick
  update-plot
end

to update-plot
  set-current-plot ""Cooperation/Defection Frequency""
  plot-histogram-helper ""cc"" blue
  plot-histogram-helper ""dd"" red
  plot-histogram-helper ""cd"" green
  plot-histogram-helper ""dc"" yellow
end

to plot-histogram-helper [pen-name color-name]
  set-current-plot-pen pen-name
  histogram [color-class] of patches with [pcolor = color-name]
end

to interact  ;; patch procedure
  let total-cooperaters count neighbors with [cooperate?]  ;; total number neighbors who cooperated
  ifelse cooperate?
    [set score total-cooperaters]                   ;; cooperator gets score of # of neighbors who cooperated
    [set score Defection-Award * total-cooperaters] ;; non-cooperator get score of a multiple of the
                                                    ;; neighbors who cooperated
end

to select-strategy  ;; patch procedure
  set old-cooperate? cooperate?
  set cooperate? [cooperate?] of max-one-of neighbors [score] ;;choose strategy (cooperate, not cooperate)
                                                            ;; of neighbor who performed the best
  establish-color
end

to establish-color  ;; patch procedure
  ifelse old-cooperate?
    [ifelse cooperate?
      [set pcolor blue
       set color-class 1]
      [set pcolor green
       set color-class 3]
    ]
    [ifelse cooperate?
      [set pcolor yellow
       set color-class 4]
      [set pcolor red
       set color-class 2]
    ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2002 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2002).  NetLogo PD Basic Evolutionary model.
; http://ccl.northwestern.edu/netlogo/models/PDBasicEvolutionary.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2002 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/PDBasicEvolutionary
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
One of the most prominently studied phenomena in Game Theory is the ""Prisoner's Dilemma.""  The Prisoner's Dilemma, which was formulated by Melvin Drescher and Merrill Flood and named by Albert W. Tucker, is an example of a class of games called non-zero-sum games.

In zero-sum games, total benefit to all players add up to zero, or in other words, each player can only benefit at the expense of other players (e.g. chess, football, poker -- one person can only win when the opponent loses).  On the other hand, in non-zero-games, each person's benefit does not necessarily come at the expense of someone else.  In many non-zero-sum situations, a person can benefit only when others benefit as well.  Non-zero-sum situations exist where the supply of a resource is not fixed or limited in any way (e.g. knowledge, artwork, and trade).  Prisoner's Dilemma, as a non-zero-sum game, demonstrates a conflict between rational individual behavior and the benefits of cooperation in certain situations.  The classical prisoner's dilemma is as follows:

Two suspects are apprehended by the police.  The police do have enough evidence to convict these two suspects.  As a result, they separate the two, visit each of them, and offer both the same deal:  ""If you confess, and your accomplice remains silent, he goes to jail for 10 years and you can go free.  If you both remain silent, only minor charges can be brought upon both of you and you guys get 6 months each.  If you both confess, then each of you two gets 5 years.""

Each suspect may reason as follows-- ""Either my partner confesses or not.  If he does confess and I remain silent, I get 10 years while if I confess, I get 5 years.  So, if my partner confesses, it is best that I confess and get only 5 years than 10 years in prison.  If he didn't, then by confessing, I go free, whereby remaining silent, I get 6 months.  Thus, if he didn't confess, it is best to confess, so that I can go free.   Whether or not my partner confesses or not, it is best that I confess.""

In a non-iterated prisoner's dilemma, the two partners will never have to work together again.  Both partners are thinking in the above manner and decide to confess.  Consequently, they both receive 5 years in prison.  If neither would have confessed, they would have only gotten 6 months each.  The rational behavior paradoxically leads to a socially unbeneficial outcome.


|                             Payoff Matrix
|                             -------------
|                              YOUR PARTNER
|                     Cooperate            Defect
|                    -----------------------------
|       Cooperate |   (0.5, 0.5)           (0, 10)
|  YOU            |
|       Defect    |(10, 0)              (5, 5)
|
|        (x, y) = x: your score, y: your partner's score
|        Note: lower the score (number of years in prison), the better.


In an Iterated Prisoner's Dilemma where you have more than two players and multiple rounds, such as this one, the scoring is different.  In this model, it is assumed that an increase in the number of people who cooperate will increase proportionately the benefit for each cooperating player (which would be a fine assumption, for example, in the sharing of knowledge).  For those who do not cooperate, assume that their benefit is some factor (alpha) multiplied by the number of people who cooperate (that is, to continue the previous example, the non-cooperating players take knowledge from others but do not share any knowledge themselves).  How much cooperation is incited is dependent on the factor multiple for not cooperating.  Consequently, in an iterated prisoner's dilemma with multiple players, the dynamics of the evolution in cooperation may be observed.

|                             Payoff Matrix
|                             -------------
|                                OPPONENT
|                     Cooperate            Defect
|                    -----------------------------
|       Cooperate |(1, 1)            (0, alpha)
|  YOU            |
|       Defect    |(alpha, 0)        (0, 0)
|
|        (x, y) = x: your score, y: your partner's score
|        Note: higher the score (amount of the benefit), the better.


HOW TO USE IT
--------------
Decide what percentage of patches should cooperate at the initial stage of the simulation and change the INITIAL-COOPERATION slider to match what you would like.  Next, determine the DEFECTION-AWARD multiple (mentioned as alpha in the payoff matrix above) for defecting or not cooperating.  The Defection-Award multiple varies from range of 0 to 3.  Press SETUP and note that red patches (that will defect) and blue patches (cooperate) are scattered across the  .  Press GO to make the patches interact with their eight neighboring patches.  First, they count the number of neighboring patches that are cooperating.  If a patch is cooperating, then its score is number of neighboring patches that also cooperated.   If a patch is defecting, then its score is the product of the number of neighboring patches who are cooperating and the Defection-Award multiple.



HOW IT WORKS
------------
Each patch will either cooperate (blue) or defect (red) in the initial start of the model.  At each cycle, each patch will interact with all of its 8 neighbors to determine the score for the interaction.  Should a patch have cooperated, its score will be the number of neighbors that also cooperated.  Should a patch defect, then the score for this patch will be the product of the Defection-Award multiple and the number of neighbors that cooperated (i.e. the patch has taken advantage of the patches that cooperated).

In the subsequent round, the patch will set its old-cooperate? to be the strategy it used in the previous round.  For the upcoming round, the patch will adopt the strategy of one of its neighbors that scored the highest in the previous round.

If a patch is blue, then the patch cooperated in the previous and current round.
If a patch is red, then the patch defected in the previous iteration as well as the current round.
If a patch is green, then the patch cooperated in the previous round but defected in the current round.
If a patch is yellow, then the patch defected in the previous round but cooperated in the current round.



THINGS TO NOTICE
----------------
Notice the effect the Defection-Award multiple plays in determining the number of patches that will completely cooperate (red) or completely defect (blue). At what Defection-Award multiple value will a patch be indifferent to defecting or cooperating?  At what Defection-Award multiple value will there be a dynamic change between red, blue, green, and yellow - where in the end of the model no particular color dominates all of the patches (i.e. view is not all red or all blue)?

Note the Initial-Cooperation percentage.  Given that Defection-Award multiple is low (below 1), if the initial percentage of cooperating patches is high, will there be more defecting or cooperating patches eventually?  How about when the Defection-Award multiple is high?  Does the initial percentage of cooperation effect the outcome of the model, and, if so, how?



THINGS TO TRY
-------------
Increase the Defection-Award multiple by moving the ""Defection-Award"" slider (just increase the ""Defection-Award"" slider while model is running), and observe how the histogram for each color of patch changes. In particular, pay attention to the red and blue bars.  Does the number of pure cooperation or defection decrease or increase with the increase of the Defection-Award multiple?  How about with a decrease of the Defection-Award multiple? (Just increase the ""Defection-Award"" slider while model is running.)

At each start of the model, either set the initial-cooperation percentage to be very high or very low (move the slider for ""initial-cooperation""), and proportionally value the Defection-Award multiple (move the slider for ""Defection-Award"" in the same direction) with regards to the initial-cooperation percentage.  Which color dominates the world, when the initial-cooperation is high and the Defection-Award is high?  Which color dominates the world when initial-cooperation is low and the Defection-Award multiple is also low?



EXTENDING THE MODEL
-------------------
Alter the code so that the patches have a strategy to implement.  For example, instead of adopting to cooperated or defect based on the neighboring patch with the maximum score.  Instead, let each patch consider the history of cooperation or defection of it neighboring patches, and allow it to decide whether to cooperate or defect as a result.

Implement these four strategies:
1.  Cooperate-all-the-time: regardless of neighboring patches' history, cooperate.
2.  Tit-for-Tat:  only cooperate with neighboring patches, if they have never defected.  Otherwise, defect.
3.  Tit-for-Tat-with-forgiveness: cooperate if on the previous round, the patch cooperated.  Otherwise, defect.
4.  Defect-all-the-time: regardless of neighboring patches' history, defect.

How are the cooperating and defecting patches distributed?  Which strategy results with the highest score on average?  On what conditions will this strategy be a poor strategy to use?


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (2002).  NetLogo PD Basic Evolutionary model.  http://ccl.northwestern.edu/netlogo/models/PDBasicEvolutionary.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2002 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/PDBasicEvolutionary for terms of use.
"
PD Two Person Iterated,/models/Sample Models/Social Science/Unverified/Prisoner's Dilemma,"breed [ users user ]
breed [ computers computer ]

globals [
  human-score
  computer-score
  hidden-strategy
]

turtles-own [
  score                  ;;my current score
  defect-now?            ;;what will I do this round?
  partner                ;;the who of my partner
  partner-defected?      ;;did my partner defect last round?
  partner-defected-past? ;;did my partner defect two rounds ago?
]

to setup
  ca
  ;;place the computer
  create-computers 1 [
    set partner 1
    set shape ""computer""
    set heading 90
    fd max-pxcor / 2
  ]
  ;;place the human
  create-users 1 [
    set partner 0
    set shape ""person""
    set heading 270
    fd abs min-pxcor / 2
  ]
  ;;initially assume you and your partner have always cooperated
  ask turtles [
    set defect-now? false
    set partner-defected? false
    set partner-defected-past? false
    set size 10
    set label 3.0
  ]
  prepare-next-round
  ;;choose the secret strategy the computer will play if select-computer-strategy? is off
  set hidden-strategy random 6
  do-plotting
end


;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Runtime Procedures;;;
;;;;;;;;;;;;;;;;;;;;;;;;;

to play
  ;;choose strategy
  ask users [ set-action human-strategy ]
  play-a-round
  tick
  ;;update the displayed score in the view
  ask turtles [ set label precision (score / ticks) 3]
  do-plotting
  prepare-next-round
end

to play-a-round
  ;ask each turtle to select its strategy
  ifelse select-computer-strategy?
    [ask computers [ set-action computer-strategy ]]
    [ask computers [ set-action hidden-strategy ]]
  ;based upon the strategy each agent has chosen, determine this round's payoffs
  ask turtles [ get-payoff ]
end

to prepare-next-round
  set computer-score [score] of turtle 0
  set human-score [score] of turtle 1
  ;;display the computer's action in the last round
  if display-history? [
    ask users [
      ifelse partner-defected?
        [output-print ""Last turn your partner defected""]
        [output-print ""Last turn your partner cooperated""]
    ]
    output-print ""Choose your action""
  ]
end

to set-action [strategy ] ;;Turtle Procedure
  ;;call the strategy based on the number passed through
  if (strategy = ""random"") [ act-randomly ]
  if (strategy = ""cooperate"") [ cooperate ]
  if (strategy = ""defect"") [ defect ]
  if (strategy = ""tit-for-tat"") [ tit-for-tat ]
  if (strategy = ""tit-for-two-tats"") [ tit-for-two-tats ]
  if (strategy = ""unforgiving"") [ unforgiving ]
  if (strategy = ""custom-strategy"") [ custom-strategy ]
end


;;;;;;;;;;;;;;;;;;
;;; Strategies ;;;
;;;;;;;;;;;;;;;;;;

to act-randomly ;;Turtle Procedure
  ifelse (random 2 = 0)
    [set defect-now? false]
    [set defect-now? true]
end

to cooperate  ;;Turtle Procedure
  set defect-now? false
end

to defect ;;Turtle Procedure
  set defect-now? true
end

to tit-for-tat ;;Turtle Procedure
  ifelse partner-defected?
    [ set defect-now? true ]
    [ set defect-now? false ]
end

to tit-for-two-tats ;;Turtle Procedure
  ifelse (partner-defected? and partner-defected-past?)
    [set defect-now? true]
    [set defect-now? false]
end

to unforgiving ;;Turtle Procedure
  ifelse (partner-defected? or defect-now?)
    [set defect-now? true]
    [set defect-now? false]
end

to custom-strategy ;;Turtle Procedure
  ;;Currently defaults to tit-for-tat.  Can you do better?
  ifelse partner-defected? ;;partner defected stores your partner's action last round
    [set defect-now? true]
    [set defect-now? false]
end

;;;;;;;;;;;;;;;;;;;;;;
;;; End Strategies ;;;
;;;;;;;;;;;;;;;;;;;;;;

to get-payoff ;;Turtle Procedure
  set partner-defected-past? partner-defected?
  set partner-defected? [defect-now?] of turtle partner
  ifelse partner-defected?
    [ifelse defect-now?
      [set score score + 1]
      [set score score + 0]
    ]
    [ifelse defect-now?
      [set score score + 5]
      [set score score + 3]
    ]
end

to do-plotting
  set-current-plot-pen ""human""
  plot [label] of turtle 1
  set-current-plot-pen ""computer""
  plot [label] of turtle 0
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2002 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2002).  NetLogo PD Two Person Iterated model.
; http://ccl.northwestern.edu/netlogo/models/PDTwoPersonIterated.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2002 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/PDTwoPersonIterated
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model is an iterated version of the prisoner's dilemma.  If you are unfamiliar with the basic concepts of the prisoner's dilemma, please refer to the PD BASIC model found in the PRISONER'S DILEMMA suite.



HOW IT WORKS
------------
The PD BASIC model presents an interesting problem: In order to minimize the overall jail time you would cooperate with your partner and remain silent and not confess.  However, the rational choice is to defect against your partner by confessing.  If your partner does not confess you will go free.  If your partner confesses, you will go to jail for three years, much better than the five you would have earned had you refused to confess.  Unfortunately, your partner is in the same position.  Acting rationally, you will both be worse off.

The dilemma is made more interesting when you know you will interact with the person again.  Let us consider the case where you and a friend are chosen for a research study to play the prisoner's dilemma game; only instead of the payoffs being years of jail time, they are money.

The researchers separate you and your friend into separate rooms allowing communication to occur only through a computer.  They give you a sheet with the rules for the iterated prisoner's dilemma that reads as follows:

1.  This game will consist of an unspecified number of rounds.  At the end of the game, you will receive $1 for each point you have earned.

2.  Each round you and your partner will have the opportunity to earn points by choosing to either cooperate (C) or defect (D).  Communication will be done only through the computer.  The only message you will be able to pass is cooperate or defect.  Neither person will see the other's message until both have chosen their action.

3.  Your payoff for each round will determined by the actions as follows:

|          | Partner's Action
|   Your   |
|   Action |   C       D
|   -------|-----------------
|       C  |   3       0
|   -------|-----------------
|       D  |   5       1
|   -------|-----------------

(Note: This way of determining your payoff is the opposite of the PD BASIC model. In PD BASIC, you were awarded something bad- jail time. In this model, you are awarded something good- money.)

Your partner has an identical payoff matrix.


HOW TO USE IT
-------------

Buttons:

SETUP: Begin playing the iterated prisoner's dilemma.  If you choose to turn the SELECT-COMPUTER-STRATEGY? switch off before pressing this button, the computer's strategy will be randomly chosen at this time.

PLAY ONCE: Play a single round of the prisoner's dilemma with the strategy you have selected.

PLAY REPEATEDLY: Repeatedly play rounds of the prisoner's dilemma between you and the computer.  You can change your strategy at any time.  If the SELECT-COMPUTER-STRATEGY? switch is on you can also change the computer's strategy at any time.

With both PLAY buttons, the computer's action each round will be displayed in the command center.

Switches:

SELECT-COMPUTER-STRATEGY?: If on, you may select the computer's strategy using the computer strategy slider.  If off, the computer's strategy will be randomly chosen from the strategy list found below, excluding the Custom Strategy.

DISPLAY-HISTORY?: Turn on or off messaging in the command center.

Sliders:

HUMAN-STRATEGY - Select your strategy from the list below.

COMPUTER STRATEGY - Select the computer's strategy from the list below.

Strategies:

Random - randomly cooperate or defect
Cooperate - cooperate always
Defect - defect always
Tit-for-Tat - If the opponent cooperates this round cooperate next round.  If the opponent defects this round, defect next round.  Initially cooperate.
Tit-for-Two-Tats - If the opponent cooperates this round cooperate next round.  If the opponent defects two rounds in a row, defect the next round.  Initially cooperate.
Unforgiving - Cooperate always unless the opponent defects once.  Upon opponent defection retaliate by defecting always.
Custom-Strategy - This strategy is intended to be written by you.  It currently defaults to Tit-for-Tat.

Monitors:

HUMAN-SCORE - The total points you have earned

COMPUTER-SCORE - The total points the computer has earned

ITERATION - The number of rounds that have been played

Plots:

AVERAGE SCORE: The average scores of you and the computer each round vs. the number of iterations.  This is a good indicator of how well you are doing relative to the maximum possible average of $5 per round.


THINGS TO NOTICE
----------------
Should the computer always plays strategy #1 (cooperate), then which strategy for the user results in the highest score?

If the computer always plays strategy #2 (defect), then what is the nature of the average score plot when the user plays strategy #3 - #6 (Tit-for-Tat, Tit-for-Two-Tat, Unforgiving, and Custom Strategy, respectively)?  Why does such a nature arise for these combination of strategies?

What is the nature of the plot for average score when the computer always plays strategy #3 and the user plays every startegy except strategy #2 (defect) and strategy #0 (random)?  Why does such a curve arise?


THINGS TO TRY
-------------
1.  Turn the SELECT-COMPUTER-STRATEGY? switch off.  Setup the model and play the iterated prisoner's dilemma against the computer.  You may choose between selecting your strategy each round using the PLAY ONCE button, or automating your choices each round using the PLAY REPEATEDLY button.  What approach wins you the most money?

2.  Turn the SELECT-COMPUTER-STRATEGY? switch on.  Experiment with playing different strategies against one another.  Which strategies do the best?  Which do the worst?  Why?

3.  Repeat task 1 several times.  How does the best strategy vary?  Based on you experience in task 2, why might this be so?

4.  The researchers now tell you that they will double the amount of money the person with the most points gets at the end, but the other person will get nothing.  In the event of a tie, each person still receives $1 per point.  How does this change your strategy?  Why?

5.  Describe a real life scenario that is similar to the iterated prisoner's dilemma, preferably one you have experienced.  How might the strategies examined here relate to actions taken in that scenario?


EXTENDING THE MODEL
-------------------
Even the most complex strategies in this model are relatively simple.  Surely you can do better.  Redefine the CUSTOM-STRATEGY procedure attempting to develop a strategy that can earn a higher score than those presented in the model or a human player.  Test it against the other strategies and yourself.  What are its strengths?  What are its weaknesses?  Try to keep improving it.

Examine the PD N-PERSON ITERATED model


NETLOGO FEATURES
----------------
Note the use of the turtle variable LABEL to display each turtle's average score in the View.

Note that the SET-ACTION [STRATEGY] procedure uses ""[]"" to define a parameter that must be passed through when it is called.


RELATED MODELS
--------------
PD Basic
PD N-Person Iterated
PD Basic Evolutionary


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (2002).  NetLogo PD Two Person Iterated model.  http://ccl.northwestern.edu/netlogo/models/PDTwoPersonIterated.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2002 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/PDTwoPersonIterated for terms of use.
"
PD N-Person Iterated,/models/Sample Models/Social Science/Unverified/Prisoner's Dilemma,"globals [
  ;;number of turtles with each strategy
  num-random
  num-cooperate
  num-defect
  num-tit-for-tat
  num-unforgiving
  num-unknown

  ;;number of interactions by each strategy
  num-random-games
  num-cooperate-games
  num-defect-games
  num-tit-for-tat-games
  num-unforgiving-games
  num-unknown-games

  ;;total score of all turtles playing each strategy
  random-score
  cooperate-score
  defect-score
  tit-for-tat-score
  unforgiving-score
  unknown-score
]

turtles-own [
  score
  strategy
  defect-now?
  partner-defected? ;;action of the partner
  partnered?        ;;am I partnered?
  partner           ;;WHO of my partner (nobody if not partnered)
  partner-history   ;;a list containing information about past interactions
                    ;;with other turtles (indexed by WHO values)
]


;;;;;;;;;;;;;;;;;;;;;;
;;;Setup Procedures;;;
;;;;;;;;;;;;;;;;;;;;;;

to setup
  ca
  store-initial-turtle-counts ;;record the number of turtles created for each strategy
  setup-turtles ;;setup the turtles and distribute them randomly
end

;;record the number of turtles created for each strategy
;;The number of turtles of each strategy is used when calculating average payoffs.
;;Slider values might change over time, so we need to record their settings.
;;Counting the turtles would also work, but slows the model.
to store-initial-turtle-counts
  set num-random n-random
  set num-cooperate n-cooperate
  set num-defect n-defect
  set num-tit-for-tat n-tit-for-tat
  set num-unforgiving n-unforgiving
  set num-unknown n-unknown
end

;;setup the turtles and distribute them randomly
to setup-turtles
  make-turtles ;;create the appropriate number of turtles playing each strategy
  setup-common-variables ;;sets the variables that all turtles share
end

;;create the appropriate number of turtles playing each strategy
to make-turtles
  crt num-random [ set strategy ""random"" set color gray - 1 ]
  crt num-cooperate [ set strategy ""cooperate"" set color red ]
  crt num-defect [ set strategy ""defect"" set color blue ]
  crt num-tit-for-tat [ set strategy ""tit-for-tat"" set color lime ]
  crt num-unforgiving [ set strategy ""unforgiving"" set color turquoise - 1 ]
  crt num-unknown [set strategy ""unknown"" set color magenta ]
end

;;set the variables that all turtles share
to setup-common-variables
  ask turtles [
    set score 0
    set partnered? false
    set partner nobody
    setxy random-xcor random-ycor
  ]
  setup-history-lists ;;initialize PARTNER-HISTORY list in all turtles
end

;;initialize PARTNER-HISTORY list in all turtles
to setup-history-lists
  let num-turtles count turtles

  let default-history [] ;;initialize the DEFAULT-HISTORY variable to be a list

  ;;create a list with NUM-TURTLE elements for storing partner histories
  repeat num-turtles [ set default-history (fput false default-history) ]

  ;;give each turtle a copy of this list for tracking partner histories
  ask turtles [ set partner-history default-history ]
end


;;;;;;;;;;;;;;;;;;;;;;;;
;;;Runtime Procedures;;;
;;;;;;;;;;;;;;;;;;;;;;;;

to go
  clear-last-round
  ask turtles [ partner-up ]                        ;;have turtles try to find a partner
  let partnered-turtles turtles with [ partnered? ]
  ask partnered-turtles [ select-action ]           ;;all partnered turtles select action
  ask partnered-turtles [ play-a-round ]
  do-bookkeeping
  tick
end

to clear-last-round
  let partnered-turtles turtles with [ partnered? ]
  ask partnered-turtles [ release-partners ]
end

;;release partner and turn around to leave
to release-partners
  set partnered? false
  set partner nobody
  rt 180
  set label """"
end

;;have turtles try to find a partner
;;Since other turtles that have already executed partner-up may have
;;caused the turtle executing partner-up to be partnered,
;;a check is needed to make sure the calling turtle isn't partnered.

to partner-up ;;turtle procedure
  if (not partnered?) [              ;;make sure still not partnered
    rt (random-float 90 - random-float 90) fd 1     ;;move around randomly
    set partner one-of (turtles-at -1 0) with [ not partnered? ]
    if partner != nobody [              ;;if successful grabbing a partner, partner up
      set partnered? true
      set heading 270                   ;;face partner
      ask partner [
        set partnered? true
        set partner myself
        set heading 90
      ]
    ]
  ]
end

;;choose an action based upon the strategy being played
to select-action ;;turtle procedure
  if strategy = ""random"" [ act-randomly ]
  if strategy = ""cooperate"" [ cooperate ]
  if strategy = ""defect"" [ defect ]
  if strategy = ""tit-for-tat"" [ tit-for-tat ]
  if strategy = ""unforgiving"" [ unforgiving ]
  if strategy = ""unknown"" [ unknown ]
end

to play-a-round ;;turtle procedure
  get-payoff     ;;calculate the payoff for this round
  update-history ;;store the results for next time
end

;;calculate the payoff for this round and
;;display a label with that payoff.
to get-payoff
  set partner-defected? [defect-now?] of partner
  ifelse partner-defected? [
    ifelse defect-now? [
      set score (score + 1) set label 1
    ] [
      set score (score + 0) set label 0
    ]
  ] [
    ifelse defect-now? [
      set score (score + 5) set label 5
    ] [
      set score (score + 3) set label 3
    ]
  ]
end

;;update PARTNER-HISTORY based upon the strategy being played
to update-history
  if strategy = ""random"" [ act-randomly-history-update ]
  if strategy = ""cooperate"" [ cooperate-history-update ]
  if strategy = ""defect"" [ defect-history-update ]
  if strategy = ""tit-for-tat"" [ tit-for-tat-history-update ]
  if strategy = ""unforgiving"" [ unforgiving-history-update ]
  if strategy = ""unknown"" [ unknown-history-update ]
end


;;;;;;;;;;;;;;;;
;;;Strategies;;;
;;;;;;;;;;;;;;;;

;;All the strategies are described in the Information Tab.

to act-randomly
  set num-random-games num-random-games + 1
  ifelse (random-float 1.0 < 0.5) [
    set defect-now? false
  ] [
    set defect-now? true
  ]
end

to act-randomly-history-update
;;uses no history- this is just for similarity with the other strategies
end

to cooperate
  set num-cooperate-games num-cooperate-games + 1
  set defect-now? false
end

to cooperate-history-update
;;uses no history- this is just for similarity with the other strategies
end

to defect
  set num-defect-games num-defect-games + 1
  set defect-now? true
end

to defect-history-update
;;uses no history- this is just for similarity with the other strategies
end

to tit-for-tat
  set num-tit-for-tat-games num-tit-for-tat-games + 1
  set partner-defected? item ([who] of partner) partner-history
  ifelse (partner-defected?) [
    set defect-now? true
  ] [
    set defect-now? false
  ]
end

to tit-for-tat-history-update
  set partner-history
    (replace-item ([who] of partner) partner-history partner-defected?)
end

to unforgiving
  set num-unforgiving-games num-unforgiving-games + 1
  set partner-defected? item ([who] of partner) partner-history
  ifelse (partner-defected?)
    [set defect-now? true]
    [set defect-now? false]
end

to unforgiving-history-update
  if partner-defected? [
    set partner-history
      (replace-item ([who] of partner) partner-history partner-defected?)
  ]
end

;;defaults to tit-for-tat
;;can you do better?
to unknown
  set num-unknown-games num-unknown-games + 1
  set partner-defected? item ([who] of partner) partner-history
  ifelse (partner-defected?) [
    set defect-now? true
  ] [
    set defect-now? false
  ]
end

;;defaults to tit-for-tat-history-update
;;can you do better?
to unknown-history-update
  set partner-history
    (replace-item ([who] of partner) partner-history partner-defected?)
end


;;;;;;;;;;;;;;;;;;;;;;;;;
;;;Plotting Procedures;;;
;;;;;;;;;;;;;;;;;;;;;;;;;

;;procedure called by go that calculates scores and plots
to do-bookkeeping
  do-scoring
  do-plotting
end

;;calculate the total scores of each strategy
to do-scoring
  set random-score  (calc-score ""random"" num-random)
  set cooperate-score  (calc-score ""cooperate"" num-cooperate)
  set defect-score  (calc-score ""defect"" num-defect)
  set tit-for-tat-score  (calc-score ""tit-for-tat"" num-tit-for-tat)
  set unforgiving-score  (calc-score ""unforgiving"" num-unforgiving)
  set unknown-score  (calc-score ""unknown"" num-unknown)
end

;; returns the total score for a strategy if any turtles exist that are playing it
to-report calc-score [strategy-type num-with-strategy]
  ifelse num-with-strategy > 0 [
    report (sum [ score ] of (turtles with [ strategy = strategy-type ]))
  ] [
    report 0
  ]
end

;;if a strategy has had any interactions, plot the average score per interaction
to do-plotting
  if num-random-games > 0 [
    set-current-plot-pen ""random""
    plot random-score / (num-random-games)
  ]
  if num-defect-games > 0 [
    set-current-plot-pen ""defect""
    plot defect-score / (num-defect-games)
  ]
  if num-cooperate-games > 0 [
    set-current-plot-pen ""cooperate""
    plot cooperate-score / (num-cooperate-games)
  ]
  if num-tit-for-tat-games > 0 [
    set-current-plot-pen ""tit-for-tat""
    plot tit-for-tat-score / (num-tit-for-tat-games)
  ]
  if num-unforgiving-games > 0 [
    set-current-plot-pen ""unforgiving""
    plot unforgiving-score / (num-unforgiving-games)
  ]
  if num-unknown-games > 0 [
    set-current-plot-pen ""unknown""
    plot unknown-score / (num-unknown-games)
  ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2002 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2002).  NetLogo PD N-Person Iterated model.
; http://ccl.northwestern.edu/netlogo/models/PDN-PersonIterated.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2002 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/PDN-PersonIterated
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model is a multiplayer version of the iterated prisoner's dilemma. It is intended to explore the strategic implications that emerge when the world consists entirely of prisoner's dilemma like interactions. If you are unfamiliar with the basic concepts of the prisoner's dilemma or the iterated prisoner's dilemma, please refer to the PD BASIC and PD TWO PERSON ITERATED models found in the PRISONER'S DILEMMA suite.



HOW IT WORKS
------------
The PD TWO PERSON ITERATED model demonstrates an interesting concept: When interacting with someone over time in a prisoner's dilemma scenario, it is possible to tune your strategy to do well with theirs. Each possible strategy has unique strengths and weaknesses that appear through the course of the game. For instance, always defect does best of any against the random strategy, but poorly against itself. Tit-for-tat does poorly with the random strategy, but well with itself.

This makes it difficult to determine a single ""best"" strategy. One such approach to doing this is to create a world with multiple agents playing a variety of strategies in repeated prisoner's dilemma situations. This model does just that. The turtles with different strategies wander around randomly until they find another turtle to play with. (Note that each turtle remembers their last interaction with each other turtle. While some strategies don't make use of this information, other strategies do.)

Payoffs
-------
When two turtles interact, they display their respective payoffs as labels.

Each turtle's payoff for each round will determined as follows:

|             | Partner's Action
|  Turtle's   |
|   Action    |   C       D
| ------------|-----------------
|       C     |   3       0
| ------------|-----------------
|       D     |   5       1
| ------------|-----------------
|  (C = Cooperate, D = Defect)

(Note: This way of determining payoff is the opposite of how it was done in the PD BASIC model. In PD BASIC, you were awarded something bad- jail time. In this model, something good is awarded- money.)



HOW TO USE IT
--------------

Buttons:

SETUP: Setup the world to begin playing the multi-person iterated prisoner's dilemma. The number of turtles and their strategies are determined by the slider values.

GO: Have the turtles walk around the world and interact.

GO ONCE: Same as GO except the turtles only take one step.

Sliders:

N-STRATEGY: Multiple sliders exist with the prefix N- then a strategy name (e.g., n-cooperate). Each of these determines how many turtles will be created that use the STRATEGY. Strategy descriptions are found below:

Strategies:

RANDOM - randomly cooperate or defect

COOPERATE - always cooperate

DEFECT - always defect

TIT-FOR-TAT - If an opponent cooperates on this interaction cooperate on the next interaction with them. If an opponent defects on this interaction, defect on the next interaction with them. Initially cooperate.

UNFORGIVING - Cooperate until an opponent defects once, then always defect in each interaction with them.

UNKNOWN - This strategy is included to help you try your own strategies. It currently defaults to Tit-for-Tat.

Plots:

AVERAGE-PAYOFF - The average payoff of each strategy in an interaction vs. the number of iterations. This is a good indicator of how well a strategy is doing relative to the maximum possible average of 5 points per interaction.


THINGS TO NOTICE
----------------
Set all the number of player for each strategy to be equal in distribution.  For which strategy does the average-payoff seem to be highest?  Do you think this strategy is always the best to use or will there be situations where other strategy will yield a higher average-payoff?

Set the number of n-cooperate to be high, n-defects to be equivalent to that of n-cooperate, and all other players to be 0.  Which strategy will yield the higher average-payoff?

Set the number of n-tit-for-tat to be high, n-defects to be equivalent to that of n-tit-for-tat, and all other playerst to be 0.  Which strategy will yield the higher average-payoff?  What do you notice about the average-payoff for tit-for-tat players and defect players as the iterations increase?  Why do you suppose this change occurs?

Set the number n-tit-for-tat to be equal to the number of n-cooperate.  Set all other players to be 0.  Which strategy will yield the higher average-payoff?  Why do you suppose that one strategy will lead to higher or equal payoff?



THINGS TO TRY
--------------
1.  Observe the results of running the model with a variety of populations and population sizes. For example, can you get cooperate's average payoff to be higher than defect's? Can you get Tit-for-Tat's average payoff higher than cooperate's? What do these experiments suggest about an optimal strategy?

2.  Currently the UNKNOWN strategy defaults to TIT-FOR-TAT. Modify the UNKOWN and UNKNOWN-HISTORY-UPDATE procedures to execute a strategy of your own creation. Test it in a variety of populations.  Analyze its strengths and weaknesses. Keep trying to improve it.

3.  Relate your observations from this model to real life events. Where might you find yourself in a similar situation? How might the knowledge obtained from the model influence your actions in such a situation? Why?


EXTENDING THE MODEL
---------------------
Relative payoff table - Create a table which displays the average payoff of each strategy when interacting with each of the other strategies.

Complex strategies using lists of lists - The strategies defined here are relatively simple, some would even say naive.  Create a strategy that uses the PARTNER-HISTORY variable to store a list of history information pertaining to past interactions with each turtle.

Evolution - Create a version of this model that rewards successful strategies by allowing them to reproduce and punishes unsuccessful strategies by allowing them to die off.

Noise - Add noise that changes the action perceived from a partner with some probability, causing misperception.

Spatial Relations - Allow turtles to choose not to interact with a partner.  Allow turtles to choose to stay with a partner.

Environmental resources - include an environmental (patch) resource and incorporate it into the interactions.


NETLOGO FEATURES
-----------------
Note the use of the TO-REPORT primitive in the function CALC-SCORE to return a number

Note the use of lists and turtle ID's to keep a running history of interactions in the PARTNER-HISTORY turtle variable.

Note how agent sets that will be used repeatedly are stored when created and reused to increase speed.


RELATED MODELS
---------------
PD Basic

PD Two Person Iterated

PD Basic Evolutionary


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (2002).  NetLogo PD N-Person Iterated model.  http://ccl.northwestern.edu/netlogo/models/PDN-PersonIterated.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2002 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/PDN-PersonIterated for terms of use.
"
PD Basic,/models/Sample Models/Social Science/Unverified/Prisoner's Dilemma,"globals [partner-is-silent?]

to setup
  clear-all
  ;;Build the jail cell
  ask patches with [ count neighbors != 8 ] [
    set pcolor gray]

  ;;make the face visible
  crt 1 [set color gray set size 30 set shape ""face""]
  ;; set up the prisoner's dilemma
  ifelse partner-silence-known? [
    set partner-is-silent? partner-silent?
  ]
  [
    ;;if partner silence is not known, choose randomly whether or not he is silent.
    ifelse random 2 = 0
    [ set partner-is-silent? true ]
    [ set partner-is-silent? false ]
  ]
end

;;play the game, changing the face depending on the outcome.
to answer
  setup  ;;clears variables away so that setup doesn't need to be pressed every time.

  ;;next the four possible combinations of choices are dealt with.
  ;;the result corresponds to the tables in the interface and information tabs.
  ;;first check to see if your partner was silent.
  ifelse partner-is-silent? [
      ;;now go through your two possible choices
      ifelse you-silent? [
      ask turtles [set shape ""face silent""]
      user-message ""You and your partner both remain silent.  You are sentenced to one year imprisonment.""
    ] [
      ask turtles [set shape ""face devious""]
      user-message ""You confess and your partner remains silent. You go free.""
    ]
  ]
  ;;your partner confessed.
  [
    ;;again go through your two possible choices
    ifelse you-silent? [
      ask turtles [set shape ""face sucker"" ]
      user-message ""You remain silent, but your partner confesses.  You are sentenced to five years imprisonment.""
    ] [
      ask turtles [set shape ""face rational""]
      user-message ""You and you partner both confess.  You are sentenced to three years imprisonment.""
    ]
  ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2002 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2002).  NetLogo PD Basic model.
; http://ccl.northwestern.edu/netlogo/models/PDBasic.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2002 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/PDBasic
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
You and your partner have been arrested for robbing a bank and find yourselves in the classic prisoner's dilemma.  The police place each of you into separate rooms and come to you with the following proposal...

""We know you two did this, but don't have proof for anything but a minor charge of firearm possession that will give you a year of jail time.  Confess to the robbery and we will make sure the judge goes easy on you, 3 years.  If your partner confesses and you don't, we're going to throw the book at you and give you 5 years of prison time.  If your partner doesn't and you do, we will let you go free.""

Should you remain silent or should you confess? How much jail time you will receive depends on your answer and also on your partner's answer to the same question. The following table summarizes the results of the four different situations:

| Your Action | Partner's Action | Your Jail Time | Partner's Jail Time
|----------------------------------------------------------------------
|   Silent          Silent               1                  1
|   Silent          Confess              5                  0
|   Confess         Silent               0                  5
|   Confess         Confess              3                  3


HOW TO USE IT
-------------
SETUP: Place yourself in the prisoner's dilemma

ANSWER: Answer the police and receive your sentence.

YOU-SILENT?: If you are silent, you will not confess.  If you are not silent, you will confess.

PARTNER-SILENCE-KNOWN?: When on, this switch allows you to control the actions of your partner with the PARTNER-SILENT? switch.

PARTNER-SILENT?: If your partner is silent, he will not confess.  If he is not silent, he will confess.


THINGS TO TRY
-------------
Turn off PARTNER-SILENCE-KNOWN?.  Attempt to minimize your prison sentence.  Can you do better than your partner?  Why or why not?

What strategy is best for the group as a whole?

Describe a real life scenario that is similar to the prisoner's dilemma, preferably one from your own life.  What was the best decision?  Why?


EXTENDING THE MODEL
--------------------
Examine the PD TWO PERSON ITERATED model.


NETLOGO FEATURES
----------------
The use of the USER-MESSAGE primitive to give the prison sentence.

The use the SIZE turtle variable and TURTLE SIZES option on the view to make large faces.

The use of the SHAPE turtle variable to change the faces.


RELATED MODELS
--------------
PD Two Person Iterated

PD N-Person Iterated

PD Basic Evolutionary


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (2002).  NetLogo PD Basic model.  http://ccl.northwestern.edu/netlogo/models/PDBasic.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2002 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/PDBasic for terms of use.
"
Traffic Intersection,/models/Sample Models/Social Science/Unverified,"globals [ stop-light ]
turtles-own [ speed ]
patches-own [ clear-in ]

;;;;;;;;;;;;;;;;;;;;
;;SETUP PROCEDURES;;
;;;;;;;;;;;;;;;;;;;;

to setup
  clear-all
  set-default-shape turtles ""car""
  ask patches
    [ set pcolor green - 1
      if abs pxcor <= 1 or abs pycor <= 1
        [ set pcolor black ]
    ]
  set stop-light ""north""
  draw-stop-light
  do-plotting
end

to draw-stop-light
  ask patches with [abs pxcor <= 1 and abs pycor <= 1]
    [ set pcolor black ]
  ifelse stop-light = ""north""
  [ ask patch 0 -1 [ set pcolor red ]
    ask patch -1 0 [ set pcolor green ]
  ]
  [ ask patch 0 -1 [ set pcolor green ]
    ask patch -1 0 [ set pcolor red ]
  ]
end

;;;;;;;;;;;;;;;;;;;;;;
;;RUNTIME PROCEDURES;;
;;;;;;;;;;;;;;;;;;;;;;

to go
  move-cars
  make-new-cars
  if auto? ;; switch the light automatically
  [ if ticks mod (green-length + yellow-length) = 0
    [ switch ]
    if ticks mod (green-length + yellow-length) > green-length
    [ ask patches with [pcolor = green]
      [ set pcolor yellow ]
    ]
  ]
  tick
  do-plotting
end

to make-new-cars
  if (random-float 100 < freq-north) and not any? turtles-on patch 0 min-pycor
    [
      crt 1
        [ set ycor min-pycor
          set heading 0
          set color 5 + 10 * random 14
          set speed min (list clear-ahead speed-limit)
        ]
    ]
  if (random-float 100 < freq-east) and not any? turtles-on patch min-pxcor 0
    [
      crt 1
        [ set xcor min-pxcor
          set heading 90
          set color 5 + 10 * random 14
          set speed min (list clear-ahead speed-limit)
        ]
    ]
end

to move-cars
  ask turtles [ move ]
  check-for-collisions
end

to move ;; turtle procedure
  let clear-to clear-ahead
  ifelse clear-to > speed
  [ if speed < speed-limit
    [ set speed speed + min (list max-accel (clear-to - 1 - speed)) ] ;; accelerate
    if speed > speed-limit
    [ set speed speed-limit ] ;; but don't speed
  ]
  [ set speed speed - min (list max-brake (speed - (clear-to - 1))) ;; brake
    if speed < 0 [ set speed 0 ]
  ]
  repeat speed ;; move ahead the correct amount
  [
    fd 1
    if not can-move? 1
    [ die ]

    if pcolor = orange
    [ set clear-in 5  ;; if you hit an accident you cause another one
      die
    ]
  ]
end

to-report clear-ahead ;;turtle procedure
  let n 1
  repeat max-accel + speed  ;; look ahead the number of patches that could be travelled
  [ if (n * dx + pxcor <= max-pxcor) and (n * dy + pycor <= max-pycor)
    [ if([pcolor] of patch-ahead n = red) or
        ([pcolor] of patch-ahead n = orange) or
        (any? turtles-on patch-ahead n)
      [ report n ]
      set n n + 1
    ]
  ]
  report n
end

to check-for-collisions
  ask patches with [ pcolor = orange ]
  [ set clear-in clear-in - 1
    if clear-in = 0
    [ set pcolor black ]
  ]
  ask patches with [ count turtles-here > 1 ]
  [
    set pcolor orange
    set clear-in 5
    ask turtles-here [ die ]
  ]
end

to switch
  ifelse stop-light = ""north""
  [ set stop-light ""east""
    draw-stop-light
  ]
  [ set stop-light ""north""
    draw-stop-light
  ]
end

;;;;;;;;;;;;;;;;;;;;;;;
;;PLOTTING PROCEDURES;;
;;;;;;;;;;;;;;;;;;;;;;;

to do-plotting
  set-current-plot-pen ""eastbound""
  plot count turtles with [heading = 90 and speed = 0]
  set-current-plot-pen ""northbound""
  plot count turtles with [heading = 0 and speed = 0]
  set-current-plot-pen ""overall""
  plot count turtles with [speed = 0]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2002.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Traffic Intersection model.
; http://ccl.northwestern.edu/netlogo/models/TrafficIntersection.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/TrafficIntersection
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
In this model the turtles are cars traveling through an intersection.  The user has the ability to control the frequency of cars coming from each direction, the speed of the cars, and the timing of the light at the traffic intersection.  Once the frequency and speed of cars is selected, the user should run the simulation and adjust the timing of the traffic light so as to minimize the amount of waiting time of cars traveling through the intersection.


HOW IT WORKS
------------

The rules for each car are:
- I can only go in the direction I started in, or stop.
- I stop for cars in front of me and red lights, and I slow down at a yellow light.
- If I am moving quickly and I see that I will have to stop soon, I slow down proportional to the distance of non-free space up to MAX-BRAKE.
- If I see that I have free space in front of me, I speed up proportional to the amount of free space up to MAX-ACCEL.
- If I am on the same space as another car, we crash and die.


HOW TO USE IT
-------------

WAIT-TIME-OVERALL shows how many cars are waiting during the given clock tick.
WAIT-TIME-EASTBOUND shows how many eastbound cars are waiting during the given clock tick.
WAIT-TIME-NORTHBOUND shows how many northbound cars are waiting during the given clock tick.

CLOCK shows how many ticks have elapsed.

Use the FREQ-EAST slider to select how often new eastbound cars travel on the road.
Use the FREQ-NORTH slider to select how often new northbound cars travel on the road.

Use the SPEED-LIMIT slider to select how fast the cars will travel.
Use the MAX-ACCEL slider to determine how fast the cars can accelerate.
Use the MAX-BRAKE slider to determine how fast the cars can decelerate.

Use the GREEN-LENGTH slider to set how long the light will remain green.
Use the YELLOW-LENGTH slider to set how long the light will remain yellow.

Press GO ONCE to make the cars move once.
Press GO to make the cars move continuously.
To stop the cars, press the GO button again.


THINGS TO NOTICE
----------------
Cars start out evenly spaced but over time, they form bunches. What kinds of patterns appear in the traffic flow?

Under what conditions do the cars appear to be moving backwards?

Gridlock happens when cars are unable to move because cars from the other direction are in their path.  What settings cause gridlock in this model?  What settings can be changed to end the gridlock?


THINGS TO TRY
-------------
Try to answer the following questions before running the simulations.

Record your predictions.

Compare your predicted results with the actual results.
- What reasoning led you to correct predictions?
- What assumptions that you made need to be revised?

Try different numbers of eastbound cars while keeping all other slider values the same.
Try different numbers of northbound cars while keeping all other slider values the same.
Try different values of SPEED-LIMIT while keeping all other slider values the same.
Try different values of MAX-ACCEL while keeping all other slider values the same.
Try different values of GREEN-LENGTH and YELLOW-LENGTH while keeping all other slider values the same.

For all of the above cases, consider the following:
- What happens to the waiting time of eastbound cars?
- What happens to the waiting time of northbound cars?
- What happens to the overall waiting time?
- What generalizations can you make about the impact of each variable on the waiting time of cars?
- What kind of relationship exists between the number of cars and the waiting time they experience?
- What kind of relationship exists between the speed of cars and the waiting time they experience?
- What kind of relationship exists between the number of ticks of green light and the waiting time cars experience?

Use your answers to the above questions to come up with a strategy for minimizing the waiting time of cars.

What factor (or combination of factors) has the most influence over the waiting time experienced by the cars?


EXTENDING THE MODEL
-------------------
Find a realistic way to eliminate all crashes by only changing car behavior.

Allow different light lengths for each direction in order to control wait time better.

In the model, the yellow light is only for visual effect.  In real life, it tells cars that they need to start braking if they're going to be able to stop before the light turns red.  Make the cars use this information, and see how it affects the model.

Is there a better way to measure the efficiency of an intersection than the current number of stopped cars?


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Traffic Intersection model.  http://ccl.northwestern.edu/netlogo/models/TrafficIntersection.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/TrafficIntersection for terms of use.
"
El Farol Network Congestion,/models/Sample Models/Social Science/Unverified,"breed [ patrons patron ]

;; the 'b', 'a', and 'r' breeds are single turtles that spell 'bar'
breed [ bs b ]
breed [ as a ]
breed [ rs r ]

;;;;;;;;;;;;;;;
;; Variables ;;
;;;;;;;;;;;;;;;

globals [
  attendance          ;; number of patrons currently attending bar
  sum-attendance      ;; sum of attendance after N days
  average-attendance  ;; sum-attendance / days
  regulars            ;; patrons who attend at least every other day
  casuals             ;; patrons who do not attend every other day
]

patrons-own [
  attending?          ;; whether or not a patron attended during the previous day
  ;; how often the patron wishes to go to the bar, which is the
  ;; variable c in the Bell and Sethares paper
  attendance-frequency
  ;; the number of days remaining until the patron attends next,
  ;; which is the variable p in the Bell and Sethares paper
  phase
]

;;;;;;;;;;;;;;;;;;;;;;;;
;;; Setup Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;

to setup
  ca
  setup-world
  setup-patrons
  setup-plot
  update-plots
end

;; creates the colorful background images
to setup-world
  set sum-attendance 0
  set average-attendance 0
  ask patches
    [ set pcolor scale-color green ((random 500) + 5000) 0 9000 ]
  create-street
  create-bar
end

;; creates a street that runs vertically in the middle of the world
to create-street
  ask patches with [pxcor >= -1 and pxcor <= 1]
    [set pcolor black]
  ask patches with [pxcor = 0 and pycor mod 2 = 0]
    [set pcolor yellow]
end

;; draws a black bar with the word ""bar"" inside
to create-bar
  ask patches with [pycor < 2 and pycor > -2 and pxcor >= 9 and pxcor < 12]
    [set pcolor black]
  create-bs 1
    [set shape ""b""
      setxy (max-pxcor - 2) 0]
  create-as 1
    [set shape ""a""
      setxy (max-pxcor - 1) 0]
  create-rs 1
    [set shape ""r""
      setxy max-pxcor 0]
end

;; creates patrons and places them in unique patches
to setup-patrons
  if population >= (max-pxcor - 1) * world-height
    [user-message (word ""The population is too large for the size of the world.""
                        ""  Either decrease the population or increase the number of ""
                        ""patches in the world."")
      stop]
  create-patrons population
    [ set shape ""person""
      set color sky
      set size 1
      set attending? false
      set attendance 0
      find-patch
      set attendance-frequency (1 + random 20)
      set phase (1 + random attendance-frequency) ]
end

;; locate unoccupied patches for patrons
to find-patch
  setxy ((random min-pxcor ) - 1)
        random-pycor
  while [any? other turtles-here]
      [find-patch]    ;; keeps running until each patron is alone on patch
end

;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Runtime Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

to go
  phase-step
  tick
  check-attendance
  update-plots
  phase-update
end

;; counts down phase. if, following this count down, the phase has been completed,
;; the patron will attend now
to phase-step
  ask patrons
    [if (phase > 1) [set phase (phase - 1)]
      if phase <= 1  [set attending? true]]
end

;; checks whether or not the bar is overcrowded
to check-attendance
  calculate-attendance-by-type
  calculate-average-attendance
  attendees-skip-across-street
  display  ;; so we see them moving
  ;; Patrons who are in the bar always have perfect information about attendance
  ;; If the perfect-information? is On, then also patrons who are outside have
  ;; this information
  ifelse perfect-information?
    [ask patrons [update-attendance-frequency] ]
    [ask patrons with [attending?] [update-attendance-frequency] ]
end

;; finds the number of patrons who are attending and determines if they are casuals or regulars
to calculate-attendance-by-type
  set attendance count patrons with [attending?]
  set regulars count patrons with [attendance-frequency < 3]
  ask patrons with [attendance-frequency < 3]
    [set color red]
  set casuals (population - regulars)
  ask patrons with [attendance-frequency >= 3]
    [set color sky]
end

;; determines the cumulative ratio between total attendance and days since the onset of the
;; current run of the model
to calculate-average-attendance
  set sum-attendance (sum-attendance + attendance)
  set average-attendance (sum-attendance / ticks)
end

;; skips attending customers to the other side of the world across from the vertical axis
to attendees-skip-across-street
  ask patrons with [attending?]
    [setxy (0 - xcor) ycor]
end

;; patrons update the frequency of their individual attendance schedule (the phase or cycle).
;; if the bar was crowded, they'll come back less frequently than before, and vice versa
;; returning less frequently means increasing the phase, and vice versa
;; 'frequency-update' is the interface slider value for increasing/decreasing the phase
to update-attendance-frequency ;; patron procedure
  if attendance < (Equilibrium - dead-zone)
    [if (attendance-frequency > 1)
      [set attendance-frequency (attendance-frequency - frequency-update)]]
  if attendance > Equilibrium
    [set attendance-frequency (attendance-frequency + frequency-update)]
end

;; updates by setting phase to be attendance-frequency
to phase-update
  ;; now that the day is over, attending patrons return across the street
  ;; these patrons now begin counting down all over again from their current personal
  ;; value of 'attendance-frequency'
  attendees-skip-across-street
  ask patrons with [attending?]
    [set attending? false
      set phase attendance-frequency]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Plotting Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

to setup-plot
  set-current-plot ""Attendance History""
  set-plot-y-range 0 population
  set-current-plot ""Attendance Type""
  set-plot-y-range 0 population
end

to update-plots
  update-attendance
  update-attendance-type
end

to update-attendance
  set-current-plot ""Attendance History""
  set-current-plot-pen ""now""
  plot attendance
  set-current-plot-pen ""cumulative""
  plot average-attendance
end

to update-attendance-type
  set-current-plot ""Attendance Type""
  set-current-plot-pen ""casuals""
  plot-pen-reset
  plotxy 0 casuals
  set-current-plot-pen ""regulars""
  plot-pen-reset
  plotxy 1 regulars
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2003 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2003).  NetLogo El Farol Network Congestion model.
; http://ccl.northwestern.edu/netlogo/models/ElFarolNetworkCongestion.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2003 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/ElFarolNetworkCongestion
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
El Farol is a bar in Santa Fe.  The bar is popular, but becomes overcrowded when too many patrons attend.  Patrons are happy when less than a certain amount of patrons attend, say 60 for example, but they are unhappy when more than some other amount of patrons attend, say 70.  What will happen as time passes and people have pleasant or unpleasant experiences?

Is it always true that the more a bar is popular, the higher its attendance?  Does it makes sense to say that a bar ""has it's ups and downs, but on the whole it's stable?""

This model problematizes a seemingly simple situation of social interaction to reveal that it is not that simple.  Working in this model, we encounter and appreciate the inherent coordination challenges that can arise in complex dynamic systems involving agents with intention and specified needs and criteria of satisfaction.  Can patrons of a bar somehow self organize to optimize overall satisfaction?


HOW IT WORKS
------------
El Farol is a fun place to be, and patrons keep returning.  But it can get crowded there.  If it is crowded, patrons may not come back as often as they had previously, but if it happens not to be crowded, the patrons will come again sooner.

Patrons of El Farol each have initial inclinations to visit the bar or not.  These personal inclinations are expressed in the frequencies of each patron's visits (the variable ATTENDANCE-FREQUENCY.  For example, a value of 9 means they go to the bar every 9 days).  ATTENDANCE-FREQUENCY is the variable c in the Bell and Sethares paper.  When the model starts running, patrons have different times until their next visit (stored in the variable PHASE. For example, a value of 5 means the patron will go to the bar in 5 days time).  PHASE is the variable p in the Bell and Sethares paper.  For each patron, the initial values of ATTENDANCE-FREQUENCY and PHASE are chosen randomly, within a designated range determined by the other settings of the model.  Each patron's PHASE value decreases as the model runs until it drops below 1, at which time the patron goes to the bar.  While in the bar, the patron determines how crowded the bar is and changes the value of ATTENDANCE-FREQUENCY accordingly.  If attendance at the bar exceeds the EQUILIBRIUM value, i.e. bar is overcrowded, the patron increases ATTENDANCE-FREQUENCY by the FREQUENCY-UPDATE value.  That means that in the future, this patron will wait longer before returning to this bar.  If attendance is below the critical value (EQUILIBRIUM - DEAD-ZONE), i.e. bar is not crowded, the patron decreases ATTENDANCE-FREQUENCY by the FREQUENCY-UPDATE value. ATTENDANCE-FREQUENCY remains unchanged if attendance falls within the DEAD-ZONE range.  The PHASE is then reset to the new value of ATTENDANCE-FREQUENCY.


HOW TO USE IT
-------------
Sliders:
POPULATION: the number of patrons that will be created in this experiment
EQUILIBRIUM: the number of patrons beyond which the bar becomes overcrowded
DEAD-ZONE: determines the range below the equilibrium at which the bar is perceived neither as crowded nor as not crowded
FREQUENCY-UPDATE: value to update the ATTENDANCE-FREQUENCY by in response to a positive or negative experience at the bar

Buttons:
SETUP - initiates variables towards a new run
GO ONCE - runs the model for one time tick, so we get the behavior over a single 'day'
GO - runs the model repeatedly, until it is stopped by pressing again

Switches:
PERFECT-INFORMATION?: if turned on, agents will have access to attendance information whether they are attending or not and will adjust their preferences accordingly

Plots:
ATTENDANCE HISTORY: shows how many patrons are currently in the bar and the cumulative ratio of total patrons to total days
ATTENDANCE TYPE: shows the current totals of two types of patrons -- casuals and regulars (including those in and out of the bar)

After choosing the variables, click the SETUP button to setup the model. All patrons start on the left side of the world. This means that none of them are attending the bar at this moment. If they choose to attend, they will move to the right side of the world. Patrons are colored sky by default. This means that they are 'casual' patrons (less than every other day). If they attend more than every other day, they will turn red to show that they are now 'regular' patrons.

You can choose between GO ONCE and GO to run the model. Also, for initial runs, you may want to slow down the model, using the speed slider above the View, so as to see the patrons attending and leaving the bar.


THINGS TO NOTICE
----------------
Try different settings and examine both plots.  Note that the ATTENDANCE HISTORY plot tends to converge on some value.  Note how the ATTENDANCE TYPE plot occasionally spikes up or down.  This means that there are a lot of casual patrons who are attending the bar often, and once in a while, they all happen to attend on the same day.  With PERFECT-INFORMATION? set to Off, the numbers of casuals and regulars tend to converge on some stable values. You will also notice that the average attendance seems to converge toward the (EQUILIBRIUM - DEAD-ZONE) number.

When PERFECT-INFORMATION? is turned On, everyone has access to the same information about attendance, and they all respond uniformly by updating their ATTENDANCE-FREQUENCY values.  So the group as a whole usually either all go or they do not go at all.  Thus, an increase in information seems to prevent some wiggle room that would make more patrons satisfied.


THINGS TO TRY
-------------
How does changing the value on the FREQUENCY-UPDATE slider affect the behavior of the system? Try to guess, then run the model under different values for that slider and examine the results.

Play with the relation between values in the POPULATION and EQUILIBRIUM sliders.  Try to imagine how these settings would impact your own behavior, and see if the model matches your expectations.


EXTENDING THE MODEL
-------------------
Currently, all patrons have the same tolerance to crowds.  Assign random EQUILIBRIUM values to the attending turtles and evaluate how this modification affects the group behavior.

Invent and implement advanced patron strategies for optimizing their experience at the bar.  One idea is to have patrons remember historical data such as ""it is always crowded every 7th day"" or ""every time it is crowded 4 days in a row, the next day is always not crowded.""  What do you expect such an extension might do?  Can we, in principle, guarantee more satisfied patrons by making them more savvy?  Should we give this power of prediction to all patrons, or should we control who has these strategies (just as we controlled who has perfect information)?  Is it fair to favor some patrons over others?

Improve the visual features.  Perhaps the bar could be made to look more like an actual bar.

A final idea would be to create a HubNet version of the El Farol simulation.


NETLOGO FEATURES
----------------
Look at the code for procedure attendees-skip-across-street.

|  to attendees-skip-across-street
|    ask patrons with [attending?]
|    [setxy (0 - xcor) ycor]
|  end

The code asks each patron that has a true value for the 'attending?' (true/false) variable to set their x coordinate.  Yet, this procedure is called both when the patron crosses the street to the right so as to enter the bar and again when the patron exits the bar and crosses back to the left.  How can it be that the same code both sends a patron to the right and to the left?

The answer lies in the meaning of xcor and how it relates to the minus sign ( - ) just before it. xcor reports a value representing the right/left position of a turtle.  To the right of central vertical line (the y-axis, where the street is in this model), the xcor values are positive, and to the left of the axis the values are negative.  When a patron is in the left section of the world, subtracting the xcor flips the xcor to a positive value.  For instance, if the patron is at (-5, 3), the patron will be sent to (+5, 3).  When this patron has completed attending, this same code sends the patron back from (+5, 3) to (-5, 3).


RELATED MODELS
--------------
The Social Science models Party and Segregation each deal with situations in which individuals have specified preferences and act upon these preferences.


CREDITS AND REFERENCES
----------------------
Original implementation: Eric Cheng, for the Center for Connected Learning and Computer-Based Modeling.

This model is based on a paper by Ann Bell and William Sethares, ""The El Farol Problem and the Internet: Congestion and Coordination Failure"".

To refer to this model in academic publications, please use:  Wilensky, U. (2003).  NetLogo El Farol Network Congestion model.  http://ccl.northwestern.edu/netlogo/models/ElFarolNetworkCongestion.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2003 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/ElFarolNetworkCongestion for terms of use.
"
Divide The Cake,/models/Sample Models/Social Science/Unverified,"turtles-own [
  ;; ""appetite"" will reflect the behavior of the three types of agents: '2' for modest,
  ;; '3' for fair, and '4' for greedy.  Note that the ratio between these three numbers
  ;; 2:3:4 is equal to the ratio of agent types' eating habits: 1/3 : 1/2 : 2/3.
  ;; In principle, we could have worked with 1/3, 1/2, and 2/3 but it's just easier to
  ;; work with integers.   So we will think of a whole as ""6"" and not as ""1"".
  appetite
  ;; true or false for ""is it my turn to run the 'eat' procedure?,"" will help us manage
  ;; the behavior of turtles who are on the same patch.
  turn?
]

to setup
  ca
  ask patches
    [ set pcolor green ]
  setup-turtles
  update-plot
end

to setup-turtles
  let total (modest-proportion + fair-proportion + greedy-proportion)
  crt initial-number
    [ setxy random-xcor random-ycor
      ;; This will assign proportions of the turtles to agent types
      ;; according to the ratio of greedy, fair, and modest turtles
      ;; as set in their respective sliders.  The procedure uses the
      ;; fact that, given enough turtles, the random yet uniform
      ;; distribution of individual turtles' values from 0 to 1.0
      ;; will assign these turtles to different agent types so as to
      ;; approximate a correspondence with the number of turtles in
      ;; each type, as determined by the user's ratio settings.
      let breed-rand random-float 1.0
      ifelse breed-rand < (fair-proportion / total)
        [ set appetite 3
          set color red ]
        [ ifelse breed-rand < ((total - greedy-proportion) / total)
            [ set appetite 2
              set color brown ]
            [ set appetite 4
              set color blue ] ] ]
end

to go
  ;; Main loop - agents move around and eat the grass
  ;; Here all agents receive a 'true' value for their 'turn?' Boolean variable.
  ;; Later, in the 'eat' procedure, only a single turtle of turtle pairs who are on the same patch will get to use this value.
  ask turtles
    [ set turn? true
      move
      eat ]
  tick
  update-plot
end

to move  ;; turtle procedure
  ;; Agents move in random directions every turn,
  ;; at least one patch per turn.
  rt random-float 360

  ;; Note that 'travel-distance' is scaled down by the (1 - viscosity) factor, unless 'viscosity' is 0.
  fd 1 + (travel-distance * (1 - viscosity))
end

to eat ;; turtle procedure
  ;; We need the turn? variable so turtles who are eligible
  ;; to eat will not get two chances to reproduce.
  ;; Only where there is exactly a pair of turtles on a patch are both turtles eligible to eat.
  ;; Logically, we can't manage more than two turtles, because we could not, then, distinguish between
  ;; the presence of three modest turtles (2 + 2 + 2) or two fair turtles (3 + 3);
  ;; Also, if appetites on a patch exceeded resources, that is if their total was greater than 6, we would not know if this
  ;; were because two turtles have gone beyond 6 and they should die, or because there were three or more turtles on the patch.
  if (count turtles-here = 2 and turn?)
    [ ifelse (6 >= sum [appetite] of turtles-here)
        [ ask turtles-here  ;; including myself!
            [ reproduce
              set turn? false ] ]
        [ ask turtles-here  ;; including myself!
           [ die ] ] ]
  set turn? false
end

to reproduce ;; turtle procedure
  ;; Note that the higher a turtle's appetite value, the higher are its
  ;; chances of reproduction.
  if (random 6) < appetite
    [ hatch 1 ]
end

to update-plot
  set-current-plot ""Population vs. Time""
  set-current-plot-pen ""modest""
  plot count turtles with [color = brown]
  set-current-plot-pen ""fair""
  plot count turtles with [color = red]
  set-current-plot-pen ""greedy""
  plot count turtles with [color = blue]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2002.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Divide The Cake model.
; http://ccl.northwestern.edu/netlogo/models/DivideTheCake.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/DivideTheCake
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model (and Cooperation and Altruism) are part of the EACH curriculum: ""Evolution of Altruistic and Cooperative Habits: Learning About Complexity in Evolution"".  See http://ccl.northwestern.edu/cm/EACH/ for more information.

This is an evolutionary game-playing model.  Three types of agents must divide a common resource.  In the original model it's cake, but let's think of it as edible grass instead, which is green.  The agents come in three types: modest, fair, and greedy.  The agents move around competing for grass.  Agents need grass in order to produce offspring, so over time, the agent types that get more grass will tend to increase in number.


HOW IT WORKS
------------
When there are only two agents on a patch of grass, each of the agents tries to eat a certain amount of the grass.

There are fair agents (red), modest agents (brown), and greedy agents (blue).  Fair agents try to eat half the grass, modest agents try to eat a third of the grass, and greedy agents try to eat two-thirds of the grass.

If the total amount requested by both agents is greater than 100%, then both agents die.  Otherwise, each agent gets his requested share of the patch's resources.   Each agent then enters a reproduction lottery based on its appetite:  The greater the appetite, the greater the chance of reproduction.  This factor gives a fitness advantage to the agents with a greater appetite that counteracts the disadvantage of having a greater appetite (viz., the higher chance of asking for too much food and dying).

Each turn, every patch resets to the full amount of grass.


HOW TO USE IT
-------------
SETUP: Creates the agents.

GO: Starts the model running.

MODEST-PROPORTION, FAIR-PROPORTION, GREEDY-PROPORTION:  These sliders set the proportions of the three agent types within the initial number of agents.  Note that the actual numbers chosen for these three sliders are irrelevant -- only the ratio of the three numbers counts vis-a-vis the setting of the INITIAL-NUMBER slider.  For example, the ratio settings ""1 1 1"" will produce roughly equal numbers of each type, as will the settings ""79 79 79"" or what-have-you.  Likewise, the setting ""0 0 1"" is no different from ""0 0 88"", etc.

INITIAL-NUMBER: Creates this number of turtles of all three types together.

TRAVEL-DISTANCE: The value of this variable determines the number of steps an agent moves each turn.  This value is the mobility of an agent.

VISCOSITY: This variable is the difficulty of movement.  It limits the general mobility of agents.


THINGS TO NOTICE
-----------------
If you run the model with the default settings (high viscosity), notice how the population of fair (1/2) agents increases.  Why does this happen?  Also, notice how the modest (1/3) and greedy (2/3) populations and the modest (1/3) and fair (1/2) populations congregate in dynamically-stable communities but the greedy (2/3) and fair (1/2) populations do not seem to co-exist.  Why does this happen?


THINGS TO TRY
-------------
Try changing the population VISCOSITY value.  What happens when this value is decreased?  How does this affect the survival and the grouping of the different populations?

Change the starting ratios of the populations.  How do these ratios affect the behavior of the model?  Why should the model depend on these ratios?

Change TRAVEL-DISTANCE.  How does it affect the model?  What is the relationship between the values of TRAVEL-DISTANCE and VISCOSITY?


EXTENDING THE MODEL
-------------------
What environmental variables might affect the model?  Should the grass grow back to its full length each turn?  How would changing the rejuvenation of available resources affect the model?

Should the agents be informed of each other's anticipated demands prior to making their claims?  If they did, then agents could bargain before asking for food, and therefore reduce their chances of death as a result of a joint demand that exceeds the available resources, e.g., 1/2 + 2/3 > 1.  This bargaining behavior would change the model drastically, but is an interesting way of exploring how populations may adapt their interpersonal behaviors in order to survive.  A question would then arise of whether such survival does or does not ultimately play against agents as a type, because the price of survival could be a depletion of resources in future generations.


RELATED MODELS
--------------
Altruism, Cooperation, PD Basic


CREDITS AND REFERENCES
----------------------
This model is based on William Harms's ""Divide the Cake"" model, described in Brian Skyrms's book ""The Evolution of the Social Contract"".

Thanks to Damon Centola for his implementation of this model.

To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Divide The Cake model.  http://ccl.northwestern.edu/netlogo/models/DivideTheCake.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/DivideTheCake for terms of use.
"
Language Change,/models/Sample Models/Social Science/Unverified,";******************************;
;  Variables
;******************************;
breed [nodes node]

nodes-own [
  state            ; current grammar state - [0,1]
  orig-state       ; save for resetting the original states
  spoken-state     ; stores output of agent's speech - 1 or 0
]

;******************************;
;  SETUP
;******************************;
to setup
  clear-all
  set-default-shape nodes ""circle""
  ask patches [ set pcolor gray ]
  repeat num-nodes [
    make-node
  ]
  distribute-grammars
  create-network
  do-plotting
end

;;; initialize nodes so a proportion start out with grammar 1
to distribute-grammars
  ;; wipe everyone's grammars back to 0
  ask nodes [
    set state 0
  ]  
  ;; then ask a select few to switch on to 1
  ask n-of ((percent-grammar-1 / 100) * num-nodes) nodes [
    set state 1.0
  ]
  ask nodes [
    set orig-state state     ; used for resetting states
    set spoken-state state   ; initial spoken state, for first timestep
    update-color
  ]
end

to create-network
  ;; make the initial network of two nodes and an edge
  let partner nobody
  let first-node one-of nodes
  let second-node one-of nodes with [ self != first-node ]
  ask first-node [ create-link-with second-node [ set color white ] ] ; make the first edge
  ;; randomly select unattached node to add to network 
  let new-node one-of nodes with [not any? link-neighbors]
  ;; and connect it to a partner already in the network
  while [ new-node != nobody ] [
    set partner find-partner
    ask new-node [ create-link-with partner [ set color white ] ]
    layout
    set new-node one-of nodes with [not any? link-neighbors]
  ]
end

;;; creates a new node, initializes its state
to make-node
  create-nodes 1 [
    ;; start in random position near edge of world
    rt random-float 360
    fd max-pxcor
    set size 2
    set state 0.0
  ]
end

to update-color
  set color scale-color red state 0 1
end

to reset-nodes
  reset-ticks
  clear-all-plots
  ask nodes [  
    set state orig-state
    update-color
  ]
  do-plotting
end

to redistribute-grammars
  reset-ticks
  clear-all-plots
  distribute-grammars
  do-plotting  
end

;;; reports a string of the agent's initial grammar - ""one"" or ""zero""
to-report orig-grammar-string
  report ifelse-value (orig-state = 1.0) [ ""one"" ] [ ""zero"" ]
end

;******************************;
;  GO
;******************************;
to go
  ask nodes [
    communicate-via update-algorithm
  ]
  ask nodes [
    update-color
  ]
  tick
  do-plotting
end

to communicate-via [ algorithm ] ; node procedure
  ;; *Discrete Grammars* ;;
  ifelse (algorithm = ""threshold"") [
    listen-threshold
  ][
  ifelse (algorithm = ""individual"") [
    listen-individual
  ] [
  ;; *Probabilistic Grammar* ;;
  ;; speak and ask all neighbors to listen
  if (algorithm = ""reward"") [
    speak
    ask link-neighbors [
      listen [ spoken-state ] of myself 
    ]
  ]]]
end

;******************************;
;  Speaking & listening
;******************************;
to speak ; node procedure
  ;; *FILTERING* ;;
  ;; alpha is the level of bias in favor of grammar 1
  ;; alpha is constant for all nodes. value of 0.025 works best with logistic
  ;; this is the logistic equation
  ;; it looks complicated in order to input values [0,1] and output to [0,1]
  if (logistic? = true) [
    let gain (alpha + .1) * 20
    let filt-val  1 / (1 + exp (- (gain * state - 1) * 5) )  
    ifelse random-float 1.0 <= filt-val [
      set spoken-state 1
    ][
      set spoken-state 0
    ]
  ]
  ;; for probabilistic learners who only have bias for grammar 1
  ;; no preference for discrete grammars (ie, no logistic)
  if (logistic? = false)[
    ;; slope needs to be greater than 1.. arbitarily set to 1.5
    ;; when state is >= 2/3, the biased-val would be greater than 1
    let biased-val (1.5 * state)
    if (biased-val > 1)[
      set biased-val 1
    ]
    ;; let biased-val (state / (state + .9 * (1 - state)))
    ifelse random-float 1.0 <= biased-val [
      set spoken-state 1
    ][
      set spoken-state 0
    ]
  ]
end

;;; listening uses a linear reward/punish algorithm
to listen [heard-state] ; node procedure
  let gamma 0.01 ; for now gamma is the same for all nodes
  ;; choose a grammar state to be in
  ifelse (random-float 1.0 <= state) [       
    ;; if grammar 1 was heard
    ifelse (heard-state = 1) [
      set state (state + (gamma * (1 - state)))
    ][
      set state (1 - gamma) * state
    ]
  ][
    ;; if grammar 0 was heard
    ifelse (heard-state = 0) [
      set state (1 - gamma) * state
    ][
      set state gamma + ((1 - gamma) * state)
    ]
  ]
end

to listen-individual ; node procedure
  set state [state] of one-of link-neighbors
end

to listen-threshold ; node procedure
  let grammar-one-sum sum [ state ] of link-neighbors
  ifelse (grammar-one-sum >= (count link-neighbors * threshold-val)) [
    set state 1
  ][
    ;; else - you don't have enough neighbors with grammar 1, and 1 is not a sink state, then change to 0
    if (sink-state-1? = false) [
      set state 0
    ]
  ]
end

;******************************;
;   Plotting
;******************************;
to do-plotting
  set-current-plot ""Mean State of Agents in the Network""
  plot mean [ state ] of nodes 
end

;******************************;
;  Making the network
;******************************;
;;; This code is borrowed from Lottery Example, from the Code Examples
;;; section of the Models Library.
;;; The idea behind this procedure is a bit tricky to understand.
;;; Basically we take the sum of the sizes of the turtles, and
;;; that's how many ""tickets"" we have in our lottery.  Then we pick
;;; a random ""ticket"" (a random number).  Then we step through the
;;; turtles to figure out which turtle holds that ticket.
to-report find-partner
  let pick random-float sum [count link-neighbors] of (nodes with [any? link-neighbors])
  let partner nobody
  ask nodes [
    ;; if there's no winner yet...
    if partner = nobody [
      ifelse count link-neighbors > pick [
        set partner self
      ][
        set pick pick - (count link-neighbors)
      ]
    ]
  ]
  report partner
end

;******************************;
;   Layout 
;******************************;
to layout
  layout-spring (turtles with [any? link-neighbors]) links 0.4 6 1
  display  ;; for smooth animation
end

;******************************;
;  Highlighting
;******************************;
to highlight
  ifelse mouse-inside? [
    do-highlight
  ] [
    undo-highlight
  ]
  display
end

;;; remove any previous highlights
to undo-highlight
  clear-output
  ask nodes [ update-color ]
  ask links [ set color white ]
end

to do-highlight
  let highlight-color blue
  let min-d min [distancexy mouse-xcor mouse-ycor] of nodes
  ;; get the node closest to the mouse
  let the-node one-of nodes with [any? link-neighbors and distancexy mouse-xcor mouse-ycor = min-d]
  ;; get the node that was previously the highlight-color
  let highlit-node one-of nodes with [ color = highlight-color ]
  if the-node != nobody and the-node != highlit-node [
    ;; highlight the chosen node
    ask the-node [
      undo-highlight
      output-print word ""original grammar state: ""  orig-grammar-string
      output-print word ""state: "" precision state 5
      set color highlight-color
      ;; highlight edges connecting the chosen node to its neighbors
      ask my-links [ set color 84 ]
      ;; highlight neighbors
      ask link-neighbors [ set color 106 ]
    ]
  ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2007 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Troutman, C. and Wilensky, U. (2007). NetLogo Language Change model.
; http://ccl.northwestern.edu/netlogo/models/LanguageChange.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2007 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/LanguageChange
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model explores how the properties of language users and the structure of their social networks can affect the course of language change. In this model, there are two linguistic variants in competition within the social network - one variant generated by grammar 0 and the other generated by grammar 1. Language users interact with each other based on who they are connected to in the network. At each iteration, everyone speaks by passing an utterance using either grammar 0 or grammar 1 to their neighbors in the network. Individuals then listen to their neighbors by changing their grammars based on what they received as input from the speakers.


HOW IT WORKS
------------
The networks in this model are constructed through the process of ""preferential attachment"" in which individuals enter the network one by one, and prefer to connect to those language users who already have many connections. This leads to the emergence of a few ""hubs"", or language users who are very well connected; most other language users have very few connections. 

There are three different options to control how language users listen and learn from their neighbors, listed in the UPDATE-ALGORITHM chooser. For two of these options, ""individual"" and ""threshold"", language users can only access one grammar at a time. Those that can only access grammar 1 are white in color, and those that can access only grammar 0 are black. For the third option, ""reward"", each grammar is associated with a weight, which determines the language user's probability of accessing that grammar. Because there are only two grammars in competition here, the weights are represented with a single value - the weight of grammar 1. The color of the nodes represent this probability; the larger the weight of grammar 1, the darker the node.

- Individual: Learners choose one of their neighbors randomly, and adopt that neighbor's grammar.

- Threshold: Learners adopt grammar 1 if some proportion of their neighbors are already using grammar 1. This proportion is set with the THRESHOLD-VAL slider. For example, if THRESHOLD-VAL is 0.30, then a learner will adopt grammar 1 if at least 30% of his neighbors have grammar 1.

- Reward: Learners update their probability of using one grammar or the other. In this algorithm, if an individual hears an utterance from grammar 1, the individual's weight of grammar 1 is increased, and they will be more likely to access that grammar in the next iteration. Similarly, hearing an utterance from grammar 0 increases the likelihood of accessing grammar 0 in the next iteration.


HOW TO USE IT
------------------
The NUM-NODES slider determines the number of nodes to be included in the network population. PERCENT-GRAMMAR-1 determines the proportion of these nodes which will be initialized to use grammar 1. The remaining nodes will be initialized to use grammar 0.

Pressing the SETUP-EVERYTHING button generates a new network based on NUM-NODES and PERCENT-GRAMMAR-1. 

The REDISTRIBUTE-GRAMMARS button keeps the same proportion of nodes with grammar 0 or 1, but reassigns who has these initial grammars. For example, if 20% of nodes are initialized with grammar 1, clicking REDISTRIBUTE-GRAMMARS will assign grammar 1 to a new sample of 20% of the population.

Press RESET-STATES to reinitialize all nodes to their original grammars. This allows you to run the model multiple times without generating a new network structure.

The LAYOUT button attempts to move the nodes around to make the structure of the network easier to see.

When the HIGHLIGHT button is pressed, roll over a node in the network to see who that node is connected to. Additionally, information about that node's initial and current grammar state will be displayed in the output area.

Press GO ONCE to allow all nodes to ""speak"" and ""listen"" once, according to the algorithm in the UPDATE-ALGORITHM dropdown menu (see the above section for more about these options). Press GO for this procedure to repeat continually.

The SINK-STATE-1? switch applies only for the ""individual"" and ""threshold"" updating algorithms. If on, once someone adopts grammar 1, they can never go back to grammar 0.

The LOGISTIC? switch applies only for the ""reward"" updating algorithm. If on, a speaker's probability of using one of the grammars while speaking is pushed to the extremes (closer to 0% or 100%), based on the output of the logistic function. 
(See http://en.wikipedia.org/wiki/Logistic_function for more on this function.)

The ALPHA slider also applies only for the ""reward"" updating algorithm, and only when LOGISTIC? is turned on. ALPHA represents a bias in favor of grammar 1. Probabilities are pushed to the extremes, then shifted toward selecting grammar 1. The larger the value of ALPHA, the more likely a language user is to speak using grammar 1.

The plot ""Mean State of Agents in the Network"" calculates the average weight of grammar 1 for all nodes in the network, at each iteration.


THINGS TO NOTICE
------------------
Over time, language users tend to arrive at using just one grammar all of the time. However, they may not all converge to the same grammar. It is possible for sub-groups to emerge, which may be seen as the formation of different dialects.


THINGS TO TRY
------------------
Under what conditions is it possible to get one grammar to spread through the entire network? Try manipulating PERCENT-GRAMMAR-1, the updating algorithm, and the various other parameters. Does the number of nodes matter too?


EXTENDING THE MODEL
------------------
Whether or not two language users interact with each other is determined by the network structure. How would the model behave if language users were connected by a small-world network rather than a preferential attachment network?

In this model, only two grammars are in competition in the network. Try extending the model to allow competition between three grammars.

Regardless of the updating algorithm, language users always start out using one grammar categorically (that is, with a weight of 0 or 1). Edit the model to allow some language users to be initialized to an intermediate weight (i.e., 0.5)


RELATED MODELS
--------------
See the Preferential Attachment model in the Networks section of the Models Library.


CREDITS AND REFERENCES
----------------------
This model was also described in Troutman, C., Clark, B., and Goldrick, M. ""Social Networks and Intraspeaker Variation During Periods of Language Change"". Paper submitted to the Penn Working Papers in Linguistics. 
http://ling.northwestern.edu/~cet883/PLC_TroutmanClarkGoldrick.pdf

To refer to this model in academic publications, please use:  Troutman, C. and Wilensky, U. (2007).  NetLogo Language Change model.  http://ccl.northwestern.edu/netlogo/models/LanguageChange.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2007 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/LanguageChange for terms of use.
"
Traffic 2 Lanes,/models/Sample Models/Social Science/Unverified,"globals
[
  selected-car   ;; the currently selected car
  average-speed  ;; average speed of all the cars
]

turtles-own
[
  speed         ;; the current speed of the car
  speed-limit   ;; the maximum speed of the car (different for all cars)
  lane          ;; the current lane of the car
  target-lane   ;; the desired lane of the car
  patience      ;; the driver's current patience
  max-patience  ;; the driver's maximum patience
  change?       ;; true if the car wants to change lanes
]

to setup
  ca
  draw-road
  set-default-shape turtles ""car""
  crt number
  [ setup-cars ]
  set selected-car one-of turtles
  ;; color the selected car red so that it is easy to watch
  ask selected-car
  [ set color red ]
  setup-plots
end

to draw-road
  ask patches
  [
    set pcolor green
    if ((pycor > -4) and (pycor < 4))
    [ set pcolor gray ]
    if ((pycor = 0) and ((pxcor mod 3) = 0))
    [ set pcolor yellow ]
    if ((pycor = 4) or (pycor = -4))
    [ set pcolor black ]
  ]
end

to setup-cars
  set color black
  set lane (random 2)
  set target-lane lane
  ifelse (lane = 0)
  [ setxy random-xcor -2 ]
  [ setxy random-xcor  2 ]
  set heading 90
  set speed 0.1 + random 9.9
  set speed-limit (((random 11) / 10) + 1)
  set change? false
  set max-patience ((random 50) + 10)
  set patience (max-patience - (random 10))

  ;; make sure no two cars are on the same patch
  loop
  [
    ifelse any? other turtles-here
    [ fd 1 ]
    [ stop ]
  ]
end

;; All turtles look first to see if there is a turtle directly in front of it,
;; if so, set own speed to front turtle's speed and decelerate.  Otherwise, if
;; look-ahead is set for 2, look ahead one more patch and do the same.  If no front
;; turtles are found, accelerate towards speed-limit

to drive
  ;; first determine average speed of the cars
  set average-speed ((sum [speed] of turtles) / number)
  set-current-plot ""Car Speeds""
  set-current-plot-pen ""average""
  plot average-speed
  set-current-plot-pen ""max""
  plot (max [speed] of turtles)
  set-current-plot-pen ""min""
  plot (abs (min [speed] of turtles) )
  set-current-plot-pen ""selected-car""
  plot ([speed] of selected-car)

  ask turtles
  [
    ifelse (any? turtles-at 1 0)
    [
      set speed ([speed] of (one-of (turtles-at 1 0)))
      decelerate
    ]
    [
      ifelse (look-ahead = 2)
      [
        ifelse (any? turtles-at 2 0)
        [
          set speed ([speed] of (one-of turtles-at 2 0))
          decelerate
        ]
        [accelerate]
      ]
      [accelerate]
    ]
    if (speed < 0.01)
    [ set speed 0.01 ]
    if (speed > speed-limit)
    [ set speed speed-limit ]
    ifelse (change? = false)
    [ signal ]
    [ change-lanes ]
    ;; Control for making sure no one crashes.
    ifelse (any? turtles-at 1 0) and (xcor != min-pxcor - .5)
    [ set speed [speed] of (one-of turtles-at 1 0) ]
    [
      ifelse ((any? turtles-at 2 0) and (speed > 1.0))
      [
        set speed ([speed] of (one-of turtles-at 2 0))
        fd 1
      ]
      [jump speed]
    ]
  ]
  tick
end

;; increase speed of cars
to accelerate  ;; turtle procedure
  set speed (speed + (speed-up / 1000))
end

;; reduce speed of cars
to decelerate  ;; turtle procedure
  set speed (speed - (slow-down / 1000))
end

;; undergoes search algorithms
to change-lanes  ;; turtle procedure
  ifelse (patience <= 0)
  [
    ifelse (max-patience <= 1)
    [ set max-patience (random 10) + 1 ]
    [ set max-patience (max-patience - (random 5)) ]
    set patience max-patience
    ifelse (target-lane = 0)
    [
      set target-lane 1
      set lane 0
    ]
    [
      set target-lane 0
      set lane 1
    ]
  ]
  [ set patience (patience - 1) ]

  ifelse (target-lane = lane)
  [
    ifelse (target-lane = 0)
    [
      set target-lane 1
      set change? false
    ]
    [
      set target-lane 0
      set change? false
    ]
  ]
  [
    ifelse (target-lane = 1)
    [
      ifelse (pycor = 2)
      [
        set lane 1
        set change? false
      ]
      [
        ifelse (not any? turtles-at 0 1)
        [ set ycor (ycor + 1) ]
        [
          ifelse (not any? turtles-at 1 0)
          [ set xcor (xcor + 1) ]
          [
            decelerate
            if (speed <= 0)
            [ set speed 0.1 ]
          ]
        ]
      ]
    ]
    [
      ifelse (pycor = -2)
      [
        set lane 0
        set change? false
      ]
      [
        ifelse (not any? turtles-at 0 -1)
        [ set ycor (ycor - 1) ]
        [
          ifelse (not any? turtles-at 1 0)
          [ set xcor (xcor + 1) ]
          [
            decelerate
            if (speed <= 0)
            [ set speed 0.1 ]
          ]
        ]
      ]
    ]
  ]
end

to signal
  ifelse (any? turtles-at 1 0)
  [
    if ([speed] of (one-of (turtles-at 1 0))) < (speed)
    [ set change? true ]
  ]
  [ set change? false ]
end

to select-car
  if (mouse-down?)
  [
    let mx mouse-xcor
    let my mouse-ycor
    if (any? turtles-on patch mx my)
    [
      ask selected-car [ set color black ]
      set selected-car one-of turtles-on patch mx my
      ask selected-car [ set color red ]
    ]
  ]
end

to setup-plots
  ;; This plot shows the different car speeds
  set-current-plot ""Car Speeds""
  set-plot-y-range 0 ((max [speed-limit] of turtles) + .5)
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Traffic 2 Lanes model.
; http://ccl.northwestern.edu/netlogo/models/Traffic2Lanes.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Traffic2Lanes
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This project is a more sophisticated two-lane version of the ""Traffic Basic"" model.  Much like the simpler model, this model demonstrates how traffic jams can form. In the two-lane version, drivers have a new option; they can react by changing lanes, although this often does little to solve their problem.

As in the traffic model, traffic may slow down and jam without any centralized cause.


HOW TO USE IT
-------------
Click on the SETUP button to set up the cars. Click on DRIVE to start the cars moving. The STEP button drives the car for just one tick of the clock.

The NUMBER slider controls the number of cars on the road. The LOOK-AHEAD slider controls the distance that drivers look ahead (in deciding whether to slow down or change lanes). The SPEED-UP slider controls the rate at which cars accelerate when there are no cars ahead. The SLOW-DOWN slider controls the rate at which cars decelerate when there is a car close ahead.

You may wish to slow down the model with the speed slider to watch the behavior of certain cars more closely.

The SELECT-CAR button allows you to pick a car to watch. It turns the car red, so that it is easier to keep track of it. SELECT-CAR is best used while DRIVE is turned off. If the user does not select a car manually, a car is chosen at random to be the ""selected car"".

The AVERAGE-SPEED monitor displays the average speed of all the cars.

The CAR SPEEDS plot displays four quantities over time:
- the maximum speed of any car - CYAN
- the minimum speed of any car - BLUE
- the average speed of all cars - GREEN
- the speed of the selected car - RED


THINGS TO NOTICE
----------------
Traffic jams can start from small ""seeds."" Cars start with random positions and random speeds. If some cars are clustered together, they will move slowly, causing cars behind them to slow down, and a traffic jam forms.

Even though all of the cars are moving forward, the traffic jams tend to move backwards. This behavior is common in wave phenomena: the behavior of the group is often very different from the behavior of the individuals that make up the group.

Just as each car has a current speed and a maximum speed, each driver has a current patience and a maximum patience. When a driver decides to change lanes, he may not always find an opening in the lane. When his patience expires, he tries to get back in the lane he was first in. If this fails, back he goes... As he gets more 'frustrated', his patience gradually decreases over time. When the number of cars in the model is high, watch to find cars that weave in and out of lanes in this manner. This phenomenon is called ""snaking"" and is common in congested highways.

Watch the AVERAGE-SPEED monitor, which computes the average speed of the cars. What happens to the speed over time? What is the relation between the speed of the cars and the presence (or absence) of traffic jams?

Look at the two plots. Can you detect discernible patterns in the plots?


THINGS TO TRY
-------------
What could you change to minimize the chances of traffic jams forming, besides just the number of cars? What is the relationship between number of cars, number of lanes, and (in this case) the length of each lane?

Explore changes to the sliders SLOW-DOWN, SPEED-UP, and LOOK-AHEAD. How do these affect the flow of traffic? Can you set them so as to create maximal snaking?


EXTENDING THE MODEL
-------------------
Try to create a 'traffic-3 lanes', 'traffic-4 lanes', 'traffic-crossroads' (where two sets of cars might meet at a traffic light), or 'traffic-bottleneck' model (where two lanes might merge to form one lane).

Note that the cars never crash into each other- a car will never enter a patch or pass through a patch containing another car. Remove this feature, and have the turtles that collide die upon collision. What will happen to such a model over time?


NETLOGO FEATURES
----------------
Note the use of mouse-down? and mouse-xcor/mouse-ycor to enable selecting a car for special attention.

Each turtle has a shape, unlike in some other models. NetLogo uses SET SHAPE to alter the shapes of turtles. You can, using the shapes editor in the Tools menu, create your own turtle shapes or modify existing ones. Then you can modify the code to use your own shapes.


RELATED MODELS
--------------
Traffic Basic


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Traffic 2 Lanes model.  http://ccl.northwestern.edu/netlogo/models/Traffic2Lanes.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Traffic2Lanes for terms of use.
"
Minority Game,/models/Sample Models/Social Science/Unverified,"globals
[
  history      ;; the history of which number was the minority (encoded into a binary number)
  minority     ;; the current number in the minority
  avg-score    ;; keeps track of the turtles' average score
  stdev-score  ;; keeps tracks of the standard deviation of the turtles' scores
]

turtles-own
[
  score             ;; each turtle's score
  choice            ;; each turtle's choice
  strategies        ;; each turtle's strategies (a list of lists)
  current-strategy  ;; each turtle's current strategy (index in above list)
  strategies-scores ;; the accumulated virtual scores for each of the turtle's strategies (a list)
]

;; setup procedure
to setup
  ca
  if (memory = 1 and strategies-per-agent > 4 )  ;; prevent an infinite loop from occurring
    [ user-message word ""You need to increase the memory variable or\n""
                        ""decrease the strategies-per-agent variable""
      stop ]
  initialize-system
  initialize-turtles
  update-system
  setup-plots
end

;; resets state variables
to initialize-system
  set history random (2 ^ memory)
  set avg-score 0
  set stdev-score 0
end

;; creates the specified number of turtles
to initialize-turtles
  crt number
    [ setxy 0 (world-height * who / number)  ;; disperse over the y-axis
      set heading 90
      assign-strategies
      set current-strategy random strategies-per-agent
      set choice item history (item current-strategy strategies)
      ifelse (color-by = ""choice"")
        [ recolor-by-choice ]
        [ set color green ]  ;; we initially set all to green to prevent divide by zero error
      set score 0
      set strategies-scores n-values strategies-per-agent [0] ]
end

;; gives the turtles their allotted number of unique strategies
to assign-strategies  ;; turtle procedure
  set strategies []
  while [ length remove-duplicates strategies < strategies-per-agent ]
    [ set strategies n-values strategies-per-agent [create-strategy] ]
end

;; reports a random strategy (a list of 1 or 0's)
to-report create-strategy
  report n-values (2 ^ memory) [random 2]
end

to setup-plots
  clear-all-plots
  set-current-plot ""Number Picking Zero""
  set-plot-y-range 0 number
  set-current-plot ""Success histogram""
  set-histogram-num-bars 25
  do-plot  ;; plot initial value
end

to go
  ask turtles [ update-scores-and-strategy ]
  set history decimal (lput minority but-first full-history)
  ask turtles [ update-choice-and-color ]
  tick
  update-system
  do-plot
  move-turtles
end

;; moves the turtles about the world (a visual aid to see their collective behavior)
to move-turtles
  ask turtles [ fd score / avg-score ]
end

;; updates minority, avg-score, and stdev-score globals
to update-system
  let num-picked-zero count turtles with [choice = 0]
  ifelse (num-picked-zero <= (number - 1) / 2)
    [ set minority 0 ]
    [ set minority 1 ]
  ;; plot this here for speed or optimization
  set-current-plot ""Number Picking Zero""
  plot num-picked-zero

  set avg-score mean [score] of turtles
  set stdev-score standard-deviation [score] of turtles
end

;; updates turtle's score and their strategies' virtual scores
to update-scores-and-strategy  ;; turtles procedure
  increment-scores
  let max-score max strategies-scores
  let max-strategies []
  let counter 0
  ;; this picks a strategy with the largest virtual score
  foreach strategies-scores
    [ if (? = max-score)
        [ set max-strategies lput counter max-strategies ]
      set counter counter + 1 ]
  set current-strategy one-of max-strategies
  if (choice = minority)
    [ set score score + 1 ]
end

;; this increases the virtual scores of each strategy
;; that selected the minority
to increment-scores  ;; turtles procedure
  ;; here we use MAP to simultaneously walk down both the list
  ;; of strategies, and the list of those strategies' scores.
  ;; ?1 is the current strategy, and ?2 is the current score.
  ;; For each strategy, we check to see if that strategy selected
  ;; the minority.  If it did, we increase its score by one,
  ;; otherwise we leave the score alone.
  set strategies-scores
      (map [ifelse-value (item history ?1 = minority)
              [?2 + 1] [?2]]
           strategies strategies-scores)
end

;; updates turtle's choice and re-colors them
to update-choice-and-color ;; turtles procedure
  set choice (item history (item current-strategy strategies))
  ifelse (color-by = ""choice"")
    [ recolor-by-choice ]
    [ recolor-by-success ]
end

to recolor-by-choice ;; turtles procedure
  ifelse (choice = 0)
      [ set color red ]
      [ set color blue ]
end

to recolor-by-success ;; turtles procedure
  ifelse (score > avg-score + stdev-score)
    [ set color red ]
    [ ifelse (score < avg-score - stdev-score)
        [ set color blue ]
        [ set color green ] ]
end

;; updates the plots three of the four plots.  one is updated in the update-system procedure
to do-plot
  let max-score max [score] of turtles
  let min-score min [score] of turtles
  set-current-plot ""Success rate""
  if (ticks != 0)
    [ set-current-plot-pen ""max""
      plot max-score / ticks
      set-current-plot-pen ""min""
      plot min-score / ticks
      set-current-plot-pen ""avg""
      plot avg-score / ticks
      set-current-plot ""Success histogram""
      histogram [score / ticks] of turtles ]
  set-current-plot ""Scores""
  set-current-plot-pen ""max""
  plot max-score
  set-current-plot-pen ""min""
  plot min-score
  set-current-plot-pen ""avg""
  plot avg-score
end

;; reports the history in binary format (with padding if needed)
to-report full-history
  report sentence n-values (memory - length binary history) [0] (binary history)
end

;; converts a decimal number to a binary number (stored in a list of 0's and 1's)
to-report binary [decimal-num]
  let binary-num []
  loop
    [ set binary-num fput (decimal-num mod 2) binary-num
      set decimal-num int (decimal-num / 2)
      if (decimal-num = 0)
        [ report binary-num ] ]
end

;; converts a binary number (stored in a list of 0's and 1's) to a decimal number
to-report decimal [binary-num]
  report reduce [(2 * ?1) + ?2] binary-num
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2004 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2004).  NetLogo Minority Game model.
; http://ccl.northwestern.edu/netlogo/models/MinorityGame.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2004 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/MinorityGame
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This is a simplified model of what takes place in an economic market.  In each time step, agents choose one of two sides, 0 or 1, and those on the minority side win a point.  This problem is inspired by the ""El Farol"" bar problem.  Each agent uses a finite set of strategies to make their decision based upon past record; however, the record consists only of which side, 0 or 1, was in the minority, not the actual population count of how many chose each side.


HOW IT WORKS
------------
Each agent begins with a score of 0 and STRATEGIES-PER-AGENT strategies. Initially, they choose a random one of these strategies to use.  The initial historical record is generated randomly.  If their current strategy correctly predicted whether 0 or 1 would be the minority, they add one point to their score.  Each strategy also earns virtual points according to if it would have been correct or not.  From then on, the agents will then use their strategy with the highest virtual point total to predict whether they should select 0 or 1.

This strategy consist of a list of 1's and 0's that is 2^MEMORY long.  The choice the turtle then makes is based off of the history of past choices.  This history is also a list of 1's and 0's that is MEMORY long, but it is encoded into a binary number.  The binary number is then used as an index into the strategy list to determine the choice.

This means that once the number of agents, the number of strategies, and the length of the historical record are chosen, all parameters are fixed and the behavior of the system is of interest.


HOW TO USE IT
-------------
GO: Starts and stops the model.

SETUP: Resets the simulation according to the parameters set by the sliders.

NUMBER: Sets the number of agents to participate.  This is always odd to insure a minority.

MEMORY: Sets the length of the history which the agents use to predict their behavior.  Most interesting between 3 and 12, though there is some interesting behavior at 1 and 2.  Note that when using a MEMORY of 1, the STRATEGIES-PER-AGENT needs to be 4 or less.

STRATEGIES-PER-AGENT: Sets the number of strategies each agent has in their toolbox.  Five is typically a good value.  However, this can be changed for investigative purposes using the slider, if desired.

COLOR-BY: ""Choice"" represents the agents changing their colors depending on if they have chosen 0 (red) or 1 (blue).  ""Success"" represents the agents changing their color depending upon their success rate (the number of times they have been in the minority divided by the number of selections).  An agent is green if they are within one standard deviation above or below the mean success rate, red if they are more than one standard deviation above, and blue if they are more than one standard deviation below.

**RECOMMENDED SETTINGS: NUMBER=501, MEMORY=6, STRATEGIES-PER-AGENT=5 (Should be loaded by default)

**CAUTION: If you are on a slow computer and the model is likewise slow, try turning off the shapes in the view.  You could also turn off the view as the plots show everything the view does, just in a different representation. Also, beware setting the MEMORY slider to higher values.  It scales exponentially (2^MEMORY), however this only has an affect when SETUP is run.  This means that for each increased unit of MEMORY, it takes twice as long for SETUP to run.


THINGS TO NOTICE
----------------
There are two extremes possible for each turn: the size of the minority is 1 agent or (NUMBER-1)/2 agents (since NUMBER is always odd).  The former would represent a ""wasting of resources"", while the latter represents a situation which is more ""for the common good.""  However, each agent acts in an inherently selfish manner, as they care only if they and they alone are in the minority.  Nevertheless, the latter situation is prevalent.  Does this represent unintended cooperation between agents, or merely coordination and well developed powers of prediction?

The agents move according to how successful they are relative to the mean success rate.  After running for about 100 time steps (at just about any parameter setting), how do the fastest and slowest agents compare?  What does this imply?


THINGS TO TRY
-------------
Notice how the population of agents choosing 0 stays close to NUMBER/2.  How do the deviations change as you change the value of MEMORY?

How do things change if you keep everything the same but change the STRATEGIES-PER-AGENT?


EXTENDING THE MODEL
-------------------
There are a few evolutionary possibilities for this model which could be coded.

(1) Maybe after some (long) amount of time, the least successful agent is replaced by a clone of the most successful agent, with zeroed scores and possibly mutated strategies.  How would things change then?

(2) Similar to (1), you could start the agents with a very small memory value, and again replace the least successful agent with a clone of the most successful agent.  But this time instead of just zeroing the scores and giving mutated strategies, you also add or subtract one unit of memory for the new agent.  What would happen here? Would their brains continue to get bigger or find some happy value?  Would people with small memory be altogether eliminated, or would they survive (maybe even still thrive)?


NETLOGO FEATURES
----------------
One feature which was instrumental to this program was the n-values primitive.  When setting up strategies for each player, they are binary numbers (stored in lists) of 2^MEMORY values. If this was done by starting with an empty list and calling fput 2^MEMORY times for each agent and for each strategy, you are calling fput NUMBER * STRATEGIES-PER-AGENT * (2^MEMORY) times.  Using n-values sped this up by about 2 or 3 orders of magnitude.

The primitives map and reduce were also used to simplify code.


RELATED MODELS
--------------
Any of the Prisoner's Dilemma models
Altruism
Cooperation


CREDITS AND REFERENCES
----------------------
Original implementation: Daniel B. Stouffer, for the Center for Connected Learning and Computer-Based Modeling.

This model was based upon studies by Dr. Damien Challet, et al.
Information can be found on the web at http://www.unifr.ch/econophysics/minority/

Challet, D. and Zhang, Y.-C. Emergence of Cooperation and Organization in an Evolutionary Game. Physica A 246, 407 (1997).

Zhang, Y.-C. Modeling Market Mechanism with Evolutionary Games. Europhys. News 29, 51 (1998).

To refer to this model in academic publications, please use:  Wilensky, U. (2004).  NetLogo Minority Game model.  http://ccl.northwestern.edu/netlogo/models/MinorityGame.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2004 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/MinorityGame for terms of use.
"
Cash Flow,/models/Sample Models/Social Science/Unverified,"globals [
  bank-loans
  bank-reserves
  bank-deposits
  bank-to-loan
  xmax
  ymax
  rich
  poor
  middle-class
  income-max
]

turtles-own [
  savings
  loans
  wallet
  temp-loan
  wealth
  customer
]

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;                     ;;;
;;;  Setup Procedures   ;;;
;;;                     ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;


to setup
  ca
  initialize-settings
  crt people [setup-turtles]
  poll-class
  setup-bank
  setup-plots
  do-plots
end


to initialize-settings
  set rich 0
  set poor 0
  set middle-class 0
  set income-max 10
end

to setup-turtles  ;;Turtle Procedure
  set shape ""person""
  setxy random-xcor random-ycor
  set wallet (random 2 * income-max)
  set savings 0
  set loans 0
  set wealth 0
  set customer -1
  get-color
end

to setup-bank
  set bank-loans 0
  set bank-reserves 0
  set bank-deposits 0
  set bank-to-loan 0
end

to setup-plots
  set xmax 300
  set ymax (2 * money-total)
  clear-all-plots
  setup-plot1
  setup-plot2
  setup-plot3
  setup-histogram
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;                     ;;;
;;; Run Time Procedures ;;;
;;;                     ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

to go
  ask turtles [do-business]
  ask turtles [
    balance-books
    get-color
  ]
  bank-balance-sheet
  poll-class
  tick
  do-plots
end

;; polls the number in each corresponding economic class
to poll-class
  set rich (count turtles with [savings > income-max])
  set poor (count turtles with [loans > income-max])
  set middle-class (count turtles) - (rich + poor)
end

to do-business  ;;Turtle Procedure
  rt random 360
  fd 1
  ;; turtle has money to trade with, and there is
  ;; another turtle to trade with on the same patch
  if ((savings > 0) or (wallet > 0) or (bank-to-loan > 0)) [
    set customer one-of other turtles-here
    if customer != nobody and (random 2) = 0          ;;50% chance of trading
      [ifelse (random 2 = 0)                          ;;50% chance of trading $2 or $5, if trading
         [ask customer [set wallet wallet + 5]
          set wallet (wallet - 5)]
         [ask customer [set wallet wallet + 2]
          set wallet (wallet - 2)]
      ]
  ]
end

;; Check the balance of our wallet.
;; Put a positive balance in savings.  Try to get a loan to cover a
;; negative balance.  If we cannot get a loan (if bank-to-loan < 0)
;; then maintain the negative wallet balance until the next round.
to balance-books  ;;Turtle Procedure
  ifelse (wallet < 0)
   [ifelse (savings >= (- wallet))
      [withdraw-from-savings (- wallet)]
      [if (savings > 0)
         [withdraw-from-savings savings]
       set temp-loan bank-to-loan
       ifelse (temp-loan >= (- wallet))
         [take-out-a-loan (- wallet)]
         [take-out-a-loan temp-loan]
      ]
   ]
   [deposit-to-savings wallet]

;; repay loans if savings are available
  if (loans > 0) and (savings > 0) [
    ifelse (savings >= loans)
      [withdraw-from-savings loans
       repay-a-loan loans]
      [withdraw-from-savings savings
       repay-a-loan wallet]
  ]
end


;; Sets aside required amount from liabilities into
;; reserves, regardless of outstanding loans.  This may
;; result in a negative bank-to-loan amount, which
;; means that the bank will be unable to loan money
;; until it can set enough aside to account for reserves.
to bank-balance-sheet
  set bank-deposits sum [savings] of turtles
  set bank-loans sum [loans] of turtles
  set bank-reserves ((reserves / 100) * bank-deposits)
  set bank-to-loan (bank-deposits - (bank-reserves + bank-loans))
end


to deposit-to-savings [amount]  ;; Turtle Procedure
  set wallet (wallet - amount)
  set savings (savings + amount)
end

to withdraw-from-savings [amount]  ;; Turtle Procedure
  set wallet (wallet + amount)
  set savings (savings - amount)
end


to repay-a-loan [amount]  ;; Turtle Procedure
  set loans (loans - amount)
  set wallet (wallet - amount)
  set bank-to-loan (bank-to-loan + amount)
end

to take-out-a-loan [amount]  ;; Turtle Procedure
  set loans (loans + amount)
  set wallet (wallet + amount)
  set bank-to-loan (bank-to-loan - amount)
end


;; color codes the rich (green),
;; middle-class (gray), and poor (red)
to get-color ;;Turtle Procedure
  set color gray
  if (savings > income-max) [set color green]
  if (loans > income-max)  [set color red]
  set wealth (savings - loans)
end


to-report savings-total
  report sum [savings] of turtles
end

to-report loans-total
  report sum [loans] of turtles
end

to-report wallets-total
  report sum [wallet] of turtles
end

to-report money-total
  report sum [wallet + savings] of turtles
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;                     ;;;
;;; Plotting Procedures ;;;
;;;                     ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

to do-plots
  set-current-plot ""Money & Loans""
  set-current-plot-pen ""money""
  plot money-total
  set-current-plot-pen ""loans""
  plot loans-total

  set-current-plot ""Savings & Wallets""
  set-current-plot-pen ""savings""
  plot savings-total
  set-current-plot-pen ""wallets""
  plot wallets-total

  set-current-plot ""Income Dist""
  set-current-plot-pen ""rich""
  plot rich
  set-current-plot-pen ""middle""
  plot middle-class
  set-current-plot-pen ""poor""
  plot poor

  every 1 [plot-histogram]
end


to plot-histogram
  set-current-plot ""Wealth Dist Hist""
  let wealth-list [wealth] of turtles
  let min-wealth round (min wealth-list)
  let max-wealth round (max wealth-list)
  ifelse min-wealth < max-wealth
  [ set-plot-x-range min-wealth max-wealth ]
  [ set-plot-x-range min-wealth (min-wealth + 1) ]

  ;;draw gray line in center of distribution
  set-current-plot-pen ""ave-wealth""
  plot-pen-reset
  let ave-wealth mean wealth-list
  plotxy ave-wealth 0
  plotxy ave-wealth people

  set-current-plot-pen ""hist""
  set-histogram-num-bars 10
  histogram [wealth] of turtles
end


to setup-plot1
  set-current-plot ""Money & Loans""
  set-plot-x-range 0 xmax
  set-plot-y-range -50 ymax
end

to setup-plot2
  set-current-plot ""Savings & Wallets""
  set-plot-x-range 0 xmax
  set-plot-y-range -50 ymax
end

to setup-plot3
  set-current-plot ""Income Dist""
  set-plot-x-range 0 xmax
  set-plot-y-range 0 people
end


to setup-histogram
  set-current-plot ""Wealth Dist Hist""
  set-plot-y-range 0 people
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Cash Flow model.
; http://ccl.northwestern.edu/netlogo/models/CashFlow.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/CashFlow
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model is a simple extension of the model ""Bank Reserves"". The purpose of the model is to help the user examine whether there is a relationship between the reserve ratio that banks must keep and the degree of equality in the distribution of the money that exist in the system.

It models the creation of money in an economy through a private banking system. As most of the money in the economy is kept in banks but only a little of it needs to be used (i.e. in cash form) at any one time, the banks need only keep a small portion of their savings on-hand for those transactions. This portion of the total savings is known as the banks' reserves. The banks are then able to loan out the rest of their savings. The government (the user in this case) sets a reserve ratio mandating how much of the banks' holdings must be kept in reserve at a given time. One 'super-bank' is used in this model to represent all banks in an economy. As this model demonstrates, the reserve ratio is the key determiner of how much money is created in the system.

In each round, people (represented by turtles) interact with each other to simulate everyday economic activity. Given a randomly selected number, when a person is on the same patch as someone else it will either give the person two or five dollars, or no money at all. After this, people must then sort out the balance of their wallet with the bank. People will put a positive wallet balance in savings, or pay off a negative balance from funds already in savings. If the savings account is empty and the wallet has a negative balance, a person will take out a loan from the bank if funds are available to borrow (if bank-to-loan > 0). Otherwise, the person maintains the negative balance until the next round. Lastly, if someone has money in savings and money borrowed from the bank, that person will pay off as much of the loan as possible using the savings.

The number of rich people in each moment is calculated by enumerating the number of people whose savings exceed 10 dollars. The number of poor people is the number of people whose loans exceed 10 dollars. The rest of the people are considered to belong to the ""middle-class"".



HOW TO USE IT
-------------
The RESERVES slider sets the banking reserve ratio (the percentage of money that a bank must keep in reserve at a given time). The PEOPLE slider sets the number of people that will be created in the model when the SETUP button is pressed. The SETUP button resets the model: it redistributes the patch colors, creates PEOPLE people and initializes all stored values. The GO button starts and stops the running of the model and the plotter.



THINGS TO NOTICE
----------------
There are numerous display windows in the interface to help the user see where money in the economy is concentrated at a given time. SAVINGS-TOTAL indicates the total amount of money currently being kept in savings (and thus, in the banking system). LOANS-TOTAL is the amount the bank has lent out. WALLETS-TOTAL gives an indication of the total amount of money kept in the peoples' wallets. This figure may be negative at times when the bank has no more money to loan (the turtle will maintain a negative wallet balance until a loan is possible). MONEY-TOTAL indicates the total-amount of money currently in the economy (SAVINGS-TOTAL + WALLETS-TOTAL). Because WALLETS-TOTAL is generally kept at 0 in this model (we are assuming that everyone deposits all they can in savings), MONEY-TOTAL and SAVINGS TOTAL tend to be the same.

The three lower monitors show the number of rich, middle-class, or poor people. A person's color tells us whether he is rich (green color), middle-class (gray), or poor (red).

There are four plots to help you observe the operation of the economy. Plot 1 plots the number of LOANS-TOTAL and MONEY-TOTAL as a function of time.  Plot 2 plots the number of SAVINGS-TOTAL and WALLETS-TOTAL. Plot 3 plots income distribution and is the feature that you should pay the most attention to. The green pen plots the number of rich people; the black pen plots the number of middle-class people; the red pen plots the number of poor people. Finally, the fourth plot is a histogram that depicts how wealth is distributed among the population. Wealth is distributed in ten bars. Each bar corresponds to one tenth of the range of wealth.  The gray line in the histogram represents the mean wealth value of all the turtles.


THINGS TO TRY
-------------
Vary the RESERVES rate as the model runs, and watch the effect this has on income distribution. You can either watch the three Income Distribution monitors, or the Income Distribution plot.  Set RESERVES initially to 100 and observe the Income Distribution plot. Gradually lower RESERVES and see the effect on wealth distribution. Can you see whether the two of them are positively, negatively, or not related?


EXTENDING THE MODEL
--------------------
Try extending the model to include payments of interest in the banking system. People with money deposited in savings should be credited with interest on their account (at a certain rate) from the bank from time to time. People with money on loan should make interest payments on their account to the bank from time to time.

This model has turtles interact in a very simple way to have money change hands (and create a need for loans). Try changing the model so that money moves around the system in a different way.


RELATED MODELS
--------------
See ""Bank Reserves"".


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Cash Flow model.  http://ccl.northwestern.edu/netlogo/models/CashFlow.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/CashFlow for terms of use.
"
Scatter,/models/Sample Models/Social Science,"turtles-own
[
  nearby-classmates         ;; agentset of turtles within some specified radius
  closest-classmate         ;; the nearest turtle
  stopped?                  ;; if the turtle hasn't moved
  rule                      ;; the turtle's rule (the rules are named by strings)
  origin                    ;; the turtle's original position
  close-classmates          ;; turtles within the too-close range
  far-classmates            ;; turtles within the too-far range
  total-distance-moved      ;; total distance moved by the turtle
  previous-patch            ;; patch the turtle was previously on
]

globals
[
]


;;
;; SETUP AND HELPERS
;;

to setup
  ca
  set-default-shape turtles ""circle""
  make-turtles
  setup-plots
  update-plots
end

to make-turtles
  if [count patches in-radius initial-radius] of patch 0 0 < num-turtles-to-create
  [ user-message (word ""There aren't enough patches in initial-radius to create the number ""
                       ""of turtles you've asked for.  Please make initial-radius larger or decrease ""
                       ""the number of turtles."")
    stop ]
  ask patch 0 0 [
      create-initial-turtles num-random-min   ""random-min""   violet
      create-initial-turtles num-random       ""random""       brown
      create-initial-turtles num-random-away  ""random-away""  pink
      create-initial-turtles num-open-min     ""open-min""     blue
      create-initial-turtles num-open-min-max ""open-min-max"" orange ]
  set-common-variables
end

;; reports the total number of turtles the user has requested
to-report num-turtles-to-create
  report num-random-min +
         num-random +
         num-random-away +
         num-open-min +
         num-open-min-max
end

;; ask n random patches without a turtle on them that are within initial-radius of the
;; asker to sprout a turtle with the rule set to turtle-rule and color to turtle-color
to create-initial-turtles [n turtle-rule turtle-color]
  ask n-of n (patches in-radius initial-radius with [not any? turtles-here])
  [ sprout 1
    [ set rule turtle-rule
      set color turtle-color ] ]
end

;; initializes turtle variables
;; also moves the turtles a bit so that they are a bit more randomly scattered
to set-common-variables
  ask turtles
  [ set xcor xcor - 0.5 + random-float 1
    set ycor ycor - 0.5 + random-float 1
    set origin patch-here
    set stopped? false
    set total-distance-moved 0 ]
end


;;
;; GO AND TURTLE STRATEGIES
;;

to go
  if all? turtles [stopped?] [ stop ]
  ask turtles [
    set previous-patch patch-here
    if rule = ""random-min""   [ move-random-min ]
    if rule = ""random""       [ move-random ]
    if rule = ""random-away""  [ move-random-away ]
    if rule = ""open-min""     [ move-open-min ]
    if rule = ""open-min-max"" [ move-open-min-max ]
    set total-distance-moved (total-distance-moved + (distance previous-patch))
  ]
  tick
  update-plots
end

;; set a random heading and move at
;; each time step, with no stopping condition
to move-random ;; turtle procedure
  rt random 360
  avoid-walls
  fd step-size
end

;; turtle procedure: set a random heading and move until
;; all other turtles are at least ""too-close"" away
to move-random-min
  set nearby-classmates other turtles in-radius too-close
  ifelse any? nearby-classmates  ; if there aren't turtles nearby, stop, you are scattered
  [ rt random 360
    avoid-walls
    fd step-size
    set stopped? false ]
  [ set stopped? true ]
end

;; set heading in the direction opposite
;; of the closest turtle, without stopping
to move-random-away ;; turtle procedure
  set closest-classmate min-one-of other turtles [distance myself]
  face closest-classmate
  rt 180
  avoid-walls
  fd step-size
  set stopped? false
end

;; set heading towards the largest open space,
;; stopping when all other turtles are at least ""too-close"" away
to move-open-min ;; turtle procedure
  set nearby-classmates other turtles in-radius too-close
  ifelse any? nearby-classmates
  [ facexy (mean [xcor] of nearby-classmates)
           (mean [ycor] of nearby-classmates)
    rt 180
    avoid-walls
    fd step-size
    set stopped? false ]
  [ set stopped? true ]
end

;; when turtles are too close, move to an open space,
;; when turtles get too far, move in towards a more populated area, and otherwise, stop
to move-open-min-max ;; turtle procedure
  set close-classmates other turtles in-radius too-close
  set far-classmates other turtles in-radius too-far
  ifelse any? close-classmates  ; move to an open space
  [ facexy (mean [xcor] of close-classmates)
    (mean [ycor] of close-classmates)
    rt 180
    avoid-walls
    fd step-size
    set stopped? false ]
  [ ifelse not any? far-classmates  ; move to a more populated space in the 'room'
    [ facexy mean [xcor] of other turtles
      mean [ycor] of other turtles
      avoid-walls
      fd step-size
      set stopped? false ]
    [ set stopped? true ] ]
end

;; if a turtle gets to a wall, it turns around
to avoid-walls ;; turtle procedure
  if not can-move? 1
  [ rt 180 ]
end

;;
;; PLOTTING
;;

to setup-plots
  set-current-plot ""Average Distance from Origin""
  set-plot-x-range 0 30
  set-plot-y-range  0 5 ; set initial y range to half of height

  set-current-plot ""Mobility of Scatterers""
  set-plot-x-range 0 5
  set-plot-y-range 0 (max-pxcor)
end

to update-plots
  update-distance-plot
  update-concentric-histogram
end

;; for each type of turtle, plots the average distance of each
;; of the turtles from its starting spot
to update-distance-plot
  set-current-plot ""Average Distance from Origin""
  plot-rule-mean ""random-min""
  plot-rule-mean ""random-away""
  plot-rule-mean ""random""
  plot-rule-mean ""open-min""
  plot-rule-mean ""open-min-max""
end

;; if there are any turtles with turtle-rule as their rule, plot the
;; mean distance from the origin with the appropriate plot pen
to plot-rule-mean [turtle-rule]
  if any? (turtles with [rule = turtle-rule])
  [ set-current-plot-pen turtle-rule
    plot mean [distance origin] of (turtles with [rule = turtle-rule]) ]
end

;; a histogram of the total distance traveled by turtles,
;; grouped in concentric circles from the center patch
to update-concentric-histogram
  set-current-plot ""Mobility of Scatterers""
  plot-pen-reset
  ; between the center patch and max-pxcor/4
  set-plot-pen-color red
  if (any? turtles with [(distancexy 0 0) <= ((world-width - 1) / 8)])
  [ ask patch 0 0
    [ plot mean [total-distance-moved] of (turtles with [(distancexy 0 0) <= ((world-width - 1) / 8)])
                            ] ]
  ; between max-pxcor/4 and max-pxcor/2
  if (any? turtles with [((distancexy 0 0) > ((world-width - 1) / 8)) and
                         ((distancexy 0 0) <= ((world-width - 1) / 4))])
  [ set-plot-pen-color green
    ask patch 0 0
    [ plot mean [total-distance-moved] of (turtles with [((distancexy 0 0) > ((world-width - 1) / 8)) and
                                           ((distancexy 0 0) <= ((world-width - 1) / 4))])
                            ] ]
  ; between max-pxcor/2 and (3/4)max-pxcor
  if (any? turtles with [((distancexy 0 0) > ((world-width - 1) / 4)) and
                         ((distancexy 0 0) <= (3 * (world-width - 1) / 8))])
  [ set-plot-pen-color violet
    ask patch 0 0
    [ plot mean [total-distance-moved] of (turtles with [((distancexy 0 0) > ((world-width - 1) / 4)) and
                                           ((distancexy 0 0) <= (3 * (world-width - 1) / 8))])
                            ] ]
  ; between (3/4)max-pxcor and max-pxcor
  if (any? turtles with [((distancexy 0 0) > (3 * ((world-width - 1) / 8)) and
                         ((distancexy 0 0) <= ((world-width - 1) / 2 )))] )
  [ set-plot-pen-color orange
    ask patch 0 0
    [ plot mean [total-distance-moved] of (turtles with [((distancexy 0 0) > ( 3 * ((world-width - 1) / 8)) and
                                           ((distancexy 0 0) <= (world-width - 1) / 2))])
                            ] ]
  ; everything outside of max-pxcor
  if (any? turtles with [(distancexy 0 0) > (world-width - 1) / 2])
  [ set-plot-pen-color blue
    ask patch 0 0
    [ plot mean [total-distance-moved] of (turtles with [(distancexy 0 0) > (world-width - 1) / 2])
                            ] ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2004 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2004).  NetLogo Scatter model.
; http://ccl.northwestern.edu/netlogo/models/Scatter.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2004 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Scatter
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model simulates students' ideas about scattering, which takes place just before exercising in gym. The students in a class start out all bunched up, and the teacher asks them to spread out or scatter.  This simulation shows the spread of the group when the individual students follow simple rules to decide whether to move and where.  The scatterers move according to rules that were gleaned from several interviews with sixth-grade students.

The students were asked: ""At the beginning of a Physical Education class, the students are standing close together. The teacher tells the students to scatter so they may perform calisthenics. What happens? Can you describe and explain?""  The students described the scattering process verbally, using coins to simulate the process and drawing a series of pictures to depict the succeeding steps.


HOW IT WORKS
------------
This model implements several scattering rules, which the user can mix and match:

RANDOM-MIN: Move in a random direction until you are far enough away from all of your neighbors. Random-min turtles (the violet ones) set their heading and move in a random direction if and only if there are turtles that are too close.

OPEN-MIN: Move into the largest open nearby space until you are far enough away from all of your neighbors. Open-min turtles (blue) also stop when other turtles are too close. If there are turtles that are too close, they find the heading that will take them to the largest open space.

OPEN-MIN-MAX: Move into the largest open nearby space until you are far enough away, but not too far. If you're too close, move away. If you're too far, move closer. The open-min-max turtles (orange) move to the largest open space if other turtles are too close. If the other turtles are too far away (that is, there aren't turtles within a certain space), the turtle in question moves to a more populated area.

Two of the scattering rules do not have stopping conditions, so they continue scattering indefinitely:

RANDOM-AWAY: Move in a random direction away from the person that is closest too you. Random-away turtles (pink) look at the turtle closest to them and move in the opposite direction.

RANDOM: Move about randomly, disregarding all other scatterers. Random turtles (brown) just run around in a random direction, never looking at the turtles around them.

The scattering students move at equal speeds, if they move at all. Two students cannot occupy the same location. Whether or not to move and where to move depends on each of the rules that are described. The color of the scattering students reflects the rule that they are following.


HOW TO USE IT
-------------
Use the sliders to the right of the view to specify the number of turtles to create with each rule.

With the first three rules, the TOO-CLOSE slider sets the distance, in patches, that the turtles must be away from other turtles before stopping. The NUM-RANDOM-MIN slider indicates the number of turtles to create that move in a random direction, stopping when they are at least the distance specified by TOO-CLOSE from other turtles. Use the NUM-OPEN-MIN slider to specify how many turtles to create that move to the largest open space if there are turtles within TOO-CLOSE.

NUM-OPEN-MIN-MAX specifies the number of turtles to create that must have turtles within a certain range in order to stop. TOO-CLOSE indicates how far away other turtles must be for a turtle to stop, and TOO-FAR indicates how close the turtle in question must be to at least another turtle for it to stop.

The NUM-RANDOM-AWAY slider indicates the number of turtles to create that move away from the closest turtle, without ever stopping. NUM-RANDOM indicates the number of turtles that move in random directions without stopping.

To indicate the radius within which you want the turtles to be initially scattered, use the INITIAL-RADIUS slider. INITIAL-RADIUS must be large enough to fit the number of turtles indicated by the above sliders. See NetLogo Features, below.

To vary the distance that a turtle moves each time step, change the STEP-SIZE slider.

Press SETUP to create the number of turtles indicated, in the INITIAL-RADIUS specified. Press GO to start the model and the plots.

The plot AVERAGE DISTANCE FROM ORIGIN shows the average distance that turtles of a certain rule have moved from their original position over time. It is color-coded to match the colors of the turtles. To observe the average distance of turtles of a certain rule, watch the line of the same color.

The MOBILITY OF SCATTERERS histogram displays the average total distance moved by turtles within a certain range away from the origin. Each of the bars plots the average total distance of turtles in five concentric circles radiating from the center patch. Note that this differs from that of the AVERAGE DISTANCE FROM ORIGIN plot, which measures the distance from the turtle's present spot to its original spot, in that it adds up each step taken by the turtle.

The TICKS monitor displays the number of clock cycles that GO has run.


THINGS TO NOTICE
----------------
While the group is spreading, notice the individual turtles' routes.  You can use the ""watch turtle"" functionality (by clicking on a turtle) or pen-downing a single turtle to observe its path.  Try this with a number of turtles. How do the individual and group patterns relate?

Like two people walking towards each other down a hallway trying to avoid colliding, the rules of the turtles deciding their heading based on other turtles can conflict. For instance, several neighboring turtles moving to the largest open space may choose to move to the same open spot and, in doing so, move closer to the other turtles. This can form clusters of turtles, even while the group is spreading and even in the periphery of the group.

Certain rules get to a settled, or scattered, state more quickly than others do. Which rules are better for efficient scattering?

Observe the shape of the ""Average distance from Origin"" plot: Why is it shaped the way it is?  What other phenomena behave in a similar way?

When observing the MOBILITY OF SCATTERERS plot, notice how scatterers farther on the outside will sometimes move a greater total distance or a smaller total distance, depending on the rule.

There are often threshold values where the scatterers will never settle down, and the model will not stop. For instance, if TOO-CLOSE is too great and there are too many turtles, they will never have enough room to completely scatter.

Some of the rules produce a more ordered end formation than others. Why is this, and which ones exhibit this behavior?  Do any regions show higher densities than others?

When certain rules are mixed together, segregation occurs. That is, turtles of a certain rule tend to be surrounded by more turtles of the same rule than not. Which combinations of rules produce this segregation more than others?


THINGS TO TRY
-------------
When experimenting with the move-into-range turtles, vary the TOO-CLOSE and TOO-FAR sliders concurrently with the STEP-SIZE slider. If the step size is too big and the TOO-CLOSE and TOO-FAR values creating too narrow of a range, will the scatterers ever settle?

Try mixing rules to explore how turtles of different rules interact with each other.

Watch what happens when a few random-scatter turtles run around a set of turtles with stopping conditions, like move-to-open-space turtles.

Vary the STEP-SIZE slider, and see what effect this has on the model. Does a bigger step size make for more or less efficient scattering?

Try varying INITIAL-RADIUS to make the starting formation tighter or more spread out.

Pen-down one turtle, and watch its path as it moves about the world. How does it compare with the group?

Which rule seems to simulate real situations of scattering people?


EXTENDING THE MODEL
-------------------
Try to think of other rules that scatterers follow. For example, figure out rules to get the turtles to fill up the entire space. Alternatively, turtles could move towards a friend or away from an enemy. Also, try to think of stopping conditions other than being a certain distance from other turtles.

Turtles could have a variable ""stubbornness,"" which indicates how likely a turtle is to move or not. A dawdle or friendliness variable could indicate a likeliness to hang around other turtles.

Try giving the scatterers the ability to back track. For instance, if a scatterer moving to an open space finds that their movement takes them to a more populated area, they could move back to where they were before.

Allow turtle to have varying speeds or step sizes, simulating the differing stride lengths of individual scatterers

Devise other ways to model the scattering in the aggregate sense; for example, measure the density in a certain area.

What if there was a location (e.g. a fire) that people were trying to get away from while scattering?  Devise a way to model such a situation.  You can include physical structures, such as walls and doors.


NETLOGO FEATURES
----------------
The model creates turtles by asking patches to sprout a turtle initialized with a certain rule. Because a patch can only sprout one turtle, only a certain number of turtles can fit in a certain radius. The model verifies that the user hasn't asked for more turtles than can fit in the initial-radius specified to avoid an error.


CREDITS AND REFERENCES
----------------------
The study is described in Levy, S.T., & Wilensky, U. (2004). Making sense of complexity: Patterns in forming causal connections between individual agent behaviors and aggregate group behaviors. In U. Wilensky (Chair) and S. Papert (Discussant) Networking and complexifying the science classroom: Students simulating and making sense of complex systems using the HubNet networked architecture. The annual meeting of the American Educational Research Association, San Diego, CA, April 12 - 16, 2004. http://ccl.northwestern.edu/papers/midlevel-AERA04.pdf

Thanks to Stephanie Bezold for her work on this model.

To refer to this model in academic publications, please use:  Wilensky, U. (2004).  NetLogo Scatter model.  http://ccl.northwestern.edu/netlogo/models/Scatter.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2004 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Scatter for terms of use.
"
El Farol,/models/Sample Models/Social Science,"globals [
  attendance        ;; the current attendance at the bar
  history           ;; list of past values of attendance
  home-patches      ;; agentset of green patches
  bar-patches       ;; agentset of blue patches
  crowded-patch     ;; patch where we show the ""CROWDED"" label
]

turtles-own [
  strategies      ;; list of strategies
  best-strategy   ;; index of the current best strategy
  attend?         ;; true if the agent currently plans to attend the bar
  prediction      ;; current prediction of the bar attendance
]

to setup
  clear-all
  set-default-shape turtles ""person""

  ;; create the 'homes'
  set home-patches patches with [pycor < 0 or (pxcor <  0 and pycor >= 0)]
  ask home-patches [ set pcolor green ]

  ;; create the 'bar'
  set bar-patches patches with [pxcor > 0 and pycor > 0]
  ask bar-patches [ set pcolor blue ]

  ;; initialize the previous attendance randomly so the agents have a history
  ;; to work with from the start
  set history n-values (memory-size * 2) [random 100]
  set attendance first history

  ;; use one of the patch labels to visually indicate whether or not the
  ;; bar is ""crowded""
  ask patch (0.75 * max-pxcor) (0.5 * max-pycor) [
    set crowded-patch self
    set plabel-color red
  ]

  ;; create the agents and give them random strategies
  crt 100 [
    set color white
    move-to-empty-one-of home-patches
    set strategies n-values number-strategies [random-strategy]
    set best-strategy first strategies
    update-strategies
  ]

  ;; plot the initial state
  update-plots
end


to go
  ;; update the global variables
  ask crowded-patch [ set plabel """" ]
  ;; have each agent predict attendance at the bar and decide whether or not to go
  ask turtles [
    set prediction predict-attendance best-strategy sublist history 0 memory-size
    set attend? (prediction <= overcrowding-threshold)  ;; true or false
  ]
  ;; depending on their decision the turtles go to the bar or stay at home
  ask turtles [
    ifelse attend?
      [ move-to-empty-one-of bar-patches
        set attendance attendance + 1 ]
      [ move-to-empty-one-of home-patches ]
  ]

  ;; if the bar is crowded indicate that on the view
  set attendance count turtles-on bar-patches
  if attendance > overcrowding-threshold [
    ask crowded-patch [ set plabel ""CROWDED"" ]
  ]
  ;; plot the results and update the attendance history
  update-plots
  set history fput attendance but-last history
  ;; have the agents decide what the new best strategy is
  ask turtles [ update-strategies ]
  ;; advance the clock
  tick
end

;; determines which strategy would have predicted the best results had it been used this round.
;; the best strategy is the one that has the sum of smallest difference between the
;; current attendance and the predicted attendance for each of the preceding
;; weeks (going back MEMORY-SIZE weeks)
to update-strategies
  let best-score memory-size * 100 + 1
  foreach strategies [
    let score 0
    let week 1
    repeat memory-size [
      set prediction predict-attendance ? sublist history week (week + memory-size)
      set score score + abs (item (week - 1) history - prediction)
      ;set score score + abs (current-attendance - prediction)
      set week week + 1
    ]
    if (score <= best-score) [
      set best-score score
      set best-strategy ?
    ]
  ]
end

;; plots the current-attendance vs. the ticks and the threshold
to update-plots

  ;; plot the attendance
  set-current-plot-pen ""attendance""
  plotxy ticks attendance

  ;; plot a threshold line -- an attendance level above this line makes the bar
  ;; unappealing, but below this line unappealing
  set-current-plot-pen ""threshold""
  plot-pen-reset
  plotxy 0 overcrowding-threshold
  plotxy plot-x-max overcrowding-threshold
end

;; this reports a random strategy. a strategy is just a set of weights from -1.0 to 1.0 which
;; determines how much emphasis is put on each previous time period when making
;; an attendance prediction for the next time period
to-report random-strategy
  report n-values (memory-size + 1) [1.0 - random-float 2.0]
end

;; This reports an agent's prediction of the current attendance
;; using a particular strategy and portion of the attendance history.
;; More specifically, the strategy is then described by the formula
;; p(t) = x(t - 1) * a(t - 1) + x(t - 2) * a(t -2) +..
;;      ... + x(t - MEMORY-SIZE) * a(t - MEMORY-SIZE) + c * 100,
;; where p(t) is the prediction at time t, x(t) is the attendance of the bar at time t,
;; a(t) is the weight for time t, c is a constant, and MEMORY-SIZE is an external parameter.
to-report predict-attendance [strategy subhistory]
  ;; the first element of the strategy is the constant, c, in the prediction formula.
  ;; one can think of it as the the agent's prediction of the bar's attendance
  ;; in the absence of any other data
  ;; then we multiply each week in the history by its respective weight
  report first strategy + sum (map [?1 * ?2] butfirst strategy subhistory)
end

;; In this model it doesn't really matter exactly which patch
;; a turtle is on, only whether the turtle is in the home area
;; or the bar area.  Nonetheless, to make a nice visualization
;; this procedure is used to ensure that we only have one
;; turtle per patch.
to move-to-empty-one-of [locations]  ;; turtle procedure
  move-to one-of locations
  while [any? other turtles-here] [
    move-to one-of locations
  ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2007 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Rand, W. and Wilensky, U. (2007). NetLogo El Farol model.
; http://ccl.northwestern.edu/netlogo/models/ElFarol.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2007 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/ElFarol
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
El Farol is a bar in Santa Fe, New Mexico.  The bar is popular -- especially on Thursday nights when the offer Irish music -- but sometimes becomes overcrowded and unpleasant. In fact, if the patrons of the bar think it will be overcrowded they stay home; otherwise they go enjoy themselves at El Farol.  This model explores what happens to the overall attendance at the bar on these popular Thursday evenings, as the patrons use different strategies for determining how crowded they think the bar will be.

El Farol was originally put forth by Brian Arthur (1994) as an example of how one might model economic systems of boundedly rational agents who use inductive reasoning.


HOW IT WORKS
------------
An agent will go to the bar on Thursday night if they think that there will not be more than a certain number of people there -- a number given by the OVERCROWDING-THRESHOLD.  To predict the attendance for any given week, each agent has access to a set of prediction strategies and the actual attendance figures of the bar from previous Thursdays.  A prediction strategy is represented as a list of weights that determines how the agent believes that each time period of the historical data affects the attendance prediction for the current week.  This definition of a strategy is based on an implementation of Arthur's model as revised by David Fogel et al. (1999).  The agent decides which one of its strategies to use by determining which one would have done the best had they used it in the preceding weeks.

The number of strategies an agent has is given by NUMBER-STRATEGIES, and distributed randomly to the agents.  The length of the attendance history the agents can use for a prediction or evaluation of a strategy is given by MEMORY-SIZE.


HOW TO USE IT
-------------
To use the model, set the NUMBER-STRATEGIES, OVERCROWDING-THRESHOLD and MEMORY size, press SETUP, and then GO.

The plot shows the average attendance at the bar over time.


THINGS TO NOTICE
----------------
The green part of the world represents the homes of the patrons, while the blue part of the world represents the El Farol Bar.  Over time the attendance will increase and decrease but its mean value comes close to the OVERCROWDING-THRESHOLD.


THINGS TO TRY
-------------
Try running the model with different settings for MEMORY-SIZE and NUMBER-STRATEGIES.  What happens to the variability in attendance as you decrease NUMBER-STRATEGIES?  What happens to the variability in the plot if you decrease MEMORY-SIZE?


EXTENDING THE MODEL
-------------------
Currently the weights that determine each strategy are randomly generated.  Try altering the weights so that they only reflect a mix of the following agent strategies:
- always predict the same as last week's attendance
- an average of the last several week's attendance
- the same as 2 weeks ago
Can you think of other simple rules one might follow?

At the end of Arthur's original paper, he mentions that though he uses a simple learning technique (the ""bag of strategies"" method) almost any other kind of machine learning technique would achieve the same results.  In fact Fogel et al. implemented a genetic algorithm and got different results.  Try implementing another machine learning technique and see what the results are.


NETLOGO FEATURES
----------------
Lists are used to represent strategies and attendance histories.  N-VALUES is useful for generating random strategies.


RELATED MODELS
--------------
Arthur's original model has been generalized as the Minority Game which also exists in the Models Library.  In addition there is a model called El Farol Network Congestion that uses the El Farol Bar Problem as a model of how to choose the best path in a network.  Finally, there is an alternative implementation of this model with more parameters that is part of the NetLogo User Community Models.


CREDITS AND REFERENCES
----------------------
This model is inspired by a paper by W. Brian Arthur. ""Inductive Reasoning and Bounded Rationality"", W. Brian Arthur, The American Economic Review, 1994, v84n2, p406-411.

David Fogel et al. also built a version of this model using a genetic algorithm.  ""Inductive reasoning and bounded rationality reconsidered"", Fogel, D.B.; Chellapilla, K.; Angeline, P.J., IEEE Transactions on Evolutionary Computation, 1999, v3n2, p142-146.

To refer to this model in academic publications, please use:  Rand, W. and Wilensky, U. (2007).  NetLogo El Farol model.  http://ccl.northwestern.edu/netlogo/models/ElFarol.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2007 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/ElFarol for terms of use.
"
Traffic Grid,/models/Sample Models/Social Science,"globals
[
  grid-x-inc               ;; the amount of patches in between two roads in the x direction
  grid-y-inc               ;; the amount of patches in between two roads in the y direction
  acceleration             ;; the constant that controls how much a car speeds up or slows down by if
                           ;; it is to accelerate or decelerate
  phase                    ;; keeps track of the phase
  num-cars-stopped         ;; the number of cars that are stopped during a single pass thru the go procedure
  current-light            ;; the currently selected light

  ;; patch agentsets
  intersections ;; agentset containing the patches that are intersections
  roads         ;; agentset containing the patches that are roads
]

turtles-own
[
  speed     ;; the speed of the turtle
  up-car?   ;; true if the turtle moves downwards and false if it moves to the right
  wait-time ;; the amount of time since the last time a turtle has moved
]

patches-own
[
  intersection?   ;; true if the patch is at the intersection of two roads
  green-light-up? ;; true if the green light is above the intersection.  otherwise, false.
                  ;; false for a non-intersection patches.
  my-row          ;; the row of the intersection counting from the upper left corner of the
                  ;; world.  -1 for non-intersection patches.
  my-column       ;; the column of the intersection counting from the upper left corner of the
                  ;; world.  -1 for non-intersection patches.
  my-phase        ;; the phase for the intersection.  -1 for non-intersection patches.
  auto?           ;; whether or not this intersection will switch automatically.
                  ;; false for non-intersection patches.
]


;;;;;;;;;;;;;;;;;;;;;;
;; Setup Procedures ;;
;;;;;;;;;;;;;;;;;;;;;;

;; Initialize the display by giving the global and patch variables initial values.
;; Create num-cars of turtles if there are enough road patches for one turtle to
;; be created per road patch. Set up the plots.
to setup
  ca
  setup-globals

  ;; First we ask the patches to draw themselves and set up a few variables
  setup-patches
  make-current one-of intersections
  label-current

  set-default-shape turtles ""car""

  if (num-cars > count roads)
  [
    user-message (word ""There are too many cars for the amount of ""
                       ""road.  Either increase the amount of roads ""
                       ""by increasing the GRID-SIZE-X or ""
                       ""GRID-SIZE-Y sliders, or decrease the ""
                       ""number of cars by lowering the NUMBER slider.\n""
                       ""The setup has stopped."")
    stop
  ]

  ;; Now create the turtles and have each created turtle call the functions setup-cars and set-car-color
  crt num-cars
  [
    setup-cars
    set-car-color
    record-data
  ]

  ;; give the turtles an initial speed
  ask turtles [ set-car-speed ]

  setup-plots
end

;; Initialize the global variables to appropriate values
to setup-globals
  set current-light nobody ;; just for now, since there are no lights yet
  set phase 0
  set num-cars-stopped 0
  set grid-x-inc world-width / grid-size-x
  set grid-y-inc world-height / grid-size-y

  ;; don't make acceleration 0.1 since we could get a rounding error and end up on a patch boundary
  set acceleration 0.099
end

;; Make the patches have appropriate colors, set up the roads and intersections agentsets,
;; and initialize the traffic lights to one setting
to setup-patches
  ;; initialize the patch-owned variables and color the patches to a base-color
  ask patches
  [
    set intersection? false
    set auto? false
    set green-light-up? true
    set my-row -1
    set my-column -1
    set my-phase -1
    set pcolor brown + 3
  ]

  ;; initialize the global variables that hold patch agentsets
  set roads patches with
    [(floor((pxcor + max-pxcor - floor(grid-x-inc - 1)) mod grid-x-inc) = 0) or
    (floor((pycor + max-pycor) mod grid-y-inc) = 0)]
  set intersections roads with
    [(floor((pxcor + max-pxcor - floor(grid-x-inc - 1)) mod grid-x-inc) = 0) and
    (floor((pycor + max-pycor) mod grid-y-inc) = 0)]

  ask roads [ set pcolor white ]
  setup-intersections
end

;; Give the intersections appropriate values for the intersection?, my-row, and my-column
;; patch variables.  Make all the traffic lights start off so that the lights are red
;; horizontally and green vertically.
to setup-intersections
  ask intersections
  [
    set intersection? true
    set green-light-up? true
    set my-phase 0
    set auto? true
    set my-row floor((pycor + max-pycor) / grid-y-inc)
    set my-column floor((pxcor + max-pxcor) / grid-x-inc)
    set-signal-colors
  ]
end

;; Initialize the turtle variables to appropriate values and place the turtle on an empty road patch.
to setup-cars  ;; turtle procedure
  set speed 0
  set wait-time 0
  put-on-empty-road
  ifelse intersection?
  [
    ifelse random 2 = 0
    [ set up-car? true ]
    [ set up-car? false ]
  ]
  [
    ; if the turtle is on a vertical road (rather than a horizontal one)
    ifelse (floor((pxcor + max-pxcor - floor(grid-x-inc - 1)) mod grid-x-inc) = 0)
    [ set up-car? true ]
    [ set up-car? false ]
  ]
  ifelse up-car?
  [ set heading 180 ]
  [ set heading 90 ]
end

;; Find a road patch without any turtles on it and place the turtle there.
to put-on-empty-road  ;; turtle procedure
  move-to one-of roads with [not any? turtles-on self]
end

;; Initialize the plots
to setup-plots
  set-current-plot ""Stopped Cars""
  set-plot-y-range 0 num-cars
  plot num-cars-stopped

  set-current-plot ""Average Wait Time of Cars""
  plot mean [ wait-time ] of turtles

  set-current-plot ""Average Speed of Cars""
  set-plot-y-range 0 speed-limit
  plot mean [ speed ] of turtles
end


;;;;;;;;;;;;;;;;;;;;;;;;
;; Runtime Procedures ;;
;;;;;;;;;;;;;;;;;;;;;;;;

;; Run the simulation
to go

  update-current

  ;; have the intersections change their color
  set-signals
  set num-cars-stopped 0

  ;; set the turtles speed for this time thru the procedure, move them forward their speed,
  ;; record data for plotting, and set the color of the turtles to an appropriate color
  ;; based on their speed
  ask turtles
  [
    set-car-speed
    fd speed
    record-data
    set-car-color
  ]

  ;; update the plots with the new information from this pass thru the procedure
  do-plotting
  ;; update the phase and the global clock
  next-phase
  tick
end

to choose-current
  if mouse-down?
  [
    let x-mouse mouse-xcor
    let y-mouse mouse-ycor
    if [intersection?] of patch x-mouse y-mouse
    [
      update-current
      unlabel-current
      make-current patch x-mouse y-mouse
      label-current
      stop
    ]
  ]
end

;; Set up the current light and the interface to change it.
to make-current [light]
  set current-light light
  set current-phase [my-phase] of current-light
  set current-auto? [auto?] of current-light
end

;; update the variables for the current light
to update-current
  ask current-light [
    set my-phase current-phase
    set auto? current-auto?
  ]
end

;; label the current light
to label-current
  ask current-light
  [
    ask patch-at -1 1
    [
      set plabel-color black
      set plabel ""current""
    ]
  ]
end

;; unlabel the current light (because we've chosen a new one)
to unlabel-current
  ask current-light
  [
    ask patch-at -1 1
    [
      set plabel """"
    ]
  ]
end

;; have the traffic lights change color if phase equals each intersections' my-phase
to set-signals
  ask intersections with [auto? and phase = floor ((my-phase * ticks-per-cycle) / 100)]
  [
    set green-light-up? (not green-light-up?)
    set-signal-colors
  ]
end

;; This procedure checks the variable green-light-up? at each intersection and sets the
;; traffic lights to have the green light up or the green light to the left.
to set-signal-colors  ;; intersection (patch) procedure
  ifelse power?
  [
    ifelse green-light-up?
    [
      ask patch-at -1 0 [ set pcolor red ]
      ask patch-at 0 1 [ set pcolor green ]
    ]
    [
      ask patch-at -1 0 [ set pcolor green ]
      ask patch-at 0 1 [ set pcolor red ]
    ]
  ]
  [
    ask patch-at -1 0 [ set pcolor white ]
    ask patch-at 0 1 [ set pcolor white ]
  ]
end

;; set the turtles' speed based on whether they are at a red traffic light or the speed of the
;; turtle (if any) on the patch in front of them
to set-car-speed  ;; turtle procedure
  ifelse pcolor = red
  [ set speed 0 ]
  [
    ifelse up-car?
    [ set-speed 0 -1 ]
    [ set-speed 1 0 ]
  ]
end

;; set the speed variable of the turtle to an appropriate value (not exceeding the
;; speed limit) based on whether there are turtles on the patch in front of the turtle
to set-speed [ delta-x delta-y ]  ;; turtle procedure
  ;; get the turtles on the patch in front of the turtle
  let turtles-ahead turtles-at delta-x delta-y

  ;; if there are turtles in front of the turtle, slow down
  ;; otherwise, speed up
  ifelse any? turtles-ahead
  [
    ifelse any? (turtles-ahead with [ up-car? != [up-car?] of myself ])
    [
      set speed 0
    ]
    [
      set speed [speed] of one-of turtles-ahead
      slow-down
    ]
  ]
  [ speed-up ]
end

;; decrease the speed of the turtle
to slow-down  ;; turtle procedure
  ifelse speed <= 0  ;;if speed < 0
  [ set speed 0 ]
  [ set speed speed - acceleration ]
end

;; increase the speed of the turtle
to speed-up  ;; turtle procedure
  ifelse speed > speed-limit
  [ set speed speed-limit ]
  [ set speed speed + acceleration ]
end

;; set the color of the turtle to a different color based on how fast the turtle is moving
to set-car-color  ;; turtle procedure
  ifelse speed < (speed-limit / 2)
  [ set color blue ]
  [ set color cyan - 2 ]
end

;; keep track of the number of stopped turtles and the amount of time a turtle has been stopped
;; if its speed is 0
to record-data  ;; turtle procedure
  ifelse speed = 0
  [
    set num-cars-stopped num-cars-stopped + 1
    set wait-time wait-time + 1
  ]
  [ set wait-time 0 ]
end

to change-current
  ask current-light
  [
    set green-light-up? (not green-light-up?)
    set-signal-colors
  ]
end

;; cycles phase to the next appropriate value
to next-phase
  ;; The phase cycles from 0 to ticks-per-cycle, then starts over.
  set phase phase + 1
  if phase mod ticks-per-cycle = 0
    [ set phase 0 ]
end


;;;;;;;;;;;;;;;;;;;;;;;;;
;; Plotting Procedures ;;
;;;;;;;;;;;;;;;;;;;;;;;;;

;; plot the data from this pass thru the go procedure
to do-plotting
  plot-new-value ""Stopped Cars"" num-cars-stopped
  plot-new-value ""Average Wait Time of Cars"" mean [ wait-time ] of turtles
  plot-new-value ""Average Speed of Cars"" mean [ speed ] of turtles
end

to plot-new-value [ name-of-plot value ]
  set-current-plot name-of-plot
  plot value
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2003 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2003).  NetLogo Traffic Grid model.
; http://ccl.northwestern.edu/netlogo/models/TrafficGrid.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2003 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/TrafficGrid
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
You control traffic lights and overall variables, such as the speed limit and the number of cars, in a real-time traffic simulation.  This allows you to explore traffic dynamics, which can lead into many areas of study, from calculus to social studies.

Try to develop strategies to improve traffic and to understand the different ways to measure the quality of traffic.


HOW IT WORKS
------------
Each time step, the cars attempt to move forward at their current speed.  If their current speed is less than the speed limit and there is no car directly in front of them, they accelerate.  If there is a slower car in front of them, they match the speed of the slower car and decelerate.  If there is a red light or a stopped car in front of them, they stop.

There are two different ways the lights can change.  First, the user can change any light at any time by making the light current, and then clicking CHANGE LIGHT.  Second, lights can change automatically, once per cycle.  Initially, all lights will automatically change at the beginning of each cycle.


HOW TO USE IT
-------------
Change the traffic grid (using the sliders GRID-SIZE-X and GRID-SIZE-Y) to make the desired number of lights.  Change any other of the settings that you would like to change.  Press the SETUP button.

At this time, you may configure the lights however you like, with any combination of auto/manual and any phase. Changes to the state of the current light are made using the CURRENT-AUTO?, CURRENT-PHASE and CHANGE LIGHT controls.  You may select the current intersection using the SELECT INTERSECTION control.  See below for details.

Start the simulation by pressing the GO button.  You may continue to make changes to the lights while the simulation is running.

Buttons:

SETUP - generates a new traffic grid based on the current GRID-SIZE-X and GRID-SIZE-Y and NUM-CARS number of cars.  This also clears all the plots. All lights are set to auto, and all phases are set to 0.
GO - runs the simulation indefinitely
CHANGE LIGHT - changes the direction traffic may flow through the current light. A light can be changed manually even if it is operating in auto mode.
SELECT INTERSECTION - allows you to select a new ""current"" light. When this button is depressed, click in the intersection which you would like to make current. When you've selected an intersection, the ""current"" label will move to the new intersection and this button will automatically pop up.

Sliders:

SPEED-LIMIT - sets the maximum speed for the cars
NUM-CARS - the number of cars in the simulation (you must press the SETUP button to see the change)
TICKS-PER-CYCLE - sets the number of ticks that will elapse for each cycle.  This has no effect on manual lights.  This allows you to increase or decrease the granularity with which lights can automatically change.
GRID-SIZE-X - sets the number of vertical roads there are (you must press the SETUP button to see the change)
GRID-SIZE-Y - sets the number of horizontal roads there are (you must press the SETUP button to see the change)
CURRENT-PHASE - controls when the current light changes, if it is in auto mode. The slider value represents the percentage of the way through each cycle at which the light should change. So, if the TICKS-PER-CYCLE is 20 and CURRENT-PHASE is 75%, the current light will switch at tick 15 of each cycle.

Switches:

POWER? - toggles the presence of traffic lights
CURRENT-AUTO? - toggles the current light between automatic mode, where it changes once per cycle (according to CURRENT-PHASE), and manual, in which you directly control it with CHANGE LIGHT.

Plots:

STOPPED CARS - displays the number of stopped cars over time
AVERAGE SPEED OF CARS - displays the average speed of cars over time
AVERAGE WAIT TIME OF CARS - displays the average time cars are stopped over time


THINGS TO NOTICE
----------------
When cars have stopped at a traffic light, and then they start moving again, the traffic jam will move backwards even though the cars are moving forwards.  Why is this?

When POWER? is turned off and there are quite a few cars on the roads, ""gridlock"" usually occurs after a while.  In fact, gridlock can be so severe that traffic stops completely.  Why is it that no car can move forward and break the gridlock?  Could this happen in the real world?

Gridlock can occur when the power is turned on, as well.  What kinds of situations can lead to gridlock?


THINGS TO TRY
-------------
Try changing the speed limit for the cars.  How does this affect the overall efficiency of the traffic flow?  Are fewer cars stopping for a shorter amount of time?  Is the average speed of the cars higher or lower than before?

Try changing the number of cars on the roads.  Does this affect the efficiency of the traffic flow?

How about changing the speed of the simulation?  Does this affect the efficiency of the traffic flow?

Try running this simulation with all lights automatic.  Is it harder to make the traffic move well using this scheme than controlling one light manually?  Why?

Try running this simulation with all lights automatic.  Try to find a way of setting the phases of the traffic lights so that the average speed of the cars is the highest.  Now try to minimize the number of stopped cars.  Now try to decrease the average wait time of the cars.  Is there any correlation between these different metrics?


EXTENDING THE MODEL
-------------------
Currently, the maximum speed limit (found in the SPEED-LIMIT slider) for the cars is 1.0.  This is due to the fact that the cars must look ahead the speed that they are traveling to see if there are cars ahead of them.  If there aren't, they speed up.  If there are, they slow down.  Looking ahead for a value greater than 1 is a little bit tricky.  Try implementing the correct behavior for speeds greater than 1.

When a car reaches the edge of the world, it reappears on the other side.  What if it disappeared, and if new cars entered the city at random locations and intervals?


NETLOGO FEATURES
----------------
This model uses two forever buttons which may run at the same time, to allow the user to select a new current intersection while the model is running.

It also uses a chooser to allow the user to choose between several different possible plots, or to display all of them at once.


RELATED MODELS
--------------
Traffic Basic simulates the flow of a single lane of traffic in one direction
Traffic 2 Lanes adds a second lane of traffic
Traffic Intersection simulates a single intersection

The HubNet activity Gridlock has very similar functionality but allows a group of users to control the cars in a participatory fashion.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (2003).  NetLogo Traffic Grid model.  http://ccl.northwestern.edu/netlogo/models/TrafficGrid.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2003 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/TrafficGrid for terms of use.
"
Party,/models/Sample Models/Social Science,"globals [
  group-sites    ;; agentset of patches where groups are located
  boring-groups  ;; how many groups are currently single-sex
]

turtles-own [
  happy?         ;; true or false
]

to setup
  clear-all
  set group-sites patches with [group-site?]
  set-default-shape turtles ""person""
  create-turtles number [
    choose-sex                   ;; become a man or a woman
    set size 3                   ;; be easier to see
    move-to one-of group-sites
  ]
  ask turtles [ update-happiness ]
  count-boring-groups
  setup-plots
  update-labels
  ask turtles [ spread-out-vertically ]
  update-plots
end

to go
  if all? turtles [happy?]
    [ stop ]  ;; stop the simulation if everyone is happy
  ask turtles [ set ycor 0 ]  ;; put all people back on the x-axis
  ask turtles [ update-happiness ]
  ask turtles [ leave-if-unhappy ]
  find-new-groups
  update-labels
  count-boring-groups
  ask turtles [ spread-out-vertically ]
  update-plots
  tick
end

to update-happiness  ;; turtle procedure
  let total count turtles-here
  let same count turtles-here with [color = [color] of myself]
  let opposite (total - same)
  ;; you are happy if the proportion of people of the opposite sex
  ;; does not exceed your tolerance
  set happy? (opposite / total) <= (tolerance / 100)
end

to leave-if-unhappy  ;; turtle procedure
  if not happy? [
    set heading one-of [90 270]  ;; randomly face right or left
    fd 1                         ;; leave old group
  ]
end

to find-new-groups
  display   ;; force display update so we see animation
  let malcontents turtles with [not member? patch-here group-sites]
  if not any? malcontents [ stop ]
  ask malcontents [ fd 1 ]
  find-new-groups
end

to-report group-site?  ;; patch procedure
  ;; if your pycor is 0 and your pxcor is where a group should be located,
  ;; then you're a group site.
  ;; In this model (0,0) is near the right edge, so pxcor is usually
  ;; negative.
  ;; first figure out how many patches apart the groups will be
  let group-interval floor (world-width / num-groups)
  report
    ;; all group sites are in the middle row
    (pycor = 0) and
    ;; leave a right margin of one patch, for legibility
    (pxcor <= 0) and
    ;; the distance between groups must divide evenly into
    ;; our pxcor
    (pxcor mod group-interval = 0) and
    ;; finally, make sure we don't wind up with too many groups
    (floor ((- pxcor) / group-interval) < num-groups)
end

to spread-out-vertically  ;; turtle procedure
  ifelse woman?
    [ set heading 180 ]  ;; face north
    [ set heading   0 ]  ;; face south
  fd 4                   ;; leave a gap
  while [any? other turtles-here] [ fd 1 ]
end

to count-boring-groups
  ask group-sites [
    ifelse boring?
      [ set plabel-color gray  ]
      [ set plabel-color white ]
  ]
  set boring-groups count group-sites with [plabel-color = gray]
end

to-report boring?  ;; patch procedure
  ;; To see whether this group is single sex, we collect the colors
  ;; of the turtles into a list, then remove all the duplicates
  ;; from the list.  If the result is a list with exactly one color
  ;; in it, then the group is single sex.
  report length remove-duplicates ([color] of turtles-here) = 1
end

to update-labels
  ask group-sites [ set plabel count turtles-here ]
end

;;;
;;; color procedures
;;;

;; Blue represents male, pink represents female. No stereotypes are meant
;; to be promoted. Simply change the colors right here if you'd like.

to choose-sex  ;; turtle procedure
  set color one-of [pink blue]
end
to-report woman?  ;; turtle procedure
  report color = pink
end

;;;
;;; plotting procedures
;;;

to setup-plots
  set-current-plot ""Number Happy""
  set-plot-y-range 0 number
end

to update-plots
  set-current-plot ""Number Happy""
  set-current-plot-pen ""Happy""
  plot count turtles with [happy?]
  set-current-plot ""Single Sex Groups""
  plot boring-groups
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1997 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1997).  NetLogo Party model.
; http://ccl.northwestern.edu/netlogo/models/Party.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1997 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Party
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This is a model of a cocktail party.  The men and women at the party form groups.  A party-goer becomes uncomfortable and switches groups if their current group has too many members of the opposite sex.  What types of group result?


HOW IT WORKS
------------
The party-goers have a TOLERANCE that defines their comfort level with a group that has members of the opposite sex.  If they are in a group that has a higher percentage of people of the opposite sex than their TOLERANCE allows, then they are considered ""uncomfortable"", and they leave that group to find another group.  Movement continues until everyone at the party is ""comfortable"" with their group.


HOW TO USE IT
-------------
The NUMBER slider controls how many people are in the party, and the NUM-GROUPS slider controls how many groups form.

The SETUP button forms random groups.  To advance the model one step at a time, use the GO ONCE button. The GO button keeps the model running until everybody is comfortable.

The numbers in the view show the sizes of the groups.  White numbers are mixed groups and gray numbers are single-sex groups.

To set the tolerance of the people for the opposite sex, use the TOLERANCE slider.  You can move the slider while the model is running.  If the TOLERANCE slider is set to 75, then each person will tolerate being in a group with less than or equal to 75% people of the opposite sex.

The NUMBER HAPPY and SINGLE SEX GROUPS plots and monitors show how the party changes over time.  NUMBER HAPPY is how many party-goers are happy (that is, comfortable).  SINGLE SEX GROUPS shows the number groups containing only men or only women.


THINGS TO NOTICE
----------------
At the end of the simulation (when everyone is happy), notice the number of single-sex groups.  Are there more than at the start?


THINGS TO TRY
-------------
Try varying TOLERANCE.  Is there a critical tolerance at which each all groups end up being single-sex?  At different tolerance levels, does it take longer or shorter for everyone to become comfortable?

See how many mixed groups (not a single-sex group) you can get.

Using the GO ONCE button, experiment with different tolerances.  Watch how one unhappy person can disrupt the stability of other groups.

Is it possible to have an initial grouping such that the party never reaches a stable state?  (i.e. the model never stops running)

Observe real parties.  Is this model descriptive of real social settings?  What tolerance level do real people typically have?


EXTENDING THE MODEL
-------------------
Add more attributes to the model.  Instead of male/female, try a trait that has more than two types, like race or religion.  (You might use NetLogo's breeds feature to implement that.)

Allow each breed of person to have their own tolerance.

Complicate the tolerance rules: For example, the tolerance could go up as long as there are at least two of one breed.

Allow groups to subdivide, instead of finding new groups.

Set a maximum group size, so that if there are too many people in the group, they become unhappy.


NETLOGO FEATURES
-----------------
Most NetLogo models put the origin (0,0) in the center of the world, but here, we have placed the origin near the right edge of the world and most of the patches have negative X coordinates.  This simplifies the math for situating the groups.

Horizontal wrapping is enabled, but vertical wrapping is disabled.  Thus, the world topology is a ""vertical cylinder"".

Notice the use of the MOD primitive to space out the groups evenly.  Setting up the groups in this manner allows for easy movement from group to group.


RELATED MODELS
--------------
Segregation


CREDITS AND REFERENCES
----------------------
This model is based on the work of the pioneering economist Thomas Schelling:
Schelling, T. (1978). Micro-motives and Macro-Behavior. New York: Norton.

See also:
Resnick, M. & Wilensky, U. (1998). Diving into Complexity: Developing Probabilistic Decentralized Thinking through Role-Playing Activities. Journal of Learning Sciences, Vol. 7, No. 2.  http://ccl.northwestern.edu/papers/starpeople/

To refer to this model in academic publications, please use:  Wilensky, U. (1997).  NetLogo Party model.  http://ccl.northwestern.edu/netlogo/models/Party.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1997 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Party for terms of use.
"
Team Assembly,/models/Sample Models/Social Science,"globals
[
  newcomer              ;; an agent who has never collaborated
  component-size        ;; current running size of component being explored
  giant-component-size  ;; size of largest connected component
  components            ;; list of connected components
]

turtles-own
[
  incumbent?   ;; true if an agent has collaborated before
  in-team?     ;; true if an agent belongs to the new team being constructed
  downtime     ;; the number of time steps passed since the agent last collaborated
  explored?    ;; used to compute connected components in the graph
]

links-own
[
  new-collaboration?  ;; true if the link represents the first time two agents collaborated
]


;;;;;;;;;;;;;;;;;;;;;;;;
;;; Setup Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;

to make-newcomer
  create-turtles 1
  [
    set color blue + 1
    set size 1.8
    set incumbent? false
    set in-team? false
    set newcomer self
    set downtime 0
    set explored? false
  ]
end


to setup
  clear-all
  set-default-shape turtles ""circle""

  ;; assemble the first team
  repeat team-size [ make-newcomer ]
  ask turtles
  [
    set in-team? true
    set incumbent? true
  ]
  tie-collaborators
  color-collaborations

  ask turtles  ;; arrange turtles in a regular polygon
  [
    set heading (360 / team-size) * who
    fd 1.75
    set in-team? false
  ]
end


;;;;;;;;;;;;;;;;;;;;;;;
;;; Main Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;

to go
  ;; all existing turtles are now considered incumbents
  ask turtles [set incumbent? true set color gray - 1.5 set size 0.9]
  ask links [set new-collaboration? false]

  ;; assemble a new team
  pick-team-members
  tie-collaborators
  color-collaborations

  ;; age turtles
  ask turtles
  [
    ;; agents drop out of the collaboration network when they become inactive for max-downtime steps
    if downtime > max-downtime
      [die]

    set in-team? false
    set downtime downtime + 1
  ]

  if layout? [ layout ]
  if plot? [ do-plot ]
  tick
end


;; choose turtles to be in a new team
to pick-team-members
  let new-team-member nobody
  repeat team-size
  [
    ifelse random-float 100.0 >= p  ;;with a probability P, make a newcomer
    [
      make-newcomer
      set new-team-member newcomer
    ]
    [
      ;; with a probability Q, choose a new team member who was a previous collaborator of an existing team member
      ;; if the current team has at least one previous collaborator.
      ;; otherwise collaborate with a previous incumbent
      ifelse random-float 100.0 < q and any? (turtles with [in-team? and (any? link-neighbors with [not in-team?])])
        [set new-team-member one-of turtles with [not in-team? and (any? link-neighbors with [in-team?])]]
        [set new-team-member one-of turtles with [not in-team?]]
    ]
    ask new-team-member  ;; specify turtle to become a new team member
    [
      set in-team? true
      set downtime 0
      set size 1.8
      set color ifelse-value incumbent? [yellow + 2] [blue + 1]
    ]
  ]
end


;; forms a link between all unconnected turtles with in-team? = true
to tie-collaborators
  ask turtles with [in-team?]
  [
    create-links-with other turtles with [in-team?]
    [
      set new-collaboration? true  ;; specifies newly-formed collaboration between two members
      set thickness 0.3
    ]
  ]
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Visualization Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; color links according to past experience
to color-collaborations
    ask links with [[in-team?] of end1 and [in-team?] of end2]
    [
      ifelse new-collaboration?
      [
        ifelse ([incumbent?] of end1) and ([incumbent?] of end2)
        [
          set color yellow       ;; both members are incumbents
        ]
        [
          ifelse ([incumbent?] of end1) or ([incumbent?] of end2)
            [ set color green ]  ;; one member is an incumbent
            [ set color blue ]   ;; both members are newcomers
        ]
      ]
      [
        set color red            ;; members are previous collaborators
      ]
    ]
end

;; perform spring layout on all turtles and links
to layout
  repeat 12 [
    layout-spring turtles links 0.18 0.01 1.2
    display
  ]
end


to do-plot
  ;; plot stacked histogram of link types
  set-current-plot ""Link counts""
  let total 0
  set-current-plot-pen ""previous collaborators""
  plot-pen-up plotxy ticks total
  set total total + count links with [color = red]
  plot-pen-down plotxy ticks total
  set-current-plot-pen ""incumbent-incumbent""
  plot-pen-up plotxy ticks total
  set total total + count links with [color = yellow]
  plot-pen-down plotxy ticks total
  set-current-plot-pen ""newcomer-incumbent""
  plot-pen-up plotxy ticks total
  set total total + count links with [color = green]
  plot-pen-down plotxy ticks total
  set-current-plot-pen ""newcomer-newcomer""
  plot-pen-up plotxy ticks total
  set total total + count links with [color = blue]
  plot-pen-down plotxy ticks total

  ;; calculate and plot connected component metrics
  find-all-components
  set-current-plot ""% of agents in the giant component""
  plotxy ticks (giant-component-size / (count turtles))
  set-current-plot ""Average component size""
  plotxy ticks (mean components)
end



;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Network Exploration ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; to find all the connected components in the network, their sizes and starting turtles
to find-all-components
  set components []
  set giant-component-size 0

  ask turtles [ set explored? false ]
  ;; keep exploring till all turtles get explored
  loop
  [
    ;; pick a turtle that has not yet been explored
    let start one-of turtles with [ not explored? ]
    if start = nobody [ stop ]
    ;; reset the number of turtles found to 0
    ;; this variable is updated each time we explore an
    ;; unexplored turtle.
    set component-size 0
    ask start [ explore ]
    ;; the explore procedure updates the component-size variable.
    ;; so check, have we found a new giant component?
    if component-size > giant-component-size
    [
      set giant-component-size component-size
    ]
    set components lput component-size components
  ]
end

;; finds all turtles reachable from this turtle
to explore ;; turtle procedure
  if explored? [ stop ]
  set explored? true
  set component-size component-size + 1
  ask link-neighbors [ explore ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2007 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Bakshy, E. and Wilensky, U. (2007). NetLogo Team Assembly model.
; http://ccl.northwestern.edu/netlogo/models/TeamAssembly.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2007 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/TeamAssembly
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model of collaboration networks illustrates how the behavior of individuals in assembling small teams for short-term projects can give rise to a variety of large-scale network structures over time.  It is an adaptation of the team assembly model presented by Guimera et al (2005).  The rules of the model draw upon observations of collaboration networks ranging from Broadway productions to scientific publications in psychology and astronomy.

Many of the general features found in the networks of creative enterprises can be captured by the Team Assembly model with two simple parameters: the proportion of newcomers participating in a team and the propensity for past collaborators to work again with one another.


HOW IT WORKS
------------
At each tick a new team is assembled.  Team members are either inexperienced ""newcomers"" -- people who have not previously participated in any teams -- or are established ""incumbents"" -- experienced people who have previously participated on a team.  Each member is chosen sequentially.  The P slider gives the probability that a new team member will be an incumbent.  If the new member is not a newcomer, then with a probability given by the Q slider, an incumbent will be chosen at random from the pool of previous collaborators of an incumbent already on the team.  Otherwise, a new member will just be randomly chosen from all incumbents.  When a team is created, all members are linked to one another.  If an agent does not participate in a new team for a prolonged period of time, the agent and her links are removed from the network.

Agents in a newly assembled team are colored blue if they are newcomers and yellow if they are incumbents.  Smaller grey circles represent those that are not currently collaborating.  Links indicate members' experience at their most recent time of collaboration.  For example, blue links between agents indicate that two agents collaborated as newcomers.  Green and yellow links correspond to one-time newcomer-incumbent and incumbent-incumbent collaborations, respectively.  Finally, red links indicate that agents have collaborated with one another multiple times.


HOW TO USE IT
-------------
Click the SETUP button to start with a single team.  Click GO ONCE to assemble an additional team.  Click GO to indefinitely assemble new teams.  You may wish to use the GO ONCE button for the first few steps to get a better sense of how the parameters affect the assembly of teams.

Visualization Controls:
- LAYOUT?: controls whether or not the spring layout algorithm runs at each tick.  This procedure attempts to move the nodes around to make the structure of the network easier to see.  Switching off LAYOUT? will significantly increase the speed of the model.
- PLOT?: switches on and off the plots. Again, off speeds up the model.

The REDO LAYOUT button lets you run the layout algorithm without assembling new teams.

Parameters:
- TEAM-SIZE: the number of agents in a newly assembled team.
- MAX-DOWNTIME: the number of steps an agent will remain in the world without collaborating before it retires.
- P: the probability an incumbent is chosen to become a member of a new team
- Q: the probability that the team being assembled will include a previous collaborator of an incumbent on the team, given that the team has at least one incumbent.

Plots:
- LINK COUNTS: plots a stacked histogram of the number of links in the collaboration network over time.  The colors correspond to collaboration ties as follows:
-- Blue: two newcomers
-- Green: a newcomer and an incumbent
-- Yellow: two incumbents that have not previously collaborated with one another
-- Red: Repeat collaborators
-  % OF AGENTS IN THE GIANT COMPONENT: plots the percentage of agents belonging to the largest connected component network over time.
- AVERAGE COMPONENT SIZE: plots the average size of isolated collaboration networks as a fraction of the total number of agents

Using the plots, one can observe important features of the network, like the distribution of link types or the connectivity of the network vary over time.


THINGS TO NOTICE
----------------
The model captures two basic features of collaboration networks that can influence or stifle innovation in creative enterprises by varying the values of P and Q.  First is the distribution of the type of the connection between collaborators, which can be seen in the LINK COUNTS plot. An overabundance of newcomer-newcomer (blue) links might indicate that a field is not taking advantage of experienced members. On the other hand, a multitude of repeat collaborations (red) and incumbent-incumbent (yellow) links may indicate a lack of in diversity of ideas or experiences.

Second is the overall connectivity of the collaboration network.  For example, many academic fields are said to be comprised of an ""invisible college"" of loosely connected academic communities.  By contrast, patent networks tend to consist of isolated clusters or chains of inventors.  You can see one measure of this on the % OF AGENTS IN THE GIANT COMPONENT plot -- the giant component being the size of the largest connected chain of collaborators.

You can also see the different emergent topologies in the display.   New collaborations or synergy among teams naturally tend to the center of the display. Teams or clusters of teams with few connections to new collaborations naturally ""float"" to the edges of the world. Newcomers always start in the center of the world. Incumbents, which are chosen at random, may be located in any part of the screen. Thus, collaborations amongst newcomers and or distant team components tend toward the center, and disconnected clusters are repelled from the centered.

Finally, note that the structure of collaboration networks in the model can change dramatically over time. Initially, only new teams are generated; the collaborative field has not existed long enough for members to retire. However, after a period of time (MAX-DOWNTIME), inactive agents begin to retire, and the number of agents becomes relatively stable -- the emergent effects of P and Q become more apparent in this equilibrium stage.  Note also that the end of the growth stage is often marked by a drop in the connectivity of the network.


THINGS TO TRY
-------------
Keeping Q fixed at 40%, how does the structure of collaboration networks vary with P?  For example, which values of P produce isolated clusters of agents?  As P increases, how do these clusters combine to form more complex structures?  Over which values of P does the transition from a disconnected network to a fully connected network occur?

Set P to 40% and Q to 100%, so that all incumbents choose to work with past collaborators.  Press SETUP, then GO, and let the model run for about 100 steps after the number of agents in the network stops growing.  What happens to the connectivity of the collaboration network?  Keeping P fixed, continue to lower Q in decrements of 5-10%.

Try keeping P and Q constant and varying TEAM-SIZE.  How does the global structure of the network change with larger or smaller team sizes?  Under which ranges of P and Q does this relation hold?


EXTENDING THE MODEL
-------------------
What happens when the size of new teams are not constant?  Try changing the rules so that team sizes vary randomly from a distribution or increase over time.

How do P and Q relate to the global clustering coefficient of the network?  You may wish to use code from the Small Worlds model in the Networks section of Sample Models.

Can you modify the model so that agents are more likely to collaborate with collaborators of collaborators?

Collaboration networks can alternatively be thought of as a network consisting of individuals linked to projects.  For example, one can represent a scientific journal with two types of nodes, scientists and publications.  Ties between scientists and publications represent authorship.  Thus, links between a publication multiple scientists specify co-authorship.  More generally, a collaborative project may be represented one type of node, and participants another type.  Can you modify the model to assemble teams using bipartite networks?


RELATED MODELS
--------------
Preferential Attachment - gives a generative explanation of how general principles of attachment can give rise to a network structure common to many technological and biological systems.

Giant Component - shows how critical points exist in which a network can transition from a rather disconnected topology to a fully connected topology


CREDITS AND REFERENCES
----------------------
This model is based on:
R Guimera, B Uzzi, J Spiro, L Amaral; Team Assembly Mechanisms Determine Collaboration Network Structure and Team Performance. Science 2005, V308, N5722, p697-702
http://amaral.northwestern.edu/Publications/Papers/Guimera-2005-Science-308-697.pdf


To refer to this model in academic publications, please use:  Bakshy, E. and Wilensky, U. (2007).  NetLogo Team Assembly model.  http://ccl.northwestern.edu/netlogo/models/TeamAssembly.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2007 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/TeamAssembly for terms of use.
"
Ethnocentrism,/models/Sample Models/Social Science,";; agents have a probablity to reproduce and a strategy
turtles-own [ PTR cooperate-with-same? cooperate-with-different? ]

globals [
  ;; the remaining variables support the replication of published experiments
  meet                  ;; how many interactions occurred this turn
  meet-agg              ;; how many interactions occurred through the run
  last100meet           ;; meet for the last 100 ticks
  meetown               ;; what number of individuals met someone of their own color this turn
  meetown-agg           ;; what number of individuals met someone of their own color throughout the run
  last100meetown        ;; meetown for the last 100 ticks
  meetother             ;; what number of individuals met someone of a different color this turn
  meetother-agg         ;; what number of individuals met someone of a different color throughout the run
  last100meetother      ;; meetother for the last 100 ticks
  coopown               ;; how many interactions this turn were cooperating with the same color
  coopown-agg           ;; how many interactions throughout the run were cooperating with the same color
  last100coopown        ;; coopown for the last 100 ticks
  coopother             ;; how many interactions this turn were cooperating with a different color
  coopother-agg         ;; how many interactions throughout the run were cooperating with a different color
  defother              ;; how many interactions this turn were defecting with a different color
  defother-agg          ;; how many interactions throughout the run were defecting with a different color
  last100defother       ;; defother for the last 100 ticks
  last100cc             ;; how many cooperate-cooperate genotypes have there been in the last 100 ticks
  last100cd             ;; how many cooperate-defect genotypes have there been in the last 100 ticks
  last100dc             ;; how many defect-cooperate genotypes have there been in the last 100 ticks
  last100dd             ;; how many defect-defect genotypes have there been in the last 100 ticks
  last100consist-ethno  ;; how many interactions consistent with ethnocentrism in the last 100 ticks
  last100coop           ;; how many interactions have been cooperation in the last 100 ticks
]

to setup-empty
  clear-all
  ;; initialize all the variables
  set meetown 0
  set meetown-agg 0
  set meet 0
  set meet-agg 0
  set coopown 0
  set coopown-agg 0
  set defother 0
  set defother-agg 0
  set meetother 0
  set meetother-agg 0
  set coopother 0
  set coopother-agg 0
  set last100dd []
  set last100cd []
  set last100cc []
  set last100dc []
  set last100coopown []
  set last100defother []
  set last100consist-ethno []
  set last100meetown []
  set last100meetother []
  set last100meet []
  set last100coop []
end

;; creates a world with an agent on each patch
to setup-full
  setup-empty
  ask patches [ create-turtle ]
end

;; creates a new agent in the world
to create-turtle  ;; patch procedure
  sprout 1 [
    set color random-color
    ;; determine the strategy for interacting with someone of the same color
    set cooperate-with-same? (random-float 1.0 < immigrant-chance-cooperate-with-same)
    ;; determine the strategy for interacting with someone of a different color
    set cooperate-with-different? (random-float 1.0 < immigrant-chance-cooperate-with-different)
    ;; change the shape of the agent on the basis of the strategy
    update-shape
  ]
end

to-report random-color
  report one-of [red blue yellow green]
end

;; this is used to clear stats that change between each tick
to clear-stats
  set meetown 0
  set meet 0
  set coopown 0
  set defother 0
  set meetother 0
  set coopother 0
end

;; the main routine
to go
  clear-stats     ;; clear the turn based stats
  immigrate       ;; new agents immigrate into the world

  ;; reset the probability to reproduce
  ask turtles [ set PTR initial-PTR ]

  ;; have all of the agents interact with other agents if they can
  ask turtles [ interact ]
  ;; now they reproduce
  ask turtles [ reproduce ]
  death           ;; kill some of the agents
  update-stats    ;; update the states for the aggregate and last 100 ticks
  update-plots
  tick
end

;; draws the appropriate results on the plots
to update-plots
  set-current-plot-pen ""CC""  ;; altruists
  plotxy ticks count turtles with [shape = ""circle""]
  set-current-plot-pen ""CD""  ;; ethnocentric
  plotxy ticks count turtles with [shape = ""circle 2""]
  set-current-plot-pen ""DC""  ;; cosmopolitans
  plotxy ticks count turtles with [shape = ""square""]
  set-current-plot-pen ""DD""  ;; selfish
  plotxy ticks count turtles with [shape = ""square 2""]
end

;; random individuals enter the world on empty cells
to immigrate
  let empty-patches patches with [not any? turtles-here]
  ;; we can't have more immigrants than there are empty patches
  let how-many min list immigrants-per-day (count empty-patches)
  ask n-of how-many empty-patches [ create-turtle ]
end

to interact  ;; turtle procedure

  ;; interact with Von Neumann neighborhood
  ask turtles-on neighbors4 [
    ;; the commands inside the ASK are written from the point of view
    ;; of the agent being interacted with.  To refer back to the agent
    ;; that initiated the interaction, we use the MYSELF primitive.
    set meet meet + 1
    set meet-agg meet-agg + 1
    ;; do one thing if the individual interacting is the same color as me
    if color = [color] of myself [
      ;; record the fact the agent met someone of the own color
      set meetown meetown + 1
      set meetown-agg meetown-agg + 1
      ;; if I cooperate then I reduce my PTR and increase my neighbors
      if [cooperate-with-same?] of myself [
        set coopown coopown + 1
        set coopown-agg coopown-agg + 1
        ask myself [ set PTR PTR - cost-of-giving ]
        set PTR PTR + gain-of-receiving
      ]
    ]
    ;; if we are different colors we take a different strategy
    if color != [color] of myself [
      ;; record stats on encounters
      set meetother meetother + 1
      set meetother-agg meetother-agg + 1
      ;; if we cooperate with different colors then reduce our PTR and increase our neighbors
      ifelse [cooperate-with-different?] of myself [
        set coopother coopother + 1
        set coopother-agg coopother-agg + 1
        ask myself [ set PTR PTR - cost-of-giving ]
        set PTR PTR + gain-of-receiving
      ]
      [
        set defother defother + 1
        set defother-agg defother-agg + 1
      ]
    ]
  ]
end

;; use PTR to determine if the agent gets to reproduce
to reproduce  ;; turtle procedure
  ;; if a random variable is less than the PTR the agent can reproduce
  if random-float 1.0 < PTR [
    ;; find an empty location to reproduce into
    let destination one-of neighbors4 with [not any? turtles-here]
    if destination != nobody [
      ;; if the location exists hatch a copy of the current turtle in the new location
      ;;  but mutate the child
      hatch 1 [
        move-to destination
        mutate
      ]
    ]
  ]
end

;; modify the children of agents according to the mutation rate
to mutate  ;; turtle procedure
  ;; mutate the color
  if random-float 1.0 < mutation-rate [
    let old-color color
    while [color = old-color]
      [ set color random-color ]
  ]
  ;; mutate the strategy flags;
  ;; use NOT to toggle the flag
  if random-float 1.0 < mutation-rate [
    set cooperate-with-same? not cooperate-with-same?
  ]
  if random-float 1.0 < mutation-rate [
    set cooperate-with-different? not cooperate-with-different?
  ]
  ;; make sure the shape of the agent reflects its strategy
  update-shape
end

to death
  ;; check to see if a random variable is less than the death rate for each agent
  ask turtles [
    if random-float 1.0 < death-rate [ die ]
  ]
end

;; make sure the shape matches the strategy
to update-shape
  ;; if the agent cooperates with same they are a circle
  ifelse cooperate-with-same? [
    ifelse cooperate-with-different?
      [ set shape ""circle"" ]    ;; filled in circle (altruist)
      [ set shape ""circle 2"" ]  ;; empty circle (ethnocentric)
  ]
  ;; if the agent doesn't cooperate with same they are a square
  [
    ifelse cooperate-with-different?
      [ set shape ""square"" ]    ;; filled in square (cosmopolitan)
      [ set shape ""square 2"" ]  ;; empty square (egoist)
  ]
end

;; this routine calculates a moving average of some stats over the last 100 ticks
to update-stats
  set last100dd        shorten lput (count turtles with [shape = ""square 2""]) last100dd
  set last100cc        shorten lput (count turtles with [shape = ""circle""]) last100cc
  set last100cd        shorten lput (count turtles with [shape = ""circle 2""]) last100cd
  set last100dc        shorten lput (count turtles with [shape = ""square""]) last100dc
  set last100coopown   shorten lput coopown last100coopown
  set last100defother  shorten lput defother last100defother
  set last100meetown   shorten lput meetown last100meetown
  set last100coop      shorten lput (coopown + coopother) last100coop
  set last100meet      shorten lput meet last100meet
  set last100meetother shorten lput meetother last100meetother
end

;; this is used to keep all of the last100 lists the right length
to-report shorten [the-list]
  ifelse length the-list > 100
    [ report butfirst the-list ]
    [ report the-list ]
end

;; these are used in the BehaviorSpace experiments

to-report meetown-percent
  report meetown / max list 1 meet
end
to-report meetown-agg-percent
  report meetown-agg / max list 1 meet-agg
end
to-report coopown-percent
  report coopown / max list 1 meetown
end
to-report coopown-agg-percent
  report coopown-agg / max list 1 meetown-agg
end
to-report defother-percent
  report defother / max list 1 meetother
end
to-report defother-agg-percent
  report defother-agg / max list 1 meetother-agg
end
to-report consist-ethno-percent
  report (defother + coopown) / (max list 1 meet )
end
to-report consist-ethno-agg-percent
  report (defother-agg + coopown-agg) / (max list 1 meet-agg )
end
to-report coop-percent
  report (coopown + coopother) / (max list 1 meet )
end
to-report coop-agg-percent
  report (coopown-agg + coopother-agg) / (max list 1 meet-agg)
end
to-report cc-count
  report sum last100cc / max list 1 length last100cc
end
to-report cd-count
  report sum last100cd / max list 1 length last100cd
end
to-report dc-count
  report sum last100dc / max list 1 length last100dc
end
to-report dd-count
  report sum last100dd / max list 1 length last100dd
end
to-report cc-percent
  report cc-count / (max list 1 (cc-count + cd-count + dc-count + dd-count))
end
to-report cd-percent
  report cd-count / (max list 1 (cc-count + cd-count + dc-count + dd-count))
end
to-report dc-percent
  report dc-count / (max list 1 (cc-count + cd-count + dc-count + dd-count))
end
to-report dd-percent
  report dd-count / (max list 1 (cc-count + cd-count + dc-count + dd-count))
end
to-report last100coopown-percent
  report sum last100coopown / max list 1 sum last100meetown
end
to-report last100defother-percent
  report sum last100defother / max list 1 sum last100meetother
end
to-report last100consist-ethno-percent
  report (sum last100defother + sum last100coopown) / max list 1 sum last100meet
end
to-report last100meetown-percent
  report sum last100meetown / max list 1 sum last100meet
end
to-report last100coop-percent
  report sum last100coop / max list 1 sum last100meet
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2003 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2003).  NetLogo Ethnocentrism model.
; http://ccl.northwestern.edu/netlogo/models/Ethnocentrism.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2003 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Ethnocentrism
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model, due to Robert Axelrod and Ross A. Hammond, suggests that ""ethnocentric"" behavior can evolve under a wide variety of conditions, even when there are no native ""ethnocentrics"" and no way to differentiate between agent types.  Agents compete for limited space via Prisoner Dilemma's type interactions. ""Ethnocentric"" agents treat agents within their group more beneficially than those outside their group.  The model includes a mechanism for inheritance (genetic or cultural) of strategies.


HOW IT WORKS
------------
Each agent has three traits: a) color, b) whether they cooperate with same colored agents, and c) whether they cooperate with different colored agents.  An ""ethnocentric"" agent is one which cooperates with same colored agents, but does not cooperate with different colored agents. An ""altruist"" cooperates with all agents, while an ""egoist"" cooperates with no one.  A ""cosmopolitan"" cooperates with agents of a different color but not of their own color.

At each time step, the following events occur:

1. Up to IMMIGRANTS-PER-DAY, new agents appear in random locations with random traits.

2. Agents start with an INITIAL-PTR (Potential-To-Reproduce) chance of reproducing.  Each pair of adjacent agents interact in a one-move Prisoner's Dilemma in which each chooses whether or not to help the other.  They either gain, or lose some of their potential to reproduce.

3. In random order, each agent is given a chance to reproduce.  Offspring have the same traits as their parents, with a MUTATION-RATE chance of each trait mutating.  Agents are only allowed to reproduce if their is an empty space next to them.  Each agent's birth-rate is reset to the INITIAL-PTR.

4. The agent has a DEATH-RATE chance of dying, making room for future offspring and immigrants.


HOW TO USE IT
-------------
To prepare the simulation for a new run, press SETUP EMPTY.  Press GO to start the simulation running, press GO again to stop it.

SETUP FULL will allow you to start with a full world of random agents.

COST-OF-GIVING indicates how much it costs an agent to cooperate with another agent.

GAIN-OF-RECEIVING indicates how much an agent gains if another agent cooperates with them.

IMMIGRANT-CHANCE-COOPERATE-WITH-SAME indicates the probability that an immigrating agent will have the COOPERATE-WITH-SAME? variable set to true.

IMMIGRANT-CHANCE-COOPERATE-WITH-DIFFERENT indicates the probability that an immigrating agent will have the COOPERATE-WITH-DIFFERENT? variable set to true.


THINGS TO NOTICE
----------------
Agents appear as circles if they cooperate with the same color.  They are filled in if they also cooperate with a different color (altruists) or empty if they do not (ethnocentrics).  Agents are squares if they do not cooperate with the same color.  The agents are filled in if they cooperate with a different color (cosmopolitans) or empty if they do not (egoists).

Observe the interaction along the edge of a group of ethnocentric agents, and non-ethnocentric agents.  What behaviors do you see?  Is one more stable?  Does one expand into the other group?

Observer the STRATEGY COUNTS plot.  Does one strategy occur more than others?  What happens when we change the model?


THINGS TO TRY
-------------
Set the IMMIGRANT-CHANCE-COOPERATE sliders both to 1.0.  This means there are only altruists created.  Do ethnocentrics and other strategies ever evolve?  Do they ever out compete the altruists?

Change the values of COST-OF-GIVING and GAIN-OF-RECEIVING and observe the effects on the model and the level of ethnocentricity.

This model comes with a group of BehaviorSpace experiments defined.  You can access them by choosing BehaviorSpace on the Tools menu.  These are the original experiments that Axelrod and Hammond ran to test the robustness of this model. These experiments vary lots of parameters like the size of the world, IMMIGRANTS-PER-DAY and COST-OF-GIVING.  These experiments are detailed at   http://www-personal.umich.edu/~axe/Shared_Files/Axelrod.Hammond/index.htm


EXTENDING THE MODEL
-------------------
Add more colors to the model.  Does the behavior change?

Make some patches richer than others, so that agents on them have a higher chance of reproducing.  Distribute this advantage across the world in different ways such as randomly, in blobs, or in quarters.

Tag patches with a color.  distribute the colors across the world in different ways: blobs, randomly, in discrete quarters.  Agents use the patch color under other agents to determine whether to cooperate with them or not.


NETLOGO FEATURES
----------------
To ensure fairness, the agents should run in random order.  Agentsets in NetLogo are always in random order, so no extra code is needed to achieve this.


RELATED MODELS
--------------
Segregation
PD Basic


CREDITS AND REFERENCES
----------------------
This model is a NetLogo version of the ethnocentrism model presented by Robert Axelrod at Northwestern University at the NICO (Northwestern Institute on Complex Systems) conference on October 25th, 2003.

See also Ross A. Hammond and Robert Axelrod, The Evolution of Ethnocentrism, http://www-personal.umich.edu/~axe/research/Hammond-Ax_Ethno.pdf

To refer to this model in academic publications, please use:  Wilensky, U. (2003).  NetLogo Ethnocentrism model.  http://ccl.northwestern.edu/netlogo/models/Ethnocentrism.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2003 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Ethnocentrism for terms of use.
"
Segregation,/models/Sample Models/Social Science,"globals [
  percent-similar  ;; on the average, what percent of a turtle's neighbors
                   ;; are the same color as that turtle?
  percent-unhappy  ;; what percent of the turtles are unhappy?
]

turtles-own [
  happy?       ;; for each turtle, indicates whether at least %-similar-wanted percent of
               ;; that turtles' neighbors are the same color as the turtle
  similar-nearby   ;; how many neighboring patches have a turtle with my color?
  other-nearby ;; how many have a turtle of another color?
  total-nearby  ;; sum of previous two variables
]


to setup
  clear-all
  if number > count patches
    [ user-message (word ""This pond only has room for "" count patches "" turtles."")
      stop ]

  ;; create turtles on random patches.
  ask n-of number patches
    [ sprout 1
      [ set color red ] ]
  ;; turn half the turtles green
  ask n-of (number / 2) turtles
    [ set color green ]
  update-variables
  do-plots
end

to go
  if all? turtles [happy?] [ stop ]
  move-unhappy-turtles
  update-variables
  tick
  do-plots
end

to move-unhappy-turtles
  ask turtles with [ not happy? ]
    [ find-new-spot ]
end

to find-new-spot
  rt random-float 360
  fd random-float 10
  if any? other turtles-here
    [ find-new-spot ]          ;; keep going until we find an unoccupied patch
  move-to patch-here  ;; move to center of patch
end

to update-variables
  update-turtles
  update-globals
end

to update-turtles
  ask turtles [
    ;; in next two lines, we use ""neighbors"" to test the eight patches
    ;; surrounding the current patch
    set similar-nearby count (turtles-on neighbors)
      with [color = [color] of myself]
    set other-nearby count (turtles-on neighbors)
      with [color != [color] of myself]
    set total-nearby similar-nearby + other-nearby
    set happy? similar-nearby >= ( %-similar-wanted * total-nearby / 100 )
  ]
end

to update-globals
  let similar-neighbors sum [similar-nearby] of turtles
  let total-neighbors sum [total-nearby] of turtles
  set percent-similar (similar-neighbors / total-neighbors) * 100
  set percent-unhappy (count turtles with [not happy?]) / (count turtles) * 100
end

to do-plots
  set-current-plot ""Percent Similar""
  plot percent-similar
  set-current-plot ""Percent Unhappy""
  plot percent-unhappy
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Segregation model.
; http://ccl.northwestern.edu/netlogo/models/Segregation.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Segregation
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This project models the behavior of two types of turtles in a mythical pond. The red turtles and green turtles get along with one another. But each turtle wants to make sure that it lives near some of ""its own."" That is, each red turtle wants to live near at least some red turtles, and each green turtle wants to live near at least some green turtles. The simulation shows how these individual preferences ripple through the pond, leading to large-scale patterns.

This project was inspired by Thomas Schelling's writings about social systems (such as housing patterns in cities).


HOW TO USE IT
-------------
Click the SETUP button to set up the turtles. There are equal numbers of red and green turtles. The turtles move around until there is at most one turtle on a patch.  Click GO to start the simulation. If turtles don't have enough same-color neighbors, they jump to a nearby patch.

The NUMBER slider controls the total number of turtles. (It takes effect the next time you click SETUP.)  The %-SIMILAR-WANTED slider controls the percentage of same-color turtles that each turtle wants among its neighbors. For example, if the slider is set at 30, each green turtle wants at least 30% of its neighbors to be green turtles.

The % SIMILAR monitor shows the average percentage of same-color neighbors for each turtle. It starts at about 50%, since each turtle starts (on average) with an equal number of red and green turtles as neighbors. The % UNHAPPY monitor shows the percent of turtles that have fewer same-color neighbors than they want (and thus want to move). Both monitors are also plotted.


THINGS TO NOTICE
----------------
When you execute SETUP, the red and green turtles are randomly distributed throughout the pond. But many turtles are ""unhappy"" since they don't have enough same-color neighbors. The unhappy turtles jump to new locations in the vicinity. But in the new locations, they might tip the balance of the local population, prompting other turtles to leave. If a few red turtles move into an area, the local green turtles might leave. But when the green turtles move to a new area, they might prompt red turtles to leave that area.

Over time, the number of unhappy turtles decreases. But the pond becomes more segregated, with clusters of red turtles and clusters of green turtles.

In the case where each turtle wants at least 30% same-color neighbors, the turtles end up with (on average) 70% same-color neighbors. So relatively small individual preferences can lead to significant overall segregation.


THINGS TO TRY
-------------
Try different values for %-SIMILAR-WANTED. How does the overall degree of segregation change?

If each turtle wants at least 40% same-color neighbors, what percentage (on average) do they end up with?


EXTENDING THE MODEL
-------------------
Incorporate social networks into this model.  For instance, have unhappy turtles decide on a new location based on information about what a neighborhood is like from other turtles in their network.

Change the rules for turtle happiness.  One idea: suppose that the turtles need some minimum threshold of ""good neighbors"" to be happy with their location.  Suppose further that they don't always know if someone makes a good neighbor. When they do, they use that information.  When they don't, they use color as a proxy -- i.e., they assume that turtles of the same color make good neighbors.


NETLOGO FEATURES
----------------
N-OF and SPROUT are used to create turtles while ensuring no patch has more than one turtle on it.

When a turtle moves, MOVE-TO is used to move the turtle to the center of the patch it eventually finds.


CREDITS AND REFERENCES
----------------------
Schelling, T. (1978). Micromotives and Macrobehavior. New York: Norton.
See also a recent Atlantic article:   Rauch, J. (2002). Seeing Around Corners; The Atlantic Monthly; April 2002;Volume 289, No. 4; 35-48. http://www.theatlantic.com/issues/2002/04/rauch.htm

To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Segregation model.  http://ccl.northwestern.edu/netlogo/models/Segregation.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Segregation for terms of use.
"
Simple Birth Rates,/models/Sample Models/Social Science,"globals
[
  red-count            ; population of red turtles
  blue-count           ; population of blue turtles
]

turtles-own
[
  fertility            ; the whole number part of fertility
  fertility-remainder  ; the fractional part (after the decimal point)
]

to setup
  clear-output
  setup-experiment
end

to setup-experiment
  cp ct
  clear-all-plots
  reset-ticks
  crt carrying-capacity
  [
    setxy random-xcor random-ycor         ; randomize turtle locations
    ifelse who < (carrying-capacity / 2)  ; start out with equal numbers of reds and blues
      [ set color blue ]
      [ set color red ]
    set size 2                            ; easier to see
  ]
  setup-plot
  plot-counts
end

to go
  wander
  reproduce
  grim-reaper
  tick
  plot-counts
end

;; to enable many repetitions with same settings
to go-experiment
  go
  if red-count = 0
  [
    output-print (word ""red extinct after "" ticks "" generations"")
    setup-experiment
  ]
  if blue-count = 0
  [
    output-print (word ""blue extinct after "" ticks "" generations"")
    setup-experiment
  ]
end

to wander
  ask turtles
  [
    rt random-float 30 - random-float 30
    fd 5
  ]
end

to reproduce
  ask turtles
  [
    ifelse color = red
    [
      set fertility floor red-fertility
      set fertility-remainder red-fertility - (floor red-fertility)
    ]
    [
      set fertility floor blue-fertility
      set fertility-remainder blue-fertility - (floor blue-fertility)
    ]
    ifelse (random-float 100) < (100 * fertility-remainder)
      [ hatch fertility + 1 ]
      [ hatch fertility     ]
  ]
end

;; kill turtles in excess of carrying capacity
;; note that reds and blues have equal probability of dying
to grim-reaper
  let num-turtles count turtles
  if num-turtles <= carrying-capacity
    [ stop ]
  let chance-to-die (num-turtles - carrying-capacity) / num-turtles
  ask turtles
  [
    if random-float 1.0 < chance-to-die
      [ die ]
  ]
end

to plot-counts
  set-current-plot ""Populations""

  set red-count count turtles with [ color = red ]
  set-current-plot-pen ""Reds""
  plot red-count

  set blue-count count turtles with [ color = blue ]
  set-current-plot-pen ""Blues""
  plot blue-count

  set-current-plot-pen ""Total""
  plot count turtles
end


to setup-plot
  set-current-plot ""Populations""
  set-plot-y-range 0 floor (carrying-capacity * 1.2)
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Simple Birth Rates model.
; http://ccl.northwestern.edu/netlogo/models/SimpleBirthRates.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/SimpleBirthRates
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This is a simple model of population genetics.  There are two populations, the REDS and the BLUES. Each has settable birth rates.  The reds and blues move around and reproduce according to their birth rates.  When the carrying capacity of the terrain is exceeded, some agents die (each agent has the same chance of being selected for death) to maintain a relatively constant population.  The model allows you to explore how differential birth rates affect the ratio of reds to blues.


HOW TO USE IT
-------------
Each pass through the GO function represents a generation in the time scale of this model.

The CARRYING-CAPACITY slider sets the carrying capacity of the terrain.  The model is initialized to have a total population of CARRYING-CAPACITY with half the population reds and half blues.

The RED-FERTILITY and BLUE-FERTILITY sliders sets the average number of children the reds and blues have in a generation.  For example, a fertility of 3.4 means that each parent will have three children minimum, with a 40% chance of having a fourth child.

The # BLUES and # REDS monitors display the number of reds and blues respectively.

The GO button runs the model.  A running plot is also displayed of the number of reds, blues and total population (in green).

The RUN-EXPERIMENT button lets you experiment with many trials at the same settings.  This button outputs the number of ticks it takes for either the reds or the blues to die out given a particular set of values for the sliders.  After each extinction occurs, the world is cleared and another run begins with the same settings.  This way you can see the variance of the number of generations until extinction.


THINGS TO NOTICE
--------------------
How does differential birth rates affect the population dynamics?

Does the population with a higher birth rate always start off growing faster?

Does the population with a lower birth rate always end up extinct?


THINGS TO TRY
-----------------
Try running an experiment with the same settings many times.
Does one population always go extinct? How does the number of generations until extinction vary?


EXTENDING THE MODEL
-------------------
In this model, once the carrying capacity has been exceeded, every member of the population has an equal chance of dying. Try extending the model so that reds and blues have different saturation rates. How does the saturation rate compare with the birthrate in determining the population dynamics?

In this model, the original population is set to the carrying capacity (both set to CARRYING-CAPACITY). Would population dynamics be different if these were allowed to vary independently?

In this model, reds are red and blues blue and progeny of reds are always red, progeny of blues are always blue. What if you allowed reds to sometimes have blue progeny and vice versa? How would the model dynamics be different?


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Simple Birth Rates model.  http://ccl.northwestern.edu/netlogo/models/SimpleBirthRates.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/SimpleBirthRates for terms of use.
"
Cooperation,/models/Sample Models/Social Science,"turtles-own [ energy ]
patches-own [ grass ]

breed [ cooperative-cows cooperative-cow ]
breed [ greedy-cows greedy-cow ]

to setup
  ca
  setup-cows
  ask patches [
    set grass max-grass-height
    color-grass
  ]
  do-plotting
end

to setup-cows
  set-default-shape turtles ""cow""   ;; applies to both breeds
  crt initial-cows [
    setxy random-xcor random-ycor
    set energy metabolism * 4
    ifelse (random-float 1.0 < cooperative-probability) [
      set breed cooperative-cows
      set color pink
    ] [
      set breed greedy-cows
      set color blue
    ]
  ]
end

to go
  ask turtles [
    move
    eat
    reproduce
  ]
  ask patches [
    grow-grass
    color-grass
  ]
  tick
  do-plotting
end

to reproduce  ;; turtle procedure
  if (energy > reproduction-threshold) [
    set energy energy - reproduction-cost
    hatch 1
  ]
end

to grow-grass  ;; patch procedure
  ifelse ( grass >= low-high-threshold) [
    if (high-growth-chance >= (random-float 100)) [
      set grass grass + 1
    ]
  ][
    if (low-growth-chance >= (random-float 100)) [
      set grass grass + 1
    ]
  ]
  if (grass > max-grass-height) [
    set grass max-grass-height
  ]
end

to color-grass  ;; patch procedure
  set pcolor scale-color green grass 0 (2 * max-grass-height)
end

to move  ;; turtle procedure
  rt random-float 360
  fd stride-length
  set energy energy - metabolism
  if (energy < 0) [ die ]
end

to eat  ;; turtle procedure
  ifelse breed = cooperative-cows [
    eat-cooperative
  ] [
    if breed = greedy-cows [
      eat-greedy
    ]
  ]
end

to eat-cooperative  ;; turtle procedure
  if (grass > low-high-threshold) [
    set grass grass - 1
    set energy energy + grass-energy
  ]
end

to eat-greedy  ;; turtle procedure
  if (grass > 0) [
    set grass grass - 1
    set energy energy + grass-energy
  ]
end

to do-plotting
  set-current-plot ""Cows over time""
  set-current-plot-pen ""cooperative""
  plot count cooperative-cows
  set-current-plot-pen ""greedy""
  plot count greedy-cows
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Cooperation model.
; http://ccl.northwestern.edu/netlogo/models/Cooperation.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Cooperation
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model (and Altruism and Divide the Cake) are part of the EACH curriculum: ""Evolution of Altruistic and Cooperative Habits: Learning About Complexity in Evolution"".  See http://ccl.northwestern.edu/cm/EACH/ for more information.

This is an evolutionary biology model.  In it, agents (cows) compete for natural resources (grass).  Cows that are more successful in getting grass reproduce more often, and will thus be more evolutionarily successful.  This model includes two kinds of cows, greedy and cooperative.  It shows how these two different strategies do when competing against each other within a population that evolves over time.


HOW IT WORKS
------------
Every turn, each cow looks at the patch that it is currently on, and eats a unit of grass.  The greedy cows eat the grass regardless of the length of the grass on the current patch.  The cooperative cows won't eat the grass below a certain height.  This behavior is significant because below a certain height (called the ""growth threshold""), the grass grows at a far slower rate than above it.  Thus, the cooperative agents leave more food for the overall population at a cost to their individual well-being, while the greedy agents eat the grass down to the nub, regardless of the effect on the overall population.


HOW TO USE IT
-------------
GO: Starts and stops the model.

SETUP: Resets the simulation according to the parameters set by the sliders.

INITIAL-COWS: Sets the number of initial cows.

COOPERATIVE-PROBABILITY: Sets the chance an initial cow will be of the cooperative breed

STRIDE-LENGTH: This value determines the movement of the cows. Each cow will move forward STRIDE-LENGTH patches each turn.  As the value is increased, the cows will move to other patches more frequently.

GRASS-ENERGY: Each time a cow can eat some grass from the patch that it currently occupies, it increases its energy by the value of this slider.

METABOLISM: Every time step, each cow loses the amount of energy set by this slider.  If the cows energy reaches 0, it dies.  Every cow starts with a default energy of 50, which means it can go 50 / METABOLISM turns without eating.

REPRODUCTION-THRESHOLD: If a cow's energy reaches the value of this slider, it reproduces.  This value represents the food-gathering success that a cow would have to have in order to be able to reproduce.

REPRODUCTION-COST: Each time a cow reproduces, it loses the amount of energy set by this slider.  This value represents the energy cost of reproduction.

LOW-GROWTH-CHANCE: This value is the percentage chance that the grass below the growth threshold will grow back.  The higher this value, the less the discrepancy between the behaviors of the cooperative and greedy cows.

HIGH-GROWTH-CHANCE: This value is the percentage chance that the grass above the growth threshold will grow back.  The lower this value, the less the discrepancy between the behaviors of the cooperative and greedy cows.

MAX-GRASS-HEIGHT:  This value sets the highest length to which the grass can grow.

LOW-HIGH-THRESHOLD:  This value sets the grass growth threshold.  At, or above this value, the grass grows back with HIGH-GROWTH-CHANCE.  Below this value, the grass grows back with LOW-GROWTH-CHANCE.


THINGS TO NOTICE
----------------
Run the model with the default settings.  Watch the different growth curves on the population plot.  Which population expands first?  Which population wins in the end?


THINGS TO TRY
-------------
Slowly decrease the STRIDE-LENGTH slider. What happens to the populations?

At what value of STRIDE-LENGTH do the populations' growth rates change dramatically?  What does this indicate about the evolutionary advantages of Cooperating versus being Greedy?  What are the important environmental factors?

Change the METABOLISM and the GRASS-ENERGY values.  How do these values affect the model?

Change the LOW-GROWTH-CHANCE and the HIGH-GROWTH-CHANCE values.  How do these values affect the model?

How does the LOW-HIGH-THRESHOLD value affect the growth of the populations?

Can you find settings that maximize the advantage of the cooperative cows?


EXTENDING THE MODEL
-------------------
This model explores only one type of cooperative behavior, namely eating the grass above the growth threshold (the LOW-HIGH-THRESHOLD value).  What other cooperative, or altruistic, behaviors could be modeled that hurt individual fitness, while helping the group overall?  What other environmental conditions than grass length could be used to effect the health of a population?

This model relies primarily upon population ""viscosity"" (the STRIDE-LENGTH slider) to alter the behavior of the cows to allow for the success of the cooperative agents.  What other variables could have such a drastic effect on the evolutionary success of populations?

Also, consider that in this model the behaviors are fixed.  What would happen if the agents learned, or changed their behavior based on food availability?



NETLOGO FEATURES
----------------
Note how cows are created in the SETUP-COWS procedure. This is done to prevent NetLogo from giving one breed an advantage (as a result of the way NetLogo simulates parallel computations on a serial processor).  When a turtle is created, it is assigned an id number (stored in the turtle variable WHO) that is used by NetLogo to reference it.  When ASK is used, NetLogo gives each turtle a turn in order of their id numbers, from smallest to largest.  So if we had written SETUP-COWS like this:

|    to setup-cows
|      ...
|      create-greedy-cows num-greedy [ ... ]
|      create-cooperative-cows num-cooperative [ ... ]
|    end

then the initial greedy cows will all have id numbers that are lower than those of the initial cooperative cows, since id numbers are assigned in order.  This means the greedy cows will eat and reproduce first.  Theoretically this gives them an advantage.  As it happens, in most runs, the random movement of the cows would prevent this from having a significant effect on the model behavior.  Nonetheless, in the real code we intermingle the creation of the two types of cows in order to avoid any bias.

Future versions of NetLogo may support other scheduling methods besides ""in order by id number"".


RELATED MODELS
--------------
Altruism


CREDITS AND REFERENCES
-----------------------
This model and the Altruism model are part of the curriculum ""Evolution of Altruistic and Cooperative Habits: Learning About Complexity in Evolution"".  See http://ccl.northwestern.edu/cm/EACH/ for more information.

Thanks to Damon Centola, Eamon McKenzie, Josh Mitteldorf, and Scott Styles.

To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Cooperation model.  http://ccl.northwestern.edu/netlogo/models/Cooperation.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Cooperation for terms of use.
"
AIDS,/models/Sample Models/Social Science,"globals [
  infection-chance  ;; The chance out of 100 that an infected person will pass on
                    ;;   infection during one week of couplehood.
  symptoms-show     ;; How long a person will be infected before symptoms occur
                    ;;   which may cause the person to get tested.
  slider-check-1    ;; Temporary variables for slider values, so that if sliders
  slider-check-2    ;;   are changed on the fly, the model will notice and
  slider-check-3    ;;   change people's tendencies appropriately.
  slider-check-4
]

turtles-own [
  infected?          ;; If true, the person is infected.  It may be known or unknown.
  known?             ;; If true, the infection is known (and infected? must also be true).
  infection-length   ;; How long the person has been infected.
  coupled?           ;; If true, the person is in a sexually active couple.
  couple-length      ;; How long the person has been in a couple.
  ;; the next four values are controlled by sliders
  commitment         ;; How long the person will stay in a couple-relationship.
  coupling-tendency  ;; How likely the person is to join a couple.
  condom-use         ;; The percent chance a person uses protection.
  test-frequency     ;; Number of times a person will get tested per year.
  partner            ;; The person that is our current partner in a couple.
]

;;;
;;; SETUP PROCEDURES
;;;

to setup
  ca
  setup-globals
  setup-people
  setup-plot
  update-plot
end

to setup-globals
  reset-ticks
  set infection-chance 50    ;; if you have unprotected sex with an infected partner,
                             ;; you have a 50% chance of being infected
  set symptoms-show 200.0    ;; symptoms show up 200 weeks after infection
  set slider-check-1 average-commitment
  set slider-check-2 average-coupling-tendency
  set slider-check-3 average-condom-use
  set slider-check-4 average-test-frequency
end

;; Create carrying-capacity number of people half are righty and half are lefty
;;   and some are sick.  Also assigns colors to people with the ASSIGN-COLORS routine.

to setup-people
  crt initial-people
    [ setxy random-xcor random-ycor
      set known? false
      set coupled? false
      set partner nobody
      ifelse random 2 = 0
        [ set shape ""person righty"" ]
        [ set shape ""person lefty"" ]
      ;; 2.5% of the people start out infected, but they don't know it
      set infected? (who < initial-people * 0.025)
      if infected?
        [ set infection-length random-float symptoms-show ]
      assign-commitment
      assign-coupling-tendency
      assign-condom-use
      assign-test-frequency
      assign-color ]
end

;; Different people are displayed in 3 different colors depending on health
;; green is not infected
;; blue is infected but doesn't know it
;; red is infected and knows it

to assign-color  ;; turtle procedure
  ifelse not infected?
    [ set color green ]
    [ ifelse known?
      [ set color red ]
      [ set color blue ] ]
end

;; The following four procedures assign core turtle variables.  They use
;; the helper procedure RANDOM-NEAR so that the turtle variables have an
;; approximately ""normal"" distribution around the average values set by
;; the sliders.

to assign-commitment  ;; turtle procedure
  set commitment random-near average-commitment
end

to assign-coupling-tendency  ;; turtle procedure
  set coupling-tendency random-near average-coupling-tendency
end

to assign-condom-use  ;; turtle procedure
  set condom-use random-near average-condom-use
end

to assign-test-frequency  ;; turtle procedure
  set test-frequency random-near average-test-frequency
end

to-report random-near [center]  ;; turtle procedure
  let result 0
  repeat 40
    [ set result (result + random-float center) ]
  report result / 20
end

;;;
;;; GO PROCEDURES
;;;

to go
  if all? turtles [known?]
    [ stop ]
  check-sliders
  ask turtles
    [ if infected?
        [ set infection-length infection-length + 1 ]
      if coupled?
        [ set couple-length couple-length + 1 ] ]
  ask turtles
    [ if not coupled?
        [ move ] ]
  ;; Righties are always the ones to initiate mating.  This is purely
  ;; arbitrary choice which makes the coding easier.
  ask turtles
    [ if not coupled? and shape = ""person righty"" and (random-float 10.0 < coupling-tendency)
        [ couple ] ]
  ask turtles [ uncouple ]
  ask turtles [ infect ]
  ask turtles [ test ]
  ask turtles [ assign-color ]
  tick
  update-plot
end

;; Each tick a check is made to see if sliders have been changed.
;; If one has been, the corresponding turtle variable is adjusted

to check-sliders
  if (slider-check-1 != average-commitment)
    [ ask turtles [ assign-commitment ]
      set slider-check-1 average-commitment ]
  if (slider-check-2 != average-coupling-tendency)
    [ ask turtles [ assign-coupling-tendency ]
      set slider-check-2 average-coupling-tendency ]
  if (slider-check-3 != average-condom-use)
    [ ask turtles [ assign-condom-use ]
      set slider-check-3 average-condom-use ]
  if (slider-check-4 != average-test-frequency )
    [ ask turtles [ assign-test-frequency ]
      set slider-check-4 average-test-frequency ]
end

;; People move about at random.

to move  ;; turtle procedure
  rt random-float 360
  fd 1
end

;; People have a chance to couple depending on their tendency to have sex and
;; if they meet.  To better show that coupling has occurred, the patches below
;; the couple turn gray.

to couple  ;; turtle procedure -- righties only!
  let potential-partner one-of (turtles-at -1 0)
                          with [not coupled? and shape = ""person lefty""]
  if potential-partner != nobody
    [ if random-float 10.0 < [coupling-tendency] of potential-partner
      [ set partner potential-partner
        set coupled? true
        ask partner [ set coupled? true ]
        ask partner [ set partner myself ]
        move-to patch-here ;; move to center of patch
        move-to patch-here ;; partner moves to center of patch
        set pcolor gray - 3
        ask (patch-at -1 0) [ set pcolor gray - 3 ] ] ]
end

;; If two peoples are together for longer than either person's commitment variable
;; allows, the couple breaks up.

to uncouple  ;; turtle procedure
  if coupled? and (shape = ""person righty"")
    [ if (couple-length > commitment) or
         ([couple-length] of partner) > ([commitment] of partner)
        [ set coupled? false
          set couple-length 0
          ask partner [ set couple-length 0 ]
          set pcolor black
          ask (patch-at -1 0) [ set pcolor black ]
          ask partner [ set partner nobody ]
          ask partner [ set coupled? false ]
          set partner nobody ] ]
end

;; Infection can occur if either person is infected, but the infection is unknown.
;; This model assumes that people with known infections will continue to couple,
;; but will automatically practice safe sex, regardless of their condom-use tendency.
;; Note also that for condom use to occur, both people must want to use one.  If
;; either person chooses not to use a condom, infection is possible.  Changing the
;; primitive to AND in the third line will make it such that if either person
;; wants to use a condom, infection will not occur.

to infect  ;; turtle procedure
  if coupled? and infected? and not known?
    [ if random-float 11 > condom-use or
         random-float 11 > ([condom-use] of partner)
        [ if random-float 100 < infection-chance
            [ ask partner [ set infected? true ] ] ] ]
end

;; People have a tendency to check out their health status based on a slider value.
;; This tendency is checked against a random number in this procedure. However, after being infected for
;; some amount of time called SYMPTOMS-SHOW, there is a 5% chance that the person will
;; become ill and go to a doctor and be tested even without the tendency to check.

to test  ;; turtle procedure
  if random-float 52 < test-frequency
    [ if infected?
        [ set known? true ] ]
  if infection-length > symptoms-show
    [ if random-float 100 < 5
        [ set known? true ] ]
end

;;;
;;; PLOTTING PROCEDURES
;;;

to setup-plot
  set-current-plot ""Populations""
  set-plot-y-range 0 (initial-people + 50)
end

to update-plot
  set-current-plot ""Populations""
  set-current-plot-pen ""HIV-""
  plot count turtles with [not infected?]
  set-current-plot-pen ""HIV?""
  plot count turtles with [infected?] -
       count turtles with [known?]
  set-current-plot-pen ""HIV+""
  plot count turtles with [known?]
end

;;;
;;; MONITOR PROCEDURES
;;;

to-report %infected
  ifelse any? turtles
    [ report (count turtles with [infected?] / count turtles) * 100 ]
    [ report 0 ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo AIDS model.
; http://ccl.northwestern.edu/netlogo/models/AIDS.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/AIDS
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model simulates the spread of the human immunodeficiency virus (HIV), via sexual transmission, through a small isolated human population.  It therefore illustrates the effects of certain sexual practices across a population.

As is well known now, HIV is spread in a variety of ways of which sexual contact is only one.  HIV can also be spread by needle-sharing among injecting drug-users, through blood transfusions (although this has become very uncommon in countries like the United States in which blood is screened for HIV antibodies), or from HIV-infected women to their babies either before or during birth, or afterwards through breast-feeding.  This model focuses only on the spread of HIV via sexual contact.

The model examines the emergent effects of four aspects of sexual behavior.  The user controls the population's tendency to practice abstinence, the amount of time an average ""couple"" in the population will stay together, the population's tendency to use condoms, and the population's tendency to get tested for HIV.  Exploration of the first and second variables may illustrate how changes in sexual mores in our society have contributed to increases in the prevalence of sexually transmitted diseases, while exploration of the third and fourth may provide contemporary solutions to the problem.

By allowing the user to control how often an average individual will choose to be tested, the user can explore an important dimension of HIV's threat to public health.  Because the virus does not make itself immediately known in its host, individuals are often infected for some time before a test or immune deficiency symptoms (which leads to a test) identifies them as such.  Regular identification of individuals infected by the virus could have significant public health impacts if knowledge of the infection positively affected sexual behaviors.  This model explores this possibility by making all individuals who know of their positive HIV status always practice safe sex.


HOW TO USE IT
-------------
The model uses ""couples"" to represent two people engaged in sexual relations.  Individuals wander around the world when they are not in couples.  Upon coming into contact with a suitable partner, there is a chance the two individuals will ""couple"" together.  When this happens, the two individuals no longer move about, they stand next to each other holding hands as a representation of two people in a sexual relationship.

The presence of the virus in the population is represented by the colors of individuals.  Three colors are used: green individuals are uninfected, blue individuals are infected but their infection is unknown, and red individuals are infected and their infection is known.

The SETUP button creates individuals with particular behavioral tendencies according to the values of the interface's five sliders (described below).  Once the simulation has been setup, you are now ready to run it, by pushing the GO button.  GO starts the simulation and runs it continuously until GO is pushed again.  During a simulation initiated by GO, adjustments in sliders can affect the behavioral tendencies of the population.

A monitor shows the percent of the population that is infected by HIV.  In this model each time-step is considered one week; the number of weeks that have passed is shown in the toolbar.

Here is a summary of the sliders in the model.  They are explained in more detail below.

- INITIAL-PEOPLE: How many people simulation begins with.
- AVERAGE-COUPLING-TENDENCY: General likelihood member of population has sex (0-10).
- AVERAGE-COMMITMENT: How many weeks sexual relationships typically lasts (0-200).
- AVERAGE-CONDOM-USE: General chance member of population uses a condom. (0-10).
- AVERAGE-TEST-FREQUENCY: Average frequency member of population will check their HIV status in a 1-year time period (0 - 2).

The total number of individuals in the simulation is controlled by the slider INITIAL-PEOPLE (initialized to vary between 50 - 500), which must be set before SETUP is pushed.

During the model's setup procedures, all individuals are given ""tendencies"" according to four additional sliders.  These tendencies are generally assigned in a normal distribution, so that, for instance, if a tendency slider is set at 8, the most common value for that tendency in the population will be 8.  Less frequently, individuals will have values 7 or 9 for that tendency, and even less frequently will individuals have values 6 or 10 (and so on).

The slider AVERAGE-COUPLING-TENDENCY (0 - 10) determines the tendency of the individuals to become involved in couples (as stated earlier, all couples are presumed to be sexually active). When the AVERAGE-COUPLING-TENDENCY slider is set at zero, coupling is unlikely, although (because tendencies are assigned in a normal distribution) it is still possible.  Note that when deciding to couple, both individuals involved must be ""willing"" to do so, so high coupling tendencies in two individuals are actually compounded (i.e. two individuals with a 50% chance of coupling actually only have a 25% of coupling in a given tick).

The slider AVERAGE-COMMITMENT (1 - 200) determines how long individuals are likely to stay in a couple (in weeks).  Again, the tendencies of both individuals in a relationship are considered; the relationship only lasts as long as is allowed by the tendency of the partner with a shorter commitment tendency.

The slider AVERAGE-CONDOM-USE (0 - 10) determines the tendency of individuals in the population to practice safe sex.  If an individual uses a condom, it is assumed in this model that no infection by HIV is possible.  Note that this tendency (like the others) is probabilistic at several levels.  For instance, when AVERAGE-CONDOM-USE is set to 9, most of the individuals have a CONDOM-USE value of 9, although some have CONDOM-USE values of 8 or 10, and fewer yet have CONDOM-USE values of 7 or 11 (11 would be off-scale and the same as 10 for all practical purposes).  Also, an individual with a CONDOM-USE value of 9 will still sometimes not choose to use a condom (10% of the time, roughly). Simulation of condom-use is further complicated by the fact that if one partner ""wants"" to use a condom while the other partner does not, the couple does not use condoms.  This characteristic of the model is representative of the dynamics of some sexual relations, but not others.  The decision was somewhat arbitrary, and the user is invited to play with this characteristic and others in the ""Extending the Model"" section of this tab.

The slider AVERAGE-TEST-FREQUENCY (0 - 2) is the final slider of the interface.  It determines the average frequency of an individual to get tested for HIV in a one-year time span.  Set at 1.0, the average person will get tested for HIV about once a year.  Set at 0.2, the average individual will only get tested about every five years.  This tendency has significant impact because the model assumes that individuals who know that they are infected always practice safe sex, even if their tendency as healthy individuals was different.  Again, this characteristic of the model is only represented of the behaviors of some individuals.  The model was designed in this way to highlight the public health effects associated with frequent testing *and* appropriate responses to knowledge of one's HIV status.  To explore the impact of alternative behaviors on public health, the model code can be changed relatively painlessly.  These changes are described in the section, ""Extending the Model.""

The model's plot draws a line graph showing the total number of uninfected individuals (green), infected individuals whose positive status is not known (blue), and infected individuals whose positive status is known (red).


THINGS TO NOTICE
----------------
Set the INITIAL-PEOPLE slider to 300, AVERAGE-COUPLING-TENDENCY to 10, AVERAGE-COMMITMENT to 100, and the other two sliders to 0. Push SETUP and then push GO.  Notice that many individuals rapidly pair up into stationary ""couples"", with the patches behind them turned a dark gray.  These couples represent sexual activity between the two individuals.  Individuals that continue to move about (and do not have a gray patch behind them) are not engaging in sexual relations.  With RELATIONSHIP-DURATION set to 100, an average individual will have monogamous sexual relations with a partner for about 100 weeks (approximately 2 years) before ending the sexual relationship and searching out a new partner.

Stop the simulation (by pressing the GO button once again), move the AVERAGE-COUPLING-TENDENCY slider to 0, push SETUP, and start the simulation again (with the GO button).  Notice that this time, couples are not forming.  With a low COUPLING-TENDENCY, individuals do not choose to have sex, which in this model is depicted by the graphical representation of couplehood.  Notice that with these settings, HIV does not typically spread. However, spreading could happen since the population's tendency is set according to a normal distribution and a few people will probably have COUPLING-TENDENCY values above 0 at this setting.

Again reset the simulation, this time with AVERAGE-COUPLING-TENDENCY set back to 10 and AVERAGE-COMMITMENT set to 1.  Notice that while individuals do not stand still next to each other for any noticeable length of time, coupling is nevertheless occurring.  This is indicated by the occasional flash of dark gray behind individuals that are briefly next to one another.  Notice that the spread of HIV is actually faster when RELATIONSHIP-DURATION is very short compared to when it is very long.

Now run a simulation with AVERAGE-COMMITMENT equal to 1, AVERAGE-COUPLING-TENDENCY set to 1, AVERAGE-CONDOM-USE set to 10, and AVERAGE-TEST-FREQUENCY set to 1.0. With negligible couple formation and high condom use anyway, there should be no spread of HIV.  Notice how pale blue ""infection unknown"" individuals turn red much quicker in this simulation.  When the individuals turn red, they know their HIV status.  Some individuals turn red because they have been infected for long enough that they develop symptoms, which alerts them to the need for an HIV test.  Others become red because they choose to be tested.  With AVERAGE-TEST-FREQUENCY set to 1.0, healthy individuals are also being tested, but their color does not change since the tests come back negative.

When all the individuals in the simulation are either green or red, change the sliders without stopping the simulation.  Set AVERAGE-COUPLING-TENDENCY to 10, AVERAGE-COMMITMENT to 100, AVERAGE-CONDOM-USE to 0, and AVERAGE-TEST-FREQUENCY to 0.  Notice that despite the immediate formation of couples and the fact that condom-use tendency is presumably very low, some between healthy (green) individuals and infected (red) individuals, no spread of HIV occurs.  This is because while the model expects HIV positive individuals to continue to engage in sexual relations, it presumes that those individuals will always use condoms and that the condoms will always work.  The rationale for this design is discussed briefly in the ""What is it?"" section of this tab.

Finally, set INITIAL-PEOPLE to 500 to notice that couples can form on top of each other.  Watch the simulation until you see individuals by themselves, but standing still and with a gray patch behind them indicating coupling.  Underneath one of its neighbors, is the individuals partner.  This apparent bug in the program is necessary because individuals need to be able to couple fairly freely.  If space constraints prohibited coupling, unwanted emergent behavior would occur with high population densities.

Couples are formed by a partnership of ""righty"" and ""lefty"" shapes which is not immediately noticeable.  These shapes are not intended to represent genders in any fashion, but merely to provide a useful way to depict couple graphics. In order for the hands of a righty and lefty to match up, both must be off-centered in their patch.  Without this feature, two couples next to each other would appear to be a line of four individuals (instead of two groups of two).  It is intended that the differences between righty and lefty shapes not be especially apparent in order to prevent unintended associations with gender.  Any righty or lefty shape can be thought of as male or female or neither.


THINGS TO TRY
-------------
Run a number of experiments with the GO button to find out the effects of different variables on the spread of HIV.  Try using good controls in your experiment.  Good controls are when only one variable is changed between trials.  For instance, to find out what effect the average duration of a relationship has, run four experiments with the AVERAGE-COMMITMENT slider set at 1 the first time, 2 the second time, 10 the third time, and 50 the last.  How much does the prevalence of HIV increase in each case?  Does this match your expectations?

Are the effects of some slider variables mediated by the effects of others?  For instance, if lower AVERAGE-COMMITMENT values seem to increase the spread of HIV when all other sliders are set at 0, does the same thing occur if all other sliders are set at 10?  You can run many experiments to test different hypotheses regarding the emergent public health effects associated with individual sexual behaviors.


EXTENDING THE MODEL
-------------------
Like all computer simulations of human behaviors, this model has necessarily simplified its subject area substantially.  The model therefore provides numerous opportunities for extension:

The model depicts sexual activity as two people standing next to each other.  This suggests that all couples have sex and that abstinence is only practiced in singlehood.  The model could be changed to reflect a more realistic view of what couples are.  Individuals could be in couples without having sex.  To show sex, then, a new graphical representation would have to be employed.  Perhaps sex could be symbolized by having the patches beneath the couple flash briefly to a different color.

The model does not distinguish between genders.  This is an obvious over-simplification chosen because making an exclusively heterosexual model was untenable while making one that included a variety of sexual preferences might have distracted from the public health issues which it was designed to explore.  However, extending the model by adding genders would make the model more realistic.

The model assumes that individuals who are aware that they are infected always practice safe sex.  This portrayal of human behavior is clearly not entirely realistic, but it does create interesting emergent behavior that has genuine relevance to certain public health debate.  However, an interesting extension of the model would be to change individuals' reactions to knowledge of HIV status.

The model assumes that condom use is always 100% effective.  In fact, responsible condom use is actually slightly less than ideal protection from the transmission of HIV.  Add a line of code to the INFECT procedure to check for a slight random chance that a particular episode of condom-use is not effective.  Another change that can be made in the INFECT procedure regards a couple's choice of condom-use.  In this model, when the two partners of a couple ""disagree"" about whether or not to use a condom, the partner that doesn't wish to use a condom makes the choice.  The opposite possibility is also valid.

Finally, certain significant changes can easily be made in the model by simply changing the value of certain global variables in the procedure SETUP-GLOBALS.  Two variables set in this procedure that are especially worthy of investigation are INFECTION-CHANCE and SYMPTOMS-SHOW.  The former controls what chance an infection has of spreading from an infected to an uninfected partner if no protection is used.  The variable is currently set to 50, meaning that in a week of sexual relations, the chance of infection occurring is 50%.  It is not clear at this time how realistic that figure is. SYMPTOMS-SHOW is the variable that controls how long, on average, a person will have the HIV virus before symptoms begin to appear, alerting that person to the presence of some health problem.  It is currently set to 200 (weeks) in this model.


NETLOGO FEATURES
-----------------
Notice that the four procedures that assign the different tendencies generate many small random numbers and add them together.  This produces a normal distribution of tendency values.  A random number between 0 and 100 is as likely to be 1 as it is to be 99. However, the sum of 20 numbers between 0 and 5 is much more likely to be 50 than it is to be 99.

Notice that the global variables SLIDER-CHECK-1, SLIDER-CHECK-2, and so on are assigned with the values of the various sliders so that the model can check the sliders against the variables while the model is running.  Every time-step, a slider's value is checked against a global variable that holds the value of what the slider's value was the time-step before.  If the slider's current value is different than the global variable, NetLogo knows to call procedures that adjust the population's tendencies.  Otherwise, those adjustment procedures are not called.


CREDITS AND REFERENCES
----------------------
Special thanks to Steve Longenecker for model development.

To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo AIDS model.  http://ccl.northwestern.edu/netlogo/models/AIDS.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/AIDS for terms of use.
"
Rebellion,/models/Sample Models/Social Science,"breed [agents agent]
breed [cops cop]

globals [
  k                   ; factor for determining arrest probability
  threshold           ; by how much must G > N to make someone rebel?
]

agents-own [
  risk-aversion       ; R, fixed for the agent's lifetime, ranging from 0-1 (inclusive)
  perceived-hardship  ; H, also ranging from 0-1 (inclusive)
  active?             ; if true, then the agent is actively rebelling
  jail-term           ; how many turns in jail remain? (if 0, the agent is not in jail)
]

patches-own [
  neighborhood        ; surrounding patches within the vision radius
]

to setup
  clear-all

  ;; set globals
  set k 2.3
  set threshold 0.1

  ask patches [
    ;; make background a slightly dark gray
    set pcolor gray - 1
    ;; cache patch neighborhoods
    set neighborhood patches in-radius vision
  ]

  ;; create cops
  create-cops round (initial-cop-density * .01 * count patches) [
    move-to one-of patches with [not any? turtles-here]
    display-cop
  ]

  ;; create agents
  create-agents round (initial-agent-density * .01 * count patches) [
    move-to one-of patches with [not any? turtles-here]
    set heading 0
    set risk-aversion random-float 1.0
    set perceived-hardship random-float 1.0
    set active? false
    set jail-term 0
    display-agent
  ]

  ;; plot initial state of system
  update-plots
end

to go
  ask turtles [
    ; Rule M: Move to a random site within your vision
    if (breed = agents and jail-term = 0) or breed = cops
      [ move ]
    ;   Rule A: Determine if each agent should be active or quiet
    if breed = agents and jail-term = 0 [ determine-behavior ]
    ;  Rule C: Cops arrest a random active agent within their radius
    if breed = cops [ enforce ]
  ]
  ; Jailed agents get their term reduced at the end of each clock tick
  ask agents
    [ if jail-term > 0 [ set jail-term jail-term - 1 ] ]
  ; update agent display
  ask agents [ display-agent ]
  ask cops [ display-cop ]
  ; advance clock and update plots
  tick
  update-plots
end

;; AGENT AND COP BEHAVIOR

;; move to an empty patch
to move ;; turtle procedure
  if movement? or (breed = cops) [
    ;; move to a patch in vision; candidate patches are
    ;; empty or contain only jailed agents
    let targets neighborhood with
                [not any? cops-here and all? agents-here [jail-term > 0]]
    if any? targets [ move-to one-of targets ]
  ]
end

;; AGENT BEHAVIOR

to determine-behavior
  set active? (grievance - risk-aversion * estimated-arrest-probability > threshold)
end

to-report grievance
  report perceived-hardship * (1 - government-legitimacy)
end

to-report estimated-arrest-probability
  let C count cops-on neighborhood
  let A 1 + count (agents-on neighborhood) with [active?]
  ;; See Information tab for a discussion of the following formula
  report 1 - exp (- k * floor (C / A))
end

;; COP BEHAVIOR

to enforce
  if any? (agents-on neighborhood) with [active?] [
    ;; arrest suspect
    let suspect one-of (agents-on neighborhood) with [active?]
    ask suspect [
      set active? false
      set jail-term random max-jail-term
    ]
    move-to suspect  ;; move to patch of the jailed agent
  ]
end

;; VISUALIZATION OF AGENTS AND COPS

to display-agent  ;; agent procedure
  ifelse visualization = ""2D""
    [ display-agent-2D ]
    [ display-agent-3D ]
end

to display-agent-2D  ;; agent procedure
  set shape ""circle""
  ifelse active?
    [ set color red ]
    [ ifelse jail-term > 0
        [ set color black + 3 ]
        [ set color scale-color green grievance 1.5 -0.5 ] ]
end

to display-agent-3D  ;; agent procedure
  set color scale-color green grievance 1.5 -0.5
  ifelse active?
    [ set shape ""person active"" ]
    [ ifelse jail-term > 0
        [ set shape ""person jailed"" ]
        [ set shape ""person quiet"" ] ]
end

to display-cop
  set color cyan
  ifelse visualization = ""2D""
    [ set shape ""triangle"" ]
    [ set shape ""person soldier"" ]
end

;; PLOTTING

to update-plots
  let active-count count agents with [active?]
  let jailed-count count agents with [jail-term > 0]

  set-current-plot ""Active agents""
  plot active-count

  set-current-plot ""All agent types""
  set-current-plot-pen ""active""
  plot active-count
  set-current-plot-pen ""jailed""
  plot jailed-count
  set-current-plot-pen ""quiet""
  plot count agents - active-count - jailed-count
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2004 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2004).  NetLogo Rebellion model.
; http://ccl.northwestern.edu/netlogo/models/Rebellion.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2004 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Rebellion
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This project models the rebellion of a subjugated population against a central authority. It is is an adaptation of Joshua Epstein's model of civil violence (2002).

The population wanders around randomly. If their level of grievance against the central authority is high enough, and their perception of the risks involved is low enough, they openly rebel. A separate population of police officers (""cops""), acting on behalf of the central authority, seeks to suppress the rebellion. The cops wander around randomly and arrest people who are actively rebelling.


HOW IT WORKS
------------
Each ""agent,"" or member of the general population, has an individual level of grievance toward the central authority. GRIEVANCE is based on the agent's PERCEIVED-HARDSHIP, which is assigned randomly at startup, and on GOVERNMENT-LEGITIMACY, which is global across agents and specified by a slider in the interface.

Each agent also calculates an individual risk of rebelling at the beginning of each turn.  This ESTIMATED-ARREST-PROBABILITY, is based on the number of cops and already rebelling agents within VISION patches, namely 1 - exp [ - k * (C/A)_v ] -- where (C/A)_v is the ratio of cops to active agents, and k is a constant set in ""startup"" to ensure a reasonable value when there is only one cop and one agent within a particular field of vision.  In our implementation, we changed one aspect of Epstein's description.  After dividing by C by A, we take the ""floor"" of the result (that is, round downwards to an integer).  Without this change, the model does not exhibit punctuated equilibrium.  The effect of the change is that if there are more rebels than cops in the neighborhood, the probability of arrest is zero, otherwise it is very nearly 1.0.  In other words, the rule could be written more simply as:
|  ifelse A > C [ report 0 ] [ report 0.99 ]

An agent's NET-RISK is the product of the calculated ESTIMATED-ARREST-PROBABILITY and RISK-AVERSION randomly set for each agent at birth.

The model cycles through three different rules, known as M (move), A (agents) and C (cops):

- Movement rule M says that each cop and non-imprisoned agent moves to a random unoccupied site within VISION patches.

- Agent rule A says that if an agent's GRIEVANCE exceeds the NET-RISK by a small threshold (set by default to 0.1 in ""setup""), the agent decides to rebel.  This is noted by changing the agent's border color from blue to red.  (It is also possible for the agent to move from rebellion to quiet, in which case the border color changes from red to blue.)

- Cop rule C says that each cop should look for active agents within VISION patches.  If at least one exists, the cop randomly selects one active agent and sends it to jail for a number of turns between 0 and MAX-JAIL-TERM (settable by a slider in the interface) and moves to the patch of the jailed agent. The patch of the jailed agent is considered unoccupied.


HOW TO USE IT
-------------
Use the sliders to pick the initial settings for the model. INITIAL-COP-DENSITY and POPULATION-DENSITY respectively determine the density of cops and agents in the world. VISION determines the number of patches in each direction that agents and cops can see.

Click SETUP to initialize the population. Click GO to begin the simulation.

As the simulation runs, you can adjust GOVERNMENT-LEGITIMACY and MAX-JAIL-TERM. You can control the mobility of the agents through the MOVEMENT? toggle.

The visualization chooser allows you to choose between 2D visualization where the turtles are circles and triangles or 3D visualization where the agents have people shapes.

The color of the agents shows their private level of grievance. The darker the green, the higher the GRIEVANCE.  This color does not change throughout the run of a model (unless you change the GOVERNMENT-LEGITIMACY slider).


THINGS TO NOTICE
----------------
Watch how agents exhibit deceptive behavior by changing their public state when cops are present, despite a constant level of private grievance. To see this press the WATCH ONE button, slow down the model, switch to the 3D view and zoom in on the selected agent. It may be easier to see this phenomenon if you change the sliders, especially reducing the VISION.

Watch the plot of active agents. Notice that it exhibits ""punctuated equilibrium"" -- periods of quiescence followed by periods of rebellion.


THINGS TO TRY
-------------
Epstein claims that movement of the agents causes more frequent episodes of rebellion. Run the model with the MOVEMENT? switch on and off to see if you get this result.

Compare the effects of a gradual erosion in the perceived legitimacy of the central authority to a smaller, but immediate drop. For example, set GOVERNMENT-LEGITIMACY to 0.9 and reduce it to zero over 250 runs, plotting the legitimacy and the number of active agents. Now do another run, beginning with legitimacy at 0.9. This time, leave the legitimacy constant for 80 runs and then drop it to 0.7 at once. Observe the results. Try to explain them. Think of historical examples of this phenomena. What are the implications of this result for the strategy of revolutionary leaders?

Epstein quotes de Tocqueville: ""It is not always when things are going from bad to worse that revolutions break out. On the contrary, it oftener happens that when a people that has put up with oppressive rule over a long period without protest suddenly finds the government relaxing its pressure, it takes up arms against it."" Test de Tocqueville's observation in the model by comparing the effects of a gradual erosion in perceived legitimacy with a gradual erosion in the number of cops. Observe the results. Explain the difference.


EXTENDING THE MODEL
-------------------
Write a reporter procedure that reports TRUE when there is a rebellion, FALSE during quiescent periods.

Measure the intervals between episodes of rebellion. What is the distribution of these waiting times?

Try changing some of Epstein's assumptions as below. Do these changes create qualitative differences in results?

Change GOVERNMENT-LEGITIMACY such that it increases proportionally with the number of nearby jailed agents.

Change the model such that each agent's GRIEVANCE is influenced by the value of other nearby agents.


NETLOGO FEATURES
----------------
Note the use of a patch variable to store precomputed neighborhood agentsets.  This improves performance because the neighborhoods don't have to be calculated over and over again.


CREDITS AND REFERENCES
----------------------
This model, and the preceding explanation, is adapted from Joshua M. Epstein, ""Modeling civil violence: An agent-based computational approach"", Proceedings of the National Academy of Sciences, Vol. 99, Suppl. 3, May 14, 2002, and is available at http://www.pnas.org/cgi/content/abstract/99/suppl_3/7243

To refer to this model in academic publications, please use:  Wilensky, U. (2004).  NetLogo Rebellion model.  http://ccl.northwestern.edu/netlogo/models/Rebellion.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2004 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Rebellion for terms of use.
"
Muscle Development,/models/Sample Models/Biology,"breed [ muscle-fibers muscle-fiber ]

muscle-fibers-own [
  fiber-size   ;; different from built-in ""size"" because it uses different units
  max-size
]

patches-own [
  anabolic-hormone  ;; muscle building hormone
  catabolic-hormone ;; muscle breaking down hormone
]

globals [
  muscle-mass  ;; stores sum of muscle-fiber sizes
  ;; hormone bounds to ensure a realistic environment
  anabolic-hormone-max
  anabolic-hormone-min
  catabolic-hormone-max
  catabolic-hormone-min
  ;; the rate at which hormones from one fiber diffuse to others
  hormone-diffuse-rate
]

to setup
  ca
  set-default-shape muscle-fibers ""circle""
  initialize-hormones
  new-muscle-fibers
  set muscle-mass sum [fiber-size] of muscle-fibers
  do-plotting
end

to initialize-hormones
  ;; constants chosen align the model time frame for muscle development
  ;; with realistic values
  set hormone-diffuse-rate 0.75
  ask patches [
    set anabolic-hormone-max 200
    set catabolic-hormone-max 250
    set anabolic-hormone-min 50
    set catabolic-hormone-min 52
    set anabolic-hormone 50
    set catabolic-hormone 52
  ]
  regulate-hormones
end

to new-muscle-fibers
  ask patches [
    sprout-muscle-fibers 1 [
      set max-size 4
      ;; create a normalized distribution of maximum muscle fiber sizes
      ;; with median dependent on % of slow twitch fibers.
      repeat 20  [
        if random-float 100 > %-slow-twitch-fibers [
          set max-size max-size + 1
        ]
      ]
      ;; provide non-uniform starting sizes for varied results, everyone's different
      set fiber-size (0.2 + random-float 0.4) * max-size
      regulate-muscle-fibers
    ]
  ]
end

to go
  ;; note the use of the LOG primitive in the procedures called below
  ;; to simulate a natural system's tendency to adapt less and less
  ;; to each additional unit of some biological substance
  perform-daily-activity
  if lift? and (ticks mod days-between-workouts = 0)
    [ lift-weights ]
  sleep
  regulate-hormones
  develop-muscle
  set muscle-mass sum [fiber-size] of muscle-fibers
  tick
  do-plotting
end

to perform-daily-activity
  ;; simulate hormonal effect of lifestyle
  ;; activities like watching TV and working
  ask muscle-fibers [
    set catabolic-hormone catabolic-hormone + 2.0 * (log fiber-size 10)
    set anabolic-hormone anabolic-hormone + 2.5 * (log fiber-size 10)
  ]
end

to lift-weights
  ;; simulate hormonal effect of weight training
  ask muscle-fibers [
    if( random-float 1.0 < intensity / 100 * intensity / 100 ) [
      set anabolic-hormone anabolic-hormone + (log fiber-size 10) * 55
      set catabolic-hormone catabolic-hormone + (log fiber-size 10) * 44
    ]
  ]
end

to sleep
  ;; simulate hormonal effect of sleeping
  ask patches [
    set catabolic-hormone catabolic-hormone - 0.5 * (log catabolic-hormone 10) * hours-of-sleep
    set anabolic-hormone anabolic-hormone - 0.48 * (log anabolic-hormone 10) * hours-of-sleep
  ]
end

to develop-muscle
  ask muscle-fibers [
    grow
    regulate-muscle-fibers
  ]
end

to grow  ;; turtle procedure
  ;; catabolic hormones must prepare the fibers for growth before the
  ;; anabolic hormones may add mass to the fibers
  set fiber-size (fiber-size - 0.20 * (log catabolic-hormone 10))
  set fiber-size (fiber-size + 0.20 * min (list (log anabolic-hormone 10)
                                                (1.05 * log catabolic-hormone 10)))
end

to regulate-muscle-fibers ;;turtle procedure
  ;; simulate the body's natural limits on minimum and maximum fiber sizes
  if (fiber-size  < 1) [ set fiber-size 1 ]
  if (fiber-size > max-size) [ set fiber-size max-size ]
  set color scale-color red fiber-size (-0.5 * max-size) (3 * max-size)
  ;; base the visible size of the turtle on its fiber-size
  set size max list 0.2 (min list 1 (fiber-size / 20))
end

to regulate-hormones ;;patch procedure
  ;; hormones spread to neighboring fibers
  diffuse anabolic-hormone hormone-diffuse-rate
  diffuse catabolic-hormone hormone-diffuse-rate
  ;; if there are to many or to few hormones in an area,
  ;; the body will try very hard to restore a balance
  ask patches [
    set anabolic-hormone min (list anabolic-hormone anabolic-hormone-max)
    set anabolic-hormone max (list anabolic-hormone anabolic-hormone-min)
    set catabolic-hormone min (list catabolic-hormone catabolic-hormone-max)
    set catabolic-hormone max (list catabolic-hormone catabolic-hormone-min)
    ;;color patches based on hormone concentrations
    set pcolor approximate-rgb ((catabolic-hormone / catabolic-hormone-max) * 255)
                   ((anabolic-hormone / anabolic-hormone-max)  * 255)
                   0
  ]
end

to do-plotting
  set-current-plot ""Muscle Development""
  set-current-plot-pen ""muscle""
  plot muscle-mass / 100

  set-current-plot ""Hormones""
  set-current-plot-pen ""anabolic""
  plot mean [anabolic-hormone] of patches
  set-current-plot-pen ""catabolic""
  plot mean [catabolic-hormone] of patches
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2002 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2002).  NetLogo Muscle Development model.
; http://ccl.northwestern.edu/netlogo/models/MuscleDevelopment.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2002 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/MuscleDevelopment
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This is an exercise physiology model.  It is intended to help you understand the factors involved in generating the appropriate hormonal balance to develop muscle from weight lifting.  These factors include:

Frequency: How often you lift weights must be managed appropriately in order to see gains in muscle mass.  If you lift too frequently, you will not have time to recover and then rebuild stronger muscles.  If you fail to lift frequently enough, there will not be enough stimuli to elicit long term gains in muscle.

Sleep: The body performs most of its recovery while sleeping.  If you don't get enough sleep, you will not be providing enough opportunity for recovery, so you will find it difficult to gain muscle.

Intensity: How hard you works in the weight room affects how effective you are at recruiting all of your muscle fibers.  The greater the number of fibers recruited, the greater the growth stimulus, assuming appropriate recovery is provided for.

Genetic: The ratio of slow twitch to fast twitch muscle fibers plays a large role in how much muscle an individual is capable of developing.  Someone with a majority of fibers that exhibit slow twitch characteristics will have high endurance, but the potential to develop only moderate muscle mass.  An individual with a majority of fibers with fast twitch characteristics will have the potential to develop considerable muscle mass, but low endurance.

Diet: A poor diet can prevent muscle growth.  In this model we assume perfect diet.

All five of these factors must be understood and put into balance with one another in order to achieve optimal muscular development.  The appropriate combination is highly dependent on the individual and their current, unique state.  It will change over time.


HOW IT WORKS
------------
Ultimately, the effects of resistance training occur as a result of the hormonal responses it elicits from the body.  The hormones essential to muscle development can be separated into two broad classes: catabolic hormones and anabolic hormones.  Catabolic hormones break down the muscle fiber to prepare it to be rebuilt stronger by the anabolic hormones.  Note: catabolic hormones play a vital role, as muscle fibers must be broken down before they can be built back up.

This model attempts to simulate these effects with a cross sectional portrayal of a muscle at the level of the muscle fibers.  When the observer activates a muscle fiber through resistance training, the fiber releases a chemical signal that results in a surge of hormones at the location of the fiber.  These hormones affect the fiber development as mentioned above and will dissipate over time.

The circles represent muscle fibers.  The background they appear against may be thought of as the cellular fluid that contains the anabolic and catabolic hormones.  The brighter the green, the more anabolic (muscle building) the environment.  The brighter the yellow, the more catabolic (muscle destroying) the environment.


HOW TO USE IT
-------------
Buttons:
SETUP: Sets up the model
GO: Runs the model

Switches:
LIFT?: Decides whether or not the person is actively weight lifting

Sliders:
INTENSITY: How hard the lifter is working.  The greater the intensity, the greater the number of muscle fibers that will be fatigued each workout session.
HOURS-OF-SLEEP: The amount of sleep a person gets affects how quickly the body breaks down the hormones.

DAYS-BETWEEN-WORKOUTS: The frequency of the workouts effects how much time the body has to recover and then over-compensate from the last workout
%-SLOW-TWITCH-FIBERS: How likely each fiber is to possess slow twitch characteristics.

Plots:
MUSCLE DEVELOPMENT VS. TIME: The sum of all fiber sizes over time
HORMONES VS. TIME: The average hormone content near each fiber


THINGS TO TRY
----------------
Steps one through three should be run with %-SLOW-TWITCH slider set to 50.

1.  Run the model at its default settings.  What eventually happens to the amount of muscle mass?  Why?

2.  Overtraining occurs when the body is not allowed to recover completely from the last exercise session before being trained again.  This causes stagnation of muscular development, and in extreme cases, muscle loss.  What types of conditions can lead to overtraining?  What is the best way to recover from overtraining?  What steps can be taken to avoid it?

3.  Many undertake weight training in an effort to build the maximum amount of muscle they are capable of.  Find the best method for achieving this.  How must it vary over time?  Why is it important to take one's current level of condition into consideration when choosing a resistance training program?

4.  An issue rarely addressed in conventional training is that of genetic ability.  A major factor effecting this the proportion of slow twitch vs. fast twitch muscle fibers a person possesses.  Slow twitch fibers provide for greater endurance, fast twitch greater strength and size.

Attempt to obtain maximal muscular development with the %-SLOW-TWITCH slider set at 90% and then 10%. How do the results one can obtain vary with genetic ability?  Training methods?  What does this suggest about the average person following the routines of genetically gifted professional bodybuilders?


EXTENDING THE MODEL
-------------------
1. In order to ensure you have achieved maximum muscular development, add a pen named ""max-muscle"" to the ""Muscle Development"" plot.  Now modify the DO-PLOTTING procedure to use the ""max-muscle"" pen to plot the sum of the MAX-SIZE value of all the muscle fibers.

2. Nutritional quality can have a major influence on the results obtained from training.  Modify the model to allow for this influence.  Add a NUTRIENT variable to the MUSCLE-FIBER breed.  Add a NUTRITIONAL-QUALITY slider to the model.  Now modify the GO procedure to call a OBTAIN-NUTRITION function that releases nutrients into the patches.  Finally, alter the GROW procedure to use the available nutrients when adding size to a muscle fiber.

3.  Real life creates many inconsistencies in the average person's strength training program.  Add a variance function to the model that randomly generates nights of less sleep and extra rest days between workouts to reflect these inconsistencies.  Add a switch to allow the user to turn this variance on or off.  Add a slider to allow the user to adjust the level of variance.  What effect do these inconsistencies have on muscular development?


THINGS TO NOTICE
----------------
The human body is an incredibly complex system.  In order to simulate the piece of it in which we are interested, assumptions have been made about the behavior of other pieces.  This can be seen in the hard-coding of various parameters, such as the hormone limits and the maximum muscle fiber sizes.  These assumptions allow us to focus upon gaining an understanding of the overall process of muscle development without becoming burdened with excessive information.


NETLOGO FEATURES
-----------------
Note the use of the REPEAT primitive and %-SLOW-TWITCH-FIBERS variable in the NEW-MUSCLE-FIBERS procedure to generate a normal distribution of the maximum muscle fiber sizes centered at a median influenced by the %-SLOW-TWITCH-FIBERS value.

Note the use of the LOG function in the procedures which regulate hormonal release and balance.  This allows us to more closely mimic the natural tendency for each additional unit of a biological component to illicit less of an adaptive change from the system than the one before it.

Note the use of the RGB primitive in the REGULATE-HORMONES procedure to color patches based on hormone quantities and provide a smooth visual transition from an anabolic to a catabolic state.


CREDITS AND REFERENCES
----------------------
Original implementation: Scott Styles, for the Center for Connected Learning and Computer-Based Modeling.

To refer to this model in academic publications, please use:  Wilensky, U. (2002).  NetLogo Muscle Development model.  http://ccl.northwestern.edu/netlogo/models/MuscleDevelopment.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2002 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/MuscleDevelopment for terms of use.
"
Daisyworld,/models/Sample Models/Biology,"globals [
  max-age               ;; maximum age that all daisies live to
  global-temperature    ;; the average temperature of the patches in the world
  num-blacks            ;; the number of black daisies
  num-whites            ;; the number of white daisies
  scenario-phase        ;; interval counter used to keep track of what portion of scenario is currently occurring
  ]

breed [daisies daisy]

patches-own [temperature]  ;; local temperature at this location

daisies-own [
  age       ;; age of the daisy
  albedo    ;; fraction (0-1) of energy absorbed as heat from sunlight
]


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Setup Procedures ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

to setup
  clear-all
  set-default-shape daisies ""flower""
  ask patches [ set pcolor gray ]

  set max-age 25
  set global-temperature 0

  if (scenario = ""ramp-up-ramp-down""    ) [ set solar-luminosity 0.8 ]
  if (scenario = ""low solar luminosity"" ) [ set solar-luminosity 0.6 ]
  if (scenario = ""our solar luminosity"" ) [ set solar-luminosity 1.0 ]
  if (scenario = ""high solar luminosity"") [ set solar-luminosity 1.4 ]

  seed-blacks-randomly
  seed-whites-randomly
  ask daisies [set age random max-age]
  ask patches [calc-temperature]
  set global-temperature (mean [temperature] of patches)
  update-display
  update-plots
end

to seed-blacks-randomly
   ask n-of round ((start-%-blacks * count patches) / 100) patches with [not any? daisies-here]
     [ sprout-daisies 1 [set-as-black] ]
end

to seed-whites-randomly
   ask n-of floor ((start-%-whites * count patches) / 100) patches with [not any? daisies-here]
     [ sprout-daisies 1 [set-as-white] ]
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Runtime Procedures ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


to go
   ask patches [calc-temperature]
   diffuse temperature .5
   ask daisies [check-survivability]
   set global-temperature (mean [temperature] of patches)
   update-display
   tick
   update-plots
   if (scenario = ""ramp-up-ramp-down"")
   [
     if (ticks > 200 and ticks <= 400) [set solar-luminosity solar-luminosity + 0.005]
     if (ticks > 600 and ticks <= 850) [set solar-luminosity solar-luminosity - 0.0025]
   ]
   if (scenario = ""low solar luminosity"")  [set solar-luminosity 0.6 ]
   if (scenario = ""our solar luminosity"")  [set solar-luminosity 1.0 ]
   if (scenario = ""high solar luminosity"") [set solar-luminosity 1.4 ]
end

to set-as-black ;; turtle procedure
  set color black
  set albedo albedo-of-blacks
  set age 0
  set size 0.6
end

to set-as-white  ;; turtle procedure
  set color white
  set albedo albedo-of-whites
  set age 0
  set size 0.6
end

to check-survivability ;; turtle procedure
  let seed-threshold 0
  let not-empty-spaces nobody
  let seeding-place nobody

  set age (age + 1)
  ifelse age < max-age
  [
     set seed-threshold ((0.1457 * temperature) - (0.0032 * (temperature ^ 2)) - (0.6443))
     ;; This equation may look complex, but it is just a parabola.
     ;; This parabola has a peak value of 1 -- the maximum growth factor possible at an optimum
     ;; temperature of 22.5 degrees C
     ;; -- and drops to zero at local temperatures of 5 degrees C and 40 degrees C. [the x-intercepts]
     ;; Thus, growth of new daisies can only occur within this temperature range,
     ;; with decreasing probability of growth new daisies closer to the x-intercepts of the parabolas
     ;; remember, however, that this probability calculation is based on the local temperature.

     if (random-float 1.0 < seed-threshold) [
       set seeding-place one-of neighbors with [not any? daisies-here]

       if (seeding-place != nobody)
       [
         if (color = white)
         [
           ask seeding-place [sprout-daisies 1 [set-as-white]  ]
         ]
         if (color = black)
         [
           ask seeding-place [sprout-daisies 1 [set-as-black]  ]
         ]
       ]
     ]
  ]
  [die]
end

to calc-temperature  ;; patch procedure
  let absorbed-luminosity 0
  let local-heating 0
  ifelse not any? daisies-here
  [   ;; the percentage of absorbed energy is calculated (1 - albedo-of-surface) and then multiplied by the solar-luminosity
      ;; to give a scaled absorbed-luminosity.
    set absorbed-luminosity ((1 - albedo-of-surface) * solar-luminosity)
  ]
  [
      ;; the percentage of absorbed energy is calculated (1 - albedo) and then multiplied by the solar-luminosity
      ;; to give a scaled absorbed-luminosity.
    ask one-of daisies-here
      [set absorbed-luminosity ((1 - albedo) * solar-luminosity)]
  ]
  ;; local-heating is calculated as logarithmic function of solar-luminosity
  ;; where a absorbed-luminosity of 1 yields a local-heating of 80 degrees C
  ;; and an absorbed-luminosity of .5 yields a local-heating of approximately 30 C
  ;; and a absorbed-luminosity of 0.01 yields a local-heating of approximately -273 C
  set local-heating 72 * LN(absorbed-luminosity) + 80
  set temperature ((temperature + local-heating) / 2)
     ;; set the temperature at this patch to be the average of the current temperature and the local-heating effect
end

to paint-daisies   ;; daisy painting procedure which uses the mouse location draw daisies when the mouse button is down
  if mouse-down?
  [
    ask patch mouse-xcor mouse-ycor [
      ifelse not any? daisies-here
      [
        if paint-daisies-as = ""add black""
          [sprout-daisies 1 [set-as-black]]
        if paint-daisies-as = ""add white""
          [sprout-daisies 1 [set-as-white]]
      ]
      [
        if paint-daisies-as = ""remove""
          [ask daisies-here [die]]
      ]
      display  ;; update view
    ]
  ]
end

to update-display
  ifelse (show-temp-map? = true)
    [ ask patches [set pcolor scale-color red temperature -50 110] ]  ;; scale color of patches to the local temperature
    [ ask patches [set pcolor grey] ]

  ifelse (show-daisies? = true)
    [ ask daisies [set hidden? false] ]
    [ ask daisies [set hidden? true] ]
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Plotting Procedures ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


to update-plots
  set-current-plot ""Global Temperature""
  plot global-temperature

  set-current-plot ""Luminosity""
  plot solar-luminosity

  set num-whites count turtles with [color = white]
  set num-blacks count turtles with [color = black]

  set-current-plot ""Population""
  set-current-plot-pen ""Black""
  plot num-blacks
  set-current-plot-pen ""White""
  plot num-whites
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2006 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Novak, M. and Wilensky, U. (2006). NetLogo Daisyworld model.
; http://ccl.northwestern.edu/netlogo/models/Daisyworld.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2006 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Daisyworld
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model explores the ""Gaia hypothesis"", which considers the Earth as a single, self-regulating system including both living and non-living parts. In particular, this model explores how living organisms both alter and are altered by climate, which is non-living. The example organisms are daisies and the climatic factor considered is temperature.

Daisyworld is a world filled with two different types of daisies: black daisies and white daisies.  They differ in albedo, which is how much energy they absorb as heat from sunlight.  White daisies have a high surface albedo and thus reflect light and heat, thus cooling the area around them.  Black daisies have a low surface albedo and thus absorb light and heat, thus heating the area around them.  However, there is only a certain temperature range in which daisies can reproduce; if the temperature around a daisy is outside of this range, the daisy will produce no offspring and eventually die of old age.

When the climate is too cold it is necessary for the black daisies to propagate in order to raise the temperature, and vice versa -- when the the climate is too warm, it is necessary for more white daisies to be produced in order to cool the temperature.  For a wide range of parameter settings, the temperature and the population of daisies will eventually stabilize.  However, it is possible for Daisyworld to get either too hot or too cold, in which case the daisies are not able to bring the temperature back under control and all of the daisies will eventually die.


HOW IT WORKS
------------
White daisies, black daisies, and open ground (empty patches) each have an albedo or percentage of energy they absorb as heat from sunlight. Sunlight energy can be changed with the SOLAR-LUMINOSITY slider (a value of 1.0 simulates the average solar luminosity of our sun).

Each time step, every patch will calculate the temperature at that spot based on (1) the energy absorbed by the daisy at that patch and (2) the diffusion of 50% of the temperature value at that patch between its neighbors.  Open ground patches that are adjacent to a daisy have a probability of sprouting a daisy that is the same color as the neighboring daisy, based on a parabolic probability function that depends on the local temperature (where an optimum temperature of 22.5 yields a maximum probability of 100% of sprouting a new daisy). Daisies age each step of the simulation until they reach a maximum age, at which point they die and the patch they were in becomes open.


HOW TO USE IT
-------------
START-%-WHITES and START-%-BLACKS sets the starting percentage of the patches that will be occupied by daisies (of either color) after pressing SETUP.

Selecting PAINT-DAISIES-AS and pressing PAINT-DAISIES allows the user to draw or erase daisies in the VIEW, by left clicking on patches.

ALBEDO-OF-WHITES and ALBEDO-OF-BLACKS sets the amount of heat absorbed by each of these daisy colors. ALBEDO-OF-SURFACE sets the amount of heat absorbed by an empty patch.

The SOLAR-LUMINOSITY sets the amount of incident energy on each patch from sunlight. But this value only will stay fixed at the user set value if the SCENARIO chooser is set to ""maintain current luminosity"". Other values of this chooser will change the albedo values. For example ""ramp-up-ramp-down"" will start the solar luminosity at a low value, then start increasing it to a high value, and then bring it back down again over the course of a model run.

SHOW-TEMP-MAP? shows a color map of temperature at each patch. Light red represents hotter temperatures, and darker red represents colder temperatures.


THINGS TO NOTICE
----------------
Run the simulation. What happens to the daisies?  Do the populations ever remain stable?  Are there ever population booms and busts?  If so, what causes them? (Hint: how do the daisies affects the climate? How does the climate then affect the daisies?)

What happens if boom and bust cycles just keep getting bigger and bigger? The swings can't keep getting bigger forever.

Does the planet ever become completely filled with life, or completely devoid of life?

Try running the simulation without the daisies. What happens to the planet's temperature? How is it different from what happens with the daisies?

Can the Daisyworld system be said to exhibit ""hysteresis""?  Hysteresis is a property of systems that do not instantly follow the forces applied to them, but react slowly, or do not return completely to their original state.  The state of such systems depend on their immediate history.


THINGS TO TRY
-------------
Try running the model with SHOW-DAISIES? off and SHOW-TEMP-MAP? on. You might be able to see interesting spatial patterns that emerge in temperature concentrations and periodic redistricting of temperature regions more easily in this mode.

Try adjusting the fixed temperature diffusion setting in the procedures (change it from 0.5). What happens to the behavior of Daisyworld if temperature is never diffused (set to 0.0)?


EXTENDING THE MODEL
-------------------
Black and white daisies represent two extreme types of daisies that could exist in this world.  Implement a third species of daisy.  You will need to choose what your daisy does and how it is different from black and white daisies.  How does your new daisy affect the results of this model?

Sunlight is only one aspect that controls the growth of daisies and other forms of life.  Change the model so different parts of the world have different levels of soil quality.  How will this affect the outcome?

Many people feel that the Gaia hypothesis can be disturbed by human causes.  Implement pollution in the model.  Does this cause the daisies to die off quicker or more often?

Can you think of any other ways in which living organisms both alter and are altered by their environment?


NETLOGO FEATURES
----------------
Uses the DIFFUSE primitive to distribute heat between patches.


RELATED MODELS
--------------
An alternate Daisyworld model is listed on the User Community Model page. It uses patches only (no turtles).
http://ccl.northwestern.edu/netlogo/models/community/


CREDITS AND REFERENCES
----------------------
The Daisyworld model was first proposed and implemented by Lovelock and Andrew Watson. The original Gaia hypothesis is due to Lovelock.

Watson, A.J., and J.E. Lovelock, 1983, ""Biological homeostasis of the global environment: the parable of Daisyworld"", Tellus 35B, 286-289. (The original paper by Watson and Lovelock introducing the Daisyworld model.)

http://www.carleton.edu/departments/geol/DaveSTELLA/Daisyworld/daisyworld_model.htm

To refer to this model in academic publications, please use:  Novak, M. and Wilensky, U. (2006).  NetLogo Daisyworld model.  http://ccl.northwestern.edu/netlogo/models/Daisyworld.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2006 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Daisyworld for terms of use.
"
Ant Lines,/models/Sample Models/Biology,"breed [ leaders leader ]
breed [ followers follower ]

globals [
  nest-x nest-y    ;; location of center of nest
  food-x food-y    ;; location of center of food
  leader-heading   ;; heading of the leader ant
]

to setup
  ca
  set-default-shape turtles ""bug""
  set nest-x 10 + min-pxcor                      ;; set up nest and food locations
  set nest-y 0
  set food-x max-pxcor - 10
  set food-y 0
  ;; draw the nest in brown by stamping a circular
  ;; brown turtle
  ask patch nest-x nest-y [
    sprout 1 [
      set color brown
      set shape ""circle""
      set size 10
      stamp
      die
    ]
  ]
  ;; draw the nest in orange by stamping a circular
  ;; orange turtle
  ask patch food-x food-y [
    sprout 1 [
      set color orange
      set shape ""circle""
      set size 10
      stamp
      die
    ]
  ]
  create-leaders 1
    [ set color red                                ;; leader ant is red
      set size 2
      wiggle 50 ]                                  ;; ...and starts out with a random heading
  create-followers (num-ants - 1)
    [ set size 2
      set color yellow ]                           ;; middle ants are yellow
  ask turtles
    [ setxy nest-x nest-y                          ;; start the ants out at the nest
      set heading 90 ]
  ask turtle (num-ants - 1)
    [ set color blue                               ;; last ant is blue
      set pen-size 2
      pd ]                                         ;; ...and leaves a trail
  ask leaders
    [ set pen-size 2
      pd ]                                         ;; the leader also leaves a trail
  set leader-heading [heading] of one-of leaders
end

to go
  if all? turtles [xcor >= food-x]
    [ stop ]
   ask leaders                                      ;; the leader ant wiggles and moves
     [ wiggle leader-wiggle-angle
       correct-path
       if (xcor > (food-x - 5 ))                    ;; leader heads straight for food, if it is close
         [ facexy food-x food-y ]
       if xcor < food-x                             ;; do nothing if you're at or past the food
         [ fd 0.5 ] ]
   ask followers
     [ face turtle (who - 1)                        ;; follower ants follow the ant ahead of them
       if time-to-start? and (xcor < food-x)        ;; followers wait a bit before leaving nest
         [ fd 0.5 ] ]
  set leader-heading [heading] of one-of leaders
  tick
end

;; turtle procedure; wiggle a random amount, averaging zero turn
to wiggle [angle]
  rt random-float angle
  lt random-float angle
end

;; turtle procedure
to correct-path
  ifelse heading > 180
    [ rt 180 ]
    [ if patch-at 0 -5 = nobody
        [ rt 100 ]
     if patch-at 0 5 = nobody
        [ lt 100 ] ]
end

;; turtle reporter; if true, then the ant is authorized to move out of the nest
to-report time-to-start?
  report ([xcor] of (turtle (who - 1))) > (nest-x + start-delay + random start-delay )
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1997 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1997).  NetLogo Ant Lines model.
; http://ccl.northwestern.edu/netlogo/models/AntLines.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1997 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/AntLines
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This project models the behavior of ants following a leader towards a food source. The leader ant moves towards the food along a random path; after a small delay, the second ant in the line follows the leader by heading directly towards where the leader is located. Each subsequent ant follows the ant ahead of it in the same manner.

Even though the leader may take a very circuitous path towards the food, the ant trail, surprisingly, adopts a smooth shape. While it is not yet clear if this model is a biologically accurate model of ant behavior, it is an interesting mathematical exploration of the emergent behavior of a series of agents following each other serially.


HOW TO USE IT
-------------
The SETUP button initializes the model. A brown ant nest is placed on the left side of the world. Inside it are a number of ants (yellow) determined by the NUM-ANTS slider. On the right hand of the world is an orange source of food.

The GO button starts the ants moving. The leader ant (turtle 0) is set in motion roughly in the direction of the food. It wiggles as it moves. That is, it does not head directly towards the food, but changes its heading a random amount to the left or right before it takes each step.

The maximum amount the leader ant can wiggle at each step (and therefore the raggedness of the leader ant's path) is governed by the LEADER-WIGGLE-ANGLE slider. When the leader ant gets close enough to the food to ""smell"" it, it stops wiggling and heads directly for the food. The leader ant leaves a red trace as it moves.

Each subsequent ant follows the ant ahead of it by heading directly towards it before it takes each step. The follower ants do not leave a trace. The yellow line of ants, however, traces out a curve in the drawing. The last ant to go leaves a blue trace.

The amount of time between ants departing their nest is governed by the START-DELAY slider (plus some random factor).

The ANTS-RELEASED monitor shows you how many ants have left the nest. The other monitor shows you the heading of the lead ant.


THINGS TO NOTICE
----------------
How does the shape of the ant line change over time?

How does the path of the initial ant compare with the path of the final ant?


THINGS TO TRY
-------------
Try varying the maximum wiggle angle (LEADER-WIGGLE-ANGLE). How does that affect the shape of initial and final ant lines?

Try varying the delay. How does that affect the shape of initial and final ant lines?

How can you slow down the flattening out of the ant line? Can you make the path fail to converge to a straight line?

How can you speed up the flattening out of the ant line?


EXTENDING THE MODEL
-------------------
How might you keep track of, measure, or plot the flattening process?

What if you relaxed the ant following rules -- maybe add some ""wiggle"" to their behavior?


NETLOGO FEATURES
-----------------
In NetLogo, the default behavior of the ants is to move in parallel.  Notice the use of delays based on turtle ids in the TIME-TO-START? reporter to make the turtles leave the nest serially.


CREDITS AND REFERENCES
------------------------
The model was inspired by the work of Alfred Bruckstein (see Bruckstein 1993: ""Why the ant trails look so straight and nice"", The Mathematical Intelligencer, Vol. 15, No. 2).

To refer to this model in academic publications, please use:  Wilensky, U. (1997).  NetLogo Ant Lines model.  http://ccl.northwestern.edu/netlogo/models/AntLines.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1997 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/AntLines for terms of use.
"
Rabbits Grass Weeds,/models/Sample Models/Biology,"breed [rabbits rabbit]
rabbits-own [ energy ]

to setup
  ca
  grow-grass-and-weeds
  set-default-shape rabbits ""rabbit""
  create-rabbits number [
    set color white
    setxy random-xcor random-ycor
    set energy random 10  ;start with a random amt. of energy
  ]
  setup-plot
  do-plot
end

to go
  if not any? rabbits [ stop ]
  grow-grass-and-weeds
  move
  tick
  do-plot
end

to move
  ask rabbits
  [ step
    eat-grass
    eat-weeds
    reproduce
    death ]
end

to grow-grass-and-weeds
  ask patches [
    if pcolor = black [
      if ( random-float 1000 ) < weeds-grow-rate
        [ set pcolor violet ]
      if ( random-float 1000 ) < grass-grow-rate
        [ set pcolor green ]
  ] ]
end

to step   ;moving takes some energy
  rt random-float 50
  lt random-float 50
  fd 1
  set energy ( energy - 0.5 )
end

to eat-grass       ;;gain ""grass-energy"" by eating grass
  if ( pcolor = green )
  [ set pcolor black
    set energy ( energy + grass-energy ) ]
end

to eat-weeds     ;;gain ""weed-energy"" by eating weeds
  if ( pcolor = violet )
  [ set pcolor black
    set energy ( energy + weed-energy )]
end

to reproduce     ;;give birth to a new rabbit, but it takes lots of energy
  if ( energy > birth-threshold )
    [ set energy ( energy / 2 )
      hatch 1 [ fd 1 ] ]
end

to death     ;;die if you run out of energy
  if ( energy < 0 )
    [ die ]
end

to do-plot
  set-current-plot ""Populations""
  set-current-plot-pen ""grass""
  plot ( ( count patches with [pcolor = green] ) / 4 )
  set-current-plot-pen ""rabbits""
  plot count rabbits
  set-current-plot-pen ""weeds""
  plot ( ( count patches with [pcolor = violet] ) / 4 )
end

to setup-plot ;; set up plotting
  set-current-plot ""Populations""
  set-plot-y-range 0 number
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2001 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2001).  NetLogo Rabbits Grass Weeds model.
; http://ccl.northwestern.edu/netlogo/models/RabbitsGrassWeeds.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2001 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/RabbitsGrassWeeds
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This project explores a simple ecosystem made up of rabbits, grass, and weeds. The rabbits wander around randomly, and the grass and weeds grow randomly.   When a rabbit bumps into some grass or weeds, it eats the grass and gains energy. If the rabbit gains enough energy, it reproduces. If it doesn't gain enough energy, it dies.

The grass and weeds can be adjusted to grow at different rates and give the rabbits differing amounts of energy.  The model can be used to explore the competitive advantages of these variables.


HOW TO USE IT
-------------
Click the SETUP button to setup the rabbits (red), grass (green), and weeds (violet). Click the GO button to start the simulation.

The NUMBER slider controls the initial number of rabbits. The BIRTH-THRESHOLD slider sets the energy level at which the rabbits reproduce.  The GRASS-GROWTH-RATE slider controls the rate at which the grass grows.  The WEEDS-GROWTH-RATE slider controls the rate at which the weeds grow.

The model's default settings are such that at first the weeds are not present (weeds-grow-rate = 0, weeds-energy = 0).  This is so that you can look at the interaction of just rabbits and grass.  Once you have done this, you can start to add in the effect of weeds.


THINGS TO NOTICE
----------------
Watch the COUNT-RABBITS monitor and the POPULATIONS plot window to see how the rabbit population changes over time. At first, there is not enough grass for the rabbits, and many rabbits die. But that allows the grass to grow more freely, providing an abundance of food for the remaining rabbits. The rabbits gain energy and reproduce. The abundance of rabbits leads to a shortage of grass, and the cycle begins again.

The rabbit population goes through a damped oscillation, eventually stabilizing in a narrow range. The total amount of grass also oscillates, out of phase with the rabbit population.

These dual oscillations are characteristic of predator-prey systems. Such systems are usually described by a set of differential equations known as the Lotka-Volterra equations. NetLogo provides a new way of studying predatory-prey systems and other ecosystems.


THINGS TO TRY
-------------
Leaving other parameters alone, change the grass-grow-rate and let the system stabilize again.  Would you expect that there would now be more grass?  More rabbits?

Change only the birth-threshold of the rabbits.  How does this affect the steady-state levels of rabbits and grass?

With the current settings, the rabbit population goes through a damped oscillation. By changing the parameters, can you create an undamped oscillation? Or an unstable oscillation?

In the current version, each rabbit has the same birth-threshold. What would happen if each rabbit had a different birth-threshold? What if the birth-threshold of each new rabbit was slightly different from the birth-threshold of its parent? How would the values for birth-threshold evolve over time?

Now add weeds by making the sliders WEEDS-GROW-RATE the same as GRASS-GROW-RATE and WEEDS-ENERGY the same as GRASS-ENERGY.  Notice that the amount of grass and weeds is about the same.

Now make grass and weeds grow at different rates.  What happens?

What if the weeds grow at the same rate as grass, but they give less energy to the rabbits when eaten (WEEDS-ENERGY is less than GRASS-ENERGY)?

Think of other ways that two plant species might differ and try them out to see what happens to their relative populations.  For example, what if a weed could grow where there was already grass, but grass couldn't grow where there was a weed?  What if the rabbits preferred the plant that gave them the most energy?

Run the model for a bit, then suddenly change the birth-threshold to zero.  What happens?


NETLOGO FEATURES
----------------
Notice that every black patch has a random chance of growing grass or
weeds each turn, using the rule:

|    if (random-float 1000) < weeds-grow-rate and pcolor = black
|      [ set pcolor violet ]
|    if (random-float 1000) < grass-grow-rate and pcolor = black
|      [ set pcolor green ]


RELATED MODELS
--------------
Look at Wolf Sheep Predation for another interacting ecosystem with different rules.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (2001).  NetLogo Rabbits Grass Weeds model.  http://ccl.northwestern.edu/netlogo/models/RabbitsGrassWeeds.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2001 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/RabbitsGrassWeeds for terms of use.
"
Tabonuco Yagrumo,/models/Sample Models/Biology/Unverified,";; To see the rest of this model, look in the System Dynamics Modeler
;; window.  (If the window isn't showing, you can open it from the
;; Tools menu.)

globals [ previous-carbon ]

to setup
  ca
  set previous-carbon 0
  system-dynamics-setup    ;; defined by the System Dynamics Modeler
  do-plot
end

to go
  system-dynamics-go       ;; defined by the System Dynamics Modeler
  do-plot
  set previous-carbon carbon
end

to do-plot
  set-current-plot ""output""
  set-current-plot-pen ""carbon""
  plotxy ticks carbon
  set-current-plot-pen ""nitrogen""
  plotxy ticks nitrogen
  set-current-plot ""productivity""
  set-current-plot-pen ""productivity""
  plotxy ticks productivity
  set-current-plot ""trees""
  system-dynamics-do-plot
 end

to-report pulse [volume initial interval]
  set interval abs interval
  let our-x ticks - initial
  let peak volume / dt
  let slope peak / ( dt / 2 )
  let offset abs our-x
  ;; if we have passed the initial pulse, then recalibrate
  ;; to the next pulse interval, if there IS an interval given
  if ( interval > 0 and our-x > ( dt / 2 ) )
    [ set offset  ( our-x mod interval )
      if ( offset > dt / 2 ) [ set offset 0 + offset - interval ]  ]
  ;; the down side of the pulse
  if ( offset >= 0 and offset <= dt / 2  )
     [ report peak - ( slope * offset ) ]
  ;; the upside of the pulse
  if ( offset < 0 and offset >= ( 0 - ( dt / 2 ) ) )
     [ report slope * min (list ( dt / 2 ) ( abs ( interval - offset ) ) ) ]
  report 0
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2006 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2006).  NetLogo Tabonuco Yagrumo model.
; http://ccl.northwestern.edu/netlogo/models/TabonucoYagrumo.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2006 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/TabonucoYagrumo
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This is a system dynamics model of a simple ecosystem.  Two species of trees -- tabonuco and yagrumo -- compete for space in a forest canopy.  This model illustrates the role of hurricane destruction in this ecosystem, as well as the resultant nitrogen and carbon produced by the ecosystem.


HOW IT WORKS
------------
The relations between the tree species and the amount of space into which they can grow are defined in the System Dynamics Modeler.  The TABONUCO and YAGRUMO stocks represent the population of the two tree species.  They can only grow in the gaps of the forest canopy.  These spaces are represented by the GAPS stock.  The rate at which the trees grow or die is represented by the TABONUCO-GROWS and YAGRUMO-GROWS flows.  The flows connect to the GAPS stock to the tree stocks.  If more trees grow, there are fewer gaps in the forest.  If trees die then there are more gaps.

Tabonuco trees grow slower than yagrumo trees, these rates are represented by the TABONUCO-GROWTH-RATE and YAGRUMO-GROWTH-RATE variables.  However, tabonuco trees outlive yagrumo trees.  This relationship is represented by the TABONUCO-OUTGROWS-YAGRUMO flow from the YAGRUMO stock to the TABONUCO stock.

The YAGRUMO-GROWS and TABONUCO-GROWS flows are also connected to the DISTURBANCE variable.  DISTURBANCE represents the destruction of trees by hurricanes.  The HURRICANE-STRENGTH and HURRICANE-FREQUENCY variables determine the timing and amount of disturbance, which can be controlled by sliders.

The model also tracks the amount of carbon and nitrogen produced by the trees.  The trees produce resources via photosynthesis.  The rest of the living things in the forest use these resources.  The CARBON and NITROGEN variables calculate how much of those chemicals are produced by the trees.


HOW TO USE IT
-------------
Press the SETUP button to initialize the model.

To run the model continuously, press GO.

To run the model for one time step, press STEP.

Alternatively, you can run only 250 steps by pressing the
SETUP REPEAT 250 [ GO ] button.

Adjust the USER-HURRICANE-FREQUENCY slider to determine how many time units occur between hurricanes.

Adjust the USER-HURRICANE-STRENGTH slider to determine how many trees are destroyed by the hurricanes


THINGS TO NOTICE
----------------
Hurricanes play an important role in the ecosystem.  The relative amount of each tree is highly sensitive to both the rate and strength of hurricanes.  Both species co-exist only within a certain range of hurricane frequency and strength.


THINGS TO TRY
-------------
Change the USER-HURRICANE-FREQUENCY slider, observe what happens to the YAGRUMO population, and the productivity.  Do the same with USER-HURRICANE-STRENGTH.

Use BehaviorSpace (on the Tools menu) to sweep the parameter space for the USER-HURRICANE-FREQUENCY and USER-HURRICANE-STRENGTH.  An experiment that does this is included.

Use the GLOBALS monitor to observe the value off stocks, constants, model time, and model dt.


EXTENDING THE MODEL
-------------------
Add a third species of tree to the model.

Model the competition for the shared GAP stock in a different manner.

Vary the strength of the hurricanes, randomly, across an interval.


NETLOGO FEATURES
----------------
This model uses the System Dynamics Modeler.

It includes a built-in BehaviorSpace experiment.


RELATED MODELS
--------------
Tabonuco Yagrumo Hybrid


CREDITS AND REFERENCES
----------------------
This model is based on the work of The Learning Partnership in the Journey to El Yunque project (PI's include Steven McGee, Jess Zimmerman, and Steven Croft). To view the original materials or to learn more about that project, go to URL http://elyunque.net/journey.html

To refer to this model in academic publications, please use:  Wilensky, U. (2006).  NetLogo Tabonuco Yagrumo model.  http://ccl.northwestern.edu/netlogo/models/TabonucoYagrumo.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2006 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/TabonucoYagrumo for terms of use.
"
Algae,/models/Sample Models/Biology/Unverified,"globals [
  algae-height-list
  ;;; some patch agentsets to make things easier to read
  air
  water
  ground
]

patches-own [ light ]

breed [ algae an-algae ]

algae-own [ ballast ]

;;;;;;;;;;;;;;;;;;;;;;
;; SETUP PROCEDURES ;;
;;;;;;;;;;;;;;;;;;;;;;

to setup
  clear-all
  setup-globals
  setup-environment
  setup-algae
  update-plots
end

to setup-globals
  set algae-height-list []
  set air patches with [ pxcor = 0 and pycor = max-pycor ]
  set water patches with [ pxcor = 0 and abs pycor != max-pycor ]
  set ground patches with [ pxcor = 0 and pycor = min-pycor ]
end

to setup-environment
  ask air [ set light 1 ]
  ask ground [ set light 0 ]
  ask water [ set light 0 ]
  ask patches with [ pxcor != 0 ] [
    set pcolor gray + 1.75
  ]
  recolor-environment
end

to recolor-environment
  ask air [
    if day-and-night? [
      ifelse daytime? [
        set pcolor yellow + 3
      ] [
        set pcolor black
      ]
    ]
  ]
  ask ground [
    set pcolor brown
  ]
  ask water [
    ifelse light > 0 [
      ;; make water with more light brighter yellow
      set pcolor yellow - 4 + light * 7
    ] [
      ;; make deeper water darker so things are prettier
      set pcolor blue - 2 - 0.1 * distance one-of air
    ]
  ]
end

to setup-algae
  set-default-shape algae ""algae""
  create-algae 50 [
    set ballast 0.3 + random-float 0.4
    set heading 0
    set color one-of [red yellow lime sky]
    setxy 0 [pycor] of one-of water
    ;; spread the algae throughout the water patches
    setxy xcor - 0.2 + random-float 0.4
          ycor - 0.5 + random-float 1
  ]
end

;;;;;;;;;;;;;;;;;;;
;; GO PROCEDURES ;;
;;;;;;;;;;;;;;;;;;;

to go
  if not any? algae [ stop ]
  ;; 24 hour days
  let day ticks / 24
  ;; assume all months are the same length
  let month day / 10
  ;; day length cycles up and down based on the time of year
  if change-day-length? [
    set day-length 12 + 4 * sin ( month * 180 / 12 )
  ]
  step
end

to step
  if day-and-night? [
    spread-light
  ]
  ask algae [
    change-ballast light
  ]
  ask algae [
    move
  ]
  recolor-environment
  tick
  update-plots
end

to change-ballast [ light-present ] ; algae procedure
  ;; algae lose some ballast per hour (but don't get less than 0)
  set ballast max list 0 (ballast - 0.1)
  ;; the amount of new ballast depends on how much light and has some randomness
  let new-ballast light-present - random-float 0.05
  ;; ballast can't be greater than 1
  set ballast min list 1 ballast + new-ballast
end

to move ; algae procedure
  ;; if ballast is empty, amount-to-move is 1
  ;; if ballast is full, amount-to-move is -1
  ;; ballast stays between 0 (empty) and 1 (full)
  let amount-to-move (1 - (2 * ballast))
  if amount-to-move > 0 [
    ;; algae don't go into the air
    let distance-to-air (max-pycor - 0.5 - ycor)
    set amount-to-move min list distance-to-air amount-to-move
  ]
  fd amount-to-move
  ;; algae die if on the bottom
  if member? patch-here ground [ die ]
end

to spread-light
  ifelse daytime? [
    ask air [ set light 1 ]
    ask water [ set light 0 ]
    ;; we sort the water patches top to bottom and then ask them in turn
    ;; to grab some light from above
    foreach sort water [
      ask ? [
        let light-gained light-spreadiness * [light] of patch-at 0 1
        set light light + light-gained
      ]
    ]
  ] [
    ask air [ set light 0 ]
    ask water [ set light 0 ]
  ]
end

to-report daytime?
  report ticks mod 24 < day-length
end

;;;;;;;;;;;;;;;;;;;;;;;;;
;; PLOTTING PROCEDURES ;;
;;;;;;;;;;;;;;;;;;;;;;;;;

to update-plots
  let current-algae-height mean [ycor] of algae
  set algae-height-list fput current-algae-height algae-height-list

  ;; let things go for a bit before starting the plotting
  if ticks > 100 [
    do-plotting
  ]
end

to do-plotting
  set algae-height-list sublist algae-height-list 0 24

  set-current-plot ""average height""
  set-current-plot-pen ""average height""
  plot mean algae-height-list

  set-current-plot ""day length""
  set-current-plot-pen ""day length""
  plot day-length

  set-current-plot ""algae distribution""
  histogram [ ycor ] of algae
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2005 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2005).  NetLogo Algae model.
; http://ccl.northwestern.edu/netlogo/models/Algae.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2005 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Algae
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This is a model of a simplified aquatic ecosystem consisting of a column of water containing algae, light, and nutrients.  There is more light at the top but more food at the bottom, so algae move up and down to balance their needs.


HOW IT WORKS
------------
Algae need both light and nutrients (such as ammonia and phosphate) in order to grow. Although there is ample light near the lake surface, there are few nutrients.  On the other hand, it is dark deep in the lake, but there is a lot of ammonia and phosphate down there. Some algae can move up and down in the water column to get both light and nutrients. These algae make dense substances using the energy from light in order to make them sink, and then burn up those dense substances in the dark at the deeper parts of the water column.

The algae move up and down in the water column based on how dense they are. The algae's density is something that changes continuously based on how much light they are able to get during the day. Density decreases some every turn because the algae use the dense substances to produce chemical energy. However, the algae can also use light energy to make the dense substances. The more light present, the denser they get. When they become denser than water, they move down. Deeper water gets less light, so the deeper algae goes, the less density it is able to add. When algae becomes less dense than water, it moves up towards the surface again. Also, as the seasons change, the length of the day changes, which changes how much light is present throughout the day.


HOW TO USE IT
-------------
The SETUP button prepares the ecosystem and the GO button runs the simulation.

The LIGHT-SPREADINESS slider changes how much the light penetrates the water. The higher the ""spreadiness,"" the more light can reach down into the water. If the DAY-AND-NIGHT? switch is on, the DAY-LENGTH slider changes how much of each day has sunlight. If it is off, light does not change throughout the day. If the CHANGE-DAY-LENGTH? switch is on, DAY-LENGTH changes as GO is running, simulating the changes of the seasons. If it is off, DAY-LENGTH will only change manually.

The AVERAGE-HEIGHT plot shows a history of the average height of the algae over the past 24 hour period. The DAY-LENGTH plot show the history of the DAY-LENGTH slider. The ALGAE-DISTRIBUTION plot shows the current position of the algae. Lower algae appear farther to the right in the plot.


THINGS TO NOTICE
----------------
Notice how as the days get longer, the average height of the algae gets lower. Similarly, as the days get shorter, the average height of the algae gets higher. Also, the more the light penetrates the water, the lower the algae are on average.

The color of the patches indicate the light intensity at that depth in the water column - the more yellow, the more light is present.

Sometimes the algae clumps all together and sometimes the algae forms multiple clumps.


THINGS TO TRY
-------------
To get time to pass faster, use the speed slider.

Turn off DAY-AND-NIGHT? to see that the algae still go up and down when the sun is always shining.

How does having lots of LIGHT-SPREADINESS and a small DAY-LENGTH compare to having little LIGHT-SPREADINESS and a big DAY-LENGTH? (It'll help to turn off CHANGE-DAY-LENGTH?.)


EXTENDING THE MODEL
-------------------
Even though algae need both light and nutrients, this simple model only considers the role of light. Add a nutrient gradient in the water column. The floor could contain nutrients and the algae might contribute to the gradient when they die.

When real algae are healthy, they grow new algae. Also, when they run out of food, they die. Add these rules to the model.


NETLOGO FEATURES
----------------
In the SPREAD-LIGHT procedure, the water patches grab light from the patch directly above them. Note the use of the FOREACH and SORT primitives to ensure that the patches are asked in the desired order.

In order to display all of the elements of the control strip above it, the 2D View needs to be of a certain minimum width, so world-width is larger than it needs to be. The necessary patches are stored as patch agentsets in the AIR, WATER, and GROUND global variables and the SETUP-ENVIRONMENT procedure ""gets rid"" of the unnecessary patches:
|  ask patches with [pxcor != 0] [
|    set pcolor gray + 1.75
|  ]


CREDITS AND REFERENCES
----------------------
This model is based on a preliminary model developed by Allan Konopka at the 2004 NetLogo Workshop at Northwestern University.

Thanks to Josh Unterman for his work on this model.

To refer to this model in academic publications, please use:  Wilensky, U. (2005).  NetLogo Algae model.  http://ccl.northwestern.edu/netlogo/models/Algae.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2005 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Algae for terms of use.
"
Tabonuco Yagrumo Hybrid,/models/Sample Models/Biology/Unverified,";; To see the rest of this model, look in the System Dynamics Modeler
;; window.  (If the window isn't showing, you can open it from the
;; Tools menu.)

globals [ previous-carbon
          tabonuco-growth
          yagrumo-growth
          tabonuco-death
          yagrumo-death
          converted-to-tabonuco ]

breed [ tabonucos tabonuco ]
breed [ yagrumos yagrumo ]


to setup
  ca
  set-default-shape yagrumos ""plant""
  set-default-shape tabonucos ""tree""
  set previous-carbon 0
  system-dynamics-setup             ;; defined by System Dynamics Modeler
  agent-setup
  do-plot
end

to go
  agent-go
  system-dynamics-go                ;; defined by System Dynamics Modeler
  do-plot
  set previous-carbon carbon
end

;; Agent-Based rule setup for model.
to agent-setup
  ask n-of tabonuco-stock patches [ sprout-tabonucos 1 [ set color sky ] ]
  ask n-of yagrumo-stock patches with [ not any? turtles-here ] [ sprout-yagrumos 1 [ set color pink ] ]
end


;; Agent-Based rules for the model
;; These are only run oncce per cycle of the model, and the order is important
;; Tabonuco trees get first shot at open patches.
to agent-go
  set yagrumo-growth agent-yagrumo-growth yagrumo-stock
  set tabonuco-growth agent-tabonuco-growth tabonuco-stock

  set tabonuco-death agent-tabonuco-death disturbance
  set yagrumo-death agent-yagrumo-death disturbance
  set converted-to-tabonuco agent-tabonuco-conversion tabonuco-outgrowth-rate
end

to-report empty-patches
  report patches with [ not any? turtles-here ]
end

;; Rules governing the conversion of yagrumo trees to tabonuco trees
;; Only yagrumo trees next to an existing tabonuco tree can be converted
;; and only tabonuco-outgrowth-rate are converted.
to-report agent-tabonuco-conversion [ rate ]
  let total-converted 0
  let convertables yagrumos with [ any? neighbors with [ any? tabonucos-here ] ]
  ask n-of (count convertables * rate) convertables
    [ set total-converted total-converted + 1
      set breed tabonucos set color sky ]
  report total-converted
end


;; Rules governing the growth of Tabonuco trees
;; only trees with an empty patch next to them get a chance to reproduce
;; and only tabonuco-growth-rate of those trees can reproduce
to-report agent-tabonuco-growth [ current ]
  let total-grown 0
  let growable tabonucos with [ not all? neighbors [ any? turtles-here ] ]
  ask n-of ( count growable * tabonuco-growth-rate ) growable
    [ let seedpatch one-of neighbors with [ not any? turtles-here ]
      if ( seedpatch != nobody )
        [ ask seedpatch
            [ sprout-tabonucos 1 [ set color sky ]
              set total-grown total-grown + 1
            ]
        ]
    ]
    report total-grown
end

;; Rules governing the growth of Yagrumo trees
;; only trees with an empty patch next to them get a chance to reproduce
;; and only tabonuco-growth-rate of those trees can reproduce
to-report agent-yagrumo-growth [ current ]
 let total-grown 0
  let growable yagrumos with [ not all? neighbors [ any? turtles-here ] ]
  ask n-of ( count growable  * yagrumo-growth-rate ) growable
    [ let seedpatch one-of neighbors with [ not any? turtles-here ]
      if ( seedpatch != nobody )
        [ ask seedpatch
            [ sprout-yagrumos 1 [ set color pink ]
              set total-grown total-grown + 1
            ]
        ]
    ]
    report total-grown
end


;; Rules governing destruction of Tabonuco trees
to-report agent-tabonuco-death [ dist ]
  let total-dead 0
  ask n-of min (list (count tabonucos) ( tabonuco-stock * dist ) ) tabonucos
    [ set total-dead total-dead + 1
      die
    ]
  report total-dead
end

;; Rules governing destruction of Yagrumo trees
to-report agent-yagrumo-death [ dist ]
  let total-dead 0
  ask n-of min (list (count yagrumos) ( yagrumo-stock * dist ) ) yagrumos
    [ set total-dead total-dead + 1
      die
    ]
  report total-dead
end


to do-plot
  set-current-plot ""output""
  set-current-plot-pen ""carbon""
  plotxy ticks carbon
  set-current-plot-pen ""nitrogen""
  plotxy ticks nitrogen
  set-current-plot ""productivity""
  set-current-plot-pen ""productivity""
  plotxy ticks productivity
  ;set-current-plot-pen ""disturbance""
  ;plotxy system-dynamics-t disturbance
  set-current-plot ""trees""
  set-current-plot-pen ""tabonuco""
  plotxy ticks amount-of-tabonuco
  set-current-plot-pen ""yagrumo""
  plotxy ticks amount-of-yagrumo
 ;; set-current-plot ""gaps""
 ;; set-current-plot-pen ""gaps""
 ;; plotxy system-dynamics-t gaps
end

to-report pulse [ volume initial interval ]
  set interval abs interval
  let our-x ticks - initial
  let peak volume / dt
  let slope peak / ( dt / 2 )
  let offset abs our-x
  ;; if we have passed the initial pulse, then recalibrate
  ;; to the next pulse interval, if there IS an interval given
  if ( interval > 0 and our-x > ( dt / 2 ) )
    [ set offset  ( our-x mod interval )
      if ( offset > dt / 2 ) [ set offset 0 + offset - interval ]  ]
  ;; the down side of the pulse
  if ( offset >= 0 and offset <= dt / 2  )
     [ report peak - ( slope * offset ) ]
  ;; the upside of the pulse
  if ( offset < 0 and offset >= ( 0 - ( dt / 2 ) ) )
     [ report slope * min (list ( dt / 2 ) ( abs ( interval - offset ) ) ) ]
  report 0
end

to test-pulse [ volume initial interval ]
  setup
  repeat 250 [
    let y pulse volume initial interval
    output-print y
    set-current-plot ""productivity""
    plotxy ticks y
    tick-advance dt ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2006 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2006).  NetLogo Tabonuco Yagrumo Hybrid model.
; http://ccl.northwestern.edu/netlogo/models/TabonucoYagrumoHybrid.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2006 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/TabonucoYagrumoHybrid
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This is a model of a simple ecosystem of two species of trees that compete for space in a forest canopy.  Tabonuco Yagrumo Hybrid is different from Tabonuco Yagrumo in that the competition for space is explicitly modeled using turtles and patches, as opposed to being modeled as a relationship between stocks in the System Dynamics Modeler.  It is intended to be a simple example of how the two approaches can be combined into a hybrid model, and its behavior is similar to the non-hybrid version.


HOW IT WORKS
------------
The TABONUCO and YAGRUMO stocks represent the population of the two tree species.  The rate at which the stocks of both trees grow or die is represented by the TABONUCO-GROWS and YAGRUMO-GROWS flows.  These values come from the agent-based part of the model, where the trees compete for open pace in the forest.  The forest is modeled using turtles and patches.  Each tree is a turtle and lives on a patch.  It can only grow into an open patch immediately next to it.  If more trees grow, there are fewer gaps in the forest.  If trees die then there are more gaps.

Tabonuco trees grow slower than yagrumo trees, these rates are represented by the TABONUCO-GROWTH-RATE and YAGRUMO-GROWTH-RATE variables.  In each tick of the model, the two tree species attempt to grow into the available spaces.  However, tabonuco trees outlive yagrumo trees.  This relationship is represented by the TABONUCO-OUTGROWS-YAGRUMO flow from the YAGRUMO stock to the TABONUCO stock.  To represent this in the agent-based portion of the model, yagrumo trees are turned into tabonuco trees in the forest.

The YAGRUMO-DIES and TABONUCO-DIES flows are connected to the DISTURBANCE variable.  This variable represents the destruction of trees by hurricanes.  The HURRICANE-STRENGTH and HURRICANE-FREQUENCY variables determine the timing and amount of disturbance, which can be controlled by sliders.

The model also tracks the amount of carbon and nitrogen produced by the trees.  The trees produce resources via photosynthesis.  The rest of the living things in the forest use these resources.  The CARBON and NITROGEN variables calculate how much of those chemicals are produced by the trees.


HOW TO USE IT
-------------
Press the SETUP button to initialize the model.

To run the model continuously, press GO.

To run the model for one time step, press STEP.

Alternatively, you can run only 250 steps by pressing the
SETUP REPEAT 250 [ GO ] button.

Adjust the USER-HURRICANE-FREQUENCY slider to determine how many time units occur between hurricanes.

Adjust the USER-HURRICANE-STRENGTH slider to determine how many trees are destroyed by the hurricanes


THINGS TO NOTICE
----------------
Hurricanes play an important role in the ecosystem.  The relative amount of each tree is highly sensitive to both the rate and strength of hurricanes.  Both species co-exist only within a certain range of hurricane frequency and strength.

The results of the model is different from Tabonuco Yagrumo in several ways.  First, the curves are not smooth, because they are not generated only by a function, but have have random events generating the results.  Second, the modeling of Tabonuco outgrowing Yagrumo in this model causes the Yagrumo to grow less, because the available spaces for it to grow into are reduced.

THINGS TO TRY
-------------
Change the USER-HURRICANE-FREQUENCY slider, observe what happens to the YAGRUMO population, and the productivity.  Do the same with USER-HURRICANE-STRENGTH.

Use the BehaviorSpace Tool to sweep the parameter space for the USER-HURRICANE-FREQUENCY and USER-HURRICANE-STRENGTH.

Use the GLOBALS monitor to observe the value of stocks, constants, model time, and model dt.


EXTENDING THE MODEL
-------------------
Experiment with trying different rules for competition for space.

Vary the strength of the hurricanes, randomly, across an interval.


NETLOGO FEATURES
----------------
This model provides a simple example of combining agent-based and system dynamics modeling.

RELATED MODELS
--------------
The Tabonuco Yagrumo model.

CREDITS AND REFERENCES
----------------------
The following model is based on the work of The Learning Partnership in the Journey to El Yunque project (PI's include Steven McGee, Jess Zimmerman, and Steven Croft). To view the original materials or to learn more about that project, go to URL http://elyunque.net/journey.html

To refer to this model in academic publications, please use:  Wilensky, U. (2006).  NetLogo Tabonuco Yagrumo Hybrid model.  http://ccl.northwestern.edu/netlogo/models/TabonucoYagrumoHybrid.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2006 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/TabonucoYagrumoHybrid for terms of use.
"
Honeycomb,/models/Sample Models/Biology/Unverified,"patches-own [chemical]

to setup
  clear-all
  crt num-bees
    [ setxy random-xcor random-ycor
      set color yellow - 3 + random 7 ]  ;; varying the color makes the bees easier to follow with your eyes
  ask patches [ set chemical 0 ]
end

to go
  ask turtles [
    rt 4 * chemical
    fd 1 + ((chemical ^ 2) / 60)
    set chemical chemical + 2      ;; drop chemical onto patch
  ]
  ;; for speed, only run the patches every 10th tick
  if ticks mod 10 = 0 [
    diffuse chemical 0.1
    ask patches [
      set chemical chemical * 0.90       ;; evaporate chemical
      set pcolor scale-color gray chemical 0 20
    ]
  ]
  tick
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2003 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2003).  NetLogo Honeycomb model.
; http://ccl.northwestern.edu/netlogo/models/Honeycomb.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2003 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Honeycomb
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
How are groups of bees able to build their honeycombs out of perfect hexagons?  This model illustrates one hypothesis for a possible mechanism.


HOW IT WORKS
------------
Each bee moves in a clockwise circle, spreading a chemical pheromone behind it.  Over time, the pheromone diffuses and eventually evaporates.  The pheromone affects the behavior of the bees crawling over it as follows: the bees move faster when there is more pheromone, but they also decrease their turn radius.  The effects of these two rules balance each other, leaving the size of the loops roughly constant.


HOW TO USE IT
-------------
Press SETUP to create some bees, and press GO to start them on their rounds.  If you want the model to run faster, make the bees invisible with the HIDE BEES button.  Turn off the display through the view controls to make the model run even faster.


THINGS TO NOTICE
----------------
Initially, the bees draw a big mess of irregular loops.  But over time, the loops sort themselves out into a loose grid.  As more time passes, the grid becomes more and more regular, approaching a perfect hexagonal lattice, which is the optimal arrangement for maximizing the number of circles that fit on a surface.


THINGS TO TRY
-------------
Experiment with the effect of varying the number of bees.


EXTENDING THE MODEL
-------------------
There are a lot of arbitrarily chosen numbers in the Procedures tab.  Experiment with the effect of varying them.

In this version of the models, the bees wrap around the edges of the world.  Try modifying the model so the bees are clustered near the center of the world, to prevent wrapping.  What happens?

Also, try having the bees all start from a central location.  Does this still produce the hexagonal lattice throughout the entire world?


NETLOGO FEATURES
----------------
It takes time to diffuse and evaporate the chemical across every patch in the world, so instead of doing it every turtle step, we do it every 10 turtle steps.  This speeds up the model a lot without noticeably altering the behavior.


RELATED MODELS
--------------
Slime and Ants are other models that use pheromones to coordinate the behavior of individuals into an interesting overall effect.


CREDITS AND REFERENCES
----------------------
The rules for this model were invented by David Little in 1995.  The NetLogo code is adapted from his original MacStarLogo code.  On the starlogo-users list, he wrote:

""During a visit to Tilff, in the Belgian Ardennes this summer, I was amazed to watch live beehives that had been built with glass walls, in the Bee Museum there. You could see into the hive, and observe the bees' activity (safely!). As if by magic, the regular architecture of the hive emerges from the seemingly random motions of the workers: the famous hexagonal array, constructed on both sides of plates hung vertically, and evenly spaced apart. The million-dollar question is, how do they do it? Is the beehive determined by their genes? How is it that different sized bees make cells all exactly the same size?

""That the piling up of round objects easily ends up as a hexagonal array, I already knew: it takes up the least amount of space. Being almost totally ignorant of entomology, nevertheless, I made an amateur hypothesis: maybe the hive is the result of a few simple behavioral rules, and there is no hive 'blueprint' in the bees' genes. The apparent random motion of the bees is perhaps in fact highly organised into feedback loops: a bee's next move must depend on what she and the others have done and built before.

""I don't claim that real bees work with the same rules, but I've proved my hypothesis anyway!""

Researchers have extensively studied honeycomb formation.  Here are some references to consult for further information:

Camazine, S., et al., Self-organization in biological systems. 2001, Princeton, NJ: Princeton University Press. 538. (ch.16)

Camazine, 1990 -- SO pattern formation in the combs of honey bee colonies.

Pratt, Stephen. 1998. Condition-dependent timing of comb construction by honey bee colonies, animal behaviour, 56, 603-610

Theraulaz, G. & Bonabeau, E. (1995) Modelling the collective building of complex architectures in social insects with lattice swarms. Journal of theoretical Biology 177, 381-400.

Theraulaz and Eric Bonabeau. Coordination in distributed building. Science, 269(4):686--688, 1995.

To refer to this model in academic publications, please use:  Wilensky, U. (2003).  NetLogo Honeycomb model.  http://ccl.northwestern.edu/netlogo/models/Honeycomb.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2003 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Honeycomb for terms of use.
"
Plant Growth,/models/Sample Models/Biology/Unverified,"turtles-own
[
  water     ;; Amount of stored water
  sugar     ;; Amount of stored sugar
  adjacent  ;; Holds the identity of the adjacent turtles when nutrients are being shared
]

patches-own
[
  moisture  ;; Amount of water in the soil
  light     ;; Amount of light available for the leaves to turn into sugar
]

to setup-patches
  clear-all
  ask patches
  [
    ifelse pycor > 0
    [ ;; Allocate Light
      ifelse (random (world-width ^ 2)) < (nutrient-density * world-width)
      [ set light random nutrient-concentration ]
      [ set light 0 ]
    ]
    [ ;; Allocate Moisture
      ifelse (random (world-width ^ 2)) < (nutrient-density * world-width)
      [ set moisture random nutrient-concentration ]
      [ set moisture 0 ]
    ]
  ]
  diffuse-light
  diffuse-moisture
  ask patches
  [
    ifelse pycor > 0
    [
      set pcolor scale-color yellow light 14 -1
      set moisture 0  ;; No moisture in the light area
    ]
    [
      set pcolor scale-color blue moisture 14 -1
      set light 0  ;; No light in the moisture area
    ]
    ;; draw the ground
    if pycor = 0 and abs pxcor > 2
    [ set pcolor gray ]
  ]
end

to diffuse-light
  diffuse light 0.1
  if max [light] of patches > 15
  [ diffuse-light ]
end

to diffuse-moisture
  diffuse moisture 0.1
  if max [moisture] of patches > 15
  [ diffuse-moisture ]
end


to setup-plant
  set-default-shape turtles ""circle""
  ;; Kill the old Plant
  ask turtles [ die ]
  ;; Create the new Plant
  crt 1
  [
    set color brown
    set sugar 5000
    set water 5000
    set heading 0
    hatch 1
    [
      set color green fd 1
    ]
  ]
end

to grow
  ask turtles [
  ;; Get Nutrients from environment
  ifelse color = green
  [ set sugar sugar + light ]
  [ set water water + moisture ]
  ;; Grow Plant
  if random 100 < 1
  [
    hatch 1
    [
      move
      ;; Five Conditions under which the new growth should be aborted
      if sum [count turtles-here] of neighbors >= 3 [ die ]  ;; Overcrowding
      if any? other turtles-here [ die ]  ;; Overlapping
      if color = green and pycor < 1 [ die ]  ;; Leaves Underground
      if color = brown and pycor > 0 [ die ]  ;; Roots Aboveground
      if pcolor = gray [ die ]  ;; In the ground
      set sugar 1
      set water 1
    ]
  ]
  share-with-gs
  ;; Use Resources
  set sugar sugar - 0.1
  set water water - 0.1
  if sugar <= 0 or water <= 0 [ die ]
  ]
  tick
end

to move
  ifelse cactus?
  [ ;; Plant grows up and down only
    set heading 180 * random 2
    rt 30 - 30 * random 3
  ]
  [ ;; Plant grows in all directions
    rt random-float 360
  ]
  ;; if this is the edge of the world obviously don't grow there.
  ifelse can-move? 1
  [ fd 1 ]
  [ die ]
end

to share-with-gs
  set adjacent nobody
  if any? turtles-at 1 1
  [ set adjacent one-of turtles-at 1 1
    share-up
  ]
  if any? turtles-at 0 1
  [ set adjacent one-of turtles-at 0 1
    share-up
  ]
  if any? turtles-at -1 1
  [ set adjacent one-of turtles-at -1 1
    share-up
  ]
  if any? turtles-at 1 0
  [ set adjacent one-of turtles-at 1 0
    share-side
  ]
  if any? turtles-at 1 -1
  [ set adjacent one-of turtles-at 1 -1
    share-down
  ]
  if any? turtles-at 0 -1
  [ set adjacent one-of turtles-at 0 -1
    share-down
  ]
  if any? turtles-at -1 -1
  [ set adjacent one-of turtles-at -1 -1
    share-down
  ]
end

to share-up
  let old-water water
  set water 0.95 * water + 0.02 * [water] of adjacent
  ask adjacent [ set water 0.98 * water + 0.02 * old-water ]
end

;; Nutrients are shared equally, but the sharing is executed by the left turtle
to share-side
  let old-water water
  set water 0.95 * water + 0.05 * [water] of adjacent
  ask adjacent [ set water 0.95 * water + 0.05 * old-water ]
  let old-sugar sugar
  set sugar 0.95 * sugar + 0.05 * [sugar] of adjacent
  ask adjacent [ set sugar 0.95 * sugar + 0.05 * old-sugar ]
end

to share-down
  let old-sugar sugar
  set sugar 0.95 * sugar + 0.02 * [sugar] of adjacent
  ask adjacent [ set sugar 0.98 * sugar + 0.05 * old-sugar ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2002.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Plant Growth model.
; http://ccl.northwestern.edu/netlogo/models/PlantGrowth.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/PlantGrowth
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
Plants have the interesting tendency to 'find' resources in their environment. It is not uncommon to see plants whose leaves and stalks have bent over time in the direction of nearby sunlight, or plants that have grown long roots directed to a nearby source of moisture. It almost seems as if these plants are actually scanning the environment around them to find stable sources of nutrients. Since plants do not have eyes, we might ask how they are able to accomplish this.

This model addresses the question of how a plant is able to effectively locate resources in its environment, generally focusing growth in 'promising' areas. It is not intended to be biologically realistic.

The plant is composed of two kinds of cells - light collecting (leaves), and water collecting (roots). The plant germinates with only one leaf cell and one root cell, and will grow itself by adding new cells as long as it has the nutrients to sustain itself. Nutrients (sunlight and moisture) are concentrated in randomly-determined areas of the environment, and are collected wherever a root or leaf of the plant is located. These nutrients are then circulated around the plant as 'sugar' and 'water', when, in each turn, cells exchange resources with adjacent cells. This circulation is critical, since leaf cells do not collect any water and root cells do not produce sugar, and yet both root and leaf cells each need both water and sugar -- a cell dies if it runs out of either resource. All cells of the plant use up a fixed amount of both sugar and water every turn.

The main problem that confronts the plant is that in order to explore the environment it needs to grow outwards in many directions, but the roots/leaves that result from this may be bad investments. That is, they take up nutrients but do not contribute any. What rules can we introduce so that the plant will focus growth mainly in sunny or watery areas?

The strategy employed here is to allow sugar to propagate down to the roots more effectively than it propagates up to other leaves, and to allow water to propagate up to the leaves more effectively than it propagates down to other roots. That is, we have intentionally privileged the traffic of nutrients both in specific directions and according to the nature of the nutrient. This tends to isolate subsections of the plant that fail to collect adequate nutrients.


HOW TO USE IT
-------------
First click the SETUP-PATCHES button to allocate moisture and light and to setup the environment. You may want to click it again if you are not satisfied with the allocation of these nutrients. To adjust how these nutrients are distributed among the patches 1) use the NUTRIENT-DENSITY slider to determine the density of loci of light/moisture, 2) the NUTRIENT-CONCENTRATION slider to determine the concentration of light/moisture at each locus.

Second, click the SETUP-PLANT button to create a 'seed'. This can be clicked at any time to create a new plant so that it is possible to test multiple plants over the same environment.

Finally, click the GO button to watch the seed develop.

Very often, due to a lack of nutrients in the immediate environment of the seed, a new plant will fail. The plant (seed) begins with enough reserve nutrients to explore some of the area around it, but it will quickly die if it does not otherwise locate adequate nutrients in the environment. In this case, try creating a new plant to see if perhaps another plant will take hold (because of the use of a random function in the model, no two plants fare the same - even in an identical environment). If this does not work, then try resetting the environment, or even try increasing the concentration or density of nutrients in the environment.

Also, for variety, the CACTUS? switch controls whether the plant will grow only up and down instead of in all directions.


THINGS TO NOTICE
----------------
Observe the location of nutrients within the environment before running a plant. The colors in the environment are scaled to reveal where sources of nutrients are. Squares of yellow with a dark center indicate sunny areas, squares of blue with a dark center indicate watery areas.

How large do you expect a plant to grow (if at all) with the given setup?

Are plants more likely to grow (i.e. not die) in cactus mode or bush mode?

What happens when a cell in the middle of a branch, formerly connecting other cells to the rest of the plant, dies? Why does this happen?


THINGS TO TRY
-------------
Try growing different plants with the same patch setup (nutrient allocation). Can you generalize about the growth of a plant in a given environment?

Try growing a plant in different environments, and with different CACTUS? settings. Do you notice any limits to how large the plant can grow?


EXTENDING THE MODEL
-------------------
Sunlight and water are presented in this model as dots along a flat landscape. Real sunlight beams down from above though, and real water is generally present in a continuous gradient beneath the ground. Come up with an alternative scheme for representing sunlight and water in this model.

In order to be able to explore a larger range of ecologies, it may be useful to add interface features (sliders) and code that allows a separate setup of sun and water resources.

Currently, water resources are not depleted -- they are not even replenished, they are simply held at constant values.  You can try making the model more realistic by addressing this issue.

Improve the growth rules used in this model. A simple way to explore this would be to try and improve upon the parameters in the functions SHARE-UP, SHARE-DOWN and SHARE-SIDE (which are fixed). For this, it may be useful to set these parameters as values of sliders on the Interface.  A more in depth way would be to come up with an entirely new set of sharing or growth rules, or a different strategy altogether.

This model explores rules that will cause an artificial plant to grow in an ""efficient"" manner. Efficiency can be roughly defined here as the number of leaves in the plant that are ""good investments"" for the plant as opposed to those that only use up resources but do not contribute any. An alternative approach is to equate efficiency with the total amount of water and sunlight collected by a plant in a given environment. Think of a quantifiable measure ( a ""metric"") of efficiency for a plant and add this measure to the model. Now, use this measure in order to improve upon the growth rules of the plant? Does any one set of such rules work better than all others for all tested environments?

The settings in this model allow plants to grow in two varieties (cactus and bush) by varying the rules for where a new cell can be located relative to its parent cell. Can you come up with rules that will yield alternative shapes for the plant (i.e. palm tree, ivy...)?


NETLOGO FEATURES
----------------
Note the use of the DIFFUSE primitive to spread out the water and sunlight.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Plant Growth model.  http://ccl.northwestern.edu/netlogo/models/PlantGrowth.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/PlantGrowth for terms of use.
"
Wolf Sheep Stride Inheritance,/models/Sample Models/Biology/Unverified,"globals [
          max-energy           ;; the maximum amount of energy any animal can have
          min-energy           ;; the minimum amount of energy an animal needs to reproduce
          max-stride           ;; the maximum stride length, the minimum stride length is 0,
                               ;; the stride will always be between these limits
          wolf-gain-from-food  ;; energy units wolves get for eating
          sheep-gain-from-food ;; energy units sheep get for eating
          sheep-reproduce      ;; probability that sheep will reproduce at each time step
          wolf-reproduce       ;; probability that wolves will reproduce at each time step
          grass-regrowth-time  ;; number of ticks before eaten grass regrows.
        ]

breed [ sheep a-sheep ]
breed [ wolves wolf ]

turtles-own [ energy stride-length ]
patches-own [ countdown ]  ;; patches countdown until they regrow

to setup
  ca
  ;; initialize constant values
  set max-stride 3
  set min-energy 200
  set max-energy 500
  set wolf-gain-from-food 20
  set sheep-gain-from-food 20
  set sheep-reproduce 5
  set wolf-reproduce 6
  set grass-regrowth-time 138

  ;; setup the grass
  ask patches [ set pcolor green ]
  ask patches [
    set countdown random grass-regrowth-time ;; initialize grass grow clocks randomly
    if random 2 = 0  ;;half the patches start out with grass
      [ set pcolor brown ]
  ]

  set-default-shape sheep ""sheep""
  create-sheep initial-number-sheep  ;; create the sheep, then initialize their variables
  [
    set color white
    set stride-length initial-sheep-stride
    set size max-stride  ;; easier to see
    set energy random max-energy
    setxy random-xcor random-ycor
  ]

  set-default-shape wolves ""wolf""
  create-wolves initial-number-wolves  ;; create the wolves, then initialize their variables
  [
    set color black
    set stride-length initial-wolf-stride
    set size max-stride  ;; easier to see
    set energy random max-energy
    setxy random-xcor random-ycor
  ]
  setup-plot
  do-plot
end

to go
  if not any? turtles [ stop ]
  ask sheep [
    move
    ;; sheep always loose 0.5 units of energy each tick
    set energy energy - 0.5
    ;; if larger strides use more energy
    ;; also deduct the energy for the distance moved
    if stride-length-penalty?
    [ set energy energy - stride-length ]
    eat-grass
    reproduce-sheep
    maybe-die
  ]
  ask wolves [
    move
    ;; wolves always loose 0.5 units of energy each tick
    set energy energy - 0.5
    ;; if larger strides use more energy
    ;; also deduct the energy for the distance moved
    if stride-length-penalty?
    [ set energy energy - stride-length ]
    catch-sheep
    reproduce-wolves
    maybe-die
  ]
  ask patches [ grow-grass ]
  tick
  do-plot  ;; plot populations
end

to move  ;; turtle procedure
  rt random-float 50
  lt random-float 50
  fd stride-length
end

to eat-grass  ;; sheep procedure
  ;; sheep eat grass, turn the patch brown
  if pcolor = green [
    set pcolor brown
    set energy energy + sheep-gain-from-food  ;; sheep gain energy by eating
    if energy > max-energy
    [ set energy max-energy ]
  ]
end

to reproduce-sheep  ;; sheep procedure
  reproduce sheep-reproduce sheep-stride-length-drift
end

to reproduce-wolves  ;; wolf procedure
  reproduce wolf-reproduce wolf-stride-length-drift
end

to reproduce [reproduction-chance drift] ;; turtle procedure
  ;; throw ""dice"" to see if you will reproduce
  if random-float 100 < reproduction-chance and energy > min-energy [
    set energy (energy / 2 )  ;; divide energy between parent and offspring
    hatch 1 [
      rt random-float 360
      fd 1
      ;; mutate the stride length based on the drift for this breed
      set stride-length mutated-stride-length drift
    ]
  ]
end

to-report mutated-stride-length [drift] ;; turtle reporter
  let l stride-length + random-float drift - random-float drift
  ;; keep the stride lengths within the accepted bounds
  if l < 0
  [ report 0 ]
  if stride-length > max-stride
  [ report max-stride ]
  report l
end

to catch-sheep  ;; wolf procedure
  let prey one-of sheep-here
  if prey != nobody
  [ ask prey [ die ]
    set energy energy + wolf-gain-from-food
    if energy > max-energy [set energy max-energy]
  ]
end

to maybe-die  ;; turtle procedure
  ;; when energy dips below zero, die
  if energy < 0 [ die ]
end

to grow-grass  ;; patch procedure
  ;; countdown on brown patches, if reach 0, grow some grass
  if pcolor = brown [
    ifelse countdown <= 0
      [ set pcolor green
        set countdown grass-regrowth-time ]
      [ set countdown countdown - 1 ]
  ]
end

;;
;; Plotting Procedures
;;
to setup-plot
  set-current-plot ""wolf stride histogram""
  set-histogram-num-bars 20
  set-current-plot ""sheep stride histogram""
  set-histogram-num-bars 20
end

to do-plot
 set-current-plot ""sheep stride histogram""
 histogram [ stride-length ] of sheep     ;; using the default plot pen
 set-current-plot ""wolf stride histogram""
 histogram [ stride-length ] of wolves    ;; using the default plot pen

 set-current-plot ""stride length""
 set-current-plot-pen ""sheep""
 if any? sheep
 [ plot mean [stride-length] of sheep ]
 set-current-plot-pen ""wolves""
 if any? wolves
 [ plot mean [stride-length] of wolves ]

  set-current-plot ""populations""
  set-current-plot-pen ""sheep""
  plot count sheep
  set-current-plot-pen ""wolves""
  plot count wolves
  set-current-plot-pen ""grass / 4""
  plot count patches with [ pcolor = green ] / 4  ;; divide by four to keep it within similar
                                                  ;; range as wolf and sheep populations
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2006 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Novak, M. and Wilensky, U. (2006). NetLogo Wolf Sheep Stride Inheritance model.
; http://ccl.northwestern.edu/netlogo/models/WolfSheepStrideInheritance.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2006 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/WolfSheepStrideInheritance
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model is a variation on the predator-prey ecosystems model wolf-sheep predation.
In this model, predator and prey can inherit a stride length, which describes how far forward they move in each model time step.  When wolves and sheep reproduce, the children inherit the parent's stride length -- though it may be mutated.


HOW IT WORKS
------------
At initialization wolves have a stride of INITIAL-WOLF-STRIDE and sheep have a stride of INITIAL-SHEEP-STRIDE.  Wolves and sheep wander around the world moving STRIDE-LENGTH in a random direction at each step.  Sheep eat grass and wolves eat sheep, as in the Wolf Sheep Predation model.  When wolves and sheep reproduce, they pass their stride length down to their young. However, there is a chance that the stride length will mutate, becoming slightly larger or smaller than that of its parent.


HOW TO USE IT
-------------
INITIAL-NUMBER-SHEEP: The initial size of sheep population
INITIAL-NUMBER-WOLVES: The initial size of wolf population

Half a unit of energy is deducted from each wolf and sheep at every time step. If STRIDE-LENGTH-PENALTY? is on, additional energy is deducted, scaled to the length of stride the animal takes (e.g., 0.5 stride deducts an additional 0.5 energy units each step).

WOLF-STRIDE-DRIFT and SHEEP-STRIDE-DRIFT:  How much variation an offspring of a wolf or a sheep can have in its stride length compared to its parent.  For example, if set to 0.4, then an offspring might have a stride length up to 0.4 less than the parent or 0.4 more than the parent.


THINGS TO NOTICE
----------------
WOLF STRIDE HISTOGRAM and SHEEP STRIDE HISTOGRAM will show how the population distribution of different animal strides is changing.

In general, sheep get faster over time and wolves get slower or move at the same speed.   Sheep get faster in part, because remaining on a square with no grass is less advantageous than moving to new locations to consume grass that is not eaten.  Sheep typically converge on an average stride length close to 1.  Why do you suppose it is not advantageous for sheep stride length to keep increasing far beyond 1?

If you turn STRIDE-LENGTH-PENALTY? off, sheep will become faster over time, but will not stay close to a stride length of 1.  Instead they will become faster and faster, effectively jumping over multiple patches with each simulation step.


THINGS TO TRY
-------------
Try adjusting the parameters under various settings. How sensitive is the stability of the model to the particular parameters?

Can you find any parameters that generate a stable ecosystem where there are at least two distinct groups of sheep or wolves with different average stride lengths?


EXTENDING THE MODEL
-------------------
Add a cone of vision for sheep and wolves that allows them to chase or run away from each other.   Make this an inheritable trait.


NETLOGO FEATURES
----------------
This model uses two breeds of turtle to represent wolves and sheep.


RELATED MODELS
---------------
Wolf Sheep Predation
Bug Hunt Speeds


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Novak, M. and Wilensky, U. (2006).  NetLogo Wolf Sheep Stride Inheritance model.  http://ccl.northwestern.edu/netlogo/models/WolfSheepStrideInheritance.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2006 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/WolfSheepStrideInheritance for terms of use.
"
Moths,/models/Sample Models/Biology,"breed [ lights light ]
breed [ moths moth ]

globals
[
  scale-factor  ;; to control the form of the light field
]

lights-own
[
  intensity
]

moths-own
[
  ;; +1 means the moths turn to the right to try to evade a bright light
  ;; (and thus circle the light source clockwise). -1 means the moths
  ;; turn to the left (and circle the light counter-clockwise)
  ;; The direction tendency is assigned to each moth when it is created and does not
  ;; change during the moth's lifetime.
  direction
]

patches-own
[
  light-level ;; represents the light energy from all light sources
]

to setup
  ca
  set-default-shape lights ""circle 2""
  set-default-shape moths ""butterfly""
  set scale-factor 50
  if number-lights > 0
  [
    make-lights number-lights
    ask patches [ generate-field ]
  ]
  make-moths number-moths
end

to go
  ask moths [ move-thru-field ]
  tick
end

;;;;;;;;;;;;;;;;;;;;;;
;; Setup Procedures ;;
;;;;;;;;;;;;;;;;;;;;;;

to make-lights [ number ]
  create-lights number [
    set color white
    jump 10 + random-float (max-pxcor - 30)
    set intensity random luminance + 20
    set size sqrt intensity
  ]
end

to make-moths [ number ]
  create-moths number [
    ifelse (random 2 = 0)
      [ set direction 1 ]
      [ set direction -1 ]
    set color white
    jump random-float max-pxcor
    set size 5
  ]
end

to generate-field ;; patch procedure
  set light-level 0
  ;; every patch needs to check in with every light
  ask lights
    [ set-field myself ]
  set pcolor scale-color blue (sqrt light-level) 0.1 ( sqrt ( 20 * max [intensity] of lights ) )
end

;; do the calculations for the light on one patch due to one light
;; which is proportional to the distance from the light squared.
to set-field [p]  ;; turtle procedure; input p is a patch
  let rsquared (distance p) ^ 2
  let amount intensity * scale-factor
  ifelse rsquared = 0
    [ set amount amount * 1000 ]
    [ set amount amount / rsquared ]
  ask p [ set light-level light-level + amount ]
end

;;;;;;;;;;;;;;;;;;;;;;;;
;; Runtime Procedures ;;
;;;;;;;;;;;;;;;;;;;;;;;;

to move-thru-field    ;; turtle procedure
  ifelse (light-level <= ( 1 / (10 * sensitivity) ))
  [
    ;; if there is no detectable light move randomly
    rt flutter-amount 45
  ]
  [
    ifelse (random 25 = 0)
    ;; add some additional randomness to the moth's movement, this allows some small
    ;; probability that the moth might ""escape"" from the light.
    [
      rt flutter-amount 60
    ]
    [
      ;; turn toward the brightest light
      maximize
      ;; if the light ahead is not above the sensitivity threshold  head towards the light
      ;; otherwise move randomly
      ifelse ( [light-level] of patch-ahead 1 / light-level > ( 1 + 1 / (10 * sensitivity) ) )
      [
        lt ( direction * turn-angle )
      ]
      [
        rt flutter-amount 60
      ]
    ]
  ]
  if not can-move? 1
    [ maximize ]
  fd 1
end

to maximize  ;; turtle procedure
  face max-one-of patches in-radius 1 [light-level]
end

to-report flutter-amount [limit]
  ;; This routine takes a number as an input and returns a random value between
  ;; (+1 * input value) and (-1 * input value).
  ;; It is used to add a random flutter to the moth's movements
  report random-float (2 * limit) - limit
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2005 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2005).  NetLogo Moths model.
; http://ccl.northwestern.edu/netlogo/models/Moths.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2005 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Moths
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model demonstrates moths flying in circles around a light.  Each moth follows a set of simple rules.  None of the rules specify that the moth should seek and then circle a light.  Rather, the observed pattern arises out of the combination of the moth's random flight and the simple behavioral rules described below.

Scientists have proposed several explanations for why moths are attracted to and then circle lights. For example, scientists once believed that moths navigated through the sky by orienting themselves to the moon, and that the moths' attraction to nearby, earthly light sources (such as a street lamp) arose because they mistook the terrestrial lights for the moon.  However, while this explanation may seem reasonable, it is not supported by available scientific evidence.


HOW IT WORKS
------------
Moths exhibit two basic kinds of behavior.  When they detect a light source from a distance (as far as 200 feet away) moths tend to fly straight toward the light.  Then, when moths get close to the light, they tend to turn away from the light in order to avoid it.

First, moths sense the light in their immediate vicinity and turn toward the direction where the light is greatest.

Second, moths compare the light immediately ahead of them with the light at their current position.  If the ratio of 'light just ahead' to 'light here' is below a threshold value, then the moths fly forward toward the light.  If the ratio of 'light just ahead' to 'light here' is above a threshold value, then moths turns away from the light.  The threshold is determined by the moths' sensitivity to light.

If the moths do not detect any light, or if there simply are no lights in the space where the moths are flying, then the moths flutter about randomly.

Note that light energy is represented in this model as decreasing with the square of the distance from the light source.  This characteristic is known as a ""one over r-squared relationship,"" and is comparable to the way electrical field strength decreases with the distance from an electrical charge and the way that gravitational field strength decreases with the distance from a massive body.


HOW TO USE IT
-------------
Click the SETUP button to create NUMBER-LIGHTS with LUMINANCE and NUMBER-MOTHS.  Click the GO button to start the simulation.

NUMBER-MOTHS:  This slider determines how many lights will be created when the SETUP button is pressed.

NUMBER-LIGHTS:  This slider determines how many lights will be created when the SETUP button pressed.  Note that this value only affects the model at setup.

LUMINANCE:  This slider influences how bright the lights will be.  When a light is created, it is assigned a luminance of 20 plus a random value between 0 and LUMINANCE. Lights with a higher luminance can be sensed by moths from farther away.  Note that changing LUMINANCE while the model is running has no effect.

SENSITIVITY:  This slider determines how sensitive the moths are to light.  When SENSITIVITY is higher, moths are able to detect a given light source from a greater distance and will turn away from the light source at a greater distance.

TURN-ANGLE:  This slider determines the angle that moths turn away when they sense that the ratio of 'light ahead' to 'light here' is above their threshold value.


THINGS TO NOTICE
----------------
When the model begins, notice how moths are attracted to the two lights.  What happens when the lights are created very close together?  What happens when the lights are created very far apart?

Do all of the moths circle the same light?  When a moth begins to circle one light, does it ever change to circling the other light?  Why or why not?


THINGS TO TRY
-------------
Run the simulation without any lights.  What can you say about the moths' flight patterns?

With the simulation stopped, use the following values:
- NUMBER-LIGHTS: 1
- LUMINANCE: 1
- NUMBER-MOTHS: 10
- SENSITIVITY: 1.00
- TURN-ANGLE: 95
Notice that, at first, some moths might fly about randomly while others are attracted to the light immediately.  Why?

While the model is running increase SENSITIVITY.  What happens to the moths' flight patterns?  See if you can create conditions in which one or more of the moths can 'escape' from its state of perpetually circling the light.

Vary the TURN-ANGLE.  What happens?  Why do you think the moths behave as observed with different values of TURN-ANGLE?  What value or values do you think are most realistic?

It would be interesting to better understand the flight patterns of the moths in the model.  Add code to the model that allows you to track the movements of one or more moths (for example, by using the pen features).  Do you see a pattern?  Why might such a pattern appear and how can it be altered?


EXTENDING THE MODEL
-------------------
This model offers only one set of rules for generating moths' circular flight around a light source.  Can you think of different ways to define the rules?

Alternatively, can you imagine a way to model an earlier theory of moth behavior in which moths navigate straight lines by orienting themselves to the moon?  Do rules that allow moths to navigate according to their position relative to the moon lead to the observed circling behavior around light sources that are much, much closer than the far-away moon?


NETLOGO FEATURES
----------------
This model creates a field of light across the patches, using SCALE-COLOR to display the value, and the moths use FACE and MAX-ONE-OF to traverse the light field.

RELATED MODELS
--------------
Ants, Ant Lines, Fireflies, Flocking


CREDITS AND REFERENCES
----------------------
Adams, C.  (1989).  Why are moths attracted to bright lights?  Retrieved May 1, 2005, from http://www.straightdope.com/classics/a5_038.html

To refer to this model in academic publications, please use:  Wilensky, U. (2005).  NetLogo Moths model.  http://ccl.northwestern.edu/netlogo/models/Moths.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2005 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Moths for terms of use.
"
Disease Solo,/models/Sample Models/Biology,";;;;;;;;;;;;;;;;;;
;; Declarations ;;
;;;;;;;;;;;;;;;;;;

globals
[
  ;; number of turtles that are sick
  num-sick
  ;; when multiple runs are recorded in the plot, this
  ;; tracks what run number we're on
  run-number
  ;; counter used to keep the model running for a little
  ;; while after the last turtle gets infected
  delay
]

breed [ androids android ]
breed [ users user ]

;; androids and users are both breeds of turtle, so both androids
;; and users have these variables
turtles-own
[
  infected?    ;; whether turtle is sick (true/false)
]

;;;;;;;;;;;;;;;;;;;;;
;; Setup Functions ;;
;;;;;;;;;;;;;;;;;;;;;

;; clears the plot too
to setup-clear
  clear-all
  set run-number 1
  setup-world
end

;; note that the plot is not cleared so that data
;; can be collected across runs
to setup-keep
  clear-turtles
  clear-patches
  reset-ticks
  set run-number run-number + 1
  setup-world
end

to setup-world
  set-default-shape androids ""android""
  set-default-shape users ""person""
  set num-sick 0
  set delay 0
  create-some-androids
  create-user
  setup-plot
  do-plot
end

to infect
  ask one-of androids [ get-sick ]
end

to create-some-androids
  create-androids num-androids
  [
    setxy random-pxcor random-pycor   ;; put androids on patch centers
    set color gray
    set heading 90 * random 4
    set infected? false
  ]
end

;;;;;;;;;;;;;;;;;;;;;;;
;; Runtime Functions ;;
;;;;;;;;;;;;;;;;;;;;;;;

to go
  ;; in order to extend the plot for a little while
  ;; after all the turtles are infected...
  if num-sick = count turtles
    [ set delay delay + 1  ]
  if delay > 50
    [ stop ]
  ;; now for the main stuff;
  ;; we use EVERY to keep the activity from running too fast
  every 0.1
  [
    androids-wander
    ask turtles with [ infected? ]
      [ spread-disease ]
    set num-sick count turtles with [ infected? ]
    tick
    do-plot
  ]
end

;; controls the motion of the androids
to androids-wander
  ask androids
  [
    ifelse avoid? and not infected?
      [ avoid ] [
    ifelse chase? and infected?
      [ chase ]
      [ rt (random 4) * 90 ] ]
  ]
  ask androids [
    fd 1
  ]
end

to avoid ;; android procedure
  let candidates patches in-radius 1 with [ not any? turtles-here with [ infected? ] ]
  ifelse any? candidates
    [ face one-of candidates ]
    [ rt (random 4) * 90 ]
end

to chase ;; android procedure
  let candidates turtles in-radius 1 with [ not infected? ]
  ifelse any? candidates
    [ face one-of candidates ]
    [ rt (random 4) * 90 ]
end

to spread-disease ;; turtle procedure
  ask other turtles-here [ maybe-get-sick ]
end

to maybe-get-sick ;; turtle procedure
  ;; roll the dice and maybe get sick
  if (not infected?) and (random 100 < infection-chance)
    [ get-sick ]
end

;; set the appropriate variables to make this turtle sick
to get-sick ;; turtle procedure
  if not infected?
  [ set infected? true
  set shape word shape "" sick"" ]
end

;;;;;;;;;;;;;;;;;;;;;
;; User Procedures ;;
;;;;;;;;;;;;;;;;;;;;;

to create-user
  create-users 1
  [
    set color sky
    set size 1.5     ;; easier to see than default of 1
    set heading (random 4) * 90
    set infected? false
  ]
end

to move [ new-heading ]
  ask users
  [
    set heading new-heading
    fd step-size
  ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;
;; Plotting Procedures ;;
;;;;;;;;;;;;;;;;;;;;;;;;;

to setup-plot
  create-temporary-plot-pen word ""run "" run-number
  set-plot-pen-color item (run-number mod 5)
                          [blue red green orange violet]
end

to do-plot
  plot num-sick
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2005 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2005).  NetLogo Disease Solo model.
; http://ccl.northwestern.edu/netlogo/models/DiseaseSolo.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2005 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/DiseaseSolo
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
Disease Solo is a one-player version of the HubNet activity Disease.  It simulates the spread of a disease through a population.  One agent in the population is a person controlled by the user; the others are ""androids"" controlled by the computer.


HOW IT WORKS
------------
The user controls the blue agent via the buttons and slider on the right side of the view.  The infection is started by pressing the ""infect"" button.

Sick agents are indicated by a red circle.

Androids can move using a few different simple strategies. By default they simply move randomly, however, using the AVOID? and CHASE? switches you can indicate that uninfected androids should run from infected ones or infected androids should chase uninfected ones.

The person may also catch the infection.

Healthy ""agents"" on the same patch as sick agents have an INFECTION-CHANCE chance of becoming ill.


HOW TO USE IT
-------------

Buttons:
--------
SETUP/CLEAR - sets up the world and clears plots.
SETUP/KEEP - sets up the world without clearing the plot; this lets you compare results from different runs.
GO - runs the simulation.
INFECT - infects one of the androids

Sliders:
--------
NUM-ANDROIDS - determines how many androids are created at setup
INFECTION-CHANCE - a healthy agent's chance at every time step to become sick if it is on the same patch as an infected agent

Monitors:
---------
NUMBER SICK - the number of sick agents

Plots:
------
NUMBER SICK - the number of sick agents versus time

Switches:
---------
AVOID? - when this switch is on each uninfected android checks all four directions to see if it can move to a patch that is safe from infected agents.
CHASE? - when this switch is on each infected androids checks all four directions to see if it can infect another agent.

User Controls:
--------------
UP, DOWN, LEFT, and RIGHT - move the person around the world, STEP-SIZE determines how far the person moves each time one of the control buttons is pressed.


THINGS TO NOTICE
----------------
Think about how the plot will change if you alter a parameter.  Altering the infection chance will have different effects on the plot.


THINGS TO TRY
-------------
Do several runs of the model and record a data set for each one by using the setup/keep button. Compare the different resulting plots.

What happens to the plot as you do runs with more and more androids?


EXTENDING THE MODEL
-------------------
Currently, the agents remain sick once they're infected.  How would the shape of the plot change if agents eventually healed?  If, after healing, they were immune to the disease, or could still spread the disease, how would the dynamics be altered?

The user has a distinct advantage in this version of the model (assuming that the goal is either not to become infected, or to infect others), as the user can see the entire world and the androids can only see one patch ahead of them.  Try to even out the playing field by giving the androids a larger field of vision.

Determining the first agent who is infected may impact the way disease spreads through the population.  Try changing the target of the first infection so it can be determined by the user.


NETLOGO FEATURES
----------------
You can use the keyboard to control the person.  To activate the keyboard shortcuts for the movement button, either hide the command center or click in the white background.

The plot uses temporary plot pens, rather than a fixed set of permanent plot pens, so you can use the setup/keep button to overlay as many runs as you want.


RELATED MODELS
--------------
Disease (HubNet version)
Virus
AIDS


CREDITS AND REFERENCES
----------------------
This model is a one player version of the HubNet activity Disease.  In the HubNet version, multiple users can participate at once.

To refer to this model in academic publications, please use:  Wilensky, U. (2005).  NetLogo Disease Solo model.  http://ccl.northwestern.edu/netlogo/models/DiseaseSolo.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2005 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/DiseaseSolo for terms of use.
"
Shepherds,/models/Sample Models/Biology,"breed [ sheep a-sheep ]
breed [ shepherds shepard ]

globals
[
  sheepless-neighborhoods       ;; how many patches have no sheep in any neighboring patches?
  herding-efficiency            ;; measures how well-herded the sheep are
]
patches-own
[
  sheep-nearby                  ;; how many sheep in neighboring patches?
]
shepherds-own
[
  carried-sheep         ;; the sheep I'm carrying (or nobody if I'm not carrying in)
  found-herd?           ;; becomes true when I find a herd to drop it in
]

to setup
  ca
  set-default-shape sheep ""sheep""
  set-default-shape shepherds ""person""
  ask patches
    [ set pcolor green + (random-float 0.8) - 0.4]   ;; varying the green just makes it look nicer
  create-sheep num-sheep
    [ set color white
      set size 1.5  ;; easier to see
      setxy random-xcor random-ycor ]
  create-shepherds num-shepherds
    [ set color brown
      set size 1.5  ;; easier to see
      set carried-sheep nobody
      set found-herd? false
      setxy random-xcor random-ycor ]
  update-sheep-counts
end

to update-sheep-counts
  ask patches
    [ set sheep-nearby (sum [count sheep-here] of neighbors) ]
  set sheepless-neighborhoods (count patches with [sheep-nearby = 0])
end

to calculate-herding-efficiency
  set herding-efficiency (sheepless-neighborhoods / (count patches with [not any? sheep-here])) * 100
end

to go
  ask shepherds
  [ ifelse carried-sheep = nobody
      [ search-for-sheep ]     ;; find a sheep and pick it up
    [ ifelse found-herd?
        [ find-empty-spot ]  ;; find an empty spot to drop the sheep
      [ find-new-herd ] ]  ;; find a herd to drop the sheep in
    wiggle
    fd 1
    if carried-sheep != nobody
    ;; bring my sheep to where I just moved to
    [ ask carried-sheep [ move-to myself ] ] ]
  ask sheep with [not hidden?]
  [ wiggle
    fd sheep-speed ]
  tick
  every 1.5
  [
    update-sheep-counts
    calculate-herding-efficiency
    do-plot
  ]
end

to wiggle        ;; turtle procedure
  rt random 50 - random 50
end

to search-for-sheep ;; shepherds procedure
  set carried-sheep one-of sheep-here with [not hidden?]
  if (carried-sheep != nobody)
    [ ask carried-sheep
        [ ht ]           ;; make the sheep invisible to other shepherds
      set color blue     ;; turn shepherd blue while carrying sheep
      fd 1 ]
end

to find-new-herd ;; shepherds procedure
  if any? sheep-here with [not hidden?]
    [ set found-herd? true ]
end

to find-empty-spot ;; shepherds procedure
  if all? sheep-here [hidden?]
    [ ask carried-sheep
        [ st ]                ;; make the sheep visible again
      set color brown         ;; set my own color back to brown
      set carried-sheep nobody
      set found-herd? false
      rt random 360
      fd 20 ]
end

;; -----plotting operations-------
to do-plot
  set-current-plot ""Herding Efficiency""
  plot herding-efficiency
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Shepherds model.
; http://ccl.northwestern.edu/netlogo/models/Shepherds.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Shepherds
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This project is inspired by two simpler models: one of termites gathering wood chips into piles and one of moving sheep.  In this project, sheep wander randomly while shepherds circulate trying to herd them.  Whether or not the sheep eventually end up in a single herd depends on the number of shepherds and how fast they move compared to the sheep.


HOW IT WORKS
------------
The shepherds follow a set of simple rules.  Each shepherd starts wandering randomly.  If it bumps into a sheep, it picks the sheep up, and continues to wander randomly. When it bumps into another sheep, it finds a nearby empty space, puts its sheep down, and looks for another one.


HOW TO USE IT
-------------
Click the SETUP button to set up the shepherds (brown) and sheep (white).  Click the GO button to start the simulation.   A shepherd turns blue when it is carrying a sheep.

There are three sliders.  NUM-SHEEP and NUM-SHEPHERDS control the numbers of sheep and shepherds, respectively.   Changes in these sliders do not take effect until the next setup.

The SHEEP-SPEED slider controls the speed of the sheep relative to the shepherds.  This slider can be changed while the model is running.

While the simulation runs, a plot of the shepherds' herding efficiency is displayed.  Herding efficiency is measured here by counting the number of patches that have no sheep in their neighborhood:

efficiency = sheepless neighborhoods / (# of patches - # of sheep)
[expressed as a percentage]

As the shepherds herd the sheep, more of the neighborhoods should be empty. The measure of efficiency is fairly arbitrary; other measures could be devised.


THINGS TO NOTICE
----------------
As small herds of sheep begin to form, the herds are not ""protected"" in any way.  That is, shepherds sometimes take sheep away from existing herds.  That strategy might seem counter-productive. But if the herds were ""protected"", you would end up with lots of little herds, not several big ones.   Why is this?

In general, if there are enough shepherds and/or the shepherds move much faster than the sheep, the number of herds decreases with time. Why?  One explanation is as follows: some herds disappear, when shepherds carry away all of the sheep.  If sheep never moved, it would not be possible for a new herd to start from scratch, since shepherds always put their sheep near other sheep.  So the number of herds would necessarily decrease over time.  (The only way a ""new"" herd would start is when an existing herd splits into two.) However, since sheep move, they can form new herds. If they move too fast relative to the shepherds, the herding will break down.

If there are not enough shepherds, or if the sheep move fast enough relative to the shepherds, the shepherds cannot keep up with the wanderings of their sheep, and the sheep will disperse.

Are the final herds roughly round?  What other physical situations also produce round things?

This project is a good example of a probabilistic and decentralized strategy.  There is no shepherd in charge, and no special pre-designated site for the herds. The movement of the shepherds and sheep and thus their behavior is probabilistic. Each shepherd follows a set of simple rules, but the group as a whole accomplishes a rather sophisticated task.


THINGS TO TRY
-------------
Can you find the minimum number of shepherds needed to herd a given number of sheep?  Which helps more, doubling the number of shepherds or doubling the speed of the existing shepherds (by cutting the SHEEP-SPEED in half)?

How many sheep can one individual shepherd keep in a group?

Start with a SHEEP-SPEED of zero (the sheep stay put), let the shepherd gather them into herds, and then slowly increase the SHEEP-SPEED.   How is the herding efficiency affected?   How high does SHEEP-SPEED need to be for the shepherds to be useless, that is, for the herding efficiency returns to its initial value?  This is the same as saying that the distribution of sheep is no better than random.

When there are just two or three herds left, which of them is most  likely to ""win"" as the single, final herd?  How often does  the larger of the two herds win?  If one herd has only a  single sheep, and the other herd has the rest of the sheep, what are the chances that the first herd will win?

Compare this model to ""Termites"".  It runs slower, but aside from that, are the results the same?

In both the Termites and the Shepherds models, if the turtles don't jump away from the piles/herds they make, piling/herding happens more slowly and to a lesser extent.  Does this make sense?  Experiment with different search commands that you might give the shepherds besides ""fd 1"" and ""jump 20"".


EXTENDING THE MODEL
-------------------
Can you find other ways to measure herding efficiency?

Can you extend the model so that sheep follow each other, tending to cluster?

Can you extend the model to have the shepherds sort white sheep from black sheep?

Can you change the model so that there's only ever one sheep on a patch?  Does it change the behavior of the model?

The way the model is currently written, multiple sheep are allowed to occupy the same physical location.  And, since all shepherds search for a sheep to pick up before any of them actually take their sheep away, a shepherd may come to a location with several sheep and, examining one at random, find that another shepherd has already laid a hold of that sheep.  Currently shepherds give up on all sheep at that location when this happens, rather than seeing if there are other sheep there which are still unattended.  (If shepherds did not check to see whether a sheep was attended, multiple shepherds might each pick up the same sheep and take it away, thereby cloning it!)  Can you find a way to make shepherds check all sheep at a location before leaving?

Real shepherds often use sheepdogs to help them with their herding.  A sheepdog in this context might put down some chemical which ""scares"" the sheep, i.e., wandering sheep try to avoid it and move down gradient.  Can you implement sheepdogs and see how helpful they are?  Can you come up with a rough equivalence of how many shepherds a sheepdog can replace (to maintain the same herding efficiency), or how many sheepdogs are needed to replace a single shepherd?

Since it would be difficult to force sheep-turtles to follow shepherd-turtles which have ""picked them up"", the mechanics of picking a sheep up actually involve ""killing"" the sheep and creating a sheep-shepherd collective which wanders around following shepherd rules until it finds a place to put the sheep down, at which point another sheep is ""created"" at that location, and the collective reverts to being a normal shepherd again. Can you change the model so the shepherds actually herd the sheep rather than killing them and recreating them?


NETLOGO FEATURES
----------------
Compare this code to that of ""Termites"".  It's similar, except that sheep and shepherds are both turtles here, and active, while in Termites the wood chips are patches and remain passive.  As a result, the Termites model runs faster.

The two models are coded somewhat differently, however.  Termites uses a loops-within-GO structure that is worth noting.  GO is a turtle forever button, so each turtle executes the code in the GO function in parallel and independently of each other.  Since each turtle moves through the GO function at its own pace, it's OK for functions like search-for-chip to be written as loops, which execute repeatedly until a certain condition is satisfied.  Then each turtle goes on to the next loop.

But in this model, GO is an observer forever button, because we want to have separate ""ask"" blocks for the sheeps and the shepherds, and because we want to update the plot every so often.  Since the observer waits for all of the turtles to finish the ""ask"" before moving on to the next line of code, it wouldn't be OK for a turtle to take more than one step inside the ""ask"" -- because then all the other turtles would have to wait for it.  So instead of using loops, this model uses the boolean variables carrying-sheep? and found-herd? to keep track of whether each turtle is in sheep-finding mode, herd-finding mode, or empty-spot-finding mode.


RELATED MODELS
--------------
Termites
Painted Desert Challenge


CREDITS AND REFERENCES
----------------------
Thanks to Christopher Kribs Zaleta for his help with converting the model from StarLogoT to NetLogo.

To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Shepherds model.  http://ccl.northwestern.edu/netlogo/models/Shepherds.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Shepherds for terms of use.
"
Ants,/models/Sample Models/Biology,"patches-own [
  chemical             ;; amount of chemical on this patch
  food                 ;; amount of food on this patch (0, 1, or 2)
  nest?                ;; true on nest patches, false elsewhere
  nest-scent           ;; number that is higher closer to the nest
  food-source-number   ;; number (1, 2, or 3) to identify the food sources
]

;;;;;;;;;;;;;;;;;;;;;;;;
;;; Setup procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;

to setup
  clear-all
  set-default-shape turtles ""bug""
  crt population
  [ set size 2         ;; easier to see
    set color red  ]   ;; red = not carrying food
  setup-patches
  do-plotting
end

to setup-patches
  ask patches
  [ setup-nest
    setup-food
    recolor-patch ]
end

to setup-nest  ;; patch procedure
  ;; set nest? variable to true inside the nest, false elsewhere
  set nest? (distancexy 0 0) < 5
  ;; spread a nest-scent over the whole world -- stronger near the nest
  set nest-scent 200 - distancexy 0 0
end

to setup-food  ;; patch procedure
  ;; setup food source one on the right
  if (distancexy (0.6 * max-pxcor) 0) < 5
  [ set food-source-number 1 ]
  ;; setup food source two on the lower-left
  if (distancexy (-0.6 * max-pxcor) (-0.6 * max-pycor)) < 5
  [ set food-source-number 2 ]
  ;; setup food source three on the upper-left
  if (distancexy (-0.8 * max-pxcor) (0.8 * max-pycor)) < 5
  [ set food-source-number 3 ]
  ;; set ""food"" at sources to either 1 or 2, randomly
  if food-source-number > 0
  [ set food one-of [1 2] ]
end

to recolor-patch  ;; patch procedure
  ;; give color to nest and food sources
  ifelse nest?
  [ set pcolor violet ]
  [ ifelse food > 0
    [ if food-source-number = 1 [ set pcolor cyan ]
      if food-source-number = 2 [ set pcolor sky  ]
      if food-source-number = 3 [ set pcolor blue ] ]
    ;; scale color to show chemical concentration
    [ set pcolor scale-color green chemical 0.1 5 ] ]
end

;;;;;;;;;;;;;;;;;;;;;
;;; Go procedures ;;;
;;;;;;;;;;;;;;;;;;;;;

to go  ;; forever button
  ask turtles
  [ if who >= ticks [ stop ] ;; delay initial departure
    ifelse color = red
    [ look-for-food  ]       ;; not carrying food? look for it
    [ return-to-nest ]       ;; carrying food? take it back to nest
    wiggle
    fd 1 ]
  diffuse chemical (diffusion-rate / 100)
  ask patches
  [ set chemical chemical * (100 - evaporation-rate) / 100  ;; slowly evaporate chemical
    recolor-patch ]
  tick
  do-plotting
end

to return-to-nest  ;; turtle procedure
  ifelse nest?
  [ ;; drop food and head out again
    set color red
    rt 180 ]
  [ set chemical chemical + 60  ;; drop some chemical
    uphill-nest-scent ]         ;; head toward the greatest value of nest-scent
end

to look-for-food  ;; turtle procedure
  if food > 0
  [ set color orange + 1     ;; pick up food
    set food food - 1        ;; and reduce the food source
    rt 180                   ;; and turn around
    stop ]
  ;; go in the direction where the chemical smell is strongest
  if (chemical >= 0.05) and (chemical < 2)
  [ uphill-chemical ]
end

;; sniff left and right, and go where the strongest smell is
to uphill-chemical  ;; turtle procedure
  let scent-ahead chemical-scent-at-angle   0
  let scent-right chemical-scent-at-angle  45
  let scent-left  chemical-scent-at-angle -45
  if (scent-right > scent-ahead) or (scent-left > scent-ahead)
  [ ifelse scent-right > scent-left
    [ rt 45 ]
    [ lt 45 ] ]
end

;; sniff left and right, and go where the strongest smell is
to uphill-nest-scent  ;; turtle procedure
  let scent-ahead nest-scent-at-angle   0
  let scent-right nest-scent-at-angle  45
  let scent-left  nest-scent-at-angle -45
  if (scent-right > scent-ahead) or (scent-left > scent-ahead)
  [ ifelse scent-right > scent-left
    [ rt 45 ]
    [ lt 45 ] ]
end

to wiggle  ;; turtle procedure
  rt random 40
  lt random 40
  if not can-move? 1 [ rt 180 ]
end

to-report nest-scent-at-angle [angle]
  let p patch-right-and-ahead angle 1
  if p = nobody [ report 0 ]
  report [nest-scent] of p
end

to-report chemical-scent-at-angle [angle]
  let p patch-right-and-ahead angle 1
  if p = nobody [ report 0 ]
  report [chemical] of p
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Plotting procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

to do-plotting
  if not plot? [ stop ]
  set-current-plot ""Food in each pile""
  ;; since the plot? switch can be turned on and off at
  ;; any time, we must use PLOTXY to make sure points are
  ;; plotted with the proper x coordinates
  set-current-plot-pen ""food-in-pile1""
  plotxy ticks sum [food] of patches with [pcolor = cyan]
  set-current-plot-pen ""food-in-pile2""
  plotxy ticks sum [food] of patches with [pcolor = sky]
  set-current-plot-pen ""food-in-pile3""
  plotxy ticks sum [food] of patches with [pcolor = blue]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 1998.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Ants model.
; http://ccl.northwestern.edu/netlogo/models/Ants.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Ants
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
In this project, a colony of ants forages for food. Though each ant follows a set of simple rules, the colony as a whole acts in a sophisticated way.


HOW IT WORKS
------------
When an ant finds a piece of food, it carries the food back to the nest, dropping a chemical as it moves. When other ants ""sniff"" the chemical, they follow the chemical toward the food. As more ants carry food to the nest, they reinforce the chemical trail.


HOW TO USE IT
-------------
Click the SETUP button to set up the ant nest (in violet, at center) and three piles of food. Click the GO button to start the simulation. The chemical is shown in a green-to-white gradient.

The EVAPORATION-RATE slider controls the evaporation rate of the chemical. The DIFFUSION-RATE slider controls the diffusion rate of the chemical. There is an on-off PLOT? switch.  Turning off the plotting lets the model run faster.

If you want to change the number of ants, move the POPULATION slider before pressing SETUP.


THINGS TO NOTICE
----------------
The ant colony generally exploits the food source in order, starting with the food closest to the nest, and finishing with the food most distant from the nest. It is more difficult for the ants to form a stable trail to the more distant food, since the chemical trail has more time to evaporate and diffuse before being reinforced.

Once the colony finishes collecting the closest food, the chemical trail to that food naturally disappears, freeing up ants to help collect the other food sources. The more distant food sources require a larger ""critical number"" of ants to form a stable trail.

The consumption of the food is shown in a plot.  The line colors in the plot match the colors of the food piles.


EXTENDING THE MODEL
-------------------
Try different placements for the food sources. What happens if two food sources are equidistant from the nest? When that happens in the real world, ant colonies typically exploit one source then the other (not at the same time).

In this project, the ants use a ""trick"" to find their way back to the nest: they follow the ""nest scent."" Real ants use a variety of different approaches to find their way back to the nest. Try to implement some alternative strategies.

The ants only respond to chemical levels between 0.05 and 2.  The lower limit is used so the ants aren't infinitely sensitive.  Try removing the upper limit.  What happens?  Why?

In the UPHILL-CHEMICAL procedure, the ant ""follows the gradient"" of the chemical. That is, it ""sniffs"" in three directions, then turns in the direction where the chemical is strongest. You might want to try variants of the UPHILL-CHEMICAL procedure, changing the number and placement of ""ant sniffs.""


NETLOGO FEATURES
----------------
The built-in DIFFUSE primitive lets us diffuse the chemical easily without complicated code.

The primitive PATCH-RIGHT-AND-AHEAD is used so to make the ants smell in different directions without actually turning.


CREDITS AND REFERENCES
-----------------------

This model was developed at the MIT Media Lab.  See Resnick, M. (1994) ""Turtles, Termites and Traffic Jams: Explorations in Massively Parallel Microworlds.""  Cambridge, MA: MIT Press.  Adapted to StarLogoT, 1998, as part of the Connected Mathematics Project.  Adapted to NetLogo, 1998, as part of the Participatory Simulations Project.

To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Ants model.  http://ccl.northwestern.edu/netlogo/models/Ants.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Ants for terms of use.
"
Fireflies,/models/Sample Models/Biology,"turtles-own
[ clock        ;; each firefly's clock
  threshold    ;; the clock tick at which a firefly stops its flash
  reset-level  ;; the clock tick a firefly will reset to when it is triggered by other flashing
  window       ;; a firefly can't reset its cycle if (clock <= window)
]

to setup
  clear-all
  crt number
    [ setxy random-xcor random-ycor
      set clock random (round cycle-length)
      set threshold flash-length
      ifelse strategy = ""delay""
      [ set reset-level threshold
        set window -1 ]
      [ set reset-level 0
        set window (threshold + 1) ]
      set size 2  ;; easier to see
      recolor ]
  init-plot
end

to go
  ask turtles [
    move
    increment-clock
    if ( (clock > window) and (clock >= threshold) )
      [ look ]
  ]
  ask turtles [
    recolor
  ]
  tick
  do-plot
end

to recolor ; turtle procedure
  ifelse (clock < threshold)
    [ st
      set color yellow ]
    [ set color gray - 2
      ifelse show-dark-fireflies?
        [ st ]
        [ ht ] ]
end

to move ; turtle procedure
  rt random-float 90 - random-float 90
  fd 1
end

to increment-clock ; turtle procedure
  set clock (clock + 1)
  if clock = cycle-length
    [ set clock 0 ]
end

to look ; turtle procedure
  if count turtles in-radius 1 with [color = yellow] >= flashes-to-reset
    [ set clock reset-level ]
end

to init-plot
  set-current-plot ""Flashing Fireflies""
  set-plot-y-range 0 number
end

to do-plot
  set-current-plot-pen ""flashing""
  plot count turtles with [color = yellow]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Fireflies model.
; http://ccl.northwestern.edu/netlogo/models/Fireflies.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Fireflies
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model demonstrates a population of fireflies which synchronize their flashing using only the interactions between the individual fireflies. It is a good example of how a distributed system (i.e. a system with many interacting elements, but no 'leader') can coordinate itself without any central coordinator.

Though most species of firefly are not generally known to synchronize in groups, there are some (for example, Pteroptyx cribellata, Luciola pupilla,and Pteroptyx malaccae) that have been observed to do so in certain settings. This model generalizes two main strategies used by such insects to synchronize with each other (phase delay and phase advance synchronization, as described below), retaining the essentials of the strategies while downplaying biological detail.


HOW IT WORKS
------------
Each firefly constantly cycles through its own clock, flashing at the beginning of each cycle and then resetting the clock to zero once it has reached the maximum. At the start of each simulation all fireflies begin at a random point in their cycles (though they all have the same cycle lengths) and so flashing will occur erratically through the population. As fireflies perceive other flashes around them they are able to use this information to reset their own clocks to try and synchronize with the other fireflies in their vicinity. Each firefly uses the same set of rules to govern its own clock, and depending on the parameters of the simulation, the population may synchronize more or less effectively.


HOW TO USE IT
--------------
GO: starts and stops the simulation.

SETUP: resets the simulation according to the parameters set by the sliders.

NUMBER: sets the number of fireflies to be created.

CYCLE-LENGTH: sets the length of each firefly's clock before it resets to 0.

NUMBER-FLASHES: sets the number of flashes a firefly must see in a single tick before its clock resets.

FLASH-LENGTH: sets the duration, in ticks, of each flash.

STRATEGY: sets the synchronization strategy to be used. One value is phase delay, where upon seeing NUMBER-FLASHES flashes a firefly will reset its clock to the FLASH-LENGTH tick (just after a flash would normally occur). This causes the firefly to synchronize with the next flash of the firefly it is responding to. The other value is phase advance, where upon seeing NUMBER-FLASHES flashes a firefly will reset its clock to zero. This causes the firefly to flash immediately. Under phase advance, fireflies can only begin to reset their clocks during a window which begins two ticks after they have flashed. This assures that flashes do not get stuck in a short cycle where they persistently reset their clocks and stay lit indefinitely.

SHOW-DARK-FIREFLIES: if switch set to on, non-flashing fireflies are displayed in gray. If switch set to off, non-flashing fireflies are colored black and, thus, invisible.

All settings (except SHOW-DARK-FIREFLIES) must be set before pressing the SETUP button. Changes to the sliders (except SHOW-DARK-FIREFLIES) will have no effect on a simulation in progress.


THINGS TO NOTICE
----------------
Using the default settings (number: 1500, cycle-length: 10, flash-length: 1, number-flashes: 1, strategy: ""delay""), notice how local clusters of synchronization begin to form. See if you can figure out where each cluster is represented on the plot. As the simulation proceeds, try to determine which local cluster will eventually 'take over' the population. Did this cluster originally have the highest spike on the plot?

In phase advance simulations, why do the plots generally top off before the peaks reach the entire population?

In this model fireflies cannot reset their cycle when they are in the middle of a flash. Why was this restriction imposed?


THINGS TO TRY
-------------
Change the strategy chooser between ""delay"" and ""advance"" while keeping the other settings steady (in particular, keep NUMBER-FLASHES at 2). Which strategy seems more effective? Why?

Try adjusting NUMBER-FLASHES between 0, 1 and 2 using both phase delay and phase advance settings. Notice that each setting will give a characteristically different plot, and some of them do not allow for synchronization at all (for example, with the delay strategy, contrast NUMBER-FLASHES set to 1 as opposed to 2). Why does this control make such a difference in the outcome of the simulation?

Changing the number of fireflies in a simulation affects the density of the population (as does adjusting the size of the world). What effect does this have on a simulation?


EXTENDING THE MODEL
-------------------
This model explores only two general strategies for attaining synchrony in such cycle-governed fireflies. Can you find any others? Can you improve the existing strategies (i.e., by speeding them up)?

There are many other possible situations in which distributed agents must synchronize their behavior through the the use of simple rules. What if, instead of perceiving only other discrete flashes, an insect could sense where another insect was in its cycle (perhaps by hearing an increasingly loud hum)? What kinds of strategies for synchronization might be useful in such a situation?

If all fireflies had adjustable cycle-lengths (initially set to random intervals) would it then be possible to coordinate both their cycle-lengths and their flashing?


NETLOGO FEATURES
----------------
Note the use of agentsets to count the number of nearby fireflies that are flashing:
|    count turtles in-radius 1 with [color = yellow]


CREDITS AND REFERENCES
----------------------
Buck, John. (1988). Synchronous Rhythmic Flashing of Fireflies. The Quarterly Review of Biology, September 1988, 265 - 286.

Carlson, A.D. & Copeland, J. (1985). Flash Communication in Fireflies. The Quarterly Review of Biology, December 1985, 415 - 433.

To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Fireflies model.  http://ccl.northwestern.edu/netlogo/models/Fireflies.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Fireflies for terms of use.
"
Tumor,/models/Sample Models/Biology,"turtles-own
[
  stem?     ;; true for stem cells, false for transitory cells
  age  ;; age of cell. changes color with age
  metastatic?  ;; false for progeny of stem cell 0, true for progeny of stem cell 1
]

globals
[
  cell-count
]

to setup
  clear-all
  set-default-shape turtles ""circle 3""
  ask patches
    [ set pcolor gray ]
  set-stem
  evaluate-params
end

to set-stem   ;;create two stem cells
  crt 2
  [
    set size 2   ; easier to see
    setxy (min-pxcor / 2) 0
    set stem? true
    set metastatic? false
    set color blue
    set age 0
  ]
  ask turtle 1
  [
    set metastatic? true
    set heading 90            ;; stem cell 1 will move away
  ]
  set cell-count 2
end

to go
  ask turtles
  [
    ifelse leave-trail?
      [ pd ]
      [ pu ]
    if (who = 1) and (xcor < 25)
    [ fd 1 ]  ;stem cell movement
    set age age + 1
    move-transitional-cells
    mitosis
    death
  ]
  tick
  evaluate-params
end

;;transitional cells move and hatch more. Turtle proc.
to move-transitional-cells
  if (not stem?)
  [
    set color ( red + 0.25 * age )
    fd 1
    if (age < 6)
    [
      hatch 1
      [  ;amplification
        rt random-float 360
        fd 1
      ]
    ]
  ]
end

to mitosis ;; turtle proc. - stem cells only
  if stem?
  [
    hatch 1
    [
      fd 1
      set color red
      set stem? false
      ifelse (who = 1)
        [ set age 16 ]
        [ set age 0 ]
    ]
  ]
end

to death   ;; turtle proc.
  if (not stem?) and (not metastatic?) and (age > 20)
    [ die ]
  if (not stem?) and metastatic? and (age > 4)
    [ die ]
end

to evaluate-params
  set cell-count count turtles  ;cell count
  if (cell-count <= 0)
    [ stop ]
  set-current-plot ""Living Cells""
  plot cell-count
end

to kill-original-stem-cell
  ask turtle 0
    [ die ]
end

to kill-moving-stem-cell
  ask turtle 1
    [ die ]
end

to kill-transitory-cells
  ask turtles with [ age < 10 and not stem? ]
    [ die ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Tumor model.
; http://ccl.northwestern.edu/netlogo/models/Tumor.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Tumor
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model illustrates the growth of a tumor and how it resists chemical treatment.  A tumor consists of two kinds of cells: stem cells (blue turtles) and transitory cells (all other turtles).

During mitosis, a stem cell can divide either asymmetrically or symmetrically. In asymmetric mitosis, one of the two daughter cells remains a stem cell, replacing its parent. So a stem cell effectively never dies - it is quasi reincarnated after each division. The other daughter cell turns into a transitory cell that moves outward.

Young transitory cells may divide, breeding other transitory cells.  The transitory cells stop dividing at a certain age and change color from red to white to black, eventually dying.

A stem cell may also divide symmetrically into two stem cells (blue turtles). In this example the original stem cell divides symmetrically only once. The first stem cell remains static, but the second stem cell moves to the right. This activity, in which the cell advances into distant sites and creates another tumor colony, is called metastasis. Notice that the metastasis is red. It is made of cells that die young, when they are still red, rather than ending as black dots as in the static tumor. As the disease progresses, cells die younger and younger.

The original StarLogoT Tumor model was contributed by Gershom Zajicek M.D., Professor of Experimental Medicine and Cancer Research at The Hebrew University-Hadassah Medical School, Jerusalem.


HOW TO USE IT
--------------
SETUP: Clears the world and creates two blue neoplastic (cancerous) stem cells.  One cell stays put and the other moves to the right.
GO: Runs the simulation.
KILL TRANSITORY CELLS: Kills transitory cells that are younger than 10 time steps.
KILL STEM CELL:  Kills a stem cell. If the adjacent KILL-MOVING-CELL switch is set to OFF, the original is eliminated. If the switch is set to ON, the moving stem cell is eliminated.
KILL-MOVING-CELL: Determines which stem cell is killed when the KILL STEM CELL button is pressed.
LEAVE-TRAIL: If it's ON, the cells trace their paths; if it's OFF, they do not.
CELL-COUNT: Displays the total number of living cells.
LIVING CELLS PLOT: plots the number of living cells.


THINGS TO NOTICE
----------------
First, notice the blue dot. It represents a normal stem cell that has been transformed into a tumor stem cell.  Set the ""leave-trail"" switch to On, and click 'go'.  A tumor is formed as the stem cell creates transitory cells, which reproduce themselves.  It grows to a certain size.  As it grows, a bulge appears on the right side.  This is a tumor outgrowth, caused by symmetric mitosis of the stem cell. The outgrowth will turn into a metastasis and grow into remote regions.

After a while the tumor and metastasis appear to reach their ultimate size and nothing interesting seems to be happening. This illustrates how the tumor presents itself to the physician - as a solid cell mass. In reality, this seemingly solid mass conceals active cell turnover. To reveal it, set the leave-trail switch to Off, click on SETUP, and then click on GO to run the simulation again.

Slow down the model so you can follow individual steps.  Move the speed slider to the left, click on SETUP and GO, and observe the blue stem cell.  It divides into two blue stem cells.  One remains static, and the other moves to the right.

Look at the static stem cell (blue).  It breeds red cells which move outward and change their color as they age. When young, they are red and create more transitory cells. Then they turn white, then black, and then they die.


THINGS TO TRY
-------------
Try a treatment: click on the 'kill transitory cells' button while the model is running. This simulates treatment with a chemical agent.  The agent eliminates young (red) cells that divide, and it spares older cells.  Note that the tumor shrinks and grows again.  Continue with this ""chemotherapy"" by clicking on the button again and watch the plot.  Repeat the treatment several times until you have understood why it fails.

Most of the chemotherapy drugs known as M- and S-poisons inhibit cell division, but generally do not cause cell death. Thus chemotherapy can be represented as killing the young (red) transitory cells, since only young cells divide. Older, non-dividing transitory cells are not affected; they continue aging and finally pass away.

The problem is that the stem cells maintain the tumor and propagate its metastases. Also known as clonogenic cells, stem cells are generally resistant to chemotherapy. They can be eliminated only with high doses of chemicals, which endanger healthy stem cells. The therapeutic margin of chemical drugs is extremely narrow. That is, they do about the same amount of harm as good.

Let the tumor grow again.  Click on 'kill moving stem cell' and continue running the model.  The right blue stem cell disappears. Its progeny live a bit longer and then die. Now click on ""kill original stem cell"", and watch the gradual disappearance of the tumor, as no new cells are created and existing cells continue aging until they die and disappear.

Any questions? Before asking, continue exploring the model until you grasp its behavior.  The model reveals a hidden dimension that is difficult to understand. It is the time dimension of tissues (and the tumor) in the body.


EXTENDING THE MODEL
-------------------
What alternative treatments would you suggest?  How would you model them here?


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Tumor model.  http://ccl.northwestern.edu/netlogo/models/Tumor.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Tumor for terms of use.
"
Virus,/models/Sample Models/Biology,"turtles-own
  [ sick?        ;; if true, the turtle is infectious
    immune?      ;; if true, the turtle can't be infected
    sick-count   ;; how long the turtle has been infectious
    age ]        ;; how many weeks old the turtle is

globals
[
  %infected            ;; what % of the population is infectious
  %immune              ;; what % of the population is immune
  lifespan             ;; the average lifespan of a turtle
  average-offspring    ;; the average number of offspring a turtle could have
  carrying-capacity    ;; the number of turtles that can be in the world at one time
]

;; The setup is divided into three subroutines
to setup
  ca
  setup-constants
  setup-turtles
  update-plot
  update-global-variables
end

;; We create a variable number of turtles of which 10 are infectious,
;; and distribute them randomly
to setup-turtles
  set-default-shape turtles ""person""
  crt people
    [ setxy random-xcor random-ycor
      set age random lifespan
      set sick-count 0
      set immune? false
      set size 1.5  ;; easier to see
      ifelse (who < 10)
        [ get-sick ]
        [ get-healthy ] ]
end

to get-sick ;; turtle procedure
  set sick? true
  set immune? false
  set color red
end

to get-healthy ;; turtle procedure
  set sick? false
  set immune? false
  set sick-count 0
  set color green
end

to become-immune ;; turtle procedure
  set sick? false
  set sick-count 0
  set immune? true
  set color gray
end

to setup-constants
  set lifespan 100
  set carrying-capacity 750
  set average-offspring 4
end

to go
  get-older
  move
  infect
  recover
  reproduce
  update-global-variables
  tick
  update-plot
end

to update-global-variables
  if count turtles > 0
  [
    set %infected (count turtles with [sick?]) / (count turtles) * 100
    set %immune (count turtles with [immune?]) / (count turtles) * 100
  ]
end

;;Turtle counting variables are advanced.
to get-older
  ask turtles
  [
    set age age + 1
    if sick?
      [ set sick-count (sick-count + 1) ]
    ;; Turtles die of old age once their age equals the
    ;; lifespan (set at 1500 in this model).
    if age > lifespan
      [ die ]
  ]
end

;;Turtles move about at random.
to move
  ask turtles
  [ rt random-float 100 - random-float 100
    fd 1 ]
end

;; If a turtle is sick, it infects other turtles on the same patch.
;; Immune turtles don't get sick.
to infect
  ask turtles with [sick?]
    [ ask other turtles-here with [ not immune? ]
        [ if (random-float 100) < infectiousness
            [ get-sick ] ] ]
end

;; Once the turtle has been sick long enough, it
;; either recovers (and becomes immune) or it dies.
to recover
   ask turtles with [sick?]
     [ if (random sick-count) > (lifespan * (duration / 100))  ;; If the turtle has survived past the virus' duration, then
         [ ifelse ((random-float 100) < chance-recover)        ;; either recover or die
             [ become-immune ]
             [ die ] ] ]
end

;; If there are less turtles than the carrying-capacity
;;  then turtles can reproduce.
;; The probability of reproduction depends on average number
;;  of offspring per life.  In this model it is 4 per life (e.g.
;;  4 per 100 weeks.  The chance, therefore, for a turtle to
;;  reproduce at any given turn is 0.04 (if the population
;;  is below carrying-capacity).
to reproduce
  ask turtles with [not sick?]
    [ if (count turtles) < carrying-capacity
         and (random lifespan) < average-offspring
       [ hatch 1
           [ set age 1
             lt 45 fd 1
             get-healthy ] ] ]
end

to update-plot
  set-current-plot ""Populations""
  set-current-plot-pen ""sick""
  plot count turtles with [sick?]
  set-current-plot-pen ""immune""
  plot count turtles with [immune?]
  set-current-plot-pen ""healthy""
  plot count turtles with [not sick? and not immune?]
  set-current-plot-pen ""total""
  plot count turtles
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Virus model.
; http://ccl.northwestern.edu/netlogo/models/Virus.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Virus
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model simulates the transmission and perpetuation of a virus in a human population.  Ecological biologists have suggested a number of factors which may influence the survival of a directly transmitted virus within a population. (Yorke, et al. ""Seasonality and the requirements for perpetuation and eradication of viruses in populations."" Journal of Epidemiology, volume 109, pages 103-123)

The model is initialized with 150 people, of which 10 are infected.  People move randomly about the world in one of three states: healthy but susceptible to infection (green), sick and infectious (red), and healthy and immune (gray). People may die of infection or old age.  When the population dips below the environment's ""carrying capacity"" (set at 700 in this model) healthy people may reproduce healthy and susceptible offspring.

Some of these factors are summarized below with an explanation of how each one is treated in this model.

The density of the population
-----------------------------
Population density affects how often infected, immune and susceptible individuals come into contact with each other. You can change the size of the initial population through the PEOPLE slider.

Population turnover
-------------------
As individuals die, some who die will be infected, some will be susceptible and some will be immune.  All the new individuals who are born, replacing those who die, will be susceptible.  People may die from the virus, the chances of which are determined by the slider CHANCE-RECOVER, or they may die of old age.  In this model, people die of old age at the age of approximately 27 years.  Reproduction rate is constant in this model.  Each turn, every healthy individual has a chance to reproduce.  That chance is set so that each person will on average reproduce four times if they live 27 years.

Degree of immunity
------------------
If a person has been infected and recovered, how immune are they to the virus?  We often assume that immunity lasts a lifetime and is assured, but in some cases immunity wears off in time and immunity might not be absolutely secure.  Nonetheless, in this model, immunity does last forever and is secure.

Infectiousness (or transmissibility)
------------------------------------
How easily does the virus spread?  Some viruses with which we are familiar spread very easily.  Some viruses spread from the smallest contact every time.  Others (the HIV virus, which is responsible for AIDS, for example) require significant contact, perhaps many times, before the virus is transmitted.  In this model, infectiousness is determined by a slider.

Duration of infectiousness
--------------------------
How long is a person infected before they either recover or die?  This length of time is essentially the virus's window of opportunity for transmission to new hosts. In this model, duration of infectiousness is determined by a slider.


HOW TO USE IT
-------------
Each ""tick"" represents a week in the time scale of this model.

The INFECTIOUSNESS slider determines how great the chance is that virus transmission will occur when an infected person and susceptible person occupy the same patch.  For instance, when the slider is set to 50, the virus will spread roughly once every two chance encounters.

The DURATION slider determines the percent of the average life-span (which is 1500 weeks, or approximately 27 years, in this model) that an infected person goes through before the infection ends in either death or recovery.  Note that although zero is a slider possibility, it produces an infection of very short duration (approximately 2 weeks) not an infection with no duration at all.

The CHANCE-RECOVERY slider controls the likelihood that an infection will end in recovery/immunity.  When this slider is set at zero, for instance, the infection is always deadly.

The SETUP button resets the graphics and plots and randomly distributes 140 green susceptible people and 10 red infected people (of randomly distributed ages).  The GO button starts the simulation and the plotting function.

Three output monitors show the percent of the population that is infected, the percent that is immune, and the number of years that have passed.  The plot shows (in their respective colors) the number of susceptible, infected, and immune people.  It also shows the number of individuals in the total population in blue.


THINGS TO NOTICE
--------------------
The factors controlled by the three sliders interact to influence how likely the virus is to thrive in this population.  Notice that in all cases, these factors must create a balance in which an adequate number of potential hosts remain available to the virus and in which the virus can adequately access those hosts.

Often there will initially be an explosion of infection since no one in the population is immune and the population density is at its maximum.  This approximates the initial ""outbreak"" of a viral infection in a population, one that often has devastating consequences for the humans concerned. Soon, however, the virus becomes less common as the population dynamics change.  What ultimately happens to the virus is determined by the factors controlled the sliders.

Notice that viruses that are too successful at first (infecting almost everyone) may not survive in the long term.  Since everyone infected generally dies or becomes immune as a result, the potential number of hosts is often limited.  The exception to the above is when the DURATION slider is set so high that population turnover (reproduction) can keep up and provide new hosts.


THINGS TO TRY
-------------
Think about how different slider values might approximate the dynamics of real-life viruses.  The famous Ebola virus in central Africa has a very short duration, a very high infectiousness value, and an extremely low recovery rate. For all the fear this virus has raised, how successful is it?  Set the sliders appropriately and watch what happens.

The HIV virus which causes AIDS, has an extremely long duration, an extremely low recovery rate, but an extremely low infectiousness value.  How does a virus with these slider values fare in this model?


EXTENDING THE MODEL
-------------------
Add additional sliders controlling the carrying capacity of the world (how many people can be in the world at one time) and the average lifespan of the people.

Build a similar model simulating viral infection of a non-human host with very different reproductive rates, lifespans, and population densities.

Add a slider controlling how long immunity lasts so that immunity is not perfect or eternal.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Virus model.  http://ccl.northwestern.edu/netlogo/models/Virus.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Virus for terms of use.
"
Heatbugs,/models/Sample Models/Biology,"globals [ color-by-unhappiness? ]

turtles-own
[
  ideal-temp       ;; The temperature I want to be at
  output-heat      ;; How much heat I emit per time step
  unhappiness      ;; The magnitude of the difference between my ideal
                   ;;   temperature and the actual current temperature here
]

patches-own
[
  temp             ;; short for ""temperature""
]

to setup
  clear-all
  set color-by-unhappiness? false

  ;; creating the bugs the following way ensures that we won't
  ;; wind up with more than one bug on a patch
  ask n-of bug-count patches [
    sprout 1 [
      set ideal-temp  min-ideal-temp  + random (max-ideal-temp  - min-ideal-temp)
      set output-heat min-output-heat + random (max-output-heat - min-output-heat)
      set unhappiness abs (ideal-temp - temp)
      color-by-ideal-temp
      face one-of neighbors
      set size 2  ;; easier to see
    ]
  ]
  ;; plot the initial state of the system
  update-plot
end

to color-by-ideal-temp
  ;; when scaling the color of turtles, adjust the value
  ;; range by this amount to avoid turtles being too dark or too light.
  let range-adjustment ( max-ideal-temp - min-ideal-temp ) / 2
  set color scale-color lime ideal-temp ( min-ideal-temp - range-adjustment )
                                        ( max-ideal-temp + range-adjustment )
end

to color-by-unhappiness [ max-unhappiness ]
  set color scale-color blue unhappiness  max-unhappiness 0
end

to go
  if not any? turtles [ stop ]
  ;; diffuse heat through world
  diffuse temp diffusion-rate
  ;; The world retains a percentage of its heat each cycle.
  ;; (The Swarm and Repast versions have 1.0 meaning no
  ;; evaporation and 0.0 meaning complete evaporation;
  ;; we reverse the scale to better match the name.)
  ask patches [ set temp temp * (1 - evaporation-rate) ]
  ;; agentsets in NetLogo are always in random order, so
  ;; ""ask turtles"" automatically shuffles the order of execution
  ;; each time.
  ask turtles [ step ]
  recolor-turtles
  recolor-patches
  tick
  update-plot
end

to recolor-turtles
  if color-by-unhappiness?
  [
    let max-unhappiness max [unhappiness] of turtles
    ask turtles [ color-by-unhappiness max-unhappiness ]
  ]
end

to recolor-patches
  ;; hotter patches will be red verging on white;
  ;; cooler patches will be black
  ask patches [ set pcolor scale-color red temp 0 150 ]
end

to step  ;; turtle procedure
  ;; my unhappiness is the magnitude or absolute value of the difference
  ;; between by ideal temperature and the temperature of this patch
  set unhappiness abs (ideal-temp - temp)
  ;; if unhappy and not at the hottest neighbor,
  ;; then move to an open neighbor
  if unhappiness > 0
    [ ifelse random-float 100 < random-move-chance
        [ bug-move one-of neighbors ]
        [ bug-move best-patch ] ]
  set temp temp + output-heat
end

;; find the hottest or coolest location next to me; also
;; take my current patch into consideration
to-report best-patch  ;; turtle procedure
  ifelse temp < ideal-temp
    [ let winner max-one-of neighbors [temp]
      ifelse [temp] of winner > temp
        [ report winner ]
        [ report patch-here ] ]
    [ let winner min-one-of neighbors [temp]
      ifelse [temp] of winner < temp
        [ report winner ]
        [ report patch-here ] ]
end

to bug-move [target]  ;; turtle procedure
  ;; if we're already there, there's nothing to do
  if target = patch-here [ stop ]
  ;; move to the target patch (if it is not already occupied)
  if not any? turtles-on target [
    face target
    move-to target
    stop
  ]
  set target one-of neighbors with [not any? turtles-here]
  if target != nobody [ move-to target ]
  ;; The code above is a bit different from the original Heatbugs
  ;; model in Swarm.  In the NetLogo version, the bug will always
  ;; find an empty patch if one is available.
  ;; In the Swarm version, the bug picks a random
  ;; nearby patch, checks to see if it is occupied, and if it is,
  ;; picks again.  If after 10 tries it hasn't found an empty
  ;; patch, it gives up and stays where it is.  Since each try
  ;; is random and independent, even if there is an available
  ;; empty patch the bug will not always find it.  Presumably
  ;; the Swarm version is coded that way because there is no
  ;; concise equivalent in Swarm/Objective C to NetLogo's
  ;; 'one-of neighbors with [not any? turtles-here]'.
  ;; If you want to match the Swarm version exactly, remove the
  ;; last two lines of code above and replace them with this:
  ; let tries 0
  ; while [tries <= 9]
  ;   [ set tries tries + 1
  ;     set target one-of neighbors
  ;     if not any? turtles-on target [
  ;       move-to target
  ;       stop
  ;     ]
  ;   ]
end

to update-plot
  plot mean [unhappiness] of turtles
end

;;; the following procedures support the two extra buttons
;;; in the interface

;; remove all heat from the world
to deep-freeze
  ask patches [ set temp 0 ]
end

;; add max-output-heat to all locations in the world, heating it evenly
to heat-up
  ask patches [ set temp temp + max-output-heat ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2004 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2004).  NetLogo Heatbugs model.
; http://ccl.northwestern.edu/netlogo/models/Heatbugs.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2004 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Heatbugs
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
Heatbugs is an abstract model of the behavior of biologically-inspired agents that attempt to maintain an optimum temperature around themselves.  It demonstrates how simple rules defining the behavior of agents can produce several different kinds of emergent behavior.

Heatbugs has been used as a demonstration model for many agent-based modeling toolkits. We provide a NetLogo version to assist users in learning and comparing different toolkits.  It demonstrates coding techniques in NetLogo and may be useful as a starting point for building other models.

While this NetLogo model attempts to match the Repast and Swarm versions (see ""Credits"" below), we haven't done a rigorous comparative analysis of the different versions, so it is possible that there are small inadvertent differences in the underlying rules and behavior.


HOW IT WORKS
------------
The bugs move around on a grid of square ""patches"".  A bug may not move to a patch that already has another bug on it.

Each bug radiates a small amount of heat.  Heat gradually diffuses through the world; some heat is lost to cooling.

Each bug has an ""ideal"" temperature it wants to be.  The bigger the difference between the temperature of the patch where the bug is and the bug's ideal temperature, the more ""unhappy"" the bug is.  When a bug is unhappy, it moves.  If it is too hot, it moves to the coolest adjacent empty patch.  Conversely, if a bug is too cold, it moves to the warmest adjacent empty patch.  (Note that these bugs aren't smart enough to always move to the best available patch.)


HOW TO USE IT
-------------
After choosing the number of bugs to create, and setting the model variables, press the GO button to set the heatbugs into motion.

BUG-COUNT: The number of bugs that will inhabit the model

EVAPORATION-RATE: The percentage of the world's heat that evaporates each cycle.  A lower number means a world which cools slowly, a higher number is a world which cools quickly.

DIFFUSION-RATE: How much heat a patch (a spot in the world) diffuses to its neighbors.  A higher number means that heat diffuses through the world quickly.  A lower number means that patches retain more of their heat.

MIN/MAX-IDEAL-TEMP: The minimum and maximum ideal temperatures for heatbugs.  Each bug is given an ideal temperature between the min and max ideal temperature.

MIN/MAX-OUTPUT-HEAT: The minimum and maximum heat that heatbugs generate each cycle.  Each bug is given a output-heat value between the min and max output heat.

RANDOM-MOVE-CHANCE: The chance that a bug will make a random move even if it would prefer to stay where it is (because no more ideal patch is available).

DEEP-FREEZE: This button removes all heat from the world.

HEAT-UP: This button adds MAX-OUTPUT-HEAT to every patch in the world.

Beneath the View Window are two ""Color By:"" buttons.  The IDEAL-TEMP button colors the bugs according to their IDEAL-TEMP value.  Bugs with higher IDEAL-TEMP values will be brighter.  The HAPPINESS button does the same, but is based upon the HAPPINESS value of each agent, with happier bugs being brighter.

The WATCH-HAPPIEST and WATCH-SADDEST buttons will highlight the happiest or saddest bug at the time the button is pressed.


THINGS TO NOTICE
----------------
Depending on their ideal temperatures, some bugs will tend to clump together, while others will tend to avoid all other bugs, and others still flutter around the edges of clumps.  All of these behaviors are affected as well by the evaporation rate.

The diffusion rate affects the cohesiveness of clumps.  If diffusion-rate is slow, many tiny clumps form.  Why?

Most interesting behaviors occur when the number of bugs, how much heat they generate, and how quickly the world cools are balanced such that excessive heat does not build up.


THINGS TO TRY
-------------
Vary DIFFUSION-RATE.

Vary EVAPORATION-RATE in relation to the output-heat range of the bugs.

Use the HEAT-UP button to scramble clumped heatbugs and watch as they re-assemble into new clumps.


EXTENDING THE MODEL
-------------------
Randomize the amount of heat bugs generate each cycle.

Allow users to introduce heat into the system with the mouse.


NETLOGO FEATURES
----------------
N-OF and SPROUT together let us initially place each bug on its own patch with a minimum of code.

Notice how the code does not make any use of X and Y coordinates.  The NEIGHBORS and MOVE-TO primitives take care of sensing and motion on a toroidal grid without the need for any explicit coordinate math.

The DIFFUSE command is used to diffuse the heat around the patch grid.


RELATED MODELS
--------------
Slime


CREDITS AND REFERENCES
----------------------
Swarm version of Heatbugs -- http://www.swarm.org/wiki/Examples_of_Swarm_applications
RePast version of Heatbugs -- http://repast.sourceforge.net/examples/index.html

To refer to this model in academic publications, please use:  Wilensky, U. (2004).  NetLogo Heatbugs model.  http://ccl.northwestern.edu/netlogo/models/Heatbugs.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2004 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Heatbugs for terms of use.
"
Wolf Sheep Predation,/models/Sample Models/Biology,";; Sheep and wolves are both breeds of turtle.
breed [sheep a-sheep]  ;; sheep is its own plural, so we use ""a-sheep"" as the singular.
breed [wolves wolf]
turtles-own [energy]       ;; both wolves and sheep have energy
patches-own [countdown]

to setup
  clear-all
  ask patches [ set pcolor green ]
  ;; check GRASS? switch.
  ;; if it is true, then grass grows and the sheep eat it
  ;; if it false, then the sheep don't need to eat
  if grass? [
    ask patches [
      set countdown random grass-regrowth-time ;; initialize grass grow clocks randomly
      set pcolor one-of [green brown]
    ]
  ]
  set-default-shape sheep ""sheep""
  create-sheep initial-number-sheep  ;; create the sheep, then initialize their variables
  [
    set color white
    set size 1.5  ;; easier to see
    set label-color blue - 2
    set energy random (2 * sheep-gain-from-food)
    setxy random-xcor random-ycor
  ]
  set-default-shape wolves ""wolf""
  create-wolves initial-number-wolves  ;; create the wolves, then initialize their variables
  [
    set color black
    set size 1.5  ;; easier to see
    set energy random (2 * wolf-gain-from-food)
    setxy random-xcor random-ycor
  ]
  display-labels
  update-plot
end

to go
  if not any? turtles [ stop ]
  ask sheep [
    move
    if grass? [
      set energy energy - 1  ;; deduct energy for sheep only if grass? switch is on
      eat-grass
    ]
    reproduce-sheep
    death
  ]
  ask wolves [
    move
    set energy energy - 1  ;; wolves lose energy as they move
    catch-sheep
    reproduce-wolves
    death
  ]
  if grass? [ ask patches [ grow-grass ] ]
  tick
  update-plot
  display-labels
end

to move  ;; turtle procedure
  rt random 50
  lt random 50
  fd 1
end

to eat-grass  ;; sheep procedure
  ;; sheep eat grass, turn the patch brown
  if pcolor = green [
    set pcolor brown
    set energy energy + sheep-gain-from-food  ;; sheep gain energy by eating
  ]
end

to reproduce-sheep  ;; sheep procedure
  if random-float 100 < sheep-reproduce [  ;; throw ""dice"" to see if you will reproduce
    set energy (energy / 2)                ;; divide energy between parent and offspring
    hatch 1 [ rt random-float 360 fd 1 ]   ;; hatch an offspring and move it forward 1 step
  ]
end

to reproduce-wolves  ;; wolf procedure
  if random-float 100 < wolf-reproduce [  ;; throw ""dice"" to see if you will reproduce
    set energy (energy / 2)               ;; divide energy between parent and offspring
    hatch 1 [ rt random-float 360 fd 1 ]  ;; hatch an offspring and move it forward 1 step
  ]
end

to catch-sheep  ;; wolf procedure
  let prey one-of sheep-here                    ;; grab a random sheep
  if prey != nobody                             ;; did we get one?  if so,
    [ ask prey [ die ]                          ;; kill it
      set energy energy + wolf-gain-from-food ] ;; get energy from eating
end

to death  ;; turtle procedure
  ;; when energy dips below zero, die
  if energy < 0 [ die ]
end

to grow-grass  ;; patch procedure
  ;; countdown on brown patches: if reach 0, grow some grass
  if pcolor = brown [
    ifelse countdown <= 0
      [ set pcolor green
        set countdown grass-regrowth-time ]
      [ set countdown countdown - 1 ]
  ]
end

to update-plot
  set-current-plot ""populations""
  set-current-plot-pen ""sheep""
  plot count sheep
  set-current-plot-pen ""wolves""
  plot count wolves
  if grass? [
    set-current-plot-pen ""grass / 4""
    plot count patches with [pcolor = green] / 4  ;; divide by four to keep it within similar
                                                  ;; range as wolf and sheep populations
  ]
end

to display-labels
  ask turtles [ set label """" ]
  if show-energy? [
    ask wolves [ set label round energy ]
    if grass? [ ask sheep [ set label round energy ] ]
  ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2000.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Wolf Sheep Predation model.
; http://ccl.northwestern.edu/netlogo/models/WolfSheepPredation.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/WolfSheepPredation
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model explores the stability of predator-prey ecosystems. Such a system is called unstable if it tends to result in extinction for one or more species involved.  In contrast, a system is stable if it tends to maintain itself over time, despite fluctuations in population sizes.


HOW IT WORKS
------------
There are two main variations to this model.

In the first variation, wolves and sheep wander randomly around the landscape, while the wolves look for sheep to prey on. Each step costs the wolves energy, and they must eat sheep in order to replenish their energy - when they run out of energy they die. To allow the population to continue, each wolf or sheep has a fixed probability of reproducing at each time step. This variation produces interesting population dynamics, but is ultimately unstable.

The second variation includes grass (green) in addition to wolves and sheep. The behavior of the wolves is identical to the first variation, however this time the sheep must eat grass in order to maintain their energy - when they run out of energy they die. Once grass is eaten it will only regrow after a fixed amount of time. This variation is more complex than the first, but it is generally stable.

The construction of this model is described in two papers by Wilensky & Reisman referenced below.


HOW TO USE IT
-------------
1. Set the GRASS? switch to TRUE to include grass in the model, or to FALSE to only include wolves (red) and sheep (white).
2. Adjust the slider parameters (see below), or use the default settings.
3. Press the SETUP button.
4. Press the GO button to begin the simulation.
5. Look at the monitors to see the current population sizes
6. Look at the POPULATIONS plot to watch the populations fluctuate over time

Parameters:
INITIAL-NUMBER-SHEEP: The initial size of sheep population
INITIAL-NUMBER-WOLVES: The initial size of wolf population
SHEEP-GAIN-FROM-FOOD: The amount of energy sheep get for every grass patch eaten
WOLF-GAIN-FROM-FOOD: The amount of energy wolves get for every sheep eaten
SHEEP-REPRODUCE: The probability of a sheep reproducing at each time step
WOLF-REPRODUCE: The probability of a wolf reproducing at each time step
GRASS?: Whether or not to include grass in the model
GRASS-REGROWTH-TIME: How long it takes for grass to regrow once it is eaten
SHOW-ENERGY?: Whether or not to show the energy of each animal as a number

Notes:
- one unit of energy is deducted for every step a wolf takes
- when grass is included, one unit of energy is deducted for every step a sheep takes


THINGS TO NOTICE
----------------
When grass is not included, watch as the sheep and wolf populations fluctuate. Notice that increases and decreases in the sizes of each population are related. In what way are they related? What eventually happens?

Once grass is added, notice the green line added to the population plot representing fluctuations in the amount of grass. How do the sizes of the three populations appear to relate now? What is the explanation for this?

Why do you suppose that some variations of the model might be stable while others are not?


THINGS TO TRY
-------------
Try adjusting the parameters under various settings. How sensitive is the stability of the model to the particular parameters?

Can you find any parameters that generate a stable ecosystem that includes only wolves and sheep?

Try setting GRASS? to TRUE, but setting INITIAL-NUMBER-WOLVES to 0. This gives a stable ecosystem with only sheep and grass. Why might this be stable while the variation with only sheep and wolves is not?

Notice that under stable settings, the populations tend to fluctuate at a predictable pace. Can you find any parameters that will speed this up or slow it down?

Try changing the reproduction rules -- for example, what would happen if reproduction depended on energy rather than being determined by a fixed probability?


EXTENDING THE MODEL
-------------------
There are a number ways to alter the model so that it will be stable with only wolves and sheep (no grass). Some will require new elements to be coded in or existing behaviors to be changed. Can you develop such a version?


NETLOGO FEATURES
----------------
Note the use of breeds to model two different kinds of ""turtles"": wolves and sheep. Note the use of patches to model grass.

Note use of the ONE-OF agentset reporter to select a random sheep to be eaten by a wolf.


RELATED MODELS
---------------
Look at Rabbits Grass Weeds for another model of interacting populations with different rules.


CREDITS AND REFERENCES
----------------------
Wilensky, U. & Reisman, K. (1999). Connected Science: Learning Biology through Constructing and Testing Computational Theories -- an Embodied Modeling Approach. International Journal of Complex Systems, M. 234, pp. 1 - 12. (This model is a slightly extended version of the model described in the paper.)

Wilensky, U. & Reisman, K. (in press). Thinking like a Wolf, a Sheep or a Firefly: Learning Biology through Constructing and Testing Computational Theories -- an Embodied Modeling Approach. Cognition & Instruction.

To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Wolf Sheep Predation model.  http://ccl.northwestern.edu/netlogo/models/WolfSheepPredation.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/WolfSheepPredation for terms of use.
"
Sunflower,/models/Sample Models/Biology,";; setup is called once at the beginning of each run
;; it clears the world and resets the tick counter
to setup
  clear-all
end

;; hatch a new turtle and set its color and direction.
;; then each turtle moves forward by step-size, increases
;; its size and if it is on the edge of the view, dies.
to go
  crt 1
  [
    set color 10 * (ticks mod num-colors) + 15
    set size 0.6 * sqrt distancexy 0 0
    set heading ticks * turn-increment * 360
  ]
  ask turtles
  [
    fd step-size
    set size 0.6 * sqrt distancexy 0 0
    if distancexy 0 0 > max-pxcor
      [ die ]
  ]
  tick
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2003 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2003).  NetLogo Sunflower model.
; http://ccl.northwestern.edu/netlogo/models/Sunflower.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2003 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Sunflower
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
The interlocking spirals found in the seeds, petals and even branches of many plants occur naturally through the growth of the flower.  This model attempts to demonstrate the growth of these naturally occurring spirals.

When a new seed emerges, the older ones grow slightly and move further from the center--the source--and the youngest seed finds the largest gap between existing seeds, in which it can grow.  This gap can be found by turning counter clockwise.  The angle made by this turn is a multiple of the golden ratio (1.618).  The golden ratio, based on the Fibonacci series (1, 1, 2, 3, 5, 8, 13...), equals the limit of F(n)/F(n-1).  Thus, these spirals can be mathematically generated, using the golden ratio.


HOW IT WORKS
------------
For each clock-tick, a new turtle (can be seen as a seed or a petal) is created.  As in nature, the turtle finds the appropriate position and begins growing.  The 'appropriate position' is defined as the number of clock-ticks times the 'turn increment'.  All of the other existing turtles move forward and grow slightly, with each clock-tick.  If a turtle gets too close to the edge of the world, it dies.


HOW TO USE IT
-------------
The NUM-COLORS slider controls how many colors the turtles can be.  (Using this will make some of the spirals stand out more, other stand out less.)

The STEP-SIZE slider controls how far away the turtle moves from the center, for each clock-tick.

The TURN-INCREMENT slider dictates the degree that each new turtle will turn to set its position in the spiral.

The SET TURN-INCREMENT buttons help to set the TURN-INCREMENT slider to specific values at and around the golden ratio.  They are simply there to help achieve precision that can be difficult with the slider.


THINGS TO NOTICE
----------------
Think about the spirals that you see.  How many different ways can you make a pattern of spirals?


THINGS TO TRY
-------------
How does adding colors change the spirals you see?  Does this change the phenomena, or only what you see?


EXTENDING THE MODEL
-------------------
Make the spirals go counter-clockwise.

Make the model draw your favorite flower's petal or seed pattern.  For example, a buttercup or columbine could be made by creating 5 large petals of the appropriate colors.

In nature, real plants don't have the golden ratio ""programmed"" into them.  Rather, the spirals form as the result of an emergent process, described in Conway and Guy's book (see below) and other sources.  Can you extend this model to capture this emergent process?


NETLOGO FEATURES
----------------
Note in the code that the turtles ""die"" when they get too far from the center of the world so they make a circular pattern.


CREDITS AND REFERENCES
----------------------
This is based on pp. 113-24 of John H. Conway and Richard K. Guy's ""The Book of Numbers"".

To refer to this model in academic publications, please use:  Wilensky, U. (2003).  NetLogo Sunflower model.  http://ccl.northwestern.edu/netlogo/models/Sunflower.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2003 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Sunflower for terms of use.
"
Simple Birth Rates,/models/Sample Models/Biology,"globals
[
  red-count            ; population of red turtles
  blue-count           ; population of blue turtles
]

turtles-own
[
  fertility            ; the whole number part of fertility
  fertility-remainder  ; the fractional part (after the decimal point)
]

to setup
  clear-output
  setup-experiment
end

to setup-experiment
  cp ct
  clear-all-plots
  reset-ticks
  crt carrying-capacity
  [
    setxy random-xcor random-ycor         ; randomize turtle locations
    ifelse who < (carrying-capacity / 2)  ; start out with equal numbers of reds and blues
      [ set color blue ]
      [ set color red ]
    set size 2                            ; easier to see
  ]
  setup-plot
  plot-counts
end

to go
  wander
  reproduce
  grim-reaper
  tick
  plot-counts
end

;; to enable many repetitions with same settings
to go-experiment
  go
  if red-count = 0
  [
    output-print (word ""red extinct after "" ticks "" generations"")
    setup-experiment
  ]
  if blue-count = 0
  [
    output-print (word ""blue extinct after "" ticks "" generations"")
    setup-experiment
  ]
end

to wander
  ask turtles
  [
    rt random-float 30 - random-float 30
    fd 5
  ]
end

to reproduce
  ask turtles
  [
    ifelse color = red
    [
      set fertility floor red-fertility
      set fertility-remainder red-fertility - (floor red-fertility)
    ]
    [
      set fertility floor blue-fertility
      set fertility-remainder blue-fertility - (floor blue-fertility)
    ]
    ifelse (random-float 100) < (100 * fertility-remainder)
      [ hatch fertility + 1 ]
      [ hatch fertility     ]
  ]
end

;; kill turtles in excess of carrying capacity
;; note that reds and blues have equal probability of dying
to grim-reaper
  let num-turtles count turtles
  if num-turtles <= carrying-capacity
    [ stop ]
  let chance-to-die (num-turtles - carrying-capacity) / num-turtles
  ask turtles
  [
    if random-float 1.0 < chance-to-die
      [ die ]
  ]
end

to plot-counts
  set-current-plot ""Populations""

  set red-count count turtles with [ color = red ]
  set-current-plot-pen ""Reds""
  plot red-count

  set blue-count count turtles with [ color = blue ]
  set-current-plot-pen ""Blues""
  plot blue-count

  set-current-plot-pen ""Total""
  plot count turtles
end


to setup-plot
  set-current-plot ""Populations""
  set-plot-y-range 0 floor (carrying-capacity * 1.2)
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Simple Birth Rates model.
; http://ccl.northwestern.edu/netlogo/models/SimpleBirthRates.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/SimpleBirthRates
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This is a simple model of population genetics.  There are two populations, the REDS and the BLUES. Each has settable birth rates.  The reds and blues move around and reproduce according to their birth rates.  When the carrying capacity of the terrain is exceeded, some agents die (each agent has the same chance of being selected for death) to maintain a relatively constant population.  The model allows you to explore how differential birth rates affect the ratio of reds to blues.


HOW TO USE IT
-------------
Each pass through the GO function represents a generation in the time scale of this model.

The CARRYING-CAPACITY slider sets the carrying capacity of the terrain.  The model is initialized to have a total population of CARRYING-CAPACITY with half the population reds and half blues.

The RED-FERTILITY and BLUE-FERTILITY sliders sets the average number of children the reds and blues have in a generation.  For example, a fertility of 3.4 means that each parent will have three children minimum, with a 40% chance of having a fourth child.

The # BLUES and # REDS monitors display the number of reds and blues respectively.

The GO button runs the model.  A running plot is also displayed of the number of reds, blues and total population (in green).

The RUN-EXPERIMENT button lets you experiment with many trials at the same settings.  This button outputs the number of ticks it takes for either the reds or the blues to die out given a particular set of values for the sliders.  After each extinction occurs, the world is cleared and another run begins with the same settings.  This way you can see the variance of the number of generations until extinction.


THINGS TO NOTICE
--------------------
How does differential birth rates affect the population dynamics?

Does the population with a higher birth rate always start off growing faster?

Does the population with a lower birth rate always end up extinct?


THINGS TO TRY
-----------------
Try running an experiment with the same settings many times.
Does one population always go extinct? How does the number of generations until extinction vary?


EXTENDING THE MODEL
-------------------
In this model, once the carrying capacity has been exceeded, every member of the population has an equal chance of dying. Try extending the model so that reds and blues have different saturation rates. How does the saturation rate compare with the birthrate in determining the population dynamics?

In this model, the original population is set to the carrying capacity (both set to CARRYING-CAPACITY). Would population dynamics be different if these were allowed to vary independently?

In this model, reds are red and blues blue and progeny of reds are always red, progeny of blues are always blue. What if you allowed reds to sometimes have blue progeny and vice versa? How would the model dynamics be different?


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Simple Birth Rates model.  http://ccl.northwestern.edu/netlogo/models/SimpleBirthRates.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/SimpleBirthRates for terms of use.
"
Fur,/models/Sample Models/Biology,"patches-own
[
  new-color       ;; currently, always either white or black
  inner-neighbors ;; other cells in a circle around the cell
  outer-neighbors ;; other cells in a ring around the cell (but usually not touching the cell)
]

to setup
  clear-all
  ;; computes inner and outer neighbors in an ellipse around each cell
  ask patches
  [
    set inner-neighbors ellipse-in inner-radius-x inner-radius-y
    ;; outer-neighbors needs more computation because we want only the cells in the circular ring
    set outer-neighbors ellipse-ring outer-radius-x outer-radius-y inner-radius-x inner-radius-y
  ]

  ifelse any? patches with [ count outer-neighbors = 0 ]
    [ user-message word ""It doesn't make sense that 'outer' is equal to or smaller than 'inner.' ""
                        "" Please reset the sliders and press Setup again.""
      stop]
    [restart]
end

;; this procedure sets approximately initial-density percent of the
;; cells white and the rest black; if initial-density is set at 50%
;; then about half the cells will be white and the rest black
to restart
  reset-ticks
  ask patches
    [ ifelse random-float 100.0 < initial-density
        [ set pcolor white ]
        [ set pcolor black ] ]
end

to go
  ask patches [ pick-new-color ]
  ask patches [ set pcolor new-color ]
  tick
end

to pick-new-color  ;; patch procedure
  let activator count inner-neighbors with [pcolor = white]
  let inhibitor count outer-neighbors with [pcolor = white]
  ;; we don't need to multiply 'activator' by a coefficient because
  ;; the ratio variable keeps the proportion intact
  let difference activator - ratio * inhibitor
  ifelse difference > 0
    [ set new-color white ]
    [ if difference < 0
        [ set new-color black ] ]
  ;; note that we did not deal with the case that difference = 0.
  ;; this is because we would then want cells not to change color.
end

;;; procedures for defining elliptical neighborhoods

to-report ellipse-in [x-radius y-radius]  ;; patch procedure
  report patches in-radius (max list x-radius y-radius)
           with [1.0 >= ((xdistance myself ^ 2) / (x-radius ^ 2)) +
                        ((ydistance myself ^ 2) / (y-radius ^ 2))]
end

to-report ellipse-ring [outx-radius outy-radius inx-radius iny-radius]  ;; patch procedure
  report patches in-radius (max list outx-radius outy-radius)
           with [1.0 >= ((xdistance myself ^ 2) / (outx-radius ^ 2)) +
                        ((ydistance myself ^ 2) / (outy-radius ^ 2))
             and 1.0 <  ((xdistance myself ^ 2) / (inx-radius ^ 2)) +
                        ((ydistance myself ^ 2) / (iny-radius ^ 2))
                ]
end

;; The following two reporter give us the x and y distance magnitude.
;; you can think of a point at the tip of a triangle determining how much
;; ""to the left"" it is from another point and how far ""over"" it is from
;; that same point. These two numbers are important for computing total distances
;; in elliptical ""neighborhoods.""

;; Note that it is important to use the DISTANCEXY primitive and not
;; just take the absolute value of the difference in coordinates,
;; because DISTANCEXY handles wrapping around world edges correctly,
;; if wrapping is enabled (which it is by default in this model)

to-report xdistance [other-patch]  ;; patch procedure
  report distancexy [pxcor] of other-patch
                    pycor
end

to-report ydistance [other-patch]  ;; patch procedure
  report distancexy pxcor
                    [pycor] of other-patch
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2003 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2003).  NetLogo Fur model.
; http://ccl.northwestern.edu/netlogo/models/Fur.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2003 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Fur
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
Could it be that a single mechanism underlies such diverse patterns such as the stripes on a zebra, the spots on a leopard, and the blobs on a giraffe?  This model is a possible explanation of how the patterns on animals' skin self-organize.  If the model is right, then even though the animals may appear to have altogether different patterns, the rules underlying the formation of these patterns are the same and only some of the values (the numbers that the rules work on) are slightly different.

Thinking of the formation of fur in terms of rules also helps us understand how offspring of animals may have the same type of pattern, but not the same exact pattern. This is because what they have inherited is the rules and the values rather than a fixed picture. The process by which the rules and values generate a pattern is affected by chance factors, so each individual's pattern is different, but as long as the offspring receive the same rules and values, their own fur will self organize into the same type of pattern as their parents'.


HOW IT WORKS
------------
We model the animal skin by a square array of many melanocytes (pigment cells) that are each in either of two states: colorful ('D' for differentiated) or not-colorful ('U' for undifferentiated).  The state of a cell can flip between D and U.  The color cells (the D's) secrete two types of 'morphogens': activators (A) and inhibitors (I).  Activators, on their own, cause a central cell to become colorful; inhibitors, on their own, cause the central cell to become not colorful.  These competing morphogens are secreted in all directions so you can think of each color cell as creating a puddle that grows around it, spreading to other cells.

Each cell, whether or not it is colorful, is itself the center of its own neighborhood. For now, suppose the neighborhood is a circle.  Say this circular neighborhood has a radius of 6 cells.  This means that the cell in the center can be affected by other cells that are as far as 6 cells away from it in any direction.  So if there is a D cell within this circle and it is secreting morphogens then these morphogens will diffuse as far as this central cell (but a D cell 7 cells away will not directly or immediately affect it).  Also, each cells has an inner circle of radius, say, 3 cells.

D cells within the inner circle each contributes morphogens of type A (activator) to the central cell.  Between the inner circle and the perimeter of the outer circle we have a ring of cells that are more than 3 cells away from the center but 6 or less cells away from the center.  Every D cell in this outer ring contributes morphogens of type I (inhibitor) to the central cell.  So at every moment each cell is affected both by activator and inhibitor cells in its circle and the question is will it ultimately be activated and become colorful or inhibited and lose its color (or just remain the way it was).  The logic is that if the power of the activators is bigger than the power of the inhibitors then the cell will become colorful and vice versa (and if the power is balanced then nothing happens).  The idea of ""power"" is that it's not enough to know how many morphogens there are of each type affecting a cell but one must multiply each cell by its ""power"" (or you can think of power in terms of the concentration of the morphogens in the inner and outer neighborhoods).  Another idea is that since we'll be multiplying both types of morphogens by their power, we might as well just call the power of the activators ""1"" and the power of the inhibitors ""w * 1"" or just w.  So w is the ratio between the power of the inhibitors and the activators.  If w is bigger than 1 that means the power of the inhibitors is greater than that of the activators (for instance, if w = 2 then the inhibitors are each double as strong as each of the activators and if w = 0.5 then the inhibitors are half as strong as the activators).  If w = 0.5 and if we have as many inhibitors as we have activators that are affecting the central cell, we would logically assume that the center cells would be more activated than inhibited and so would probably become (or remain) colorful on that step.  (A tricky point to notice is that while a certain D-cell is activating a neighboring cell, this same D-cell can be inhibiting a different cell further away.)

Here are the rules that summarize what we've been discussing: count up all the D cells in the ring and call this number D*I (for instance 2 inhibitors), and count up all the D cells in the circle of radius three and call this number D*A (for instance, 5 activators).  Then compute D*A - w*D*I, and:
- if it is > 0, set the central cell to D
- if it is < 0, set the central cell to U
- if it is = 0, leave the central cell unchanged

Note that this computation happens to all cells at the same time.  After the first step and once the cells have been set accordingly, the entire business starts over at the next step. Once again, the cells are counted up according to the same rule.  The rules have not changed but because some of the D cells are now U and vice versa we might get different counts and because of that -- different results of the ""fight"" between the A and I morphogens.

So what you see is that from step to step the individual cells often change from white (representing D or color cells) to black (representing U or no-color cells) and the overall impression is that the configuration of white and black changes as a whole.  But these configurations are not random.  You will see how these configurations often take form.  Understanding how each cell behaves, as we have explained above, can help understanding how these global patterns take form.

All these explanations were for circular neighborhoods.  In this model, the neighborhoods may be elliptical instead of circular.  This is needed to produce stripes instead of spots.


HOW TO USE IT
-------------
In order that your first experiment will more-or-less match the explanations above, you should choose to set the initial-density slider to 50% (that gives each cell an equal chance of being white or black to start with and so the whole window will be roughly 50% white), set the INNER-RADIUS-X and INNER-RADIUS-Y sliders to 3 and the OUTER-RADIUS-X and OUTER-RADIUS-Y sliders to 6, and set RATIO to 0.35 (that means the I morphogens are 35% as powerful as the A morphogens).  Now press SETUP. (In later experiments you are welcome to change those settings in various combinations.)  It will take a while to complete.  If you press STEP the model will advance a single step.  If you press GO the model will keep stepping indefinitely.

It takes a while for the patches to determine their neighborhoods.  Because of this, only press SETUP when you change the radius sliders.  If you only change the INITIAL-DENSITY and RATIO sliders or if you'd like to run the model again with the same settings, press RESTART instead of SETUP.  The RESTART button doesn't ask the patches to recalculate their neighborhoods.


THINGS TO NOTICE
----------------
As the model runs, patterns may begin to emerge.  Eventually, they stabilize.  (Well, sometimes the model will run into an endless flip-flop between two states, but we could call that dynamic stability.)  Even when it seems to come to a halt, the model is still running and executing the commands and carrying out the computations, but nothing is changing visibly.  This is because for each and every cell the power of activators is equal to that of the inhibitors, so nothing changes.


THINGS TO TRY
-------------
Run the model with different INITIAL-DENSITY settings.  How, if at all, does the value of the INITIAL-DENSITY affect the emergent pattern?  Do you get the same pattern?  Do you get a different pattern?  Does it take longer?

Note how fragile the self organization of the cells is to slight changes in parameters. If you hold all other factors and slightly change just the RATIO, from trial to trial, you will note that for small ratios you will invariably get completely white fur and for high ratios you will invariably get completely black fur (why is that?).  For ratios in between it fluctuates.  That happens partially because the initial setting of black/white coloration has a random element to it (see the RESTART procedure in the code).

Try changing the sliders to have different values in the X and Y directions.


EXTENDING THE MODEL
-------------------
If you find a combination of slider and switch values that consistently give you the fur patterns of a favorite animal, you could create a button, for instance ""Zebra,"" that sets the sliders to those values. That way, if you make several of these, you can go on a virtual safari tour by moving between your favorite animals. One such combination that you could set in a single button could be:
INNER-RADIUS-X 3
INNER-RADIUS-Y 3
OUTER-RADIUS-X 6
OUTER-RADIUS-Y 6
INITIAL-DENSITY 50%
RATIO 0.35

You could call this, perhaps, Fish.

How about adding more colors? What could be the logic here? If you introduced, say, red, you would have to decide on specific conditions under which that color would appear. Also, you'd have to decide how that color influences other cells.


RELATED MODELS
--------------
The Voting model, in the Social Science section, is based on simpler rules but generates patterns that are similar in some respects.


CREDITS AND REFERENCES
----------------------
The mechanism of ""diffusion-driven instability"" was first proposed by Alan Turing in 1952. B.N. Nagorcka first proposed applying it to hair and fur. The particular variant presented in this model was proposed by David Young.

In building this model, we used information on this web site: http://classes.yale.edu/fractals/Panorama/Biology/Leopard/Leopard.html

Thanks to Seth Tisue and Dor Abrahamson for their work on this model.

To refer to this model in academic publications, please use:  Wilensky, U. (2003).  NetLogo Fur model.  http://ccl.northwestern.edu/netlogo/models/Fur.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2003 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Fur for terms of use.
"
Mimicry,/models/Sample Models/Biology/Evolution,";; two breeds of butterflies
breed [ monarchs monarch ]
breed [ viceroys viceroy ]

breed [ birds bird ]
birds-own [ memory ]

globals [
  carrying-capacity-monarchs  ;; maximum population of monarchs in the world
  carrying-capacity-viceroys  ;; maximum population of viceroys in the world
  carrying-capacity-birds     ;; maximum population of birds in the world
  color-range-begin           ;; ""lowest"" color for a butterfly
  color-range-end             ;; ""highest"" color for a butterfly
  reproduction-chance         ;; The chance and individual has of
                              ;; reproducing (0 - 100) *after*
                              ;; the chance dependent on
                              ;; carrying capacity is evaluated.    
]

;;
;; Setup Procedures
;;

to setup
  clear-all
  setup-variables
  setup-turtles
end

;; initialize constants
to setup-variables
  set carrying-capacity-monarchs 225
  set carrying-capacity-viceroys 225
  set carrying-capacity-birds 75
  set reproduction-chance 4
  set color-range-begin 15
  set color-range-end 109
end

;; create 75 birds and 450 butterflies of which half are
;; monarchs and half are viceroys.  Initially, the
;; monarchs are at the bottom of the color range and
;; the viceroys are at the top of the color range.
;; The patches are white for easy viewing.

to setup-turtles
  ask patches [ set pcolor white ]
  set-default-shape monarchs ""butterfly monarch""
  set-default-shape viceroys ""butterfly viceroy""
  create-birds carrying-capacity-birds
  [
    set color black
    set memory []
    set shape one-of [""bird 1"" ""bird 2""]
  ]
  create-monarchs carrying-capacity-monarchs [ set color red ]
  create-viceroys carrying-capacity-viceroys [ set color blue ]
  ;; scatter all three breeds around the world
  ask turtles [ setxy random-xcor random-ycor ]
end

;;
;; Runtime Procedures
;;

to go
  ask birds [ birds-move ]
  ;; turtles that are not birds are butterflies
  ask turtles with [breed != birds] [ butterflies-move ]
  ask turtles with [breed != birds] [ butterflies-get-eaten ]
  ask birds [ birds-forget ]
  ask turtles with [breed != birds] [ butterflies-reproduce ]
  tick
  update-plot
end

to birds-move ;; birds procedure
  ;; The birds are animated by alternating shapes
  ifelse shape = ""bird 1"" 
  [ set shape ""bird 2""]
  [ set shape ""bird 1"" ]
  set heading 180 + random 180
  fd 1
end

to butterflies-move ;; butterflies procedure
  rt random 100
  lt random 100
  fd 1
end

;; If there is a bird on this patch check the bird's memory
;; to see if this butterfly seems edible based on the color.
;; If the butterfly's color is not in the bird's memory
;; the butterfly dies.  If it's a monarch the bird remembers
;; that its color was yucky
to butterflies-get-eaten  ;; butterfly procedure
  let bird-here one-of birds-here
  if bird-here != nobody 
  [
    if not [color-in-memory? [color] of myself] of bird-here
    [
      if breed = monarchs
        [ ask bird-here [ remember-color [color] of myself ] ]
      die
    ]
  ]
end

;; helper procedure that determines whether the given
;; color is in a bird's memory
to-report color-in-memory? [c] ;; bird procedure
  foreach memory [ if item 0 ? = c [ report true ] ]
  report false
end

;; put a color that was yucky in memory
to remember-color [c]  ;; bird procedure
  ;; birds can only remember 3 colors at a time
  ;; so if there are more than 3 in memory we
  ;; need to remove 1 we know that the first item
  ;; in the list will always be the oldest since
  ;; we add items to the back of the list and only
  ;; 1 item can be added per tick
  if length memory >= memory-size
  [ set memory but-first memory ]
  ;; put the new memory on the end of the list
  set memory lput (list c 0) memory 
end

;; birds can only remember for so long, then
;; they forget. They remember colors for MEMORY-LENGTH
to birds-forget ;; bird procedure
  ;; first increment all of the times in memory
  set memory map [list (item 0 ?) (1 + item 1 ?)] memory
  ;; then remove any entries whose times have hit MEMORY-DURATION
  set memory filter [item 1 ? <= MEMORY-DURATION] memory
end

;; Each butterfly has an equal chance of reproducing
;; depending on how close to carrying capacity the
;; population is.
to butterflies-reproduce ;; butterfly procedure
  ifelse breed = monarchs 
  [ if random count monarchs < carrying-capacity-monarchs - count monarchs
     [ hatch-butterfly ] ]
  [ if random count viceroys < carrying-capacity-viceroys - count viceroys
     [ hatch-butterfly ] ]
end

to hatch-butterfly ;; butterfly procedure
  if random-float 100 < reproduction-chance 
  [
    hatch 1 
    [
      fd 1
      ;; the chance that the butterfly will
      ;; have a random color is determined by 
      ;; the MUTATION slider. select a base-color
      ;; between 15 and 105
      if random-float 100 < mutation-rate 
      ;; make a list that contains only the base-color 15-105
      [ set color one-of sublist base-colors 1 10 ]
    ]
 ]
end

;;
;; Plotting Procedure
;;

to update-plot
  set-current-plot ""Average Colors Over Time""
  set-current-plot-pen ""Monarchs""
  plot mean [color] of monarchs
  set-current-plot-pen ""Viceroys""
  plot mean [color] of viceroys
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Mimicry model.
; http://ccl.northwestern.edu/netlogo/models/Mimicry.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Mimicry
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
Batesian mimicry is an evolutionary relationship in which a harmless species (the mimic) has evolved so that it looks very similar to a completely different species that isn't harmless (the model).  A classic example of Batesian mimicry is the similar appearance of monarch butterflies and viceroy moths. Monarchs and viceroys are unrelated species that are both colored similarly -- bright orange with black patterns. Their colorations are so similar, in fact, that the two species are virtually indistinguishable from one another.

The classic explanation for this phenomenon is that monarchs taste yucky.  Because monarchs eat milkweed, a plant full of toxins, they become essentially inedible to birds.  Researchers have documented birds vomiting within minutes of eating monarch butterflies.  The birds then remember the experience and avoid brightly colored orange butterfly/moth species.  Viceroys, although perfectly edible, avoid predation if they are colored bright orange because birds can't tell the difference.

Recent research now suggests that viceroys might also be unpalatable to bird predators, confusing this elegant explanation.  However, we have modeled the relationship anyway.  Batesian mimicry occurs in enough other situations (snakes, for example) that the explanation's general truth is unquestionable.  The monarch-viceroy story is so accessible -- and historically relevant -- that we believe it to be instructive even if its accuracy is now questioned.


HOW IT WORKS
------------
This model simulates the evolution of monarchs and viceroys from distinguishable, differently colored species to indistinguishable mimics and models.  At the simulation's beginning there are 450 monarchs and viceroys distributed randomly across the world.  The monarchs are all colored red, while the viceroys are all colored blue.  They are also distinguishable (to the human observer only) by their shape:  the letter ""x"" represents monarchs while the letter ""o"" represents viceroys.  Seventy-five birds are also randomly distributed across the world.

When the model runs, the birds and butterflies (for the remainder of this description ""butterfly"" will be used as a general term for monarchs and viceroys, even though viceroys are technically moths) move randomly across the world.  When a bird encounters a butterfly it eats the butterfly, unless it has a memory that the butterfly's color is ""yucky.""  If a bird eats a monarch, it acquires a memory of the butterfly's color as yucky.

As butterflies are eaten, they regenerate through asexual reproduction. Each turn, every butterfly must pass two ""tests"" in order to reproduce.  The first test is based on how many butterflies of that species already exist in the world. The carrying capacity of the world for each species is 225.  The chances of reproducing are smaller the closer to 225 each population gets.  The second test is simply a random test to keep reproduction in check (set to a 4% chance in this model).  When a butterfly does reproduce it either creates an offspring identical to itself or it creates a mutant.  Mutant offspring are the same species but have a random color between blue and red, but ending in five (e.g. color equals 15, 25, 35, 45, 55, 65, 75, 85, 95, 105).  Both monarchs and Viceroys have equal opportunities to reproduce mutants.

Birds can remember up to MEMORY-SIZE yucky colors at a time.  The default value is three.  If a bird has memories of three yucky colors and it eats a monarch with a new yucky color, the bird ""forgets"" its oldest memory and replaces it with the new one.  Birds also forget yucky colors after a certain amount of time.


HOW TO USE IT
-------------
Each turn is called a TICK in this model.

The MEMORY-DURATION slider determines how long a bird can remember a color as being yucky.  The MEMORY-SIZE slider determines the number of memories a bird can hold in its memory at once.

The MUTATION-RATE slider determines the chances that a butterfly's offspring will be a mutant.  Setting the slider to 100 will make every offspring a mutant.  Setting the slider to 0 will make no offspring a mutant.

The SETUP button clears the world and randomly distributes the monarchs (all red), viceroys (all blue), and birds.  The GO button starts the simulation.

The number of monarchs and viceroys in the world are displayed in monitor as well as the maximum, minimum, and average colors for each type of butterfly.

The plot shows the average color of the monarchs and the average color of the viceroys plotted against time.


THINGS TO NOTICE
----------------
Initially, the birds don't have any memory, so both monarchs and viceroys are eaten equally. However, soon the birds ""learn"" that red is a yucky color and this protects most of the monarchs.  As a result, the monarch population makes a comeback toward carrying capacity while the viceroy population continues to decline.  Notice also that as reproduction begins to replace eaten butterflies, some of the replacements are mutants and therefore randomly colored.

As the simulation progresses, birds continue to eat mostly butterflies that aren't red.  Occasionally, of course, a bird ""forgets"" that red is yucky, but a forgetful bird is immediately reminded when it eats another red monarch.  For the unlucky monarch that did the reminding, being red was no advantage, but every other red butterfly is safe from that bird for a while longer.  Monarch (non-red) mutants are therefore apt to be eaten.  Notice that throughout the simulation the average color of monarchs continues to be very close to its original value of 15.  A few mutant monarchs are always being born with random colors, but they never become dominant, as they and their offspring have a slim chance for survival.

Meanwhile, as the simulation continues, viceroys continue to be eaten, but as enough time passes, the chances are good that some viceroys will give birth to red mutants.  These butterflies and their offspring are likely to survive longer because they resemble the red monarchs.  With a mutation rate of 5%, it is likely that their offspring will be red too.  Soon most of the viceroy population is red.  With its protected coloration, the viceroy population will return to carrying capacity.


THINGS TO TRY
-------------
If the MUTATION-RATE is high, advantageous color genes do not reproduce themselves.  Conversely, if MUTATION-RATE is too low, the chances of an advantageous mutant (red) viceroy being born are so slim that it may not happen enough, and the population may go extinct.  What is the most ideal setting for the MUTATION-RATE slider so that a stable state emerges most quickly in which there are red monarchs and viceroys co-existing in the world?  Why?

If the MEMORY-LENGTH slider is set too low, birds are unable to remember that certain colors are yucky.  How low can the MEMORY-LENGTH slider be set so that a stable state of co-existing red monarchs and viceroys emerges?

If you set MUTATION-RATE to 100 and MEMORY to 0, you will soon have two completely randomly colored populations.  Once the average color of both species is about 55, return the sliders to MUTATION-RATE equals 16 and MEMORY equals 30 without resetting the model.  Does a stable mimicry state emerge?  What is the ""safe"" color?


EXTENDING THE MODEL
-------------------
One very simple extension to this model is to add a RANDOM-COLOR button.  This button would give every butterfly in the world a random color.  The advantage of red would be gone, but some color (which could be red, or any other color) would eventually emerge as the advantageous color.  This models the evolutionary process from an earlier starting place, presumably when even monarchs had different colors.

It would be interesting to see what would happen if birds were made smarter than they are in this model.  A smart bird should probably continue to experiment with yucky colors a few times before being ""convinced"" that all butterflies of that color are indeed distasteful.

You could try to add variables that kept track of how many yucky individuals of the same color a bird ate.  Presumably if a bird has eaten several monarchs that are all the same color, it will be especially attentive to avoiding that color as compared to if it had just eaten one butterfly of that color.  Making changes of this nature would presumably make the proportion of models and mimics more in keeping with the predictions of theorists that there are generally more models than mimics.  In the current model, birds aren't smart enough to learn that most butterflies may be harmless in a given situation.

In a real world situation, the birds would also reproduce.  Young birds would not have the experiences necessary to know which colors to avoid.  Reproduction of birds, depending on how it happened and how often, might change the dynamics of this model considerably.

One could also refine the mutation-making procedures of the model so that a butterfly is more likely to reproduce a mutant that is only slightly differently colored than to reproduce a mutant that is completely differently colored.  In the current model, mutants' colors are simply random.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Mimicry model.  http://ccl.northwestern.edu/netlogo/models/Mimicry.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Mimicry for terms of use.
"
Altruism,/models/Sample Models/Biology/Evolution,"patches-own [
  benefit-out                 ;; 1 for altruists, 0 for selfish
  altruism-benefit
  fitness
  self-weight self-fitness
  alt-weight alt-fitness
  harsh-weight harsh-fitness
]

to setup
  clear-all
  ask patches [ initialize ]
  do-plots
end

to initialize  ;; patch procedure
  let ptype random-float 1.0
  ifelse (ptype < altruistic-probability) [
    set benefit-out 1
    set pcolor pink
  ] [
    set benefit-out 0
    ifelse (ptype < altruistic-probability + selfish-probability) [
      set pcolor green
    ] [
      set pcolor black
    ]
  ]
end

to go
  ;; if all altruistic and selfish patches are gone, stop
  if all? patches [pcolor != pink and pcolor != green]
    [ stop ]
  ask patches [
    set altruism-benefit   benefit-from-altruism * (benefit-out + sum [benefit-out] of neighbors4) / 5
  ]
  ask patches [
    perform-fitness-check
  ]
  lottery
  tick
  do-plots
end

to perform-fitness-check  ;; patch procedure
  if (pcolor = green) [
    set fitness (1 + altruism-benefit)
  ]
  if(pcolor = pink) [
    set fitness ((1 - cost-of-altruism) + altruism-benefit)
  ]
  if (pcolor = black) [
    set fitness harshness
  ]
end

to lottery
  ask patches [ record-neighbor-fitness ]
  ask patches [ find-lottery-weights ]
  ask patches [ next-generation ]
end

to record-neighbor-fitness  ;; patch procedure
  set alt-fitness 0
  set self-fitness 0
  set harsh-fitness 0
  if (pcolor = pink) [
    set alt-fitness fitness
  ]
  if (pcolor = green) [
    set self-fitness fitness
  ]
  if (pcolor = black) [
    set harsh-fitness fitness
  ]
  update-fitness-from-neighbor 1 0
  update-fitness-from-neighbor -1 0
  update-fitness-from-neighbor 0 1
  update-fitness-from-neighbor 0 -1
end

to update-fitness-from-neighbor [x y]  ;; patch procedure
  let neighbor-color [pcolor] of patch-at x y
  let neighbor-fitness [fitness] of patch-at x y
  if (neighbor-color = pink)
    [set alt-fitness (alt-fitness + neighbor-fitness)]
  if (neighbor-color = green)
    [set self-fitness (self-fitness + neighbor-fitness)]
  if(neighbor-color = black)
    [set harsh-fitness (harsh-fitness + neighbor-fitness)]
end

to find-lottery-weights ;; patch procedure
  let fitness-sum alt-fitness + self-fitness + harsh-fitness + disease
  ifelse (fitness-sum > 0) [
    set alt-weight (alt-fitness / fitness-sum)
    set self-weight (self-fitness / fitness-sum)
    set harsh-weight ((harsh-fitness + disease) / fitness-sum)
  ] [
    set alt-weight 0
    set self-weight 0
    set harsh-weight 0
  ]
end

to next-generation ;; patch procedure
  let breed-chance random-float 1.0
  ifelse (breed-chance < alt-weight) [
    set pcolor pink
    set benefit-out 1
  ] [
    ifelse (breed-chance < (alt-weight + self-weight))[
      set pcolor green
      set benefit-out 0
    ] [
      clear-patch
    ]
  ]
end

to clear-patch ;; patch procedure
  set pcolor black
  set altruism-benefit 0
  set fitness 0
  set alt-weight 0
  set self-weight 0
  set harsh-weight 0
  set alt-fitness 0
  set self-fitness 0
  set harsh-fitness 0
  set benefit-out 0
end

to do-plots
  set-current-plot ""Populations""
  set-current-plot-pen ""altruists""
  plot count patches with [pcolor = pink]
  set-current-plot-pen ""selfish""
  plot count patches with [pcolor = green]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Altruism model.
; http://ccl.northwestern.edu/netlogo/models/Altruism.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Altruism
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model (and Cooperation and Divide the Cake) are part of the EACH curriculum: ""Evolution of Altruistic and Cooperative Habits: Learning About Complexity in Evolution"".  See http://ccl.northwestern.edu/cm/EACH/ for more information.

This is an evolutionary biology model.  It models population genetics with respect to the fitness of traits that are affected by social and environmental conditions.  The model has two types of patch agents: altruistic agents and selfish agents.

The basic premise of the model is that the selfish agents and the altruistic agents are competing for each spot in the world by entering into a genetic lottery.  You can imagine these agents as plants who ""seed"" for a spot, and the dominant seed generally wins.  The details of the lottery are explained below in HOW IT WORKS.

Under normal (non-interfering) environmental conditions, the selfish agents win, and the altruistic population is driven to extinction.  However, as outlined in 'HOW TO USE IT', when the environmental conditions are made more harsh, the altruistic population is able to survive, and even dominate the selfish population.


HOW IT WORKS
------------
1. Patches live in five-cell, plus-sign-shaped neighborhoods.  Whenever a patch is calculating something about its fitness, it is the center of the neighborhood.  For another patch, when that patch is calculating, it becomes merely one of the neighbors.

2. Each patch is an agent that has a fitness.  Each patch is also the location of a lottery for its space.  The patch and the four surrounding patches put in ""seeds"" to try to get the patch turned to their type of patch, altruist or selfish. Being successful in the lottery is getting patches to turn to your type.  We're assuming here that the type (altruistic or selfish) is the important genetic trait.

3.  Each patch calculates its own fitness using equation:
if it is A (altruist): 1 - cost + (Number Altruists in Neighborhood / 5 * benefit from Altruists)
if it is S (selfish):  1 + (Number Altruists in Neighborhood / 5 * benefit from Altruists)

Thus, the fitness of the S patch will be higher than the fitness of the A's.  If the cost is 0.2 and benefit is 0.5, for an A surrounded by two S's and two A's, then the fitness of this spot is 1 - 0.2 + (3/5 * 0.5) = 1.1.

4.  After each patch has calculated its fitness, it looks to its four neighbors.  Each of the five patches, including itself, puts a weighted seed into a genetic lottery for this center spot.  So, for example, if the neighborhood is ASASA, each of the three A's register their fitness value, and each of the two S's put in their fitness.  The A's are added, and the S's are added.  Let us assume that the A's add up to 3.2 (this includes the A in the center spot), and the S's add up to 2.6.  These two numbers are the altruist weight and selfish weight respectively, in the lottery for the center spot.  Now, the larger number, whichever it is, is called the Major seed; it is divided by the sum of all the fitnesses.

Thus, 3.2/(3.2 + 2.6) = .552

This number is the Altruism seed in the lottery.  The minor seed is 2.6/(3.2 + 2.6) = .448. (Notice that the Altruism seed of the parent is 3/5 = .600, while the child's is .552.  Even though altruism is dominating, it is losing ground.)

5.  There are a number of ways of doing the lottery itself.  Currently, we choose a random number between 0 and 1.  Now, if the Number is below the Minor seed, the minor weight gets the spot, and if it is above the major seed, the major seed gets the spot.  So, in the example, if the random number is anywhere from .449 to 1, then the Major seed gets it. If it is between 0 and .448, the minor seed gets it.


HOW TO USE IT
-------------
SETUP button -- sets up the model by creating the agents.

GO button -- runs the model

ALTRUISTIC-PROBABILITY slider -- lets you determine the initial proportion of altruists

SELFISH-PROBABILITY slider -- determines the initial proportion of selfish agents.

ALTRUISM-COST slider -- determines the value of cost in the above fitness equations.

BENEFIT-FROM-ALTRUISM slider -- determines the value of benefit in the above fitness equations.

There are two sliders for controlling environmental variables:

HARSHNESS slider -- sets the value for the resistance of empty patch spots to being populated by agents.  The value for this slider determines a corresponding value in the lottery for each empty (black) spot on the grid; the higher this value, the more difficult it is to populate.

DISEASE slider -- sets the value for the possibility that the agents in occupied spots will die.  The value for this slider is factored into the genetic lottery, and determines the percentage chance that each agent will die out from their spot.


THINGS TO TRY
-------------
1.  At first, run the model with Harshness and Disease both at 0.  Notice that the selfish population quickly dominates the world, driving the altruistic population to extinction.  How do respective population sizes affect the outcome?

2.  Play with the values of cost and benefit.  What are realistic values for actual genetic competition?  How does initial population size effect the significance of these values?

3.  Increase the Harshness and Disease values, independently, and with respect to one another.  What are the effects of the Harshness Model?  of Disease?  How are the values dependent on one another?  At what values does the altruistic population begin to have greater success?

4.  Consider why the introduction of Harshness and Disease conditions affects the success of the altruistic population.  How does each population, run alone, respond to the Harshness and Disease conditions?  If you imagine the black spots as Voids (a third type of competing agent), what is the fitness relationship between Altruists and Voids?  Selfish agents and Voids?

5.  Can you find slider values that maximize the advantage of the altruistic agents?

6.  Try running BehaviorSpace on this model to explore the model's behavior under a range of initial conditions.


EXTENDING THE MODEL
-------------------
The model can be extended in a number of interesting directions, including adding new environmental variables, adding different types of agents, and changing the altruistic and selfish weighting under different environmental conditions.

This model does not address the behaviors of individuals, only the relative weights of genetic traits.  A next step in considering the evolution of altruism is to model altruistic behaviors.  (See the related model: Cooperation.)


NETLOGO FEATURES
----------------
This model uses patches as its basic agents. Can you design an ""equivalent"" model using turtles?  How would the model dynamics be affected?


RELATED MODELS
--------------
Cooperation


CREDITS AND REFERENCES
----------------------
This model and the Cooperation model are part of the curriculum ""Evolution of Altruistic and Cooperative Habits: Learning About Complexity in Evolution"".  See http://ccl.northwestern.edu/cm/EACH/ for more information.

This model is based on a paper by Mitteldorf and Wilson, in press, ""Population Viscosity and the Evolution of Altruism"", Journal of Theoretical Biology (2000), v.204, pp.481-496.

Thanks also to Damon Centola and Scott Styles.

To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Altruism model.  http://ccl.northwestern.edu/netlogo/models/Altruism.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Altruism for terms of use.
"
Bug Hunt Speeds,/models/Sample Models/Biology/Evolution,"breed [predators predator]
breed [bugs bug]
bugs-own [
  speed    ;; either 1, 2, 3, 4, 5, or 6
]

globals [
  total-speed-1-caught      ;; keeps track of the number of bugs caught with speed of 1
  total-speed-2-caught      ;; keeps track of the number of bugs caught with speed of 2
  total-speed-3-caught      ;; keeps track of the number of bugs caught with speed of 3
  total-speed-4-caught      ;; keeps track of the number of bugs caught with speed of 4
  total-speed-5-caught      ;; keeps track of the number of bugs caught with speed of 5
  total-speed-6-caught      ;; keeps track of the number of bugs caught with speed of 6
]

to setup
  clear-all
  set-default-shape bugs ""bug""
  set-default-shape predators ""bird""
  ask patches [ set pcolor white ]   ;; white background
  foreach [1 2 3 4 5 6] [
    create-bugs initial-bugs-each-speed [ set speed ? ]
  ]
  ask bugs [
    setxy random-xcor random-ycor
    set-color
  ]
  ;; the predator breed contains one turtle that is used to represent
  ;; a predator of the bugs (a bird)
  create-predators 1 [
    set shape ""bird""
    set color black
    set size 1.5
    set heading 315
    hide-turtle
  ]
  ;; plot the initial state of the system
  update-plots
end

to go
  ;; use EVERY to limit the overall speed of the model
  every 0.03 [
    check-caught
    move-predator
    ask bugs [ fd speed * 0.08 ]
    ;; recolor the bugs in case the user changed SPEED-COLOR-MAP
    ask bugs [ set-color ]
    ;; advance the clock
    tick
    ;; plotting takes time, so only plot every 10 ticks
    if ticks mod 10 = 0 [ update-plots ]
  ]
end

;;;;;;;;;;;;;;;;;;;;;
;; Runtime Procedures
;;;;;;;;;;;;;;;;;;;;;

to move-predator
  ask predators [
    setxy mouse-xcor mouse-ycor
    ;; only show the predator if the mouse pointer is
    ;; actually inside the view
    set hidden? not mouse-inside?
  ]
end

to check-caught
  if not mouse-down? or not mouse-inside? [ stop ]
  let prey [bugs in-radius (size / 2)] of one-of predators
  ;; no prey here? oh well
  if not any? prey [ stop ]
  ;; eat only one of the bugs at the mouse location
  ask one-of prey [
    if speed = 1 [ set total-speed-6-caught total-speed-6-caught + 1 ]
    if speed = 2 [ set total-speed-5-caught total-speed-5-caught + 1 ]
    if speed = 3 [ set total-speed-4-caught total-speed-4-caught + 1 ]
    if speed = 4 [ set total-speed-3-caught total-speed-3-caught + 1 ]
    if speed = 5 [ set total-speed-2-caught total-speed-2-caught + 1 ]
    if speed = 6 [ set total-speed-1-caught total-speed-1-caught + 1 ]
    die
  ]
  ;; replace the eaten bug with a random offspring from the remaining population
  ask one-of bugs [ hatch 1 [ rt random 360 ] ]
end

to set-color  ;; turtle procedure
  if speed-color-map = ""all green""
    [ set color green ]
  if speed-color-map = ""violet shades""
    [ set color violet - 4 + speed ]
  if speed-color-map = ""rainbow""
    [ set color item (speed - 1) [violet blue green brown orange red] ]
end

;;;;;;;;;;;;;;;;;;;;;;
;; Plotting Procedures
;;;;;;;;;;;;;;;;;;;;;;

;; To avoid having to write out all of the plotting code
;; six times, we use FOREACH to loop over the six possible
;; speeds.

to update-plots
  set-current-plot ""Avg. Bug Speed vs. Time""
  plot mean [speed] of bugs
  
  set-current-plot ""Bugs Caught vs. Time""
  foreach [1 2 3 4 5 6] [
    set-current-plot-pen word ""speed="" ?
    ;; use RUNRESULT to get the value of the variable with
    ;; the given name
    plotxy ticks runresult (word ""total-speed-"" ? ""-caught"")
  ]

  ;; the HISTOGRAM primitive can't make a multi-colored histogram,
  ;; so instead we plot each bar individually
  set-current-plot ""Frequency of Bugs""
  clear-plot
  foreach [1 2 3 4 5 6] [
    set-current-plot-pen word ""pen"" ?
    plotxy ? count bugs with [speed = ?]
  ]

  set-current-plot ""Number of Bugs vs. Time""
  foreach [1 2 3 4 5 6] [
    set-current-plot-pen word ""speed="" ?
    plot count bugs with [speed = ?]
  ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2005 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Novak, M. and Wilensky, U. (2005). NetLogo Bug Hunt Speeds model.
; http://ccl.northwestern.edu/netlogo/models/BugHuntSpeeds.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2005 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/BugHuntSpeeds
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This is a natural/artificial selection model that shows the result of two competing forces on natural selection of the speed of prey.  Which force dominates depends on the behavior of predators.

One force is that predators that chase prey, tend to catch slower moving prey more often, thereby selecting for prey that are faster over many generations of offspring.

Another force is that predators who wait for their prey without moving, tend to catch prey that are moving faster more often, thereby selecting for prey that are slower over many generations of offspring.

By also adjusting whether bugs try to avoid the predator and the predictability of their motion, a different one of these competing forces will tend to dominate the selective pressure on the population.


HOW IT WORKS
------------
You assume the role of a predator amongst a population of bugs.  To begin your pursuit of bugs as a predator, press SETUP to create a population of bugs, determined by six times the INITIAL-BUGS-EACH-SPEED slider.  These bugs that are created are randomly distributed around the world and assigned a speed.

When you press GO the bugs begin to move at their designated speeds.  As they move around, try to eat as many bugs as fast as you can by clicking on them.  Alternatively, you may hold the mouse button down and move the predator over the bugs.

The six different speeds that a bug might move at are distributed amongst six different sub-populations of the bugs.  These speeds are inherited.  With each bug you eat, a new bug is randomly chosen from the population to produce one offspring.  The offspring is an exact duplicate of the parent (in its speed and location).  The creation of new offspring keeps the overall population of the bugs constant.

Initially there are equal numbers of each sub-population of bug (e.g. ten bugs at each of the 6 speeds).  Over time, however, as you eat bugs, the distribution of the bugs will change as shown in the ""Frequency of bugs"" Histogram and the ""Number of Bugs vs. Time"" graph.  In the histogram, you might see the distribution shift to the left (showing that more slow bugs are surviving) or to the right (showing that more fast bugs are surviving).  Sometimes one sub-population of a single speed of bug will be exterminated.  At this point, no other bugs of this speed can be created in the population.


HOW TO USE IT
-------------
INITIAL-BUGS-EACH-SPEED is the number of bugs you start with in each of the six sub-populations.  The overall population of bugs is determined by multiplying this value by 6.

SPEED-COLOR-MAP settings help you apply or remove color visualization to the speed of the bugs:

- The ""all green"" setting does not show a different color for each bug based on its speed"".  Keeping the color settings switched to something besides ""all green"" can tend to result in the predator (the user) unconsciously selecting bugs based on color instead of speed.

- The ""rainbow"" setting shows 6 distinct colors for the 6 different speeds a bug might have.  These color settings correspond to the plot pen colors in the graphs.

- The ""purple shades"" setting shows a gradient of dark purple to light purple for slow to fast bug speed.


THINGS TO NOTICE
----------------
The histogram tends to shift right (increasing average speed) if you assume the role of chasing easy prey.

The histogram tends to shift left (decreasing average speed) if you assume the role of waiting for prey come to you.  The same effect can also be achieved by moving the predator around the world randomly.


THINGS TO TRY
-------------
Set the model up with INITIAL-BUGS-EACH-SPEED set to 1.  Slow the model down and watch where new bugs come from when you eat a bug.  You should see a new bug hatch from one of the five remaining and it should be moving at the same speed as its parent.

Wait in one location for the bugs to come to you by placing the predator in one location and holding down the mouse button.  All bugs that run into you will be eaten.

Chase bugs around trying to catch the bug nearest you at any one time by holding the mouse button down and moving the predator around the view after the nearest bug.


EXTENDING THE MODEL
-------------------
Currently the bugs move in a straight line.  It would be more difficult if bugs wandered in a path that is not a straight line and if the bugs avoided you (the predator).  Add a wiggle to the bugs' wandering and make the amount of wiggle inheritable.

A HubNet version of the model with adjustable starting populations of bugs would help show what happens when two or more competitors assume similar vs. different hunting strategies on the same population at the same time.


RELATED MODELS
--------------
Bug Hunt Camouflage


CREDITS AND REFERENCES
----------------------
Inspired by EvoDots software:
http://faculty.washington.edu/~herronjc/SoftwareFolder/EvoDots.html

To refer to this model in academic publications, please use:  Novak, M. and Wilensky, U. (2005).  NetLogo Bug Hunt Speeds model.  http://ccl.northwestern.edu/netlogo/models/BugHuntSpeeds.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2005 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/BugHuntSpeeds for terms of use.
"
Divide The Cake,/models/Sample Models/Biology/Evolution/Unverified,"turtles-own [
  ;; ""appetite"" will reflect the behavior of the three types of agents: '2' for modest,
  ;; '3' for fair, and '4' for greedy.  Note that the ratio between these three numbers
  ;; 2:3:4 is equal to the ratio of agent types' eating habits: 1/3 : 1/2 : 2/3.
  ;; In principle, we could have worked with 1/3, 1/2, and 2/3 but it's just easier to
  ;; work with integers.   So we will think of a whole as ""6"" and not as ""1"".
  appetite
  ;; true or false for ""is it my turn to run the 'eat' procedure?,"" will help us manage
  ;; the behavior of turtles who are on the same patch.
  turn?
]

to setup
  ca
  ask patches
    [ set pcolor green ]
  setup-turtles
  update-plot
end

to setup-turtles
  let total (modest-proportion + fair-proportion + greedy-proportion)
  crt initial-number
    [ setxy random-xcor random-ycor
      ;; This will assign proportions of the turtles to agent types
      ;; according to the ratio of greedy, fair, and modest turtles
      ;; as set in their respective sliders.  The procedure uses the
      ;; fact that, given enough turtles, the random yet uniform
      ;; distribution of individual turtles' values from 0 to 1.0
      ;; will assign these turtles to different agent types so as to
      ;; approximate a correspondence with the number of turtles in
      ;; each type, as determined by the user's ratio settings.
      let breed-rand random-float 1.0
      ifelse breed-rand < (fair-proportion / total)
        [ set appetite 3
          set color red ]
        [ ifelse breed-rand < ((total - greedy-proportion) / total)
            [ set appetite 2
              set color brown ]
            [ set appetite 4
              set color blue ] ] ]
end

to go
  ;; Main loop - agents move around and eat the grass
  ;; Here all agents receive a 'true' value for their 'turn?' Boolean variable.
  ;; Later, in the 'eat' procedure, only a single turtle of turtle pairs who are on the same patch will get to use this value.
  ask turtles
    [ set turn? true
      move
      eat ]
  tick
  update-plot
end

to move  ;; turtle procedure
  ;; Agents move in random directions every turn,
  ;; at least one patch per turn.
  rt random-float 360

  ;; Note that 'travel-distance' is scaled down by the (1 - viscosity) factor, unless 'viscosity' is 0.
  fd 1 + (travel-distance * (1 - viscosity))
end

to eat ;; turtle procedure
  ;; We need the turn? variable so turtles who are eligible
  ;; to eat will not get two chances to reproduce.
  ;; Only where there is exactly a pair of turtles on a patch are both turtles eligible to eat.
  ;; Logically, we can't manage more than two turtles, because we could not, then, distinguish between
  ;; the presence of three modest turtles (2 + 2 + 2) or two fair turtles (3 + 3);
  ;; Also, if appetites on a patch exceeded resources, that is if their total was greater than 6, we would not know if this
  ;; were because two turtles have gone beyond 6 and they should die, or because there were three or more turtles on the patch.
  if (count turtles-here = 2 and turn?)
    [ ifelse (6 >= sum [appetite] of turtles-here)
        [ ask turtles-here  ;; including myself!
            [ reproduce
              set turn? false ] ]
        [ ask turtles-here  ;; including myself!
           [ die ] ] ]
  set turn? false
end

to reproduce ;; turtle procedure
  ;; Note that the higher a turtle's appetite value, the higher are its
  ;; chances of reproduction.
  if (random 6) < appetite
    [ hatch 1 ]
end

to update-plot
  set-current-plot ""Population vs. Time""
  set-current-plot-pen ""modest""
  plot count turtles with [color = brown]
  set-current-plot-pen ""fair""
  plot count turtles with [color = red]
  set-current-plot-pen ""greedy""
  plot count turtles with [color = blue]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2002.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Divide The Cake model.
; http://ccl.northwestern.edu/netlogo/models/DivideTheCake.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/DivideTheCake
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model (and Cooperation and Altruism) are part of the EACH curriculum: ""Evolution of Altruistic and Cooperative Habits: Learning About Complexity in Evolution"".  See http://ccl.northwestern.edu/cm/EACH/ for more information.

This is an evolutionary game-playing model.  Three types of agents must divide a common resource.  In the original model it's cake, but let's think of it as edible grass instead, which is green.  The agents come in three types: modest, fair, and greedy.  The agents move around competing for grass.  Agents need grass in order to produce offspring, so over time, the agent types that get more grass will tend to increase in number.


HOW IT WORKS
------------
When there are only two agents on a patch of grass, each of the agents tries to eat a certain amount of the grass.

There are fair agents (red), modest agents (brown), and greedy agents (blue).  Fair agents try to eat half the grass, modest agents try to eat a third of the grass, and greedy agents try to eat two-thirds of the grass.

If the total amount requested by both agents is greater than 100%, then both agents die.  Otherwise, each agent gets his requested share of the patch's resources.   Each agent then enters a reproduction lottery based on its appetite:  The greater the appetite, the greater the chance of reproduction.  This factor gives a fitness advantage to the agents with a greater appetite that counteracts the disadvantage of having a greater appetite (viz., the higher chance of asking for too much food and dying).

Each turn, every patch resets to the full amount of grass.


HOW TO USE IT
-------------
SETUP: Creates the agents.

GO: Starts the model running.

MODEST-PROPORTION, FAIR-PROPORTION, GREEDY-PROPORTION:  These sliders set the proportions of the three agent types within the initial number of agents.  Note that the actual numbers chosen for these three sliders are irrelevant -- only the ratio of the three numbers counts vis-a-vis the setting of the INITIAL-NUMBER slider.  For example, the ratio settings ""1 1 1"" will produce roughly equal numbers of each type, as will the settings ""79 79 79"" or what-have-you.  Likewise, the setting ""0 0 1"" is no different from ""0 0 88"", etc.

INITIAL-NUMBER: Creates this number of turtles of all three types together.

TRAVEL-DISTANCE: The value of this variable determines the number of steps an agent moves each turn.  This value is the mobility of an agent.

VISCOSITY: This variable is the difficulty of movement.  It limits the general mobility of agents.


THINGS TO NOTICE
-----------------
If you run the model with the default settings (high viscosity), notice how the population of fair (1/2) agents increases.  Why does this happen?  Also, notice how the modest (1/3) and greedy (2/3) populations and the modest (1/3) and fair (1/2) populations congregate in dynamically-stable communities but the greedy (2/3) and fair (1/2) populations do not seem to co-exist.  Why does this happen?


THINGS TO TRY
-------------
Try changing the population VISCOSITY value.  What happens when this value is decreased?  How does this affect the survival and the grouping of the different populations?

Change the starting ratios of the populations.  How do these ratios affect the behavior of the model?  Why should the model depend on these ratios?

Change TRAVEL-DISTANCE.  How does it affect the model?  What is the relationship between the values of TRAVEL-DISTANCE and VISCOSITY?


EXTENDING THE MODEL
-------------------
What environmental variables might affect the model?  Should the grass grow back to its full length each turn?  How would changing the rejuvenation of available resources affect the model?

Should the agents be informed of each other's anticipated demands prior to making their claims?  If they did, then agents could bargain before asking for food, and therefore reduce their chances of death as a result of a joint demand that exceeds the available resources, e.g., 1/2 + 2/3 > 1.  This bargaining behavior would change the model drastically, but is an interesting way of exploring how populations may adapt their interpersonal behaviors in order to survive.  A question would then arise of whether such survival does or does not ultimately play against agents as a type, because the price of survival could be a depletion of resources in future generations.


RELATED MODELS
--------------
Altruism, Cooperation, PD Basic


CREDITS AND REFERENCES
----------------------
This model is based on William Harms's ""Divide the Cake"" model, described in Brian Skyrms's book ""The Evolution of the Social Contract"".

Thanks to Damon Centola for his implementation of this model.

To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Divide The Cake model.  http://ccl.northwestern.edu/netlogo/models/DivideTheCake.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/DivideTheCake for terms of use.
"
GenDrift P global,/models/Sample Models/Biology/Evolution/Genetic Drift,"to setup
  clear-all
  ask patches
    [ set pcolor (random colors) * 10 + 5
        if pcolor = 75  ;; 75 is too close to another color so change it to 125
          [ set pcolor 125 ] ]
  do-plot
end

to go
  ask patches [ set pcolor [pcolor] of one-of patches ]
  tick
  do-plot
end

to do-plot
  set-current-plot ""Patch Colors""
  set-current-plot-pen ""color5""
  plot count patches with [pcolor = 5]
  set-current-plot-pen ""color15""
  plot count patches with [pcolor = 15]
  set-current-plot-pen ""color25""
  plot count patches with [pcolor = 25]
  set-current-plot-pen ""color35""
  plot count patches with [pcolor = 35]
  set-current-plot-pen ""color45""
  plot count patches with [pcolor = 45]
  set-current-plot-pen ""color55""
  plot count patches with [pcolor = 55]
  set-current-plot-pen ""color65""
  plot count patches with [pcolor = 65]
  set-current-plot-pen ""color125""
  plot count patches with [pcolor = 125]
  set-current-plot-pen ""color85""
  plot count patches with [pcolor = 85]
  set-current-plot-pen ""color95""
  plot count patches with [pcolor = 95]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1997 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1997).  NetLogo GenDrift P global model.
; http://ccl.northwestern.edu/netlogo/models/GenDriftPglobal.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1997 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/GenDriftPglobal
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model is an example of random selection.  It shows that patches that randomly exchange colors converge on a single color. The idea, explained in more detail in Dennett's ""Darwin's Dangerous Idea"", is that trait drifts can occur without any particular purpose or 'selecting pressure'.

The model starts with a random distribution of colors.  Each patch then randomly picks a patch to copy its color from.  (It might randomly choose itself.)

After enough time passes, a color will gain a slight dominance. By statistical advantage, a dominant color becomes more likely to win the entire grid.  However, because the process is random, there will usually be many series of dominant colors before one color finally wins.  A key aspect is that once a color disappears -- becomes extinct -- it can never reappear.


HOW TO USE IT
-------------
Use the COLORS slider to select the number of competing colors.

The SETUP button initializes the model.

The GO button starts it, and runs continuously.


THINGS TO NOTICE
----------------
Notice that often a color nearly becomes dominant, yet loses in the end.


EXTENDING THE MODEL
-------------------
Explore other rules by which patches might randomly influence each other.  What does it take for one color to ""win out""?


RELATED MODELS
--------------
GenDrift (P local)
GenDrift (T interact)
GenDrift (T reproduce)


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1997).  NetLogo GenDrift P global model.  http://ccl.northwestern.edu/netlogo/models/GenDriftPglobal.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1997 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/GenDriftPglobal for terms of use.
"
GenDrift T reproduce,/models/Sample Models/Biology/Evolution/Genetic Drift,"to setup
  ca
  crt number
  ask turtles [
    set color ((random colors) * 10) + 5
    if (color = 75)  ;; 75 is too close to another color so change it to 125
      [ set color 125 ]
    setxy random-xcor random-ycor ]
  setup-plots
  do-plots
end

to go ;; Observer Procedure
  if (variance [color] of turtles) = 0
    [ stop ]
  ask turtles [
    rt random-float 50 - random-float 50
    fd 1 ]
  birth
  death
  tick
  do-plots
end

;;TURTLES HATCH BETWEEN 0 AND 4 BABIES
to birth
  ask turtles
    [ hatch random 5 [ fd 1 ] ]
end

;;IF GLOBAL COUNT IS GREATER THAN THE ORIGINAL NUMBER,
;;TURTLES ARE RANDOMLY KILLED OFF
to death
  let total-turtles (count turtles)
  ask turtles [
    if (random total-turtles > number) [die] ]
end

;; initializes all plots
to setup-plots
  set-current-plot ""Turtle Populations""
  set-plot-y-range 0 count turtles
end


to do-plots
  set-current-plot ""Turtle Populations""
  set-current-plot-pen ""color5""
  plot  count turtles with [color = 5]
  set-current-plot-pen ""color15""
  plot  count turtles with [color = 15]
  set-current-plot-pen ""color25""
  plot  count turtles with [color = 25]
  set-current-plot-pen ""color35""
  plot  count turtles with [color = 35]
  set-current-plot-pen ""color45""
  plot  count turtles with [color = 45]
  set-current-plot-pen ""color55""
  plot  count turtles with [color = 55]
  set-current-plot-pen ""color65""
  plot  count turtles with [color = 65]
  set-current-plot-pen ""color125""
  plot  count turtles with [color = 125]
  set-current-plot-pen ""color85""
  plot  count turtles with [color = 85]
  set-current-plot-pen ""color95""
  plot  count turtles with [color = 95]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1997 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1997).  NetLogo GenDrift T reproduce model.
; http://ccl.northwestern.edu/netlogo/models/GenDriftTreproduce.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1997 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/GenDriftTreproduce
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model is an example of genetic drift.  It shows that competing breeds of turtles, each reproducing with equal likelihood on each turn, will ultimately converge on one breed without any selection pressure forcing this convergence.  The idea, explained in more detail in Dennett's ""Darwin's Dangerous Idea"", is that trait drifts can occur without any particular purpose or 'selecting pressure'.

The model starts with a random distribution of colored turtles.  They move by wiggling randomly across the world. Each turn, a turtle produces between 0 and 4 offspring.  If the total number of turtles is greater than the original number, then turtles are randomly killed until the original number is restored. After enough turns, a color will gain a slight dominance. By statistical advantage, a dominant color becomes more likely to win the entire grid.   However, because the process is random, there will usually be a series of dominant colors before one color finally wins.   Equally important is the fact that a color can never come back once it dies out.


HOW TO USE IT
-------------
The ""setup"" button initializes the model.
The ""go"" button runs the model.
Use the ""colors"" slider to select the number of competing colors.
The ""number"" slider sets the initial number of turtles.


THINGS TO NOTICE
----------------
Notice that often colors can get to quite a high population but still fail to win the race.


EXTENDING THE MODEL
-------------------
The grim reaper in the procedure ""death"" does a random harvesting of the population to keep it roughly constant.  This might be somewhat like a natural environment with a limited food supply.  Can you think of other ways to write this procedure?  Are the results affected?


RELATED MODELS
--------------
GenDrift P global
GenDrift P local
GenDrift T interact


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1997).  NetLogo GenDrift T reproduce model.  http://ccl.northwestern.edu/netlogo/models/GenDriftTreproduce.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1997 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/GenDriftTreproduce for terms of use.
"
GenDrift P local,/models/Sample Models/Biology/Evolution/Genetic Drift,"to setup
  ca
  ask patches  ;; randomly set the patches' colors
    [ set pcolor (random colors) * 10 + 5
        if pcolor = 75  ;; 75 is too close to another color so change it to 125
          [ set pcolor 125 ] ]
  do-plots
end

to go
  if (variance [pcolor] of patches) = 0
    [ stop ]
  ask patches [
    ;; each patch randomly picks a neighboring patch
    ;; to copy a color from
    set pcolor [pcolor] of one-of neighbors
  ]
  tick
  do-plots
end

to do-plots
  set-current-plot ""Patch Colors""
  set-current-plot-pen ""color5""
  plot count patches with [pcolor = 5]
  set-current-plot-pen ""color15""
  plot count patches with [pcolor = 15]
  set-current-plot-pen ""color25""
  plot count patches with [pcolor = 25]
  set-current-plot-pen ""color35""
  plot count patches with [pcolor = 35]
  set-current-plot-pen ""color45""
  plot count patches with [pcolor = 45]
  set-current-plot-pen ""color55""
  plot count patches with [pcolor = 55]
  set-current-plot-pen ""color65""
  plot count patches with [pcolor = 65]
  set-current-plot-pen ""color125""
  plot count patches with [pcolor = 125]
  set-current-plot-pen ""color85""
  plot count patches with [pcolor = 85]
  set-current-plot-pen ""color95""
  plot count patches with [pcolor = 95]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1997 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1997).  NetLogo GenDrift P local model.
; http://ccl.northwestern.edu/netlogo/models/GenDriftPlocal.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1997 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/GenDriftPlocal
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model is an example of random selection.  It shows that patches that randomly exchange colors converge on a single color. The idea, explained in more detail in Dennett's ""Darwin's Dangerous Idea"", is that trait drifts can occur without any particular purpose or 'selecting pressure'.

The model starts with a random distribution of colors.  It then randomly picks a patch to copy a color from, and randomly picks a patch to change to the copied color.  The coordinates are global, so it could happen that the same patch is selected for both roles.

After enough time passes, a color will gain a slight dominance. By statistical advantage, a dominate color becomes more likely to win the entire grid.  However, because the process is random, there will usually be many series of dominant colors before one color finally wins.  A key aspect is that once a color disappears -- becomes extinct -- it can never reappear.


HOW TO USE IT
-------------
Use the COLORS slider to select the number of competing colors.

The SETUP button initializes the model.

The GO button starts it running.


THINGS TO NOTICE
----------------
Notice that often colors can become quite dominant but still fail to win the grid.


EXTENDING THE MODEL
-------------------
Explore other rules by which patches might randomly influence each other.  What does it take for one color to ""win out""?


RELATED MODELS
--------------
GenDrift (P global)
GenDrift (T interact)
GenDrift (T reproduce)


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1997).  NetLogo GenDrift P local model.  http://ccl.northwestern.edu/netlogo/models/GenDriftPlocal.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1997 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/GenDriftPlocal for terms of use.
"
GenDrift T interact,/models/Sample Models/Biology/Evolution/Genetic Drift,"globals [
  max-percent  ;; percent of the total population that is in the
               ;; most populous group
]

to setup
  ;; We don't use clear-all here because that would erase
  ;; any walls the user drew.
  clear-turtles
  clear-all-plots
  reset-ticks
  ;; create turtles with random colors and locations
  crt number [
    set color item (random colors) [5 15 25 35 45 55 65 85 95 125]
    setxy random-xcor random-ycor
    move-off-wall
  ]
  setup-plot
  update-plot
end

to go
  if (variance [color] of turtles) = 0
    [ stop ]
  ask turtles [
    rt random 50 - random 50
    meet
    ;; move, but don't step on wall
    ifelse [pcolor] of patch-ahead 0.5 = black
      [ fd 0.5 ]
      [ rt random 360 ]
  ]
  find-top-species
  tick
  update-plot
end

to meet    ;; turtle procedure - when two turtles are next door,
           ;; the left one changes to the color of the right one
  let candidate one-of turtles-at 1 0
  if candidate != nobody [
    set color [color] of candidate
  ]
end

to find-top-species  ;;find the percentage of the most populous species
  let winning-amount 0
  foreach base-colors [
    let how-many count turtles with [color = ?]
    if how-many > winning-amount
      [ set winning-amount how-many ]
  ]
  set max-percent (100 * winning-amount / count turtles)
end

to setup-plot
  set-current-plot ""Turtle Populations""
  set-plot-y-range 0 count turtles
end

to update-plot
  foreach [5 15 25 35 45 55 65 85 95 125] [
    set-current-plot-pen word ""color"" ?
    plot count turtles with [color = ?]
  ]
end

;; ---------------------------------------------------------------------------------
;; Below this point are procedure definitions that have to do with ""walls,"" which
;; the user may create in order to separate groups of turtles from one another.
;; The use of walls is optional, and can be seen as a more advanced topic.
;; ---------------------------------------------------------------------------------

to place-wall
  if mouse-down? [
    ;; Note that when we place a wall, we must also place walls
    ;; at the world boundaries, so turtles can't change rooms
    ;; by wrapping around the edge of the world.
    ask patches with [abs pycor = max-pycor or
                      pycor = round mouse-ycor] [
      set pcolor white
      ;; There might be some turtles standing where the
      ;; new walls is, so we need to move them into a room.
      ask turtles-here [ move-off-wall ]
    ]
    display
  ]
end

to remove-wall
  if mouse-down? [
    ask patches with [pycor = round mouse-ycor]
      [ set pcolor black ]
    display
  ]
end

to remove-all-walls
  clear-patches
end

to move-off-wall  ;; turtle procedure
  while [pcolor != black] [
    move-to one-of neighbors
  ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1997 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1997).  NetLogo GenDrift T interact model.
; http://ccl.northwestern.edu/netlogo/models/GenDriftTinteract.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1997 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/GenDriftTinteract
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model is an example of random selection. It shows that turtles that randomly exchange colors converge on a single color.  The idea, explained in more detail in Dennett's ""Darwin's Dangerous Idea"", is that trait drifts can occur without any particular purpose or ""selective pressure"".


HOW IT WORKS
------------
The model starts with a random distribution of colored agents.  Turtles move by wiggling randomly across the world. When two turtles are next to each other, one turtle changes its color to the color of the other one.  Note that if a color dies out, it can never come back.


HOW TO USE IT
-------------
The NUMBER slider sets the number of turtles. The COLORS slider selects the number of competing colors, up to ten.

The SETUP button initializes the model, and GO runs the model.

A monitor shows the percentage of turtles sharing the most common color.  When this reaches 100%, the model stops.

After pressing PLACE-WALLS, the user can ""draw"" walls in the world at the location where the user clicks with the mouse.  By pressing REMOVE-WALLS, the user can remove added walls.  The REMOVE-ALL-WALLS button removes all walls including the border.  (The SETUP button does not remove walls.)


THINGS TO NOTICE
----------------
Gradually a color will gain a slight dominance. By statistical advantage, a dominant color becomes more likely to have more colors like it.  However, because the process is random, there will usually be a series of dominant colors before one color finally wins.


THINGS TO TRY
-------------
Experiment with adding walls.

When walls are added, groups of individuals can be geographically isolated so that they can not interact with their neighbors on the other side of the wall. Groups that are geographically isolated with walls will often end up with a different dominant color than the larger population.  A group of individuals that is walled off becomes a ""founding group"".  The founding group of individuals has a different genetic variability and distribution than the main population, so the frequency of certain traits may end up drifting in a different direction compared with the much larger population.


EXTENDING THE MODEL
-------------------
In this model, a turtle looks one patch to its right.  If there's another turtle there, the ""looking"" turtle changes to that turtle's color.  Since the turtles move randomly about the world, it's a matter of chance which turtle will change to the color of its neighbor.

Think of other rules for turtle interactions, random or otherwise, by which a turtle color might ""take over"".


RELATED MODELS
--------------
GenDrift (P Global)
GenDrift (P local)
GenDrift (T reproduce)


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1997).  NetLogo GenDrift T interact model.  http://ccl.northwestern.edu/netlogo/models/GenDriftTinteract.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1997 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/GenDriftTinteract for terms of use.
"
Bug Hunt Camouflage,/models/Sample Models/Biology/Evolution,";; two breeds of turtle: bugs and predators

breed [bugs bug]
bugs-own [
  red-gene    ;; gene for strength of expressing red pigment (0-100)
  blue-gene   ;; gene for strength of expressing blue pigment (0-100)
  green-gene  ;; gene for strength of expressing green pigment (0-100)
  birthday    ;; when this bug was born
]

breed [predators predator]

globals [
  total-caught                  ;; running total of the total number of bugs caught
  interval-start                ;; what the the tick value was at the start of the
                                ;; current interval
  bugs-in-a-batch               ;; how many bugs must be caught in a batch. when this is reached,
                                ;; the time to reach this (the interval) is recorded
  interval-length               ;; how long it took to catch the last number of bugs-in-a-batch
  caught-in-current-batch       ;; how many bugs have been caught so far in this current interval
  batches                       ;; how many batches have been caught (for plotting)
  adult-age                     ;; the age at which recently hatched bugs become full sized
]


to setup
  clear-all
  set bugs-in-a-batch 10        ;; ten bugs must be caught to make a batch
  set adult-age 2               ;; take 2 seconds to grow to full size
  set-default-shape bugs ""moth""
  set-default-shape predators ""hawk""
  change-environment
  make-initial-bugs
  make-predator
  update-interval-metrics
end


to go
  reset-timer
  grow-bugs
  eat-bugs
  reproduce-bugs
  ;; update the view 20 times a second
  every 0.05 [ display ]
  ;; keep the tick counter in sync with how many seconds have passed.
  ;; we don't only want to count the time that passes while the GO
  ;; button is actually down, so that's why we do RESET-TIMER above,
  ;; so we can measure how time has actually been spent in GO.
  tick-advance timer
  update-interval-metrics
  ;; plotting takes time, so only plot 10 times a second
  every 0.1 [ do-plots ]
end


;;;;;;;;;;;;;;;;;;;
;; Setup Procedures
;;;;;;;;;;;;;;;;;;;

to make-initial-bugs
  create-bugs carrying-capacity [
    set size bug-size
    set birthday (- adult-age)  ;; start at full size
    ;; assign gene frequencies from 0 to 100, where 0 represents 0% expression of the gene
    ;; and 100 represent 100% expression of the gene for that pigment
    set red-gene (random 101)
    set blue-gene (random 101)
    set green-gene (random 101)
    setxy random-xcor random-ycor
    assign-genotype-labels
    set-phenotype-color
  ]
end

;; creates the turtle that will follow the mouse pointer around and
;; represent the predator that the user is controlling
to make-predator
  create-predators 1 [
    set color white
    set size 4
    hide-turtle
  ]
end


;;;;;;;;;;;;;;;;;;;;;
;; Runtime Procedures
;;;;;;;;;;;;;;;;;;;;;

to grow-bugs
  ask bugs [
    ;; show genotypes
    assign-genotype-labels

    ;; grow the newly hatched offspring until they reach their ADULT-AGE,
    ;; at which point they should be the full BUG-SIZE
    let age ticks - birthday
    ifelse age < adult-age
      [ set size bug-size * age / adult-age ]
      [ set size bug-size ]
  ]
end


to eat-bugs
  ;; show the hawk shape under the mouse-pointer
  ask predators [
    set hidden? not mouse-inside?
    setxy mouse-xcor mouse-ycor
  ]
  if mouse-inside? and mouse-down? [
    ;; prey holds an agentset of the bugs that the mouse is close to touching.
    ;; ""close to touching"" is considered to be within a circle that is equal in size to the size
    ;; of the bug.  The shape of the bug may not take up the whole circle, but it takes up most of it.
    let prey bugs with [distance one-of predators < (size / 2)]
    if any? prey [
      set total-caught (total-caught + count prey)
      ;; increment the number of bugs caught in this interval
      set caught-in-current-batch (caught-in-current-batch + count prey)
      ask prey [ die ]
    ]
  ]
end

to reproduce-bugs
;; if the number of bugs in under the carrying capacity, bugs can generate offspring
;; otherwise no new bugs are to replace ones that are eaten
  if not any? bugs [ make-initial-bugs ]
  if count bugs < carrying-capacity [
    ask one-of bugs [ make-one-offspring ]
  ]
end


to update-interval-metrics
  ;; if in this interval-length the user has caught at least the number of bugs required for a batch
  if caught-in-current-batch >= bugs-in-a-batch [
    set caught-in-current-batch 0    ;; the counter for how many are caught in the current
                                     ;; (next) interval-length is reset
    set-current-plot ""Time to Catch 10 Bugs""
    set-plot-pen-color black
    plot (ticks - interval-start)
    set interval-start ticks
  ]
end


;; ask every bug to make one offspring (no carrying-capacity limitations are placed on this)
to make-generation
   ask bugs [ make-one-offspring ]
end


to make-one-offspring ;; turtle procedure
   ;; three possible random mutations can occur, one in each frequency of gene expression
   ;; the max-mutation-step determines the maximum amount the gene frequency can drift up
   ;; or down in this offspring
   let red-mutation   random (max-mutation-step + 1) - random (max-mutation-step + 1)
   let green-mutation random (max-mutation-step + 1) - random (max-mutation-step + 1)
   let blue-mutation  random (max-mutation-step + 1) - random (max-mutation-step + 1)
   hatch 1 [
     set red-gene   limit-gene (red-gene   + red-mutation)
     set green-gene limit-gene (green-gene + green-mutation)
     set blue-gene  limit-gene (blue-gene  + blue-mutation)
     set-phenotype-color
     set birthday ticks
     wander
   ]
end


to wander ;; turtle procedure, makes bugs wander around randomly
   rt random 360
   fd random-float (offspring-distance + 1)
end


;; imposes a threshold limit on gene-frequency.
;; without this genes could drift into negative values or very large values
;; (any value above 100%)
to-report limit-gene [gene]
  if gene < 0   [ report 0   ]
  if gene > 100 [ report 100 ]
  report gene
end

to change-environment
  ;; loads an image as a background from the current directory the model was launched from
  import-drawing environment
end

;; a visualization technique to find bugs if you are convinced they are not there anymore
;; it allows flashing without actually changing and recalculating the color attribute of the bugs
to flash-bugs
  ;; we use ASK-CONCURRENT here instead of ASK because when
  ;; the bugs WAIT, we want them all to wait together, not each
  ;; wait one at a time.
  ask-concurrent bugs [
    let old-color color
    repeat 3 [
      set color black
      display
      wait 0.1
      set color white
      display
      wait 0.1
    ]
    set color old-color
  ]
  display
end


;;;;;;;;;;;;;;;;;;;;;;
;; Visualization procedures
;;;;;;;;;;;;;;;;;;;;;;

to assign-genotype-labels  ;; turtle procedure
  ifelse show-genotype?
    ;; we display the genotype without decimal digits, to make
    ;; the data display of this information less cluttered
    [ set label (word round red-gene ""-""
                      round green-gene ""-""
                      round blue-gene) ]
    [ set label """" ]
end


;;;;;;;;;;;;;;;;;;;;;;
;; Genotype to Phenotype Conversion Procedures
;;;;;;;;;;;;;;;;;;;;;;


;; convert the genetic representation of gene frequency
;; into a phenotype (i.e., a color, using an RGB list
;; instead of a standard NetLogo color)
to set-phenotype-color  ;; turtle procedure
  ;; RGB lists are expected to be in the 0-255 range,
  ;; so we must convert from the 0-100 range in the genotype
  set color (list ((red-gene   / 100) * 255)
                  ((green-gene / 100) * 255)
                  ((blue-gene  / 100) * 255))
end

;;;;;;;;;;;;;;;;;;;;;;
;; Plotting Procedures
;;;;;;;;;;;;;;;;;;;;;;

to do-plots
  set-current-plot ""Bugs Caught vs. Time""
  set-plot-pen-color black
  plotxy ticks total-caught
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2005 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Novak, M. and Wilensky, U. (2005). NetLogo Bug Hunt Camouflage model.
; http://ccl.northwestern.edu/netlogo/models/BugHuntCamouflage.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2005 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/BugHuntCamouflage
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This is a model of natural/artificial selection that shows how a population hunted by a predator can develop camouflaging.  For example, in a forest with green leaves, green bugs may emerge as the predominant bug color.

When a predator uses color and shape to identify the location of prey in an environment, then the colors and patterns in the environment provide additional selective pressure on the prey.  If some prey tend to blend into the background better, they tend to survive longer and reproduce more often.  If this continues over many generations, the distribution of colors in a population may shift to become better camouflaged in the surrounding environment.


HOW IT WORKS
------------
You assume the role of a predator bird.  After you press GO, click on bugs as fast as you can using your mouse.  You may also keep the mouse button depressed, and move the cursor around the world.

You can watch your consumption by watching the ""Bugs Caught vs. Time"" plot.  As its slope decreases, you efficiency (or, in other words, your rate of bug consumption) is decreasing.  Also, the time to catch a batch of bugs is plotted in the ""Time to Catch 10 Bugs"" plot.

Try to consume bugs as fast as possible to remove any ""deliberation"" on your part as a predator.  The camouflaging effect will emerge more clearly if you aren't taking your time trying to find bugs that typically would be more difficult to find.

Bugs have 3 genes that determine their phenotype for color.  One gene is RED-PIGMENT-GENE-FREQUENCY, another is GREEN-PIGMENT-GENE-FREQUENCY, and the last is BLUE-PIGMENT-GENE-FREQUENCY.  The more frequently the gene for a pigment is coded for, the stronger that presence of color is in the overall blend of pigments that results in a single phenotype for coloration (determined by an RGB [Red-Green-Blue] calculation).

With each bug you eat, a new bug is randomly chosen to reproduce one offspring.  The offspring's gene-frequency for each of the three pigment genes may be different than the parent (as determined by the MUTATION-STEP slider).


HOW TO USE IT
-------------
CARRYING-CAPACITY determines the size of the population on SETUP, and how many bugs are in the world at one time when GO is pressed and bugs are being eaten.

MAX-MUTATION-STEP determines how much the pigment genes can drift from their current values in each new generation.  For example, a MUTATION-STEP of 1 means that the gene frequency for any of the three pigments could go up 1, down 1, or not change at all in the offspring.

OFFSPRING-DISTANCE determines how far away (in patches) an offspring could show up from a parent.  For example, a distance of 5 means the offspring could be 0, 1, 2, 3, 4, or 5 patches away from the parent.

BUG-SIZE can be changed at any time during GO or before SETUP to modify the size of the shapes for the bugs.

SHOW-GENOTYPE? reveals the RGB (Red-Green-Blue) gene frequency values for each bug.  The values for Red can range from 0 to 100, and this also true for Green and Blue.  These numbers represent how fully expressed each pigment is (e.g. 40-100-24 would represent genetic information that expresses the red pigment at 40% its maximum value, the green pigment at 100%, and the blue pigment at 24%.

ENVIRONMENT specifies the file name to load as a background image on SETUP or on CHANGE-ENVIRONMENT.  The image file must be located in the same directory as the model.

MAKE-SINGLE-GENERATION creates one offspring from the existing bugs, without being limited by the CARRYING-CAPACITY.

TOTAL-CAUGHT keeps track of how many bugs you have caught.

BUGS IN WORLD keeps track of how many bugs are in the world & view.

The plots ""BUGS CAUGHT VS TIME"" and ""TIME TO CATCH 10 BUGS"" plot your progress and performance as a predator.


THINGS TO NOTICE
----------------
The first thing that you will notice is that, over time, bugs will become harder and harder to detect in the environment.  The completely random mutation process is pushed in a particular direction due to selective pressure which you unintentionally exert on the bugs.

Camouflaging emerges from genes to show color, selective pressure, and small random changes (mutations) that accumulate in the offspring of survivors.


THINGS TO TRY
-------------
Try this model with a user who has never seen it.  A common response from the user (within about 1 minute of interaction with the model) is ""where did the bugs all go?""  If you keep playing with the model, the user might get better at finding the bugs, but if s/he keeps trying to catch bugs quickly, even an experienced user will find that the creatures will become very hard to find in certain environments.

Each new offspring starts at zero size and grows to full size (specified by BUG-SIZE) after a while.  This growth in size is included to make brand new offspring harder to detect.  If newly created offspring were full sized right away, your eyes would more easily detect the sudden appearance of something new.

Sometimes two or more ""near background"" colors emerge as a predominant feature in a population of bugs.  An example of this is the appearance of mostly green and red bugs in the poppy field, or dark blue/black and snow blue in the glacier background.  Other times, the saturation of the bugs appears to be selected for.  An example of this is a common outcome of ""shell colored"" bugs on the seashore background (e.g. light yellow, light tan, and light blue bugs similar to the shells of the seashore).

Larger numbers of bugs tend to take longer to start camouflaging.

In environments that have two distinct areas (such as a ground and sky), each with their own patterns and background colors, you might see two distinct populations of different camouflaging outcomes.  Often, while hunting in one area, you will be surprised to look over at the other area (after they hadn't been paying attention to that area in a while) and notice that now there are a bunch of bugs in that background that blend in this new area very well, but whose colors are distinctly different than those that blend into the original area you were hunting in.

Once you reach a point where you are having trouble finding the bugs, it is useful to either press FLASH to show where they are (and how they are camouflaged), or press CLEAR-BACKGROUND to enable you to study their color distribution and location.


EXTENDING THE MODEL
-------------------
What if you could eat a batch of bugs (e.g. 5 or 10) before they reproduced?

What if bugs reproduced sexually and recombined gene frequencies in their offspring?

What if the position of the bugs changed slightly after each day/night cycle?

Make this model into a HubNet activity and tap into the natural competition between people to better simulate competition between predators.


NETLOGO FEATURES
----------------
IMPORT-DRAWING is the primitive that loads the image into the drawing, which in this case is merely a backdrop instead of something agents actually draw in.

Because this model depends on interaction with the user, we measure the passage of time in seconds.  We use TIMER to measure how much time passes each time through GO, and we use TICK-ADVANCE to advance the clock by that amount.  (A simpler approach would have been to not use the tick counter at all and only use TIMER, but the problem with TIMER is that it keeps advancing even when GO isn't pressed.)

In the code for flashing the bugs, we use ASK-CONCURRENT.  We could have avoided it as follows, but the downside is that an extra turtle variable would have been required.
|  turtles-own [old-color]
|
|  ask bugs [ set old-color color ]
|  repeat 3 [
|    ask bugs [ set color black ]
|    display
|    wait 0.1
|    ask turtles [ set color white ]
|    display
|    wait 0.1
|  ]
|  ask bugs [ set color old-color ]
|  display


RELATED MODELS
--------------
Bug Hunt Speeds
Peppered Moths


CREDITS AND REFERENCES
----------------------
Inspired by this: BugHunt! Macintosh freeware: http://bcrc.bio.umass.edu/BugHunt/

To refer to this model in academic publications, please use:  Novak, M. and Wilensky, U. (2005).  NetLogo Bug Hunt Camouflage model.  http://ccl.northwestern.edu/netlogo/models/BugHuntCamouflage.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2005 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/BugHuntCamouflage for terms of use.
"
Sunflower Biomorphs,/models/Sample Models/Biology/Evolution,";; spawners are hidden turtles at the center of each ""flower"" that
;; are always hatching the petals you actually see
breed [spawners spawner]
breed [petals petal]

globals [
  first-parent     ;; the first parent chosen if sexual reproduction is being used
]

spawners-own [
  num-colors       ;; how many colors the petals will have
  step-size        ;; how fast petals move out (the flower's rate of growth)
  turn-increment   ;; how much each petal is rotated before moving out from
                   ;; the center; for example, a turn-increment of 0 will
                   ;; cause all the petals to move out on the same line
  size-modifier    ;; how quickly the petals grow as they move away from
                   ;; their starting location
]

petals-own [
  step-size        ;; same as for spawners
  size-modifier    ;; same as for spawners
  parent           ;; spawner that spawned this petal; distance from parent
                   ;; is used for calculating the petal's size as it grows
]

to setup
  ca
  create-spawners rows * columns
  [
    set num-colors random 14 + 1
    set step-size random-float 0.5
    set turn-increment random-float 4.0
    set size-modifier random-float 2.0
    hide-turtle        ;; we don't want to see the spawners
  ]
  arrange-spawners
  set first-parent nobody
end

to arrange-spawners
  ;; arrange the spawners around the world in a grid
  let i 0
  while [i < rows * columns]
  [
    ask turtle i
    [
      let x-int world-width / columns
      let y-int world-height / rows
      setxy (-1 * max-pxcor + x-int / 2 + (i mod columns) * x-int)
            (max-pycor + min-pycor / rows - int (i / columns) * y-int)
    ]
    set i i + 1
  ]
end

to go
  ask spawners
  [
    hatch-petals 1
    [
      set parent myself
      set color 10 * (ticks mod ([num-colors] of parent + 1)) + 15
      rt ticks * [turn-increment] of parent * 360
      set size 0
      show-turtle  ;; the petal inherits the hiddenness of its parent,
                   ;; so this makes it visible again
    ]
  ]
  ask petals
  [
    fd step-size
    set size size-modifier * sqrt distance parent
    ;; Kill the petals when they would start interfering with petals from other flowers.
    if abs (xcor - [xcor] of parent) > max-pxcor / (columns * 1.5) [ die ]
    if abs (ycor - [ycor] of parent) > max-pycor / (rows * 1.5) [ die ]
  ]
  tick
  if mouse-down? [ handle-mouse-down ]
end

to repopulate-from-two [parent1 parent2]
  ask petals [ die ]
  ask spawners
  [
    ;;if controlled-mutation? then the mutation a flower experiences is relative to its spawner's who number.
    if controlled-mutation? [set mutation who * 1 / (rows * columns)]

    ;; select one value from either parent for each of the four variables
    set num-colors ([num-colors] of one-of list parent1 parent2) + int random-normal 0 (mutation * 10) mod 15 + (1)
    set step-size ([step-size] of one-of list parent1 parent2) + random-normal 0 (mutation / 5)
    set turn-increment ([turn-increment] of one-of list parent1 parent2) + random-normal 0 (mutation / 20)
    set size-modifier ([size-modifier] of one-of list parent1 parent2) + random-normal 0 mutation

    ;;We clamp size-modifier so none of the sunflowers get too big.
    if size-modifier > 1.5 [set size-modifier 1.5]
  ]
end

to repopulate-from-one [parent1]
  ask petals [ die ]
  ask spawners
  [
    if controlled-mutation? [ set mutation who * 1 / (rows * columns) ]
    set num-colors ([num-colors] of parent1 + int random-normal 0 (mutation * 10)) mod 15 + 1
    set step-size [step-size] of parent1 + random-normal 0 (mutation / 5)
    set turn-increment [turn-increment] of parent1 + random-normal 0 (mutation / 20)
    set size-modifier [size-modifier] of parent1 + random-normal 0 mutation

    ;;We clamp size-modifier so none of the sunflowers get too big.
    if size-modifier > 1.5 [ set size-modifier 1.5 ]
  ]
end

to handle-mouse-down
  ;; get the spawner closest to where the user clicked
  let new-parent min-one-of spawners [distancexy mouse-xcor mouse-ycor]
  ifelse asexual?
  [ repopulate-from-one new-parent ]
  [
    ifelse first-parent != nobody
    [
      repopulate-from-two first-parent new-parent
      set first-parent nobody
      ask patches [ set pcolor black ]
    ]
    [
      set first-parent new-parent
      ask patches
      [
        ;; This is a little tricky; some patches may be equidistant
        ;; from more than one spawner, so we can't just ask for the
        ;; closest spawner, we have to ask for all the closest spawners
        ;; and then see if the clicked spawner is among them
        if member? new-parent (spawners with-min [distance myself])
          [ set pcolor gray - 3 ]
      ]
    ]
  ]
  ;; wait for the user to release mouse button
  while [mouse-down?] [ ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2006 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Nichols, N. and Wilensky, U. (2006). NetLogo Sunflower Biomorphs model.
; http://ccl.northwestern.edu/netlogo/models/SunflowerBiomorphs.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2006 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/SunflowerBiomorphs
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
A model of evolution where the user provides the selective pressure.  The user picks one or two flowers from a grid of randomly generated animated flowers.  The selected flowers become the ""parents"" of the next generation.  Over time, the user's selections cause the characteristics of the population to change.


HOW IT WORKS
------------
Each flower has four genes that determine its form.  For example, one flower may have bigger petals or be more colorful than another.  When the user  selects the parent or parents of the next generation, and the screen is then cleared and the flowers repopulated with genes based on the genes of their parent(s).  The user can exert selection pressure towards colorful flowers, for example, by choosing the most colorful flower(s) available.

At the center of every ""flower"" is an invisible ""spawner"".  It remains in the center continuously hatching ""petals"" that move outward.  Each spawner holds the four variables: num-colors, step-size, size-modifier, and turn-increment.  (Since each petal needs to know how far forward to move each time and how large to grow, they have their own step-size and size-modifier that is identical to the spawner's value that spawned them.)  Each turn, each spawner hatches a new petal and turns and sets its color appropriately (based on the values for num-colors and turn-increment.)  Once the spawners have all hatched a new petal, each petal simply moves forward its step-size and adjusts its size based on the distance its traveled and its size-modifier.  If a petal moves outside the box for that flower, it dies.

The user may choose between asexual (one parent) and sexual (two parents) reproduction.  The next generation is created by mutating the values of the parent(s) for the four variables.  The existing petals are then killed off, and the next generation is created.


HOW TO USE IT
-------------
Before clicking SETUP, set the ROWS and COLUMNS to the desired values.  These determine how many flowers are present in the model.

Then set the mutation rate appropriately.  The higher the mutation rate, the less flowers in the next generation will resemble their parents.  If CONTROLLED-MUTATION? is on, then the model controls the mutation by varying it within the population; in this mode, mutation varies among the individuals in the population; where the amount of MUTATION increases in each individual that is to the right of the previous one (or in the next row).  Thus, flowers near the top-left of the model will tend to more closely resemble their parents than flowers in the bottom right.

If asexual selection is selected (the ASEXUAL? switch is on), then every click will repopulate the flowers based on the values of the spawner nearest your click.  If sexual selection is selected, then the first click selects the first parent (and colors its background grey.)  When you click again, the two clicked spawners ""mate"" and populate the next generation.


THINGS TO TRY
-------------
Try and get certain flowers patterns to emerge; for example, try to selectively breed towards a very tight spiral, a non-rotating ""starfish"", or a straight line.

Remember a particularly pleasing flower, then clear all of the flowers, and see if you can evolve your favorite flower again.


EXTENDING THE MODEL
-------------------
It might be neat to allow the user to change the number of flowers while the model is running.  For example, changing the model from a 2x2 grid to a 3x3 grid might put five new flowers into the population, all based on the previously selected parent.

Change the way the parents' genes are passed on in sexual reproduction and how they are expressed.


NETLOGO FEATURES
----------------
This model uses invisible spawners to keep track of each flower.

There is a little geometry trickiness in correctly spacing the flowers in the setup procedure.


RELATED MODELS
--------------
Sunflower


CREDITS AND REFERENCES
----------------------
This model is loosely based on the Biomorphs discussed at length in Richard Dawkins' ""The Blind Watchmaker"" (1986).

In Dawkins' original model, the user was presented with a series of ""insects"" that were drawn based on nine separate values.  For example, if insect A has a ""leg-length"" value of 2 and insect B has a ""leg-length"" value of 1, then insect A would be drawn with longer legs.  These 9 variables were thus the genotype of each insect-like creature, and the drawing based on those numbers was the phenotype.  If the user clicked on an insect (or ""biomorph""), then all the insects would be erased and the chosen biomorph would be used as the basis for a new population of biomorphs.  Each variable would be mutated slightly in the new generation (representing the inheriting of a slightly higher or lower value for the genotype), and these mutated values would be used in the new population of the biomorphs.  In this manner, the new generation of  biomorphs resembled the previously chosen biomorph, with some variation.  For example, if you chose a biomorph with an exceptionally long abdomen, then, because they are all modified versions of the chosen biomorph, biomorphs in the next generation would tend to have longer abdomens than previously.

In this model, ""flowers"" are used as the biomorphs instead of the insect-like creatures Dawkins used; furthermore, these biomorphs only vary among four variables--num-color, step-size, size-modifier, and turn-increment--and not nine.  The idea is very similar, though.  The user is presented with a number of flowers.  By clicking on a flower, the user can choose the type of flower that will populate the next generation.  If ASEXUAL? is false, the user picks two biomorphs instead of just one; the next generation will be produced by selecting one the values for each of the four genotype variables from either one of the parents.

Thanks to Nate Nichols for his work on this model.

To refer to this model in academic publications, please use:  Nichols, N. and Wilensky, U. (2006).  NetLogo Sunflower Biomorphs model.  http://ccl.northwestern.edu/netlogo/models/SunflowerBiomorphs.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2006 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/SunflowerBiomorphs for terms of use.
"
Cooperation,/models/Sample Models/Biology/Evolution,"turtles-own [ energy ]
patches-own [ grass ]

breed [ cooperative-cows cooperative-cow ]
breed [ greedy-cows greedy-cow ]

to setup
  ca
  setup-cows
  ask patches [
    set grass max-grass-height
    color-grass
  ]
  do-plotting
end

to setup-cows
  set-default-shape turtles ""cow""   ;; applies to both breeds
  crt initial-cows [
    setxy random-xcor random-ycor
    set energy metabolism * 4
    ifelse (random-float 1.0 < cooperative-probability) [
      set breed cooperative-cows
      set color pink
    ] [
      set breed greedy-cows
      set color blue
    ]
  ]
end

to go
  ask turtles [
    move
    eat
    reproduce
  ]
  ask patches [
    grow-grass
    color-grass
  ]
  tick
  do-plotting
end

to reproduce  ;; turtle procedure
  if (energy > reproduction-threshold) [
    set energy energy - reproduction-cost
    hatch 1
  ]
end

to grow-grass  ;; patch procedure
  ifelse ( grass >= low-high-threshold) [
    if (high-growth-chance >= (random-float 100)) [
      set grass grass + 1
    ]
  ][
    if (low-growth-chance >= (random-float 100)) [
      set grass grass + 1
    ]
  ]
  if (grass > max-grass-height) [
    set grass max-grass-height
  ]
end

to color-grass  ;; patch procedure
  set pcolor scale-color green grass 0 (2 * max-grass-height)
end

to move  ;; turtle procedure
  rt random-float 360
  fd stride-length
  set energy energy - metabolism
  if (energy < 0) [ die ]
end

to eat  ;; turtle procedure
  ifelse breed = cooperative-cows [
    eat-cooperative
  ] [
    if breed = greedy-cows [
      eat-greedy
    ]
  ]
end

to eat-cooperative  ;; turtle procedure
  if (grass > low-high-threshold) [
    set grass grass - 1
    set energy energy + grass-energy
  ]
end

to eat-greedy  ;; turtle procedure
  if (grass > 0) [
    set grass grass - 1
    set energy energy + grass-energy
  ]
end

to do-plotting
  set-current-plot ""Cows over time""
  set-current-plot-pen ""cooperative""
  plot count cooperative-cows
  set-current-plot-pen ""greedy""
  plot count greedy-cows
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Cooperation model.
; http://ccl.northwestern.edu/netlogo/models/Cooperation.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Cooperation
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model (and Altruism and Divide the Cake) are part of the EACH curriculum: ""Evolution of Altruistic and Cooperative Habits: Learning About Complexity in Evolution"".  See http://ccl.northwestern.edu/cm/EACH/ for more information.

This is an evolutionary biology model.  In it, agents (cows) compete for natural resources (grass).  Cows that are more successful in getting grass reproduce more often, and will thus be more evolutionarily successful.  This model includes two kinds of cows, greedy and cooperative.  It shows how these two different strategies do when competing against each other within a population that evolves over time.


HOW IT WORKS
------------
Every turn, each cow looks at the patch that it is currently on, and eats a unit of grass.  The greedy cows eat the grass regardless of the length of the grass on the current patch.  The cooperative cows won't eat the grass below a certain height.  This behavior is significant because below a certain height (called the ""growth threshold""), the grass grows at a far slower rate than above it.  Thus, the cooperative agents leave more food for the overall population at a cost to their individual well-being, while the greedy agents eat the grass down to the nub, regardless of the effect on the overall population.


HOW TO USE IT
-------------
GO: Starts and stops the model.

SETUP: Resets the simulation according to the parameters set by the sliders.

INITIAL-COWS: Sets the number of initial cows.

COOPERATIVE-PROBABILITY: Sets the chance an initial cow will be of the cooperative breed

STRIDE-LENGTH: This value determines the movement of the cows. Each cow will move forward STRIDE-LENGTH patches each turn.  As the value is increased, the cows will move to other patches more frequently.

GRASS-ENERGY: Each time a cow can eat some grass from the patch that it currently occupies, it increases its energy by the value of this slider.

METABOLISM: Every time step, each cow loses the amount of energy set by this slider.  If the cows energy reaches 0, it dies.  Every cow starts with a default energy of 50, which means it can go 50 / METABOLISM turns without eating.

REPRODUCTION-THRESHOLD: If a cow's energy reaches the value of this slider, it reproduces.  This value represents the food-gathering success that a cow would have to have in order to be able to reproduce.

REPRODUCTION-COST: Each time a cow reproduces, it loses the amount of energy set by this slider.  This value represents the energy cost of reproduction.

LOW-GROWTH-CHANCE: This value is the percentage chance that the grass below the growth threshold will grow back.  The higher this value, the less the discrepancy between the behaviors of the cooperative and greedy cows.

HIGH-GROWTH-CHANCE: This value is the percentage chance that the grass above the growth threshold will grow back.  The lower this value, the less the discrepancy between the behaviors of the cooperative and greedy cows.

MAX-GRASS-HEIGHT:  This value sets the highest length to which the grass can grow.

LOW-HIGH-THRESHOLD:  This value sets the grass growth threshold.  At, or above this value, the grass grows back with HIGH-GROWTH-CHANCE.  Below this value, the grass grows back with LOW-GROWTH-CHANCE.


THINGS TO NOTICE
----------------
Run the model with the default settings.  Watch the different growth curves on the population plot.  Which population expands first?  Which population wins in the end?


THINGS TO TRY
-------------
Slowly decrease the STRIDE-LENGTH slider. What happens to the populations?

At what value of STRIDE-LENGTH do the populations' growth rates change dramatically?  What does this indicate about the evolutionary advantages of Cooperating versus being Greedy?  What are the important environmental factors?

Change the METABOLISM and the GRASS-ENERGY values.  How do these values affect the model?

Change the LOW-GROWTH-CHANCE and the HIGH-GROWTH-CHANCE values.  How do these values affect the model?

How does the LOW-HIGH-THRESHOLD value affect the growth of the populations?

Can you find settings that maximize the advantage of the cooperative cows?


EXTENDING THE MODEL
-------------------
This model explores only one type of cooperative behavior, namely eating the grass above the growth threshold (the LOW-HIGH-THRESHOLD value).  What other cooperative, or altruistic, behaviors could be modeled that hurt individual fitness, while helping the group overall?  What other environmental conditions than grass length could be used to effect the health of a population?

This model relies primarily upon population ""viscosity"" (the STRIDE-LENGTH slider) to alter the behavior of the cows to allow for the success of the cooperative agents.  What other variables could have such a drastic effect on the evolutionary success of populations?

Also, consider that in this model the behaviors are fixed.  What would happen if the agents learned, or changed their behavior based on food availability?



NETLOGO FEATURES
----------------
Note how cows are created in the SETUP-COWS procedure. This is done to prevent NetLogo from giving one breed an advantage (as a result of the way NetLogo simulates parallel computations on a serial processor).  When a turtle is created, it is assigned an id number (stored in the turtle variable WHO) that is used by NetLogo to reference it.  When ASK is used, NetLogo gives each turtle a turn in order of their id numbers, from smallest to largest.  So if we had written SETUP-COWS like this:

|    to setup-cows
|      ...
|      create-greedy-cows num-greedy [ ... ]
|      create-cooperative-cows num-cooperative [ ... ]
|    end

then the initial greedy cows will all have id numbers that are lower than those of the initial cooperative cows, since id numbers are assigned in order.  This means the greedy cows will eat and reproduce first.  Theoretically this gives them an advantage.  As it happens, in most runs, the random movement of the cows would prevent this from having a significant effect on the model behavior.  Nonetheless, in the real code we intermingle the creation of the two types of cows in order to avoid any bias.

Future versions of NetLogo may support other scheduling methods besides ""in order by id number"".


RELATED MODELS
--------------
Altruism


CREDITS AND REFERENCES
-----------------------
This model and the Altruism model are part of the curriculum ""Evolution of Altruistic and Cooperative Habits: Learning About Complexity in Evolution"".  See http://ccl.northwestern.edu/cm/EACH/ for more information.

Thanks to Damon Centola, Eamon McKenzie, Josh Mitteldorf, and Scott Styles.

To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Cooperation model.  http://ccl.northwestern.edu/netlogo/models/Cooperation.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Cooperation for terms of use.
"
Peppered Moths,/models/Sample Models/Biology/Evolution,"breed [ moths moth ] ;; might extend the model with other breeds: birds, bugs, etc.

moths-own [
  age               ;; moth's age: 0, 1 = young (can't reproduce), 2, 3 = mature (can reproduce), > 3 = old (can't reproduce)
]

globals [
  light-moths       ;; number of moths in the lightest third of possible colors
  medium-moths      ;; number of moths in the medium third of possible colors
  dark-moths        ;; number of moths in the darkest third of possible colors
  darkness          ;; darkness (pollution) level in the world
  darkening?        ;; is the world getting darker (more polluted)?
]

;; reports color value that reflects current pollution level.
;; 1 = black. 9 = white. color = white - darkness. darkness range: 0 - 8. color range: 1 - 9.
to-report env-color
  report 9 - darkness
end

;; reports numerical color change value that reflects user's speed % choice.
to-report delta-env
  report (speed / 100)
end

;; generates random color integers in black-white range (1-9)
to-report random-color
  report ((random 9) + 1)
end

;; reports maximum moth population for a given environment
to-report upper-bound
  report (4 * num-moths)
end

to setup
  ca
  setup-world
  setup-moths
  setup-plotting

  update-monitors
  update-plots
end

to setup-world
  set darkness 0
  set darkening? true ;; world starts out clean - can only get polluted
  ask patches [ set pcolor env-color ]
end

to setup-moths
  create-moths num-moths
  [
    set color random-color
    moths-pick-shape
    set age (random 3) ;; start out with random ages
    setxy random-xcor random-ycor
  ]
end

to setup-plotting
  set-current-plot ""Moth Colors Over Time""
  set-plot-y-range 0 upper-bound
end

to go
  ask moths [
    moths-mate
    moths-grim-reaper
    moths-get-eaten
    moths-age
  ]
  if cycle-pollution? [
    cycle-pollution
  ]
  tick
  update-monitors
  update-plots
end

;; asexual reproduction - moths just hatch other moths
to moths-mate ;; moth procedure
  if (age = 2 or age = 3) [
    hatch 2 [
      if (random-float 100.0 < mutation) [
    ifelse ((random 2 = 0)) [ ;; flip a coin -- darker or lighter?
      set color (round (color + ((random-float mutation) / 12.5)))
      if (color >= 9) [
        set color 9
      ]
    ][
      set color (round (color - ((random-float mutation) / 12.5 )))
      if (color <= 1) or (color >= 130) [  ;; to prevent color from wrapping
        set color 1
      ]
    ]
      ]
      moths-pick-shape
      set age 0
      rt random-float 360.0
      fd 1 ;; move away from your parent so you can be seen
    ]
  ]
end

;; we have a range of 'well-camouflaged-ness', dependent on the rate of selection
to moths-get-eaten ;; moth procedure
  if (random-float 1000.0 < ((selection * (abs (env-color - color))) + 200)) [
    die
  ]
end

;; disease, children, entomologists, etc...
;; the moth's world is a cruel place.
to moths-grim-reaper ;; moth procedure
  if ((random 13) = 0) [
    die
  ]

  ;; population overshoot / resource scarcity
  if ((count moths) > upper-bound) [
    if ((random 2) = 0) [
      die
    ]
  ]
end

to moths-age ;; moth procedure
  set age (age + 1)
end


to moths-pick-shape ;; moth procedure
  ifelse (color < 5 ) [
    set shape ""moth dark""
  ][
    set shape ""moth light""
  ]
end

to update-monitors
  ;; colors range from 1 - 9. dark moths = 1-3. medium moths = 4-6. light moths = 7-9.
  set light-moths (count moths with [color >= 7])
  set dark-moths (count moths with [color <= 3])
  set medium-moths (count moths - (light-moths + dark-moths))
end

to update-plots
  set-current-plot-pen ""Light""
  plot light-moths

  set-current-plot-pen ""Medium""
  plot medium-moths

  set-current-plot-pen ""Dark""
  plot dark-moths

  set-current-plot-pen ""Pollution""
  plot ((upper-bound / 3) * darkness / 8)
end

;; single pollution step. called by cycle-pollution. can also be invoked by ""pollute"" button.
to pollute-world
  ifelse (darkness <= (8 - delta-env)) [ ;; can the environment get more polluted?
    set darkness (darkness + delta-env)
    ask patches [ set pcolor env-color ]
  ][
    set darkening? false
  ]
end

;; single de-pollution step. called by cycle-pollution. can also be invoked by ""clean up"" button.
to clean-up-world
  ifelse (darkness >= (0 + delta-env)) [ ;; can the environment get cleaner?
    set darkness (darkness - delta-env)
    ask patches [ set pcolor env-color ]
  ][
    set darkening? true
  ]
end


;; world dims, then lightens, all in lockstep
;; a monochrome world is best for this, because otherwise it'd be very
;; difficult to tell what is a moth and what is a patch
to cycle-pollution
  ifelse (darkening? = true) [
    pollute-world
  ][
    clean-up-world
  ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Peppered Moths model.
; http://ccl.northwestern.edu/netlogo/models/PepperedMoths.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/PepperedMoths
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This project models a classic example of natural selection - the peppered moths of Manchester, England. The peppered moths use their coloration as camouflage from the birds that would eat them. (Note that in this model, the birds act invisibly.) Historically, light-colored moths predominated because they blended in well against the white bark of the trees they rested on.

However, due to the intense pollution caused by the Industrial Revolution, Manchester's trees became discolored with soot, and the light-colored moths began to stick out, while the dark-colored moths blended in. Consequently, the darker moths began to predominate.

Now, in the past few decades, pollution controls have helped clean up the environment, and the trees are returning to their original color. Hence, the lighter moths are once again thriving at expense of their darker cousins.

This model simulates these environmental changes, and how a population of moths, initially of all different colors, changes under the pressures of natural selection.

HOW TO USE IT
-------------
The NUM-MOTHS slider controls how many moths are initially present in the world. Their coloration is randomly distributed over the possible colors of the world (white to black). Simply select how many moths you'd like to begin with (around 200 is good), and press the SETUP button. Then press the GO button to begin the simulation.

The MUTATION slider controls the rate of mutation at birth. For the purposes of the simulation, the mutation rate is much higher than it might be in real life. When MUTATION is set to 0, moths are exactly the same as the parent that hatched them. When it is set to 100, there is no correlation between a parent's color and the color of its children. (Best results are seen when MUTATION is set to around 10 or 15, but experiment with the rate and watch what happens.)

The SELECTION slider determines how moths are harvested by the birds that feed on them. SELECTION wraps up nicely many factors that determine the survivability of a species - how many birds there are, how hungry they are, and just how important camouflage is to escaping predation. SELECTION provides a probabilistic window - the lower the level of the slider, the wider this window. At 0, a moth's color ceases to matter. At 100, a moth needs to be perfectly camouflaged to avoid being seen (and thus devoured). You might first try running the model with SELECTION set to around 50.

The POLLUTE and CLEAN UP once-buttons, along with the CYCLE-POLLUTION? switch, control the pollution levels in the environment. To watch the cycle described above - from clean environment to industrial revolution to pollution control - set CYCLE-POLLUTION? to on. To directly manipulate the pollution levels in the environment, set CYCLE-POLLUTION? to off, and use the POLLUTE and CLEAN UP buttons to add and remove pollution from the environment.

The SPEED slider controls just how rapidly pollution levels change. As you might guess, 1 is slow, and 100 is fast. A good speed to start with is 10.

Finally, 'Peppered Moths' uses six monitors, all of which are straightforward. TICKS reports how much time has elapsed. TOTAL MOTHS displays how many moths are present in the world. LIGHT MOTHS, MEDIUM MOTHS, and DARK MOTHS report the total numbers of moths with each color gradation. The moth population is just divided into thirds over the range of colors. POLLUTION reports the pollution level in the environment on a scale from 0% (no pollution) to 100% (maximum pollution).

THINGS TO NOTICE
----------------
The most important thing to watch is how the entire set of moths seems to change color over time. Let the model run by itself the first time - watch the world change from white to black back to white. Then see how manipulating the sliders effects the populations of moths.

Notice that during the first few initial time-steps, the moth population booms. You might then see the moth population fluctuate between different levels, some of which are quite large. The moths give birth to many offspring, but the world in which they live is finite - it has finite space and resources. If the population exceeds the available resources (carrying capacity), the moths tend die a lot faster than they would otherwise. Under normal circumstances, the average population will tend to stay constant, at a level dependent on the speed and selection rates.

Watch what happens when a drastic change in the environment occurs. (You can force this with the POLLUTE-WORLD and CLEAN-UP-WORLD buttons.) Can you kill off all of the moths in a matter of a few time-steps?

You can watch the ratios between the types of moths change either in the monitors, or graphically in the plot. The yellow line represents the lighter-colored moths, the green line represents the intermediate moths, and the blue line represents the darker-colored moths.

THINGS TO TRY
-------------
How do different levels of mutation and selection change the population? How does the speed of the model effect the rate at which the moths change? Is there a speed at which the moths can't keep up, i.e. the world changes faster than small pockets of discolored moths or mutants can help keep the population up to size?

The upper-bound for the moth population is defined as a global variable, 'upper-bound'. It is initially set to 4 * the moth population, but you can change it and watch what happens.

EXTENDING THE MODEL
-------------------
'Peppered Moths' is a nice introduction into modeling genetic and evolutionary phenomena. The code is fairly simple, and divided up into several small procedures that handle the different stages of each generation. This makes it easy for other extensions to be added to the model.

Each moth has one gene that effectively determines its survivability under current conditions. This is a turtle variable, simply the turtle's color. Add the concept of the recessive gene to 'Peppered Moths'- each moth might have two color genes (additional turtle variables), that together determine its color. Moths will then need to seek out mates, and use sexual reproduction as opposed to the unnatural asexual reproduction we see here.

NETLOGO FEATURES
-----------------
Note that all of the commands given to the moths are in a block of code that begins 'ask moths [...]'. This is because each moth is given a breed, 'moths'. This makes the code far easier to modify, especially if you want to add a different kind of animal, say, the birds that eat the moths. You would then add a new breed, 'birds', and put all code that birds are to execute in the body of 'ask birds [...]'.

CREDITS AND REFERENCES
----------------------
The peppered moths of Manchester, England as a case study in natural selection were originally studied by British scientist H. B. D. Kettlewell.

In 1998, Michael Majerus of the University of Cambridge re-examined Kettlewell's work and found that though his experimental design was questionable in some respects, his conclusions were likely correct nonetheless.  In any case, the mechanism of natural selection illustrated by this model is not in doubt.

To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Peppered Moths model.  http://ccl.northwestern.edu/netlogo/models/PepperedMoths.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/PepperedMoths for terms of use.
"
Echo,/models/Sample Models/Biology/Evolution,"globals [
  energy-threshold    ;; minimum amount of energy needed by creatures to reproduce
  all-tags            ;; sorted list of all possible tags
]

patches-own [
  well      ;; the amount of resources a patch has
  max-well  ;; the max amount of resources for that patch
]

turtles-own [
  energy    ;; current resource level
  offense   ;; offense tag
  defense   ;; defense tag
  mating    ;; mating tag (can be thought of as identifying a species)
]

to setup
  clear-all
  set energy-threshold 100
  setup-all-tags-list
  setup-patches
  setup-plots
  setup-creatures
  do-plots
end

;; Creates a list of all possible tags (of length 1, 2, or 3)
to setup-all-tags-list
  ;; we use FPUT to build up the lists since it's more efficient
  ;; than LPUT
  set all-tags []
  let tag-elements [""a"" ""b"" ""c""]
  foreach tag-elements
  [
    let i ?
    set all-tags fput (list ?) all-tags
    foreach tag-elements [
      let j ?
      set all-tags fput (list i ?) all-tags
      foreach tag-elements
        [ set all-tags fput (list i j ?) all-tags ]
    ]
  ]
  ;; as a result of using FPUT the result is in backwards order
  set all-tags reverse all-tags
end

to setup-patches
  ask patches [
    set max-well random 50
    set well max-well
    recolor-patch
  ]
end

to setup-creatures
  create-turtles init-num-creatures
  [
    setxy random-xcor random-ycor
    set offense one-of all-tags
    set defense one-of all-tags
    set mating one-of all-tags
    set size 0.5   ;; since the patch size is so big make the turtles smaller
    set energy random energy-threshold
    recolor-turtle
  ]
end

to recolor-turtle  ;; turtle procedure
  set color tag-color mating
  set label reduce [word ?1 ?2] (sentence offense ""."" defense)
end

to-report tag-color [tag]
  report 5 + 10 * position tag all-tags
end

to recolor-patch  ;; patch procedure
   set pcolor scale-color green well 0 100
end

to setup-plots
  set-current-plot ""Species Counts""
  set-plot-x-range 0 length all-tags
  set-current-plot ""Offense Tags""
  set-plot-x-range 0 length all-tags
  set-current-plot ""Defense Tags""
  set-plot-x-range 0 length all-tags
end

to go
  if not any? turtles [ stop ]
  ask patches [ replenish ]
  ask turtles [ grab-resources ]
  ask turtles [ fight ]
  ask turtles [ reproduce ]
  ask turtles [ move ]
  ask turtles [ replicate ]
  ask patches [ recolor-patch ]
  do-plots
  tick
end

to replenish  ;; patch procedure
  if well < max-well [
    set well well + ((max-well - well) * (replenish-speed / 100))
  ]
end

;; Get resources from the environment, if you need them.  You don't fight for these,
;; but instead they are shared with other agents in the same location.
to grab-resources    ;; turtle procedure
  if (energy < energy-threshold) and (well > 0) [
    set energy energy + ( well / count turtles-here )
    set well well - ( well / count turtles-here )
  ]
end

;; Try to get resources from another agent at your location.
;; This is done by comparing tags.
;; We compare id numbers to prevent the same pair from fighting
;; twice during the same tick.
to fight  ;; turtle procedure
  let candidates turtles-here with [self > myself]
  if any? candidates [ match-off-def self one-of candidates ]
end

;; if there are any other agents at your location, reproduce with them
;; We compare id numbers to prevent the same pair from fighting
;; twice during the same tick.
to reproduce   ;; turtle procedure
  let candidates turtles-here with [self > myself]
  if any? candidates [ reproduce-match self one-of candidates ]
end

to move  ;; turtle procedure
  set energy energy - 1
  ifelse energy < 20
    [ die ]
    [ rt random-normal 0 20
      fd random-float 1 ]
end

to replicate   ;; creature procedure
  if energy > energy-threshold and random-float 100 < replicate-chance
  [
    set energy energy / 2  ;; give half of your energy to your offspring
    hatch 1
  ]
end

;; Creates offspring from mating, including selective mating
to reproduce-match [agent1 agent2]
  if ( [energy] of agent1 > energy-threshold ) and
     ( [energy] of agent2 > energy-threshold )
  [
    if (not selective-mating?) or
        ( ( match-score [mating] of agent1 [offense] of agent2 > mating-selectivity ) and
          ( match-score [mating] of agent2 [offense] of agent1 > mating-selectivity ) )
    [
      hatch 1
      [
        set mating mutate cross [mating] of agent1 [mating] of agent2
        set offense mutate cross [offense] of agent1 [offense] of agent2
        set defense mutate cross [defense] of agent1 [defense] of agent2
        setxy random-xcor random-ycor
        set energy random-normal 50 20
        recolor-turtle
      ]
      ask agent1 [ set energy energy / 2 ]
      ask agent2 [ set energy energy / 2 ]
    ]
  ]
end

;; This crosses tags during reproduction by walking through
;; each position of the string.  When the letters from each tag differ at a position
;; there is an equal chance of it being either one.  When the tags are different lengths,
;; the additional letters are just appended on to the tage of the offspring.
to-report cross [tag1 tag2]
  if length tag1 > length tag2
    [ report sentence cross sublist tag1 0 length tag2 tag2 sublist tag1 length tag2 length tag1 ]
  if length tag2 > length tag1
    [ report sentence cross tag1 sublist tag2 0 length tag1 sublist tag2 length tag1 length tag2 ]
  report (map [one-of (list ?1 ?2)] tag1 tag2)
end

;; Mutates a given string
to-report mutate [tag]
  report map [ifelse-value (random-float 100 >= mutation-rate)
                [?] [one-of remove ? [""a"" ""b"" ""c""]]]
             tag
end

;; This procedure determines how resources are transferred between
;; agents.  The offense tag of an agent1 is matched with the defense
;; tag of agent 2, and the offense tag of agent2 is matched with the
;; defense tag of agent1.
to match-off-def [agent1 agent2]

  ;; match respective offense and defense tags
  let a1a2 match-score [offense] of agent1  [defense] of agent2
  let a2a1 match-score [offense] of agent2  [defense] of agent1

  ;; scale resulting scores so that all values are positive
  set a1a2 a1a2 + 6
  set a2a1 a2a1 + 6

  ;; Determine how much resource is transferred between the agents.
  ;; Each agent takes from the other based on the relative magnitude
  ;; of its match score
  set a1a2 (a1a2 / 12) * ([energy] of agent2)
  set a2a1 (a2a1 / 12) * ([energy] of agent1)

  ;; You win some, you lose some.
  ask agent1 [ set energy energy + a1a2 - a2a1 ]
  ask agent2 [ set energy energy + a2a1 - a1a2 ]

end

;; This reports a score that represents how well tag 1 matches tag 2.
;; The match takes places letter by letter -- the first
;; letters of each tag are compared, then the second letters, and so on.
;; An adjustment is made for unequal length tags.The resulting ""match-score""
;; is ultimately used to help determine how resources are transferred between agents
;; or the extent to which a potential mate matches an agent's mating conditions
to-report match-score [tag1 tag2]
  if length tag1 > length tag2
    [ report (length tag2 - length tag1) + match-score sublist tag1 0 length tag2 tag2 ]
  if length tag2 > length tag1
    [ report (length tag1 - length tag2) + match-score tag1 sublist tag2 0 length tag1 ]
  report sum (map [ifelse-value (?1 = ?2) [2] [-2]] tag1 tag2)
end

to do-plots
  set-current-plot ""Species Counts""
  ;; The HISTOGRAM primitive doesn't support giving different bars
  ;; different colors, so we roll our own histogramming code here.
  plot-pen-reset
  foreach all-tags [
    set-plot-pen-color tag-color ?
    plot count turtles with [mating = ?]
  ]

  set-current-plot ""Speciation""
  set-current-plot-pen ""species""
  plot length remove-duplicates [mating] of turtles
  set-current-plot-pen ""offense""
  plot length remove-duplicates [offense] of turtles
  set-current-plot-pen ""defense""
  plot length remove-duplicates [defense] of turtles

  set-current-plot ""Offense Tags""
  histogram [position offense all-tags] of turtles
  set-current-plot ""Defense Tags""
  histogram [position defense all-tags] of turtles

  set-current-plot ""populations""
  set-current-plot-pen ""largest species""
  let biggest-mating modes [mating] of turtles
  ifelse (length biggest-mating > 0)
  [
    set-plot-pen-color first modes [color] of turtles with [first biggest-mating = mating]
    plot count turtles with [first biggest-mating = mating]
    set-current-plot-pen ""2nd largest""
    let second-mating modes [mating] of turtles with [first biggest-mating != mating]
    ifelse (length second-mating > 0 )
    [
      set-plot-pen-color first modes [color] of turtles with [first second-mating = mating]
      plot count turtles with [first second-mating = mating]
    ]
    [ plot 0 ]
   ]
   [ plot 0 ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2005 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2005).  NetLogo Echo model.
; http://ccl.northwestern.edu/netlogo/models/Echo.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2005 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Echo
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
Echo is a model about the evolution of fitness, adapted from John Holland's book ""Hidden Order"" (1995).  It can be used to facilitate experiments in a variety of domains where an agent's fitness varies with its context.  This particular adaptation of Echo  has a biological flavor and refers to the agents as ""creatures"", and groups of agents with identical mating preferences as ""species.""

With Echo, Holland attempted to codify intuitions about complex adaptive systems into a more rigorous and abstract model.  Holland was inspired by notions from ecological systems research, especially with regards to the dynamics of niches.  How does a change in the population dynamics of an ecosystem create new niches and destroy old ones?  Echo was an attempt to create an abstract model that could facilitate understanding of the interplay of evolutionary and ecological processes.  In Echo, different niches are created where creatures can consume, transform, and exchange resources, but this model is not necessarily just a biological model it can also be viewed as a model of other phenomena like the emergence of new markets.

It should be noted that Echo as laid out in ""Hidden Order"" is not meant to be a specific model, but rather a framework for building models.  There are a number of mechanisms that are not fully specified in ""Hidden Order"" and the description includes multiple different mechanisms that can be implemented.  As a result, there is no model which is ""the Echo model"" there can only be ""an Echo model.""  This NetLogo Echo model is one particular instantiation of this framework.


HOW IT WORKS
------------
Each agent, or creature, has two components -- a reservoir to keep resources it collects, and a chromosome that contains its genetic material and defines its capabilities.

A creature expends resources moving around the world looking for resources.  A creature can gain resources either directly from its environment, or from another creature at its current location.

The amount of resources gained from its environment depends on the amount of available resources and the number of other creatures at its current location.

The amount of resources gained from another creature depends on the match between the creatures' chromosomes.  More precisely, a creature's chromosome is compromised of three ""tags"" -- an offense tag, a defense tag, and a mating condition tag -- which are represented by strings of ""a's"", ""b's"" and ""c's"".  The amount transferred from one creature to another depends on how closely the first creature's offense tag matches the second creature's defense tag.  However, all interactions, or ""fights"", between creatures are two-way exchanges -- i.e., both agents match their offense tags to the other's defense tag.  Consequently, resources can be either gained or lost on any given interaction with another agent.  For example, offense tag ""aaa"" of creature 1 to defense tag ""aaa"" of creature 2 would be a perfect match. It would entitle creature 1 to all of creature 2 resources, but the second creature could possible get some, or even all of the resources back based on the match of his offense tag to the other agent's defense tag.

If an agent's resource level drops below a minimum threshold, it dies.

An agent can only reproduce if it has acquired a minimum level of resources.  Reproduction occurs in two ways:  1) simple replication, as determined by the REPLICATE-CHANCE slider, in which case the replicated agent is identical to the parent, and 2) mating with other agents.  By default, an agent can mate with any other agent, resulting in an offspring that contains a mixed set of elements, or a ""cross"", of both parent's chromosomes.  If the SELECTIVE-MATING? switch is enabled, an agent will not mate with just anyone, but instead only mate with agents whose offense tags match its own mating condition tag.  The similarity between the mating tag and offense tag necessary for a match to occur is determined by the MATING-SELECTIVITY slider.  With either process, it is possible that the characteristics of offspring are not an exact copy or cross of the parents' chromosomes.  Mutations can occur at a rate determined by the MUTATION-RATE slider.


HOW TO USE IT
-------------
Click the SETUP button to setup the world, then click the GO button.  The agents will begin to move, exchange resources, and reproduce.  The sliders allow you to change each of the parameters of the model as described below.  The plots provide an update on the composition of the populations of agents.

The agents are colored by mating tags.  Identical mating tags share the same color; mating tags that are close are similar in color; and so on.  Each creature has its offense and defense tags as its label in the format ""offense-tag.defense-tag"".  For example, a label of ""aab.bcc"" represents a creature with an offense tag of ""aab"" and defense tag of ""bcc.""

The model includes the following parameters:

NUM-CREATURES - The number of agents with which to start the simulation.

REPLENISH-SPEED - The speed at which the resources in the environment replenish.

REPLICATE-CHANCE - The chance that a creature with sufficient energy will replicate.

SELECTIVE-MATING? - If 'Off' it is possible for agents to mate with any other agent that has enough energy to reproduce.  If 'On' agents will only mate with other agent's whose offense tag matches their own mating tag.

MATING-SELECTIVITY?  - Determines how close a similar a mating tag and offense tag must be in order for two agents to mate.  Higher, positive numbers are more selective.  '0' is the midpoint.

MUTATION-RATE - The rate at which a letter in the offense or defense tags of offspring may change during replication.

Here are descriptions of all the plots in the model:

""Offense Tags"" - A histogram of the number of each offense tag currently in existence.

""Defense Tags"" - A histogram of the number of each defense tag currently in existence.

""Species Counts"" - A histogram of the number of each species currently alive.  A species is defined as a group of agents that share an identical mating tag.

""Populations"" - This shows the number of creatures in the two largest species currently in the world.

""Speciation"" - This shows the current total number of different species, the total number of different offense tags, and the total number of different defense tags in the world.

Some other options are described below in THINGS TO TRY.


THINGS TO NOTICE
----------------
Populations often become dynamically stable with several species of oscillating population levels.

Increasing the initial NUM-CREATURES slider does not necessarily result in a larger stable population, indeed the opposite may occur as creatures compete for limited resources.


THINGS TO TRY
-------------
Change REPLENISH-SPEED to examine the impact of making resources more scarce.

See what impact increasing or lowering the MUTATION-RATE and/or switching SELECTIVE-MATING? 'On' has on the number of species that ultimately survive in situation with dynamically stable populations.


EXTENDING THE MODEL
-------------------
Add a mechanism that allows selective interaction for the exchange of resources, in addition to selective mating.

Resources could be more nuanced than the simple ""energy"" variable.  Certain locations in the environment could give off certain resources.  For example, every creature might need at least one ""c"" resource to live, but only certain wells might give resources of type ""c"".  Furthermore, resources could be transformed.  For example, one ""a"" and two ""b's"" could be turned into a ""c"" for some cost.

Currently the exchange of resources between two agents is a fight -  a zero-sum exchange.  However, this interaction could be changed to an interaction where both parties can become better off -- a situation that resembles a trade more than a fight.

Holland describes several additional extensions in some detail in Chapter 3 of Hidden Order.


EXTENDING THE MODEL (CATERPILLAR-FLY-ANT)
-----------------------------------------
Holland discusses an interesting example from nature that can be imitated in Echo -- the Caterpillar-Fly-Ant triangle.  The triangle refers to the stable, triangular relation between the three different species: Species 1 --  Flies lay eggs on caterpillars and become prey through their larva.  Species 2 -- Ants are aggressive pretenders on the flies, but not of caterpillars.  Species 3 -- Caterpillars produce nectar on their skin which ants find very attractive.  The more ants around a caterpillar the less likely it is to be attacked by a predatory fly.  This can be represented in Echo with the following tags:
| ant - offense: aaa, defense: cb
| fly - offense: aab, defense: aaa
| caterpillar - offense: c, defense: aab

Notice that the ants' offense tag matches perfectly with the fly's defense tag, making it a perfect predatory on the fly.  Likewise, the fly's offense tag matches perfectly on the caterpillar making it a perfect predator on the caterpillar.  The ant consumes the nectar of the caterpillar but does not prey on the caterpillar; thus, the ant and caterpillar have tags that result in an exchange of resources.

Try replicating this scenario.  You'll probably want to set SELECTIVE-MATING? to on and MATING-SELECTIVITY to a high value such as 5.  Is it possible to achieve a stable relationship between the three species?  (Are changes to the parameters and/or the rules of the model necessary...?)

To get you started, here's some code for creating a roughly equal number of the three species.  (You may want to experiment with different initial proportions.)  The mating tags are completely different, to discourage interspecies mating.

|   create-turtles init-num-creatures
|   [
|     let choice random 3
|     if choice = 0  ; ant
|     [
|       set offense [""a"" ""a"" ""a""]
|       set defense [""c"" ""b""]
|       set mating  [""a"" ""a"" ""a""]
|     ]
|     if choice = 1  ; fly
|     [
|       set offense [""a"" ""a"" ""b""]
|       set defense [""a"" ""a"" ""a""]
|       set mating  [""b"" ""b"" ""b""]
|     ]
|     if choice = 2  ; caterpillar
|     [
|       set offense [""c""]
|       set defense [""a"" ""a"" ""b""]
|       set mating  [""c"" ""c"" ""c""]
|     ]
|  ]


NETLOGO FEATURES
----------------
Tags are represented by lists of strings, so the code is heavily dependent on lists.  MAP, REDUCE, and FOREACH are used to do list processing.


RELATED MODELS
--------------
Sample Models > Biology > Evolution > (entire section)
Sample Models > Biology > Rabbits Grass Weeds
Sample Models > Biology > Wolf Sheep Predation


CREDITS AND REFERENCES
----------------------
Holland, J. (1995). Hidden Order: How Adaptation Builds Complexity. Addison-Wesley, Reading, Massachusetts.

To refer to this model in academic publications, please use:  Wilensky, U. (2005).  NetLogo Echo model.  http://ccl.northwestern.edu/netlogo/models/Echo.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2005 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Echo for terms of use.
"
AIDS,/models/Sample Models/Biology,"globals [
  infection-chance  ;; The chance out of 100 that an infected person will pass on
                    ;;   infection during one week of couplehood.
  symptoms-show     ;; How long a person will be infected before symptoms occur
                    ;;   which may cause the person to get tested.
  slider-check-1    ;; Temporary variables for slider values, so that if sliders
  slider-check-2    ;;   are changed on the fly, the model will notice and
  slider-check-3    ;;   change people's tendencies appropriately.
  slider-check-4
]

turtles-own [
  infected?          ;; If true, the person is infected.  It may be known or unknown.
  known?             ;; If true, the infection is known (and infected? must also be true).
  infection-length   ;; How long the person has been infected.
  coupled?           ;; If true, the person is in a sexually active couple.
  couple-length      ;; How long the person has been in a couple.
  ;; the next four values are controlled by sliders
  commitment         ;; How long the person will stay in a couple-relationship.
  coupling-tendency  ;; How likely the person is to join a couple.
  condom-use         ;; The percent chance a person uses protection.
  test-frequency     ;; Number of times a person will get tested per year.
  partner            ;; The person that is our current partner in a couple.
]

;;;
;;; SETUP PROCEDURES
;;;

to setup
  ca
  setup-globals
  setup-people
  setup-plot
  update-plot
end

to setup-globals
  reset-ticks
  set infection-chance 50    ;; if you have unprotected sex with an infected partner,
                             ;; you have a 50% chance of being infected
  set symptoms-show 200.0    ;; symptoms show up 200 weeks after infection
  set slider-check-1 average-commitment
  set slider-check-2 average-coupling-tendency
  set slider-check-3 average-condom-use
  set slider-check-4 average-test-frequency
end

;; Create carrying-capacity number of people half are righty and half are lefty
;;   and some are sick.  Also assigns colors to people with the ASSIGN-COLORS routine.

to setup-people
  crt initial-people
    [ setxy random-xcor random-ycor
      set known? false
      set coupled? false
      set partner nobody
      ifelse random 2 = 0
        [ set shape ""person righty"" ]
        [ set shape ""person lefty"" ]
      ;; 2.5% of the people start out infected, but they don't know it
      set infected? (who < initial-people * 0.025)
      if infected?
        [ set infection-length random-float symptoms-show ]
      assign-commitment
      assign-coupling-tendency
      assign-condom-use
      assign-test-frequency
      assign-color ]
end

;; Different people are displayed in 3 different colors depending on health
;; green is not infected
;; blue is infected but doesn't know it
;; red is infected and knows it

to assign-color  ;; turtle procedure
  ifelse not infected?
    [ set color green ]
    [ ifelse known?
      [ set color red ]
      [ set color blue ] ]
end

;; The following four procedures assign core turtle variables.  They use
;; the helper procedure RANDOM-NEAR so that the turtle variables have an
;; approximately ""normal"" distribution around the average values set by
;; the sliders.

to assign-commitment  ;; turtle procedure
  set commitment random-near average-commitment
end

to assign-coupling-tendency  ;; turtle procedure
  set coupling-tendency random-near average-coupling-tendency
end

to assign-condom-use  ;; turtle procedure
  set condom-use random-near average-condom-use
end

to assign-test-frequency  ;; turtle procedure
  set test-frequency random-near average-test-frequency
end

to-report random-near [center]  ;; turtle procedure
  let result 0
  repeat 40
    [ set result (result + random-float center) ]
  report result / 20
end

;;;
;;; GO PROCEDURES
;;;

to go
  if all? turtles [known?]
    [ stop ]
  check-sliders
  ask turtles
    [ if infected?
        [ set infection-length infection-length + 1 ]
      if coupled?
        [ set couple-length couple-length + 1 ] ]
  ask turtles
    [ if not coupled?
        [ move ] ]
  ;; Righties are always the ones to initiate mating.  This is purely
  ;; arbitrary choice which makes the coding easier.
  ask turtles
    [ if not coupled? and shape = ""person righty"" and (random-float 10.0 < coupling-tendency)
        [ couple ] ]
  ask turtles [ uncouple ]
  ask turtles [ infect ]
  ask turtles [ test ]
  ask turtles [ assign-color ]
  tick
  update-plot
end

;; Each tick a check is made to see if sliders have been changed.
;; If one has been, the corresponding turtle variable is adjusted

to check-sliders
  if (slider-check-1 != average-commitment)
    [ ask turtles [ assign-commitment ]
      set slider-check-1 average-commitment ]
  if (slider-check-2 != average-coupling-tendency)
    [ ask turtles [ assign-coupling-tendency ]
      set slider-check-2 average-coupling-tendency ]
  if (slider-check-3 != average-condom-use)
    [ ask turtles [ assign-condom-use ]
      set slider-check-3 average-condom-use ]
  if (slider-check-4 != average-test-frequency )
    [ ask turtles [ assign-test-frequency ]
      set slider-check-4 average-test-frequency ]
end

;; People move about at random.

to move  ;; turtle procedure
  rt random-float 360
  fd 1
end

;; People have a chance to couple depending on their tendency to have sex and
;; if they meet.  To better show that coupling has occurred, the patches below
;; the couple turn gray.

to couple  ;; turtle procedure -- righties only!
  let potential-partner one-of (turtles-at -1 0)
                          with [not coupled? and shape = ""person lefty""]
  if potential-partner != nobody
    [ if random-float 10.0 < [coupling-tendency] of potential-partner
      [ set partner potential-partner
        set coupled? true
        ask partner [ set coupled? true ]
        ask partner [ set partner myself ]
        move-to patch-here ;; move to center of patch
        move-to patch-here ;; partner moves to center of patch
        set pcolor gray - 3
        ask (patch-at -1 0) [ set pcolor gray - 3 ] ] ]
end

;; If two peoples are together for longer than either person's commitment variable
;; allows, the couple breaks up.

to uncouple  ;; turtle procedure
  if coupled? and (shape = ""person righty"")
    [ if (couple-length > commitment) or
         ([couple-length] of partner) > ([commitment] of partner)
        [ set coupled? false
          set couple-length 0
          ask partner [ set couple-length 0 ]
          set pcolor black
          ask (patch-at -1 0) [ set pcolor black ]
          ask partner [ set partner nobody ]
          ask partner [ set coupled? false ]
          set partner nobody ] ]
end

;; Infection can occur if either person is infected, but the infection is unknown.
;; This model assumes that people with known infections will continue to couple,
;; but will automatically practice safe sex, regardless of their condom-use tendency.
;; Note also that for condom use to occur, both people must want to use one.  If
;; either person chooses not to use a condom, infection is possible.  Changing the
;; primitive to AND in the third line will make it such that if either person
;; wants to use a condom, infection will not occur.

to infect  ;; turtle procedure
  if coupled? and infected? and not known?
    [ if random-float 11 > condom-use or
         random-float 11 > ([condom-use] of partner)
        [ if random-float 100 < infection-chance
            [ ask partner [ set infected? true ] ] ] ]
end

;; People have a tendency to check out their health status based on a slider value.
;; This tendency is checked against a random number in this procedure. However, after being infected for
;; some amount of time called SYMPTOMS-SHOW, there is a 5% chance that the person will
;; become ill and go to a doctor and be tested even without the tendency to check.

to test  ;; turtle procedure
  if random-float 52 < test-frequency
    [ if infected?
        [ set known? true ] ]
  if infection-length > symptoms-show
    [ if random-float 100 < 5
        [ set known? true ] ]
end

;;;
;;; PLOTTING PROCEDURES
;;;

to setup-plot
  set-current-plot ""Populations""
  set-plot-y-range 0 (initial-people + 50)
end

to update-plot
  set-current-plot ""Populations""
  set-current-plot-pen ""HIV-""
  plot count turtles with [not infected?]
  set-current-plot-pen ""HIV?""
  plot count turtles with [infected?] -
       count turtles with [known?]
  set-current-plot-pen ""HIV+""
  plot count turtles with [known?]
end

;;;
;;; MONITOR PROCEDURES
;;;

to-report %infected
  ifelse any? turtles
    [ report (count turtles with [infected?] / count turtles) * 100 ]
    [ report 0 ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo AIDS model.
; http://ccl.northwestern.edu/netlogo/models/AIDS.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/AIDS
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model simulates the spread of the human immunodeficiency virus (HIV), via sexual transmission, through a small isolated human population.  It therefore illustrates the effects of certain sexual practices across a population.

As is well known now, HIV is spread in a variety of ways of which sexual contact is only one.  HIV can also be spread by needle-sharing among injecting drug-users, through blood transfusions (although this has become very uncommon in countries like the United States in which blood is screened for HIV antibodies), or from HIV-infected women to their babies either before or during birth, or afterwards through breast-feeding.  This model focuses only on the spread of HIV via sexual contact.

The model examines the emergent effects of four aspects of sexual behavior.  The user controls the population's tendency to practice abstinence, the amount of time an average ""couple"" in the population will stay together, the population's tendency to use condoms, and the population's tendency to get tested for HIV.  Exploration of the first and second variables may illustrate how changes in sexual mores in our society have contributed to increases in the prevalence of sexually transmitted diseases, while exploration of the third and fourth may provide contemporary solutions to the problem.

By allowing the user to control how often an average individual will choose to be tested, the user can explore an important dimension of HIV's threat to public health.  Because the virus does not make itself immediately known in its host, individuals are often infected for some time before a test or immune deficiency symptoms (which leads to a test) identifies them as such.  Regular identification of individuals infected by the virus could have significant public health impacts if knowledge of the infection positively affected sexual behaviors.  This model explores this possibility by making all individuals who know of their positive HIV status always practice safe sex.


HOW TO USE IT
-------------
The model uses ""couples"" to represent two people engaged in sexual relations.  Individuals wander around the world when they are not in couples.  Upon coming into contact with a suitable partner, there is a chance the two individuals will ""couple"" together.  When this happens, the two individuals no longer move about, they stand next to each other holding hands as a representation of two people in a sexual relationship.

The presence of the virus in the population is represented by the colors of individuals.  Three colors are used: green individuals are uninfected, blue individuals are infected but their infection is unknown, and red individuals are infected and their infection is known.

The SETUP button creates individuals with particular behavioral tendencies according to the values of the interface's five sliders (described below).  Once the simulation has been setup, you are now ready to run it, by pushing the GO button.  GO starts the simulation and runs it continuously until GO is pushed again.  During a simulation initiated by GO, adjustments in sliders can affect the behavioral tendencies of the population.

A monitor shows the percent of the population that is infected by HIV.  In this model each time-step is considered one week; the number of weeks that have passed is shown in the toolbar.

Here is a summary of the sliders in the model.  They are explained in more detail below.

- INITIAL-PEOPLE: How many people simulation begins with.
- AVERAGE-COUPLING-TENDENCY: General likelihood member of population has sex (0-10).
- AVERAGE-COMMITMENT: How many weeks sexual relationships typically lasts (0-200).
- AVERAGE-CONDOM-USE: General chance member of population uses a condom. (0-10).
- AVERAGE-TEST-FREQUENCY: Average frequency member of population will check their HIV status in a 1-year time period (0 - 2).

The total number of individuals in the simulation is controlled by the slider INITIAL-PEOPLE (initialized to vary between 50 - 500), which must be set before SETUP is pushed.

During the model's setup procedures, all individuals are given ""tendencies"" according to four additional sliders.  These tendencies are generally assigned in a normal distribution, so that, for instance, if a tendency slider is set at 8, the most common value for that tendency in the population will be 8.  Less frequently, individuals will have values 7 or 9 for that tendency, and even less frequently will individuals have values 6 or 10 (and so on).

The slider AVERAGE-COUPLING-TENDENCY (0 - 10) determines the tendency of the individuals to become involved in couples (as stated earlier, all couples are presumed to be sexually active). When the AVERAGE-COUPLING-TENDENCY slider is set at zero, coupling is unlikely, although (because tendencies are assigned in a normal distribution) it is still possible.  Note that when deciding to couple, both individuals involved must be ""willing"" to do so, so high coupling tendencies in two individuals are actually compounded (i.e. two individuals with a 50% chance of coupling actually only have a 25% of coupling in a given tick).

The slider AVERAGE-COMMITMENT (1 - 200) determines how long individuals are likely to stay in a couple (in weeks).  Again, the tendencies of both individuals in a relationship are considered; the relationship only lasts as long as is allowed by the tendency of the partner with a shorter commitment tendency.

The slider AVERAGE-CONDOM-USE (0 - 10) determines the tendency of individuals in the population to practice safe sex.  If an individual uses a condom, it is assumed in this model that no infection by HIV is possible.  Note that this tendency (like the others) is probabilistic at several levels.  For instance, when AVERAGE-CONDOM-USE is set to 9, most of the individuals have a CONDOM-USE value of 9, although some have CONDOM-USE values of 8 or 10, and fewer yet have CONDOM-USE values of 7 or 11 (11 would be off-scale and the same as 10 for all practical purposes).  Also, an individual with a CONDOM-USE value of 9 will still sometimes not choose to use a condom (10% of the time, roughly). Simulation of condom-use is further complicated by the fact that if one partner ""wants"" to use a condom while the other partner does not, the couple does not use condoms.  This characteristic of the model is representative of the dynamics of some sexual relations, but not others.  The decision was somewhat arbitrary, and the user is invited to play with this characteristic and others in the ""Extending the Model"" section of this tab.

The slider AVERAGE-TEST-FREQUENCY (0 - 2) is the final slider of the interface.  It determines the average frequency of an individual to get tested for HIV in a one-year time span.  Set at 1.0, the average person will get tested for HIV about once a year.  Set at 0.2, the average individual will only get tested about every five years.  This tendency has significant impact because the model assumes that individuals who know that they are infected always practice safe sex, even if their tendency as healthy individuals was different.  Again, this characteristic of the model is only represented of the behaviors of some individuals.  The model was designed in this way to highlight the public health effects associated with frequent testing *and* appropriate responses to knowledge of one's HIV status.  To explore the impact of alternative behaviors on public health, the model code can be changed relatively painlessly.  These changes are described in the section, ""Extending the Model.""

The model's plot draws a line graph showing the total number of uninfected individuals (green), infected individuals whose positive status is not known (blue), and infected individuals whose positive status is known (red).


THINGS TO NOTICE
----------------
Set the INITIAL-PEOPLE slider to 300, AVERAGE-COUPLING-TENDENCY to 10, AVERAGE-COMMITMENT to 100, and the other two sliders to 0. Push SETUP and then push GO.  Notice that many individuals rapidly pair up into stationary ""couples"", with the patches behind them turned a dark gray.  These couples represent sexual activity between the two individuals.  Individuals that continue to move about (and do not have a gray patch behind them) are not engaging in sexual relations.  With RELATIONSHIP-DURATION set to 100, an average individual will have monogamous sexual relations with a partner for about 100 weeks (approximately 2 years) before ending the sexual relationship and searching out a new partner.

Stop the simulation (by pressing the GO button once again), move the AVERAGE-COUPLING-TENDENCY slider to 0, push SETUP, and start the simulation again (with the GO button).  Notice that this time, couples are not forming.  With a low COUPLING-TENDENCY, individuals do not choose to have sex, which in this model is depicted by the graphical representation of couplehood.  Notice that with these settings, HIV does not typically spread. However, spreading could happen since the population's tendency is set according to a normal distribution and a few people will probably have COUPLING-TENDENCY values above 0 at this setting.

Again reset the simulation, this time with AVERAGE-COUPLING-TENDENCY set back to 10 and AVERAGE-COMMITMENT set to 1.  Notice that while individuals do not stand still next to each other for any noticeable length of time, coupling is nevertheless occurring.  This is indicated by the occasional flash of dark gray behind individuals that are briefly next to one another.  Notice that the spread of HIV is actually faster when RELATIONSHIP-DURATION is very short compared to when it is very long.

Now run a simulation with AVERAGE-COMMITMENT equal to 1, AVERAGE-COUPLING-TENDENCY set to 1, AVERAGE-CONDOM-USE set to 10, and AVERAGE-TEST-FREQUENCY set to 1.0. With negligible couple formation and high condom use anyway, there should be no spread of HIV.  Notice how pale blue ""infection unknown"" individuals turn red much quicker in this simulation.  When the individuals turn red, they know their HIV status.  Some individuals turn red because they have been infected for long enough that they develop symptoms, which alerts them to the need for an HIV test.  Others become red because they choose to be tested.  With AVERAGE-TEST-FREQUENCY set to 1.0, healthy individuals are also being tested, but their color does not change since the tests come back negative.

When all the individuals in the simulation are either green or red, change the sliders without stopping the simulation.  Set AVERAGE-COUPLING-TENDENCY to 10, AVERAGE-COMMITMENT to 100, AVERAGE-CONDOM-USE to 0, and AVERAGE-TEST-FREQUENCY to 0.  Notice that despite the immediate formation of couples and the fact that condom-use tendency is presumably very low, some between healthy (green) individuals and infected (red) individuals, no spread of HIV occurs.  This is because while the model expects HIV positive individuals to continue to engage in sexual relations, it presumes that those individuals will always use condoms and that the condoms will always work.  The rationale for this design is discussed briefly in the ""What is it?"" section of this tab.

Finally, set INITIAL-PEOPLE to 500 to notice that couples can form on top of each other.  Watch the simulation until you see individuals by themselves, but standing still and with a gray patch behind them indicating coupling.  Underneath one of its neighbors, is the individuals partner.  This apparent bug in the program is necessary because individuals need to be able to couple fairly freely.  If space constraints prohibited coupling, unwanted emergent behavior would occur with high population densities.

Couples are formed by a partnership of ""righty"" and ""lefty"" shapes which is not immediately noticeable.  These shapes are not intended to represent genders in any fashion, but merely to provide a useful way to depict couple graphics. In order for the hands of a righty and lefty to match up, both must be off-centered in their patch.  Without this feature, two couples next to each other would appear to be a line of four individuals (instead of two groups of two).  It is intended that the differences between righty and lefty shapes not be especially apparent in order to prevent unintended associations with gender.  Any righty or lefty shape can be thought of as male or female or neither.


THINGS TO TRY
-------------
Run a number of experiments with the GO button to find out the effects of different variables on the spread of HIV.  Try using good controls in your experiment.  Good controls are when only one variable is changed between trials.  For instance, to find out what effect the average duration of a relationship has, run four experiments with the AVERAGE-COMMITMENT slider set at 1 the first time, 2 the second time, 10 the third time, and 50 the last.  How much does the prevalence of HIV increase in each case?  Does this match your expectations?

Are the effects of some slider variables mediated by the effects of others?  For instance, if lower AVERAGE-COMMITMENT values seem to increase the spread of HIV when all other sliders are set at 0, does the same thing occur if all other sliders are set at 10?  You can run many experiments to test different hypotheses regarding the emergent public health effects associated with individual sexual behaviors.


EXTENDING THE MODEL
-------------------
Like all computer simulations of human behaviors, this model has necessarily simplified its subject area substantially.  The model therefore provides numerous opportunities for extension:

The model depicts sexual activity as two people standing next to each other.  This suggests that all couples have sex and that abstinence is only practiced in singlehood.  The model could be changed to reflect a more realistic view of what couples are.  Individuals could be in couples without having sex.  To show sex, then, a new graphical representation would have to be employed.  Perhaps sex could be symbolized by having the patches beneath the couple flash briefly to a different color.

The model does not distinguish between genders.  This is an obvious over-simplification chosen because making an exclusively heterosexual model was untenable while making one that included a variety of sexual preferences might have distracted from the public health issues which it was designed to explore.  However, extending the model by adding genders would make the model more realistic.

The model assumes that individuals who are aware that they are infected always practice safe sex.  This portrayal of human behavior is clearly not entirely realistic, but it does create interesting emergent behavior that has genuine relevance to certain public health debate.  However, an interesting extension of the model would be to change individuals' reactions to knowledge of HIV status.

The model assumes that condom use is always 100% effective.  In fact, responsible condom use is actually slightly less than ideal protection from the transmission of HIV.  Add a line of code to the INFECT procedure to check for a slight random chance that a particular episode of condom-use is not effective.  Another change that can be made in the INFECT procedure regards a couple's choice of condom-use.  In this model, when the two partners of a couple ""disagree"" about whether or not to use a condom, the partner that doesn't wish to use a condom makes the choice.  The opposite possibility is also valid.

Finally, certain significant changes can easily be made in the model by simply changing the value of certain global variables in the procedure SETUP-GLOBALS.  Two variables set in this procedure that are especially worthy of investigation are INFECTION-CHANCE and SYMPTOMS-SHOW.  The former controls what chance an infection has of spreading from an infected to an uninfected partner if no protection is used.  The variable is currently set to 50, meaning that in a week of sexual relations, the chance of infection occurring is 50%.  It is not clear at this time how realistic that figure is. SYMPTOMS-SHOW is the variable that controls how long, on average, a person will have the HIV virus before symptoms begin to appear, alerting that person to the presence of some health problem.  It is currently set to 200 (weeks) in this model.


NETLOGO FEATURES
-----------------
Notice that the four procedures that assign the different tendencies generate many small random numbers and add them together.  This produces a normal distribution of tendency values.  A random number between 0 and 100 is as likely to be 1 as it is to be 99. However, the sum of 20 numbers between 0 and 5 is much more likely to be 50 than it is to be 99.

Notice that the global variables SLIDER-CHECK-1, SLIDER-CHECK-2, and so on are assigned with the values of the various sliders so that the model can check the sliders against the variables while the model is running.  Every time-step, a slider's value is checked against a global variable that holds the value of what the slider's value was the time-step before.  If the slider's current value is different than the global variable, NetLogo knows to call procedures that adjust the population's tendencies.  Otherwise, those adjustment procedures are not called.


CREDITS AND REFERENCES
----------------------
Special thanks to Steve Longenecker for model development.

To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo AIDS model.  http://ccl.northwestern.edu/netlogo/models/AIDS.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/AIDS for terms of use.
"
Slime,/models/Sample Models/Biology,"patches-own [chemical]

to setup
  clear-all
  crt population
  [ set color red
    set size 2  ;; easier to see
    setxy random-xcor random-ycor ]
  ask patches [ set chemical 0 ]
end

to go
  ask turtles
  [ if chemical > sniff-threshold                  ;; ignore pheromone unless there's enough here
      [ turn-toward-chemical ]
    rt random-float wiggle-angle - random-float wiggle-angle + wiggle-bias
    fd 1
    set chemical chemical + 2 ]                    ;; drop chemical onto patch
  diffuse chemical 1                               ;; diffuse chemical to neighboring patches
  ask patches
  [ set chemical chemical * 0.9                    ;; evaporate chemical
    set pcolor scale-color green chemical 0.1 3 ]  ;; update display of chemical concentration
  tick
end

to turn-toward-chemical  ;; turtle procedure
  ;; examine the patch ahead of you and two nearby patches;
  ;; turn in the direction of greatest chemical
  let ahead [chemical] of patch-ahead 1
  let myright [chemical] of patch-right-and-ahead sniff-angle 1
  let myleft [chemical] of patch-left-and-ahead sniff-angle 1
  ifelse (myright >= ahead) and (myright >= myleft)
  [ rt sniff-angle ]
  [ if myleft >= ahead
    [ lt sniff-angle ] ]
    ;; default: don't turn
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2000.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Slime model.
; http://ccl.northwestern.edu/netlogo/models/Slime.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Slime
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This project is inspired by the aggregation behavior of slime-mold cells. It shows how creatures can aggregate into clusters without the control of a ""leader.""

In this example, each turtle drops a chemical pheromone (shown in green). The turtles also ""sniff"" ahead, trying to follow the gradient of other turtles' chemicals. Meanwhile, the patches diffuse and evaporate the pheromone. Following these simple, decentralized rules, the turtles aggregate into clusters.


HOW TO USE IT
-------------
Click the SETUP button to set up a collection of slime-mold cells. Click the GO button to start the simulation.

The POPULATION slider controls the number of slime mold cells in the simulation. Changes in the POPULATION slider do not have any effect until the next SETUP command.

The other sliders affect the way turtles move. Changes to them will immediately affect the model run.

SNIFF-THRESHHOLD -- The minimum amount of chemical that must be present in a turtle's patch before the turtle will look for a chemical gradient to follow. This parameter causes the turtles to aggregate only when there are enough other cells nearby. The default value is 1.0.

SNIFF-ANGLE -- The amount, in degrees, that a turtle turns to the left and right to check for greater chemical concentrations. The default value is 45.

WIGGLE-ANGLE -- The maximum amount, in degrees, that a turtle will turn left or right in its random movements. When WIGGLE-ANGLE is set to zero, the turtle will remain at the same heading until it finds a chemical gradient to follow. The default value is 40.

WIGGLE-BIAS -- The bias of a turtle's average wiggle. When WIGGLE-BIAS = 0, the turtle's average movement is straight ahead. When WIGGLE-BIAS > 0, the turtle will tend to move more right than left. When BIAS < 0, the turtle will tend to move more left than right. The default value is 0.

There are several other critical parameters in the model that are not accessible by sliders. They can be changed by modifying the code in the procedures window.  They are:
- the evaporation rate of the chemical -- set to 0.9
- the diffusion rate of the chemical -- set to 1
- the amount of chemical deposited at each step -- set to 2


THINGS TO NOTICE
----------------
With 100 turtles, not much happens. The turtles wander around dropping chemical, but the chemical evaporates and diffuses too quickly for the turtles to aggregate.

With 400 turtles, the result is quite different. When a few turtles happen (by chance) to wander near one another, they create a small ""puddle"" of chemical that can attract any number of other turtles in the vicinity. The puddle then becomes larger and more attractive as more turtles enter it and deposit their own chemicals. This process is a good example of positive feedback: the more turtles, the larger the puddle; and the larger the puddle, the more likely it is to attract more turtles.


THINGS TO TRY
-------------
Try different values for the SNIFF-THRESHOLD, SNIFF-ANGLE, WIGGLE-ANGLE, and WIGGLE-BIAS sliders. How do they affect the turtles' movement and the formation of clumps?

Change the SNIFF-ANGLE and WIGGLE-ANGLE sliders after some clumps have formed. What happens to the clumps? Try the same with SNIFF-THRESHOLD and WIGGLE-BIAS.


EXTENDING THE MODEL
-------------------
Modify the program so that the turtles aggregate into a single large cluster.

How do the results change if there is more (or less) randomness in the turtles' motion?

Notice that the turtles only sniff for chemical in three places: forward, SNIFF-ANGLE to the left, and SNIFF-ANGLE to the right. Modify the model so that the turtles sniff all around. How does their clustering behavior change? Modify the model so that the turtles sniff in even fewer places. How does their clustering behavior change?

What ""critical number"" of turtles is needed for the clusters to form? How does the critical number change if you modify the evaporation or diffusion rate?

Can you find an algorithm that will let you plot the number of distinct clusters over time?


NETLOGO FEATURES
----------------
Note the use of the PATCH-AHEAD, PATCH-LEFT-AND-AHEAD, and PATCH-RIGHT-AND-AHEAD primitives to do the ""sniffing"".


RELATED MODELS
--------------
Ants uses a similar idea of creatures that both drop chemical and follow the gradient of the chemical.


CREDITS AND REFERENCES
----------------------
This model was developed at the MIT Media Lab.  See Resnick, M. (1994) ""Turtles, Termites and Traffic Jams: Explorations in Massively Parallel Microworlds.""  Cambridge, MA: MIT Press.  Adapted to StarLogoT, 1998, as part of the Connected Mathematics Project.  Adapted to NetLogo, 2000, as part of the Participatory Simulations Project.

To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Slime model.  http://ccl.northwestern.edu/netlogo/models/Slime.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Slime for terms of use.
"
Flocking,/models/Sample Models/Biology,"turtles-own [
  flockmates         ;; agentset of nearby turtles
  nearest-neighbor   ;; closest one of our flockmates
]

to setup
  clear-all
  crt population
    [ set color yellow - 2 + random 7  ;; random shades look nice
      set size 1.5  ;; easier to see
      setxy random-xcor random-ycor ]
end

to go
  ask turtles [ flock ]
  ;; the following line is used to make the turtles
  ;; animate more smoothly.
  repeat 5 [ ask turtles [ fd 0.2 ] display ]
  ;; for greater efficiency, at the expense of smooth
  ;; animation, substitute the following line instead:
  ;;   ask turtles [ fd 1 ]
  tick
end

to flock  ;; turtle procedure
  find-flockmates
  if any? flockmates
    [ find-nearest-neighbor
      ifelse distance nearest-neighbor < minimum-separation
        [ separate ]
        [ align
          cohere ] ]
end

to find-flockmates  ;; turtle procedure
  set flockmates other turtles in-radius vision
end

to find-nearest-neighbor ;; turtle procedure
  set nearest-neighbor min-one-of flockmates [distance myself]
end

;;; SEPARATE

to separate  ;; turtle procedure
  turn-away ([heading] of nearest-neighbor) max-separate-turn
end

;;; ALIGN

to align  ;; turtle procedure
  turn-towards average-flockmate-heading max-align-turn
end

to-report average-flockmate-heading  ;; turtle procedure
  ;; We can't just average the heading variables here.
  ;; For example, the average of 1 and 359 should be 0,
  ;; not 180.  So we have to use trigonometry.
  ;; Theoretically this could fail if both sums are 0
  ;; since atan 0 0 is undefined, but in practice that's
  ;; vanishingly unlikely.
  report atan sum [sin heading] of flockmates
              sum [cos heading] of flockmates
end

;;; COHERE

to cohere  ;; turtle procedure
  turn-towards average-heading-towards-flockmates max-cohere-turn
end

to-report average-heading-towards-flockmates  ;; turtle procedure
  ;; ""towards myself"" gives us the heading from the other turtle
  ;; to me, but we want the heading from me to the other turtle,
  ;; so we add 180
  report atan mean [sin (towards myself + 180)] of flockmates
              mean [cos (towards myself + 180)] of flockmates
end

;;; HELPER PROCEDURES

to turn-towards [new-heading max-turn]  ;; turtle procedure
  turn-at-most (subtract-headings new-heading heading) max-turn
end

to turn-away [new-heading max-turn]  ;; turtle procedure
  turn-at-most (subtract-headings heading new-heading) max-turn
end

;; turn right by ""turn"" degrees (or left if ""turn"" is negative),
;; but never turn more than ""max-turn"" degrees
to turn-at-most [turn max-turn]  ;; turtle procedure
  ifelse abs turn > max-turn
    [ ifelse turn > 0
        [ rt max-turn ]
        [ lt max-turn ] ]
    [ rt turn ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2002.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Flocking model.
; http://ccl.northwestern.edu/netlogo/models/Flocking.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Flocking
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model is an attempt to mimic the flocking of birds.  (The resulting motion also resembles schools of fish.)  The flocks that appear in this model are not created or led in any way by special leader birds.  Rather, each bird is following exactly the same set of rules, from which flocks emerge.

The birds follow three rules: ""alignment"", ""separation"", and ""cohesion"".  ""Alignment"" means that a bird tends to turn so that it is moving in the same direction that nearby birds are moving.  ""Separation"" means that a bird will turn to avoid another bird which gets too close.  ""Cohesion"" means that a bird will move towards other nearby birds (unless another bird is too close).  When two birds are too close, the ""separation"" rule overrides the other two, which are deactivated until the minimum separation is achieved.

The three rules affect only the bird's heading.  Each bird always moves forward at the same constant speed.


HOW TO USE IT
-------------
First, determine the number of birds you want in the simulation and set the POPULATION slider to that value.  Press SETUP to create the birds, and press GO to have them start flying around.

The default settings for the sliders will produce reasonably good flocking behavior.  However, you can play with them to get variations:

Three TURN-ANGLE sliders control the maximum angle a bird can turn as a result of each rule.

VISION is the distance that each bird can see 360 degrees around it.


THINGS TO NOTICE
----------------
Central to the model is the observation that flocks form without a leader.

There are no random numbers used in this model, except to position the birds initially.  The fluid, lifelike behavior of the birds is produced entirely by deterministic rules.

Also, notice that each flock is dynamic.  A flock, once together, is not guaranteed to keep all of its members.  Why do you think this is?

After running the model for a while, all of the birds have approximately the same heading.  Why?

Sometimes a bird breaks away from its flock.  How does this happen?  You may need to slow down the model or run it step by step in order to observe this phenomenon.


THINGS TO TRY
-------------
Play with the sliders to see if you can get tighter flocks, looser flocks, fewer flocks, more flocks, more or less splitting and joining of flocks, more or less rearranging of birds within flocks, etc.

You can turn off a rule entirely by setting that rule's angle slider to zero.  Is one rule by itself enough to produce at least some flocking?  What about two rules?  What's missing from the resulting behavior when you leave out each rule?

Will running the model for a long time produce a static flock?  Or will the birds never settle down to an unchanging formation?  Remember, there are no random numbers used in this model.


EXTENDING THE MODEL
-------------------
Currently the birds can ""see"" all around them.  What happens if birds can only see in front of them?  The IN-CONE primitive can be used for this.

Is there some way to get V-shaped flocks, like migrating geese?

What happens if you put walls around the edges of the world that the birds can't fly into?

Can you get the birds to fly around obstacles in the middle of the world?

What would happen if you gave the birds different velocities?  For example, you could make birds that are not near other birds fly faster to catch up to the flock.  Or, you could simulate the diminished air resistance that birds experience when flying together by making them fly faster when in a group.

Are there other interesting ways you can make the birds different from each other?  There could be random variation in the population, or you could have distinct ""species"" of bird.


NETLOGO FEATURES
----------------
Notice the need for the SUBTRACT-HEADINGS primitive and special procedure for averaging groups of headings.  Just subtracting the numbers, or averaging the numbers, doesn't give you the results you'd expect, because of the discontinuity where headings wrap back to 0 once they reach 360.


CREDITS AND REFERENCES
----------------------
This model is inspired by the Boids simulation invented by Craig Reynolds.  The algorithm we use here is roughly similar to the original Boids algorithm, but it is not the same.  The exact details of the algorithm tend not to matter very much -- as long as you have alignment, separation, and cohesion, you will usually get flocking behavior resembling that produced by Reynolds' original model.  Information on Boids is available at http://www.red3d.com/cwr/boids/.

To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Flocking model.  http://ccl.northwestern.edu/netlogo/models/Flocking.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Flocking for terms of use.
"
Termites,/models/Sample Models/Biology,"to setup
  clear-all
  set-default-shape turtles ""bug""
  ;; randomly distribute wood chips
  ask patches
  [ if random-float 100 < density
    [ set pcolor yellow ] ]
  ;; randomly distribute termites
  create-turtles number [
    set color white
    setxy random-xcor random-ycor
    set size 5  ;; easier to see
  ]
end

to go  ;; turtle procedure
  search-for-chip
  find-new-pile
  put-down-chip
end

to search-for-chip  ;; turtle procedure -- ""picks up chip"" by turning orange
  ifelse pcolor = yellow
  [ set pcolor black
    set color orange
    fd 20 ]
  [ wiggle
    search-for-chip ]
end

to find-new-pile  ;; turtle procedure -- look for yellow patches
  if pcolor != yellow
  [ wiggle
    find-new-pile ]
end

to put-down-chip  ;; turtle procedure -- finds empty spot & drops chip
  ifelse pcolor = black
  [ set pcolor yellow
    set color white
    get-away ]
  [ rt random 360
    fd 1
    put-down-chip ]
end

to get-away  ;; turtle procedure -- escape from yellow piles
  rt random 360
  fd 20
  if pcolor != black
    [ get-away ]
end

to wiggle ; turtle procedure
  fd 1
  rt random 50
  lt random 50
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Termites model.
; http://ccl.northwestern.edu/netlogo/models/Termites.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Termites
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This project is inspired by the behavior of termites gathering wood chips into piles. The termites follow a set of simple rules. Each termite starts wandering randomly. If it bumps into a wood chip, it picks the chip up, and continues to wander randomly. When it bumps into another wood chip, it finds a nearby empty space and puts its wood chip down.  With these simple rules, the wood chips eventually end up in a single pile.


HOW TO USE IT
-------------
Click the SETUP button to set up the termites (white) and wood chips (yellow). Click the GO button to start the simulation.  The termites turn orange when they are carrying a wood chip.

The NUMBER slider controls the number of termites. (Note: Changes in the NUMBER slider do not take effect until the next setup.) The DENSITY slider controls the initial density of wood chips.


THINGS TO NOTICE
----------------
As piles of wood chips begin to form, the piles are not ""protected"" in any way. That is, termites sometimes take chips away from existing piles. That strategy might seem counter-productive. But if the piles were ""protected"", you would end up with lots of little piles, not one big one.

The final piles are roughly round.  Why is this?  What other physical situations also produce round things?

In general, the number of piles decreases with time. Why? Some piles disappear, when termites carry away all of the chips. And there is no way to start a new pile from scratch, since termites always put their wood chips near other wood chips. So the number of piles must decrease over time. (The only way a ""new"" pile starts is when an existing pile splits into two.)

This project is a good example of a ""decentralized"" strategy. There is no termite in charge, and no special pre-designated site for the piles. Each termite follows a set of simple rules, but the colony as a whole accomplishes a rather sophisticated task.


THINGS TO TRY
-------------
Do the results change if you use just a single termite?  What if you use several thousand termites?

When there are just two piles left, which of them is most likely to ""win"" as the single, final pile? How often does the larger of the two piles win? If one pile has only a single wood chip, and the other pile has the rest of the wood chips, what are the chances that the first pile will win?


EXTENDING THE MODEL
-------------------
Can you extend the model to have the termites sort several colors of wood?

Plot the number of piles, or their average size, or the number of termites carrying wood chips, as the model runs.


NETLOGO FEATURES
-------------------
Notice that the wood chips do not exist as objects. They are just represented as colors in the patches. The termites update the patch colors as they pick up and put down the wood chips. In effect, the patches are being used as the data structure. This strategy is useful in many NetLogo programs.

Note than when you stop the GO forever button, the termites keep moving for a little while.  This is because they are each finishing the commands in the GO procedure.  To do this, they must finish their current cycle of finding a chip, finding a pile, and then finding an empty spot near the pile.  In most models, the GO function only moves the model forward one step, but in this model, the GO function is written to advance the turtles through a full cycle of activity.  See the ""Buttons"" section of the Programming Guide in the User Manual for more information on turtle forever buttons.


RELATED MODELS
--------------
Painted Desert Challenge, Shepherds, State Machine Example


CREDITS AND REFERENCES
----------------------
This model was developed at the MIT Media Lab.  See Resnick, M. (1994) ""Turtles, Termites and Traffic Jams: Explorations in Massively Parallel Microworlds.""  Cambridge, MA: MIT Press.  Adapted to StarLogoT, 1998, as part of the Connected Mathematics Project.  Adapted to NetLogo, 2001, as part of the Participatory Simulations Project.

To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Termites model.  http://ccl.northwestern.edu/netlogo/models/Termites.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Termites for terms of use.
"
Autumn,/models/Sample Models/Biology,"breed [leaves leaf]
breed [dead-leaves dead-leaf]
breed [raindrops raindrop]
breed [suns sun]

leaves-own [
  water-level       ;; amount of water in the leaf
  sugar-level       ;; amount of sugar in the leaf
  attachedness      ;; how attached the leaf is to the tree
  chlorophyll       ;; level of chemical making the leaf green
  carotene          ;; level of chemical making the leaf yellow
  anthocyanin       ;; level of chemical making the leaf red
]

raindrops-own [
  location          ;; either ""falling"", ""in root"", ""in trunk"", or ""in leaves""
  amount-of-water
]

globals [
  bottom-line        ;; controls where the ground is
  evaporation-temp   ;; temperature at which water evaporates
]

;; ---------------------------------------
;; setup
;; ---------------------------------------

to setup
  clear-all
  set bottom-line min-pycor + 1
  set evaporation-temp 30
  set-default-shape raindrops ""circle""
  set-default-shape suns ""circle""

  ;; Create sky and grass
  ask patches
    [ set pcolor blue - 2 ]
  ask patches with [pycor < min-pycor + 2]
    [ set pcolor green ]

  ;; Create leaves
  create-leaves number-of-leaves [
    set chlorophyll 50 + random 50
    set water-level 75 + random 25
    ;; the sugar level is drawn from a normal distribution based on user inputs
    set sugar-level random-normal start-sugar-mean start-sugar-stddev
    set carotene random 100
    change-color
    set attachedness 100 + random 50
    ;; using sqrt in the next command makes the turtles be
    ;; evenly distributed; if we just said ""fd random-float 10""
    ;; there'd be more turtles near the center of the tree,
    ;; which would look funny
    fd sqrt random-float 100
  ]

  ;; Create trunk and branches
  ask patches with [pxcor = 0 and pycor <= 5 or
                    abs pxcor = (pycor + 2) and pycor < 4 or
                    abs pxcor = (pycor + 8) and pycor < 3]
    [ set pcolor brown ]

  ;; Create the sun
  create-suns 1 [
    setxy max-pxcor - 2
          max-pycor - 3
    ;; change appearance based on intensity
    show-intensity
  ]

  ;; plot the initial state
  do-plot
end


;; ---------------------------------------
;; go
;; ---------------------------------------

to go
  ;; Stop if all of the leaves are dead
  if not any? leaves [ stop ]

  ;; Have the wind blow and rain fall;
  ;; move any water in the sky, on the ground, and in the tree;
  ;; set the appearance of the sun on the basis of its intensity.
  make-wind-blow
  make-rain-fall
  move-water
  ask suns [ show-intensity ]

  ;; Now our leaves respond accordingly
  ask attached-leaves
  [
    adjust-water
    adjust-chlorophyll
    adjust-sugar
    change-color
    change-shape
  ]

  ;; if the leaves are falling keep falling
  ask leaves [ fall-if-necessary ]

  ;; Leaves on the bottom should be killed off
  ask leaves with [ycor <= bottom-line]
    [ set breed dead-leaves ]

  ;; Leaves without water should also be killed off
  ask leaves with [water-level < 1]
    [ set attachedness 0 ]

  ;; Make sure that values remain between 0 - 100
  ask leaves [
    if chlorophyll < 0 [ set chlorophyll 0 ]
    if chlorophyll > 100 [ set chlorophyll 100 ]
    if water-level < 0 [ set water-level 0 ]
    if water-level > 100 [ set water-level 100 ]
    if sugar-level < 0 [ set sugar-level 0 ]
    if sugar-level > 100 [ set sugar-level 100 ]
    if carotene < 0 [ set carotene 0 ]
    if carotene > 100 [ set carotene 100 ]
    if anthocyanin < 0 [ set anthocyanin 0 ]
    if anthocyanin > 100 [ set anthocyanin 100 ]
    if attachedness < 0 [ set attachedness 0 ]
    if attachedness > 100 [ set attachedness 100 ]
  ]

  ;; increment the tick counter
  tick

  ;; Make a plot of what's going on
  do-plot
end


;; ---------------------------------------
;; make-wind-blow: When the wind blows,
;; the leaves move around a little bit
;; (for a nice visual effect), and
;; reduce their attachedness by the wind factor.
;; This means that leaves will fall off more
;; rapidly in stronger winds.
;; ---------------------------------------

to make-wind-blow
  ask leaves [ ifelse random 2 = 1
                 [ rt 10 * wind-factor ]
                 [ lt 10 * wind-factor ]
               set attachedness attachedness - wind-factor
             ]
end


;; ---------------------------------------
;; make-rain-fall: rain is a separate breed
;; of small turtles that come from the top of the world.
;; ---------------------------------------

to make-rain-fall
  ;; Create new raindrops at the top of the world
  create-raindrops rain-intensity [
    setxy random-xcor max-pycor
    set heading 180
    fd 0.5 - random-float 1.0
    set size .3
    set color gray
    set location ""falling""
    set amount-of-water 10
  ]
  ;; Now move all the raindrops, including
  ;; the ones we just created.
  ask raindrops [ fd random-float 2 ]
end


;; --------------------------------------------------------
;; move-water: water goes from raindrops -> ground,
;; ground -> trunk/branches, and trunk/branches to leaves.
;; --------------------------------------------------------

to move-water

  ;; We assume that the roots extend under the entire grassy area; rain flows through
  ;; the roots to the trunk
  ask raindrops with [location = ""falling"" and pcolor = green] [
    set location ""in roots""
    face patch 0 ycor
  ]

  ;; Water flows from the trunk up to the central part of the tree.
  ask raindrops with [location = ""in roots"" and pcolor = brown] [
    face patch 0 0
    set location ""in trunk""
  ]

  ;; Water flows out from the trunk to the leaves.  We're not going to
  ;; simulate branches here in a serious way
  ask raindrops with [location = ""in trunk"" and patch-here = patch 0 0] [
    set location ""in leaves""
    set heading random 360
  ]

  ;; if the raindrop is in the leaves and there is nothing left disappear
  ask raindrops with [location = ""in leaves"" and amount-of-water <= 0.5] [
    die
  ]

  ;; if the raindrops are in the trunk or leaves and they are at a place
  ;; where they can no longer flow into a leaf then disappear
  ask raindrops with [
    (location = ""in trunk"" or location = ""in leaves"")
     and (ycor > max [ycor] of leaves or
          xcor > max [xcor] of leaves or
          xcor < min [xcor] of leaves) ] [
    die
  ]

end

;;---------------------------------------------------------
;; Turtle Procedures
;; --------------------------------------------------------

;; --------------------------------------------------------
;; show-intensity: Change how the sun looks to indicate
;; intensity of sunshine.
;; --------------------------------------------------------

to show-intensity  ;; sun procedure
  set color scale-color yellow sun-intensity 0 150
  set size sun-intensity / 10
  set label word sun-intensity ""%""
  ifelse sun-intensity < 50
    [ set label-color yellow ]
    [ set label-color black  ]
end

;; --------------------------------------------------------
;; adjust-water: Handle the ups and downs of water within the leaf
;; --------------------------------------------------------

to adjust-water
  ;; Below a certain temperature, the leaf does not absorb
  ;; water any more.  Instead, it converts sugar and and water
  ;; to anthocyanin, in a proportion
  if temperature < 10 [ stop  ]

  ;; If there is a raindrop near this leaf with some water
  ;; left in it, then absorb some of that water
  let nearby-raindrops raindrops in-radius 2 with [location = ""in leaves"" and amount-of-water >= 0]

  if any? nearby-raindrops [
    let my-raindrop min-one-of nearby-raindrops [distance myself]
    set water-level water-level + ([amount-of-water] of my-raindrop * 0.20)
    ask my-raindrop [
      set amount-of-water (amount-of-water * 0.80)
    ]
  ]

  ;; Reduce the water according to the temperature
  if temperature > evaporation-temp
    [ set water-level water-level - (0.5 * (temperature - evaporation-temp)) ]

  ;; If the water level goes too low, reduce the attachedness
  if water-level < 25
    [ set attachedness attachedness - 1 ]

end


;; ---------------------------------------
;; adjust-chlorophyll: It's not easy being green.
;; Chlorophyll gets reduces when the temperature is
;; low, or when the sun is strong.  It increases when
;; the temperature is normal and the sun is shining.
;; ---------------------------------------

to adjust-chlorophyll

  ;; If the temperature is low, then reduce the chlorophyll
  if temperature < 15
    [ set chlorophyll chlorophyll - (.5 * (15 - temperature)) ]

  ;; If the sun is strong, then reduce the chlorophyll
  if sun-intensity > 75
    [ set chlorophyll chlorophyll - (.5 * (sun-intensity - 75)) ]

  ;; New chlorophyll comes from water and sunlight
  if temperature > 15 and sun-intensity > 20
    [ set chlorophyll chlorophyll + 1 ]

end


;; ---------------------------------------
;; adjust-sugar: water + sunlight + chlorophyll = sugar
;; ---------------------------------------

to adjust-sugar
  ;; If there is enough water and sunlight, reduce the chlorophyll
  ;; and water, and increase the sugar
  if water-level > 1 and sun-intensity > 20 and chlorophyll > 1
    [ set water-level water-level - 0.5
      set chlorophyll chlorophyll - 0.5
      set sugar-level sugar-level + 1
      set attachedness attachedness + 5
    ]

  ;; Every tick of the clock, we reduce the sugar by 1
  set sugar-level sugar-level - 0.5
end

;; ---------------------------------------
;; fall-if-necessary:  If a leaf is above the bottom row, make it fall down
;; If it hits the bottom line, make it a dead-leaf
;; ---------------------------------------

to fall-if-necessary
  if attachedness > 0 [ stop ]
  if ycor > bottom-line
    [
      let target-xcor (xcor + random-float wind-factor
                            - random-float wind-factor)
      facexy target-xcor bottom-line
      fd random-float (.7 * max (list wind-factor .5))
     ]
end


;; ---------------------------------------
;; change-color: Because NetLogo has a limited color scheme,
;; we need very simple rules
;; ---------------------------------------

to change-color
  ;; If the temperature is low, then we turn the
  ;; sugar into anthocyanin
  if temperature < 20 and sugar-level > 0 and water-level > 0
    [ set sugar-level sugar-level - 1
      set water-level water-level - 1
      set anthocyanin anthocyanin + 1 ]

  ;; If we have more than 50 percent chlorophyll, then
  ;; we are green, and scale the color accordingly
  ifelse chlorophyll > 50
       [ set color scale-color green chlorophyll 150 -50 ]

  ;; If we are lower than 50 percent chlorophyll, then
  ;; we have yellow (according to the carotene), red (according
  ;; to the anthocyanin), or orange (if they are about equal).

       ;; If we have roughly equal anthocyanin and carotene,
       ;; then the leaves should be in orange.
       [ if abs (anthocyanin - carotene ) < 10
           [ set color scale-color orange carotene 150 -50 ]

         if anthocyanin > carotene + 10
           [ set color scale-color red anthocyanin 170 -50 ]

         if carotene > anthocyanin + 10
           [ set color scale-color yellow carotene 150 -50 ]
       ]
end

to change-shape
  ifelse leaf-display-mode = ""solid""
    [ set shape ""default"" ]
  [ if leaf-display-mode = ""chlorophyll""
      [ set-shape-for-value chlorophyll ]
    if leaf-display-mode = ""water""
      [ set-shape-for-value water-level ]
    if leaf-display-mode = ""sugar""
      [ set-shape-for-value sugar-level ]
    if leaf-display-mode = ""carotene""
      [ set-shape-for-value carotene ]
    if leaf-display-mode = ""anthocyanin""
      [ set-shape-for-value anthocyanin ]
    if leaf-display-mode = ""attachedness""
      [ set-shape-for-value attachedness ]
  ]
end


;; ---------------------------------------
;; Plotting Procedures
;; ---------------------------------------

;; ---------------------------------------
;; do-plot: Plot our measurements
;; ---------------------------------------

to do-plot
    ;; Plot info about the number of leaves
    set-current-plot ""Leaves""

    set-current-plot-pen ""leaves""
    plot count leaves

    set-current-plot-pen ""dead leaves""
    plot count dead-leaves

    ;; Plot info about weather conditions
    set-current-plot ""Weather conditions""

    set-current-plot-pen ""temperature""
    plot temperature

    set-current-plot-pen ""sunlight""
    plot sun-intensity

    set-current-plot-pen ""rain""
    plot rain-intensity

    set-current-plot-pen ""wind""
    plot wind-factor

    ;; Plot info about leaves
    if any? leaves [

      set-current-plot ""Leaf averages""

      set-current-plot-pen ""water""
      plot mean [water-level] of leaves

      set-current-plot-pen ""chlorophyll""
      plot mean [chlorophyll] of leaves

      set-current-plot-pen ""sugar""
      plot mean [sugar-level] of leaves

      set-current-plot-pen ""carotene""
      plot mean [carotene] of leaves

      set-current-plot-pen ""anthocyanin""
      plot mean [anthocyanin] of leaves

      set-current-plot-pen ""attachedness""
      plot mean [attachedness] of leaves
   ]
end

;; returns all leaves still attached
to-report attached-leaves
  report leaves with [attachedness > 0]
end

;; makes the leaf appear to be more or less filled depending on value
to set-shape-for-value [value]
  ifelse value > 75 [ set shape ""default"" ]
  [ ifelse value <= 25 [ set shape ""default one-quarter"" ]
    [ ifelse value <= 50 [ set shape ""default half"" ]
                         [ set shape ""default three-quarter"" ]]]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2005 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2005).  NetLogo Autumn model.
; http://ccl.northwestern.edu/netlogo/models/Autumn.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2005 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Autumn
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
If you live in a climate that is warm during the summer and cold in the winter, then you are probably familiar with the beautiful autumn phenomenon in which leaves turn color before dying and falling off of the tree.  This model simulates the ways in which leaves change their colors and fall, making it possible to explore and understand this beautiful annual spectacle.


HOW IT WORKS
------------
Why and how leaves change colors and fall is surprisingly complicated, and has to do with a combination of sunlight, heat, and rain.  (Leaves can be blown off by strong winds even if they have not yet changed color, so wind has a role too.)

The colors that we see in each leaf stem from the presence of natural substances that are produced and stored in each leaf. Three substances contribute to a leaf's color:

- Green comes from chlorophyll (or a set of related substances known as chlorophylls), which converts sunlight and water into sugar.  Chlorophyll molecules are destroyed and not replenished when they are exposed to excessive sunlight and when temperatures are low.  Thus, cold sunny fall days make the overall concentration of chlorophyll decrease.  Overall chlorophyll concentration rises again in the sunlight (as long as there is not too much!) and when there is water.

- Yellow comes from a substance called carotene.  Carotene molecules help give color to carrots and sweet potatoes.  The concentration of carotene remains constant throughout a leaf's life.  However, the yellow color is often masked by the chlorophyll's green color.  A leaf with lots more chlorophyll (typical in the summer) will be exclusively green, albeit with strong yellow tints masked behind the green.  As the chlorophyll dies, however, the presence of carotene becomes apparent, resulting in a yellow leaf.

- Red comes from a substance called anthocyanins.  Anthocyanin molecules are created in the presence of high sugar concentrations and water concentrations in the leaf.  (The higher the concentration of sugar, the more anthocyanins are produced.)  Sugar concentration increases when cold weather causes the tree to shut down its water circulation to the rest of the tree; whatever water and sugar are trapped in the leaf are then converted into anthocyanins.

Each tick of the clock in the model consists of two stages: (1) Weather (rain, wind, sun) affects the leaves, adding or removing sugar, water, or chlorophyll as appropriate, and (2) the leaf reacts to its environment, adding anthocyanins as appropriate, and changing color to reflect the modified environment.

Water does not enter each leaf directly, but is absorbed by the tree's roots, from which it is pulled up the trunk and into the branches and leaves.  In this model, the entire ground is assumed to contain tree roots, and thus all raindrops flow toward the trunk once they reach the ground.  Similarly, all of the raindrops travel up the trunk of the tree, and then along the branches (which are not represented in the model), out to the leaves.  Leaves collect water from nearby raindrops. Raindrops disappear when they have no more water left in them.

Leaves in the model have an ""attachedness"" attribute, which the model uses to indicate how strongly the leaf is clinging to the tree.  Attachedness rises with water, and declines in wind and rain.  (On a very windy day, leaves may blow off even if they're completely green.)

Because the NetLogo color space does not include all possible colors, this model uses a threshold algorithm to determine the color of the leaf, as an approximation of the real color.  Whenever chlorophyll is above 50%, the leaf is green.  Below that, the leaf is given a yellow, red, or orange color, depending on if there is a majority of carotene, anthocyanins, or both, respectively.

Note that the intensity of the leaf colors varies with the level of chlorophyll, carotene, and/or anthocyanins.  So a chlorophyll-laden tree will have dark-green leaves, whereas one with only a little bit will have light-green leaves.


HOW TO USE IT
-------------
To use the model, press SETUP.  This will create the tree trunk and branches, and will also create the leaves of the tree, which are the main agents in this model.  Press GO to set the system in motion.

Now comes the interesting and/or tricky part, namely adjusting the sliders under the view so that the weather produces conditions you want to explore or study.  If the leaves appear to be losing chlorophyll due to a lack of water (which you can monitor in the ""Leaf averages"" plot), you can make it rain by adjusting the RAIN-INTENSITY slider. To make the wind blow, adjust the WIND-FACTOR slider.

The sun's strength (in terms of intensity of sunlight) is set with the SUN-INTENSITY slider.  As noted above, leaves need sunlight to produce chlorophyll and sugar -- but too much sunlight may begin to destroy these chemicals.

Finally, you can change the TEMPERATURE slider.  If the temperature is too cold, the chlorophyll molecules will be destroyed, setting in motion the creation of anthocyanins.

Once you have mastered the basics of the model, you might want to consider setting the two sliders in the top left corner, START-SUGAR-MEAN and START-SUGAR-STDDEV, which influence the mean and spread of the initial distribution of sugar among the leaves.  Maple leaves, for example, tend to have a lot of sugar in them to begin with, which means that they'll turn redder than other leaves under similar conditions.

The LEAF-DISPLAY-MODE in the lower right corner changes the way in which leaves are depicted.  Normally, each leaf is painted as a solid NetLogo ""default"" turtle wedge.  This is the case when LEAF-DISPLAY-MODE is set to ""solid,"" the default.  Selecting a different value for LEAF-DISPLAY-MODE then changes each leaf to show an empty, half-full, or full shape, according to the variable that was chosen.  Thus if LEAF-DISPLAY-MODE is set to ""water"", each leaf will be shown as empty (if low on water), half-full (if somewhat stocked with water), or full (if relatively full of water).


THINGS TO NOTICE
----------------
Leaves absorb water when they are hit by raindrops -- which means that with light rain and many leaves, the ""inside"" leaves will fail to get enough rain.

The stronger the wind, the more each leaf shakes.

You can simulate a minor hurricane by turning the wind and rain up to their maximum values.  Watch the leaves all fall off at once!


THINGS TO TRY
-------------
Can you get all of the leaves to turn red before falling?  How about to turn orange before falling?  How about yellow?  Now try to mix things up, such that the same tree will have leaves of many different colors.  (Hint: You will probably need to adjust the sun, rain, and temperature sliders several times to get the combination to look right.)

Try to get the leaves to turn yellow and then green again.

In some climates trees do not lose their leaves.  Can you adjust the climate conditions so that you can make the tree keep some of its leaves?


EXTENDING THE MODEL
-------------------
In real life, leaves that face the sun tend to be yellower than those that don't.  Change the model such that the sun can be positioned (and moved), and such that leaves facing the sun are more sensitive to sunlight than those that don't.

The model is very simplistic in its approach to water and sugar -- namely, that all water comes from rain, that raindrops can affect multiple leaves, and that raindrops disappear as they hit the ground.  A more realistic model would have raindrops disappear as soon as they hit a leaf, but would also allow for water to travel from the ground to the leaves, via the trunk and branches.  Also a more realistic model would model the transport of sugars between leaves and the storage of excess sugar in the roots.

Allow for the budding and growth of new leaves, in addition to the death of mature ones.

Add day-night cycles, in which the temperature drops and the sun goes down for several ticks of the clock.  In the dark, the tree would then consume sugars and produce water through respiration.


NETLOGO FEATURES
----------------
Because NetLogo's color space is incomplete, we needed to fake color pigmentation blending a bit.  Notice how we handle setting colors by means of thresholds.  This means that there can be sudden, jarring color changes if the weather conditions are a bit extreme.

Also note that the NetLogo color scheme, and the SCALE-COLOR primitive, produce colors that range from white to black.  Because in this model we wants to vary hues without getting too close to either black or white, we used the scale-color primitive but on a -50 to 150 scale, rather than the usual 0 to 100.

When a leaf dies, its breed changes to dead-leaves.  This keeps it in the system, but allows us to issue instructions to only those leaves that are alive.

Notice how the sun's color changes as SUN-INTENSITY changes.  What happens to the label when the sun becomes dark and small?


RELATED MODELS
--------------
Plant Growth is in some ways a model of the opposite process, namely how do leaves grow, as opposed to how do leaves die.


CREDITS AND REFERENCES
----------------------
http://scifun.chem.wisc.edu/chemweek/fallcolr/fallcolr.html
http://www.the-scientist.com/article/display/12772/

Thanks to Reuven Lerner for his work on this model.

To refer to this model in academic publications, please use:  Wilensky, U. (2005).  NetLogo Autumn model.  http://ccl.northwestern.edu/netlogo/models/Autumn.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2005 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Autumn for terms of use.
"
Continental Divide,/models/Sample Models/Earth Science,"patches-own [
  elevation
]

globals [
  water-height    ;; how high the floods are currently
  raise-water?    ;; true or false, are we ready for the water to go higher?
  ;; The rest of the variables are used only for coloring.
  flood-1-color flood-2-color
  ocean-color divide-color
  initial-ground-color flooded-ground-colors
]

;;;
;;; SETUP PROCEDURES
;;;

to setup
  clear-all
  set-default-shape turtles ""circle""
  setup-colors
  setup-elevations
  setup-floods
  color-world
end

to setup-elevations
  ;; Here we're using FOREACH to walk down two lists simultaneously:
  ;; the list of patches, and the list of elevations.
  (foreach (sort patches) elevation-data
     [ ask ?1 [ set elevation ?2 ] ] )
end

to setup-floods
  ask patches [
    if elevation = -1 [
      sprout 1 [ set color flood-1-color ]
    ]
    if elevation = -2 [
      sprout 1 [ set color flood-2-color ]
    ]
  ]
end

;;;
;;; MAIN PROCEDURES
;;;

to go
  if not any? turtles [ stop ]
  set raise-water? true
  ask turtles [ flood ]
  ask turtles [ check-for-divide ]
  ;;; if raise-water? didn't get set to false when FLOOD happened,
  ;;; there won't be more flooding at the current water-height, so raise it
  if raise-water? [
    ;; raising by 5 is less accurate than raising by 1, but it's faster
    set water-height water-height + 5
  ]
  tick
end

to flood  ;; turtle procedure
  let my-color color
  let unflooded-neighbors neighbors4 with [shade-of? pcolor initial-ground-color and
                                           not any? turtles-here with [color = my-color]]
  if not any? unflooded-neighbors [
    recolor-patch
    ;; we won't do any more flooding from this patch
    die
  ]
  ask unflooded-neighbors with [elevation < water-height] [
    sprout 1 [
      set color my-color
      set raise-water? false
    ]
  ]
end

;;; if the two floods are colliding, we must be on the divide
to check-for-divide  ;; turtle procedure
  if any? other turtles-here [
    set pcolor divide-color
    ask turtles-here [ die ]  ;; turtles-here includes me, so I die too
  ]
end

;;;
;;; COLOR PROCEDURES
;;;

to setup-colors
  set flood-1-color yellow + 1
  set flood-2-color orange + 1
  set ocean-color black
  set divide-color red
  set initial-ground-color brown
  set flooded-ground-colors [magenta blue sky turquoise lime green]
end

to color-world
  ask patches [
    ifelse elevation < 0 [    ;; check: is ocean?
      set pcolor ocean-color
    ] [
      set pcolor scale-color initial-ground-color elevation -250 max-elevation
    ]
  ]
end

to recolor-patch  ;; turtle procedure
  ;; while staying within the bounds of the list,
  ;; find the (water-height / 150)th element of the flooded-ground-colors
  let current-flooded-ground-color item (max list 0
                                                 (min list (length flooded-ground-colors - 1)
                                                           (floor (water-height / 150))))
                                        flooded-ground-colors
  set pcolor scale-color current-flooded-ground-color elevation -250 max-elevation ; -250 makes things lighter than the ocean
end

;;;
;;; THE MAP
;;;

to-report max-elevation
  report 3000
end

to-report elevation-data
  ;; -3 is ocean, -1 is the west coast, -2 is the east coast
  report [
    -3 -3 -3 -3 -1 32 92 145 190 258 348 426 493 544 580 603 614 610 589 572 558 571 610 627 621 650 714 762 793 831 876 878 838 817 816 861 951 1008 1032 1063 1100 1163 1250 1285 1266 1239 1201 1149 1081 1032 1001 958 904 849 792 742 698 628 533 486 489 490 489 467 424 335 201 124 106 101 109 119 130 144 161 172 179 180 175 174 176 207 267 292 280 274 274 275 275 275 274 274 274 274 274 281 295 339 413 418 354 287 215 169 148 120 86 45 -3 -3 -3 -3 -3 -3 3 2 -3 -3 -3 -3 -3 -3 -3 8 27 38 39 26 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 7 22 25 16 4 -3 -3 -3 -3 44 90 138 177 208 183 102 85 131 138 105 55 -3 -3 -3 -3 114 206 270 305 310 255 141 60 13 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -1 15 60 102 142 204 287 354 405 456 509 545 563 567 557 542 523 532 570 602 629 679 752 800 823 854 891 890 849 824 815 846 917 973 1015 1045 1062 1092 1134 1134 1090 1052 1020 976 919 883 867 836 790 753 724 691 653 595 518 483 491 498 505 512 519 437 266 161 123 107 113 124 140 155 170 180 185 187 184 182 179 207 264 289 279 276 278 279 280 279 276 276 278 277 275 279 291 329 392 399 348 292 231 191 173 146 110 72 30 8 5 6 10 16 22 25 24 19 12 3 -3 -3 17 40 65 85 100 97 75 60 53 41 24 12 5 8 23 22 6 2 11 21 31 32 24 14 2 4 19 46 84 125 168 204 232 217 157 146 184 184 148 90 11 -3 -3 43 153 231 277 303 310 265 167 87 24 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -1 -1 21 50 99 168 213 234 286 371 430 464 485 494 484 455 458 493 556 645 735 825 874 881 897 921 912 871 837 813 817 850 906 983 1010 987 954 910 842 749 691 669 640 606 595 607 599 570 568 593 592 566 531 490 477 494 514 536 600 704 635 393 233 155 118 122 136 158 176 189 196 198 201 203 198 186 206 259 282 278 278 284 288 290 287 281 279 284 283 275 276 283 309 353 362 337 304 263 235 222 196 157 123 93 75 70 64 57 55 59 69 84 90 85 67 36 35 66 101 138 178 219 233 220 211 204 185 155 134 124 123 130 111 65 44 47 49 48 45 40 35 30 52 99 136 162 193 228 257 279 281 264 265 286 274 230 158 56 27 70 137 227 278 290 301 310 283 218 139 47 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -1 8 40 83 106 111 153 232 292 332 358 371 368 350 361 400 465 554 635 707 745 748 760 780 772 737 709 689 701 744 791 843 840 785 722 651 569 476 422 408 392 375 378 401 416 423 457 520 565 594 600 585 566 542 533 539 614 757 720 504 336 216 152 144 149 168 181 189 192 193 193 193 188 176 194 240 265 269 276 287 291 286 278 265 261 265 261 249 242 241 257 288 300 292 286 282 280 280 265 236 212 195 185 182 176 168 165 167 175 188 192 186 165 129 118 134 163 205 245 286 302 296 290 285 269 241 222 213 205 199 168 113 86 85 83 79 75 71 70 73 107 172 215 235 253 270 286 301 315 329 338 344 328 291 223 125 88 114 155 212 240 239 241 247 227 181 115 28 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -1 -1 -1 -1 15 25 28 31 33 53 91 130 168 189 192 199 209 240 292 333 363 389 409 425 436 453 477 478 457 448 451 502 600 634 601 544 461 400 360 315 266 238 231 226 222 229 245 284 344 417 501 605 730 794 796 743 633 557 517 560 686 699 601 469 304 207 177 165 170 172 171 170 169 165 158 154 151 170 210 238 254 270 287 287 270 252 232 222 222 213 196 181 169 175 199 213 216 242 291 327 348 353 344 337 333 334 339 341 341 341 341 338 333 324 312 294 269 244 220 227 264 290 304 309 305 302 300 295 286 279 274 258 230 194 149 127 125 124 122 120 116 118 128 168 239 284 304 308 297 294 300 320 354 367 359 347 331 287 217 160 117 101 112 120 126 127 123 101 62 18 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -1 13 28 40 51 61 67 69 65 56 55 60 80 113 135 146 160 176 194 215 225 225 234 249 276 312 335 346 344 331 337 363 423 518 530 460 388 312 285 306 308 291 284 285 279 265 262 271 310 379 453 534 660 833 924 936 877 748 660 614 631 714 730 680 590 459 386 371 367 374 366 342 328 323 298 253 224 211 211 222 238 260 274 282 277 257 240 225 213 204 194 183 171 157 160 180 194 202 242 313 360 383 395 396 397 399 404 410 416 422 426 430 426 414 398 377 359 344 321 289 286 312 326 327 326 324 323 322 322 320 317 312 292 258 220 177 155 153 153 152 151 148 150 159 195 258 298 317 319 304 296 294 310 345 350 324 307 297 269 223 165 93 55 53 55 61 55 39 8 -2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -1 33 73 104 125 139 144 164 199 202 174 151 133 136 161 191 226 244 243 217 165 139 138 165 220 287 366 395 376 361 350 368 415 457 492 478 415 365 328 365 477 534 538 546 558 540 492 468 468 485 519 563 615 729 903 996 1007 970 886 837 822 822 835 809 742 698 677 683 716 745 768 750 689 654 645 584 470 392 351 311 271 262 284 288 273 260 248 242 240 230 210 203 209 209 204 210 227 240 248 284 346 381 389 394 395 396 397 398 401 406 414 426 440 443 436 416 383 364 359 351 341 340 348 353 353 353 352 352 351 349 346 339 329 311 285 246 196 171 171 171 170 169 168 167 167 188 231 260 277 288 293 292 284 288 304 289 242 211 195 174 149 105 42 17 32 40 40 25 -2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -1 33 78 116 147 161 158 174 209 214 190 162 131 140 188 240 299 309 270 218 154 121 120 149 208 271 338 368 361 355 350 365 400 415 409 385 345 327 332 392 508 585 623 657 687 694 679 678 693 707 722 728 726 792 928 1013 1048 1044 1002 993 1017 1023 1011 981 932 923 954 996 1051 1091 1119 1102 1041 1011 1011 946 815 722 667 601 525 459 403 350 299 269 259 261 275 267 238 225 228 237 254 272 290 296 290 305 340 361 367 373 378 385 393 399 403 409 418 430 444 449 445 428 398 380 374 371 371 370 367 363 360 355 348 341 334 326 319 310 299 287 273 242 195 171 171 170 168 166 162 157 151 160 185 206 221 235 247 249 241 240 247 231 194 164 143 117 89 52 7 -2 26 50 72 67 37 -2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -1 32 68 108 121 107 102 106 108 109 93 59 93 194 285 365 356 258 199 179 169 168 182 210 227 233 257 302 327 334 332 321 300 270 254 252 276 325 369 407 470 556 627 681 748 828 894 944 973 982 946 864 852 909 979 1062 1101 1095 1128 1198 1235 1239 1241 1242 1258 1287 1326 1375 1409 1428 1424 1396 1395 1419 1381 1283 1205 1148 1070 971 818 612 458 357 301 290 298 327 323 288 260 240 256 308 346 368 362 327 306 299 303 318 332 344 363 388 405 416 425 433 439 443 445 444 436 421 406 390 382 381 377 368 359 348 333 313 292 272 255 243 233 227 224 226 209 174 156 153 150 146 141 133 124 111 111 123 136 151 161 167 169 168 170 174 177 177 164 138 97 40 4 -2 -2 33 84 152 180 169 123 42 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -1 27 61 72 59 49 40 44 62 64 52 99 208 288 341 317 216 169 178 192 210 224 234 233 223 241 288 320 337 366 406 443 477 477 442 457 522 577 623 683 758 804 821 870 951 1003 1027 1031 1018 976 907 885 912 956 1017 1050 1053 1092 1167 1214 1232 1259 1294 1320 1339 1373 1424 1462 1489 1507 1517 1538 1570 1558 1502 1454 1415 1350 1260 1086 830 637 506 415 363 347 366 360 329 300 272 284 335 370 391 380 337 303 278 269 277 290 309 335 366 389 404 418 432 438 439 439 439 436 428 416 399 390 387 381 372 359 345 323 293 272 261 246 226 214 211 212 218 209 185 170 161 152 140 131 122 111 98 94 98 102 106 108 108 110 115 114 107 108 115 107 82 44 -2 -2 -3 -2 33 82 147 174 163 126 63 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -1 5 12 14 13 9 20 46 75 105 155 227 252 232 196 144 130 152 192 248 276 277 286 303 313 316 332 359 464 646 829 1013 1036 900 858 912 1005 1137 1207 1214 1178 1099 1056 1049 1013 951 893 839 828 858 893 935 942 916 896 883 896 934 971 1005 1048 1099 1124 1123 1153 1212 1266 1314 1364 1415 1454 1480 1490 1486 1482 1479 1452 1400 1269 1058 881 740 605 478 407 392 377 363 344 323 320 335 349 362 353 321 295 275 257 241 247 272 300 329 352 369 390 415 429 431 433 433 429 420 411 402 395 390 384 377 366 350 324 288 280 299 294 265 250 249 248 249 241 227 211 194 173 150 134 127 119 110 107 109 102 85 75 69 72 81 73 45 25 12 -2 -2 -2 -3 -3 -3 -2 25 46 62 56 28 2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -1 -1 4 13 16 35 70 106 143 178 210 205 163 135 120 133 175 222 273 297 292 320 380 424 454 490 532 643 823 978 1107 1127 1038 1038 1128 1225 1330 1355 1301 1219 1110 1076 1117 1105 1039 971 902 876 894 911 925 913 874 856 858 863 870 882 897 925 967 999 1023 1068 1134 1181 1211 1248 1293 1330 1359 1397 1443 1478 1503 1517 1519 1448 1302 1150 992 820 634 502 423 379 369 352 328 324 342 358 373 363 329 300 276 252 228 224 239 258 280 300 319 343 372 385 384 383 383 384 386 390 396 397 392 387 380 369 355 331 299 296 322 320 290 273 271 269 268 264 256 239 214 187 160 143 134 125 115 109 108 96 72 54 43 39 44 29 -2 -2 -2 -3 -3 -3 -3 -3 -3 -3 -2 -2 -2 -2 -2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -1 3 27 46 60 88 130 156 167 169 160 148 133 130 140 178 243 280 287 288 282 338 455 574 694 786 847 899 940 902 783 773 872 1007 1178 1248 1216 1146 1038 945 868 939 1159 1274 1283 1257 1193 1112 1013 937 884 869 890 924 971 985 967 939 901 885 892 941 1031 1111 1181 1202 1174 1157 1150 1168 1211 1279 1374 1444 1489 1548 1619 1623 1561 1441 1262 1058 830 631 460 366 351 325 289 299 356 396 420 408 359 316 281 254 235 220 210 210 220 235 255 278 304 310 298 292 293 304 326 352 381 395 396 391 381 370 359 344 324 320 331 324 299 283 277 275 277 277 273 255 221 194 172 155 144 129 113 103 98 86 66 47 28 13 3 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -2 -2 -2 -2 -2 -2 -2 -2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -1 1 19 42 61 76 101 136 154 155 147 128 122 130 155 198 238 273 281 262 262 283 379 550 733 926 1040 1074 1016 865 690 491 494 697 914 1145 1239 1196 1104 961 860 800 895 1146 1324 1430 1460 1414 1365 1311 1249 1178 1113 1053 1046 1090 1092 1050 1006 958 923 900 938 1036 1124 1200 1223 1192 1158 1119 1128 1185 1251 1327 1397 1459 1536 1627 1643 1584 1478 1325 1152 959 749 522 389 350 309 268 275 332 371 394 381 332 292 259 237 225 208 186 175 176 185 202 222 245 256 253 257 267 287 316 348 384 401 402 397 389 380 372 362 349 343 342 332 314 302 295 292 292 292 292 275 239 210 188 169 152 133 111 94 84 69 47 24 1 -2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -2 29 34 41 50 65 86 97 99 55 -2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -1 21 39 52 60 65 75 89 100 108 112 114 128 154 208 292 311 267 229 198 219 292 441 665 901 1150 1255 1217 1001 608 351 230 284 514 764 1032 1200 1267 1220 1061 954 898 941 1081 1262 1485 1587 1569 1634 1782 1834 1791 1631 1356 1218 1217 1184 1121 1081 1064 1033 986 988 1040 1107 1190 1242 1262 1246 1195 1204 1275 1307 1302 1338 1414 1485 1551 1516 1382 1274 1192 1109 1026 859 609 444 364 304 263 253 272 287 297 285 252 227 211 202 201 189 166 153 148 150 160 175 197 221 248 275 303 329 352 377 404 415 410 407 404 399 392 383 373 363 353 343 335 328 324 318 311 309 314 299 264 233 207 183 161 136 108 85 67 44 16 -2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -2 29 102 154 199 238 271 298 327 361 336 253 138 -2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -1 8 25 39 49 53 51 50 51 57 70 100 146 198 253 300 336 321 254 209 185 215 297 445 658 883 1121 1181 1062 797 384 168 149 252 479 674 837 943 990 955 836 780 785 822 889 1064 1346 1507 1547 1682 1912 2043 2074 1938 1633 1447 1379 1294 1192 1140 1136 1113 1073 1052 1050 1085 1157 1208 1237 1244 1228 1247 1298 1286 1209 1209 1287 1347 1389 1345 1215 1130 1090 1060 1040 897 631 466 403 359 336 323 322 315 301 284 262 248 242 231 215 197 178 165 160 157 157 163 175 201 241 279 316 347 373 397 419 431 431 430 427 422 413 402 389 377 366 357 350 347 346 340 328 322 322 308 280 251 221 193 168 139 107 77 48 17 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -2 43 119 186 244 292 332 364 400 442 435 378 277 132 20 -2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -1 8 17 15 21 34 39 34 28 21 25 41 107 222 328 425 427 334 270 236 220 221 247 297 393 535 688 853 831 623 410 192 135 240 390 583 642 565 479 383 324 302 351 472 547 577 736 1024 1231 1357 1519 1718 1893 2045 2042 1886 1730 1576 1421 1265 1183 1173 1165 1161 1128 1066 1057 1100 1121 1121 1155 1223 1258 1259 1189 1049 1014 1084 1128 1147 1131 1080 1042 1017 1005 1006 868 590 456 464 473 481 482 476 450 403 372 359 351 347 319 266 232 218 211 211 204 191 183 181 197 233 270 307 343 377 407 431 450 463 466 459 449 434 417 398 385 380 372 361 358 363 358 344 330 317 302 286 262 229 200 174 143 109 70 26 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -2 22 81 134 180 220 257 291 323 353 361 347 312 255 198 140 60 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -1 7 12 3 4 16 20 17 11 2 13 44 126 258 373 471 446 299 215 195 194 210 233 264 319 400 483 568 506 296 159 94 133 277 388 467 432 283 143 12 -1 -1 -1 -1 -1 -1 54 262 464 661 874 1102 1306 1485 1556 1520 1454 1359 1278 1210 1172 1162 1153 1146 1130 1106 1094 1094 1086 1069 1113 1217 1272 1277 1195 1027 961 997 1006 988 988 1004 1004 989 957 908 772 548 456 494 525 550 557 546 519 476 451 444 430 411 378 332 319 338 340 327 296 247 216 204 209 232 261 297 328 356 381 405 427 448 455 450 443 432 418 400 392 395 391 380 376 377 369 350 331 313 300 291 272 243 213 183 149 111 65 12 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -2 11 59 103 141 171 202 233 259 280 293 300 300 293 267 222 144 32 -2 -3 -3 -3 -3 -3 -3 -3 -2 -2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -1 -1 -1 -1 -1 -1 -1 -1 -1 22 78 156 255 336 398 363 232 155 132 132 155 176 198 224 254 269 268 203 75 36 86 161 260 253 141 54 -1 -1 -1 -3 -3 -3 -3 -3 -3 -1 -1 -1 -1 -1 84 300 419 507 563 643 747 877 1033 1108 1105 1080 1033 1063 1168 1193 1137 1100 1080 1117 1211 1289 1349 1299 1136 1043 1019 975 910 912 982 1012 1003 915 751 614 505 465 493 520 547 552 535 525 522 519 517 489 434 409 414 456 533 550 506 431 324 262 245 237 238 254 286 304 309 322 342 364 387 400 403 406 408 405 395 398 413 416 407 398 388 371 347 327 311 301 295 282 261 232 195 155 112 61 4 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -2 9 52 93 124 146 167 189 207 222 232 239 244 247 231 195 131 38 -2 -3 -3 -3 -3 -3 -3 -2 5 173 166 -2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 15 69 127 188 235 270 241 148 95 82 93 128 180 250 275 256 209 133 57 -1 -1 34 91 144 94 -1 -1 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 -1 -1 -1 -1 -1 236 500 791 915 872 823 769 837 1026 1109 1086 1084 1104 1145 1207 1265 1322 1308 1225 1166 1131 1076 1002 1006 1090 1135 1141 1049 859 707 590 525 511 512 530 529 510 509 525 530 524 490 430 412 437 494 584 599 540 455 345 284 272 258 242 249 276 293 300 315 339 362 385 396 394 395 397 399 400 407 421 424 417 407 392 374 353 333 315 302 295 285 273 247 208 166 122 72 16 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -2 16 57 97 126 144 160 177 190 200 208 214 220 228 217 187 138 68 7 -2 -3 -3 -3 -3 -2 54 207 389 385 195 44 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 19 41 58 74 90 81 48 36 45 76 129 242 414 466 398 295 158 61 4 -1 -1 -1 -1 -1 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 146 488 596 470 391 359 459 691 852 943 1039 1142 1196 1203 1204 1198 1229 1295 1329 1329 1305 1256 1261 1322 1367 1397 1349 1223 1039 798 634 547 502 500 490 472 471 488 486 467 438 399 387 403 439 495 494 435 374 311 281 284 273 247 245 268 295 327 359 392 419 438 439 422 408 398 400 414 421 421 418 412 402 389 377 367 350 324 305 292 283 279 259 221 182 142 96 47 14 -2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -2 32 75 116 146 164 180 194 205 214 220 222 227 234 225 199 165 121 75 28 -2 -2 -2 -2 51 188 343 515 533 398 225 14 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 -1 -1 -1 -1 -1 -1 14 46 86 133 227 367 405 340 261 167 90 30 -1 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 -1 -1 -1 16 124 257 416 563 697 891 1147 1249 1197 1169 1165 1227 1355 1428 1445 1441 1416 1423 1462 1484 1491 1480 1452 1300 1022 814 676 592 562 541 529 532 551 544 511 470 421 406 424 447 475 465 418 389 380 378 382 353 290 274 306 342 383 417 445 465 479 475 454 439 431 430 437 434 422 410 398 389 382 376 372 356 330 308 291 282 282 265 233 200 165 127 85 54 33 8 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -2 13 54 110 151 176 195 210 223 235 244 249 253 256 246 223 197 166 133 98 68 42 43 70 149 281 423 575 606 514 355 131 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 -1 -1 28 85 123 141 139 118 102 92 111 161 142 57 -1 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 56 224 200 242 351 644 1121 1302 1188 1160 1219 1300 1406 1466 1481 1488 1486 1495 1513 1491 1427 1448 1554 1492 1262 1063 894 777 711 678 677 689 712 700 652 584 495 466 498 516 521 510 484 497 547 569 562 495 370 334 387 432 468 489 496 502 508 504 491 488 496 490 469 447 423 399 377 368 372 372 367 354 332 312 292 281 279 266 243 219 193 164 131 97 63 32 3 -2 -2 -2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -2 -2 81 142 180 207 225 244 264 280 292 296 292 280 259 233 204 180 164 145 122 127 157 226 333 449 573 605 545 436 278 124 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 6 29 40 61 92 101 87 38 -1 -1 -1 6 79 31 -1 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 80 49 71 145 418 891 1108 1069 1101 1204 1291 1362 1405 1421 1443 1472 1497 1519 1484 1393 1402 1510 1499 1371 1211 1020 878 785 739 739 753 780 771 724 650 549 519 561 575 561 551 545 567 616 632 617 551 434 398 441 475 500 509 503 503 510 513 510 515 526 515 482 449 419 391 368 359 365 363 351 338 321 306 291 280 274 261 241 222 202 179 152 120 83 53 30 15 8 4 2 -2 -2 -2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -2 53 124 183 222 240 261 286 306 321 327 324 316 304 283 254 234 222 211 200 209 239 294 373 457 546 573 538 462 346 204 37 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 18 112 153 141 113 68 22 -1 -1 -3 -3 -3 -1 -1 -1 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 -1 44 72 213 465 676 844 994 1124 1201 1226 1248 1266 1309 1375 1432 1481 1466 1388 1342 1326 1330 1353 1262 1056 898 788 728 719 729 759 760 730 671 584 565 613 624 597 589 602 602 590 573 553 523 485 466 468 473 481 479 467 469 486 501 513 521 524 509 475 442 409 386 372 364 362 349 325 308 297 290 287 279 266 249 228 209 192 173 150 124 92 71 60 58 67 69 66 56 40 23 4 -2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -2 25 98 186 238 255 276 301 321 337 347 351 354 357 345 317 293 273 267 275 291 316 352 400 449 497 512 495 436 337 217 77 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 -1 -1 -1 -1 41 130 158 126 78 14 -1 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 -1 85 204 366 572 755 917 1014 1049 1081 1111 1168 1251 1314 1357 1363 1331 1283 1218 1215 1274 1235 1096 969 852 781 754 747 758 747 715 668 608 600 644 656 634 629 643 632 596 568 547 539 543 536 518 507 501 485 459 454 470 483 494 497 494 480 455 428 401 381 368 359 352 336 311 294 286 280 276 266 249 233 218 204 191 175 156 135 111 96 90 92 102 107 105 98 83 65 42 23 6 -2 -2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -2 54 127 210 261 280 300 323 343 362 378 391 404 417 416 400 380 356 349 360 374 392 415 443 465 481 486 481 442 370 273 150 39 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 24 44 31 26 30 42 62 48 -1 -1 -1 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 32 100 174 253 391 588 735 832 905 956 1021 1101 1145 1153 1179 1224 1225 1181 1151 1137 1133 1140 1087 975 894 845 805 776 735 680 643 621 625 656 671 671 671 672 659 634 614 598 596 609 607 590 575 559 527 478 455 460 459 452 444 437 429 421 409 394 376 358 344 335 323 308 296 287 275 259 242 223 212 210 205 198 186 168 153 140 130 121 116 116 118 121 120 114 99 77 62 54 44 31 12 -2 -2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -2 -2 45 138 207 254 289 312 334 353 373 394 418 445 466 483 495 502 494 470 458 456 459 467 481 501 507 497 493 496 480 444 369 255 146 44 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 -1 28 32 3 -1 -1 -1 -1 -1 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 -1 24 34 133 323 515 710 828 870 942 1042 1077 1048 1063 1121 1132 1095 1057 1017 1028 1090 1102 1065 1034 1010 963 893 822 750 708 697 702 723 737 746 732 697 670 652 637 623 623 636 635 622 607 589 554 501 472 467 462 456 447 435 429 429 415 389 365 343 329 321 312 302 292 283 267 245 227 212 206 210 210 206 197 183 174 168 162 155 148 143 141 142 140 135 123 105 94 88 80 69 53 30 14 6 -2 -2 -2 -2 -3 -3 -3 -3 -3 -3 -2 -2 4 43 105 190 248 278 308 338 367 395 418 436 456 479 504 530 549 562 557 533 522 523 520 512 519 542 541 516 502 499 488 470 413 318 227 140 58 -2 -2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 1 -1 -1 -1 -1 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 -1 -1 120 354 680 847 853 927 1069 1106 1040 1011 1020 1004 964 934 914 920 952 1019 1123 1199 1247 1216 1106 1007 919 861 835 829 843 852 857 812 719 665 651 638 625 621 626 624 615 604 592 566 528 502 489 490 506 505 487 477 476 446 387 347 326 313 308 302 293 284 272 256 234 221 216 215 219 219 215 209 202 197 195 193 191 188 184 177 168 158 147 137 129 120 109 102 97 89 78 73 74 64 43 24 5 -2 -3 -3 -3 -3 -2 4 61 105 135 171 213 250 283 318 357 400 448 477 486 493 496 518 558 579 581 571 547 544 562 556 526 529 565 568 539 513 491 470 450 407 341 282 230 187 152 96 19 -2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 8 215 540 723 764 881 1075 1136 1064 1018 998 972 941 911 883 875 886 977 1148 1285 1387 1406 1342 1269 1187 1105 1023 972 953 933 912 849 744 683 668 654 641 634 631 626 617 608 598 583 565 547 530 526 536 531 510 495 485 448 383 346 335 321 303 290 282 274 265 250 229 219 219 224 231 235 234 232 227 226 227 228 228 227 223 215 203 189 176 166 161 150 135 125 120 114 105 103 106 96 71 46 21 -2 -3 -3 -3 -3 -2 20 91 143 175 201 220 247 282 318 355 399 452 484 495 502 505 527 568 590 593 586 568 571 592 584 546 540 567 565 534 506 480 462 452 420 368 316 263 239 241 223 185 129 54 -2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 98 292 461 605 805 1061 1165 1118 1080 1050 1031 1022 986 922 889 890 974 1143 1296 1433 1535 1601 1606 1551 1435 1259 1132 1054 982 914 844 772 725 703 686 671 660 652 641 629 618 607 605 610 604 588 569 548 527 505 483 458 423 378 361 371 353 306 278 269 263 260 248 228 220 223 232 247 257 263 264 260 260 263 266 267 265 262 256 245 234 220 209 200 186 166 151 139 127 113 106 104 94 77 54 27 5 -2 -3 -3 -3 -2 6 68 121 164 195 211 238 274 306 333 367 408 441 464 485 505 530 560 582 596 601 597 602 615 605 569 551 549 534 504 482 467 464 474 452 399 329 242 215 249 278 301 264 168 86 18 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 88 227 400 628 910 1075 1123 1144 1136 1132 1132 1090 1006 949 920 979 1127 1284 1449 1589 1703 1753 1738 1669 1547 1420 1286 1151 1014 912 845 794 761 734 713 695 680 665 649 635 625 624 633 628 609 582 547 524 511 492 467 442 417 408 417 398 349 309 278 262 259 249 230 222 224 235 253 270 284 291 291 293 297 300 302 302 300 295 285 273 260 246 234 217 196 177 160 145 130 119 110 97 79 57 30 11 -2 -3 -3 -3 -3 -2 48 102 157 194 213 241 278 309 334 363 396 428 459 491 522 551 576 595 607 616 620 623 626 612 582 561 551 534 508 492 486 484 486 464 418 355 274 255 297 335 369 343 259 184 117 32 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 18 151 353 626 869 1081 1210 1255 1274 1268 1222 1135 1053 975 992 1103 1251 1437 1572 1655 1716 1754 1810 1886 1830 1643 1436 1210 1051 960 890 840 798 764 737 717 696 676 661 650 642 634 618 594 566 535 522 527 523 511 502 497 488 474 455 431 382 308 268 262 251 233 223 222 232 251 272 296 312 322 327 329 331 333 335 337 332 321 307 293 278 261 244 225 204 183 167 156 142 125 103 78 54 32 15 3 -2 -3 -3 -3 -2 32 88 153 198 224 255 293 327 357 386 414 445 480 517 557 589 614 627 627 631 638 635 623 606 584 573 573 564 545 536 537 521 487 455 425 394 360 357 384 395 390 368 329 267 182 77 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 -1 164 421 709 1030 1240 1339 1390 1394 1363 1296 1204 1087 1055 1107 1211 1366 1475 1539 1611 1692 1812 1970 1986 1860 1684 1457 1262 1100 981 905 848 809 776 750 726 706 689 675 660 644 622 593 566 543 534 540 543 544 547 552 540 509 493 492 445 354 296 272 254 241 232 226 230 246 269 300 324 342 352 356 360 364 367 368 363 351 338 324 307 288 269 250 227 201 181 170 153 131 107 80 59 44 30 18 6 -2 -3 -3 -2 32 87 157 207 236 268 303 334 363 390 414 448 493 536 576 608 631 634 617 610 613 616 619 612 594 588 596 594 582 575 573 546 494 455 429 410 398 393 395 379 344 319 304 258 183 86 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 58 292 596 970 1234 1390 1482 1511 1513 1488 1401 1254 1167 1140 1163 1237 1302 1357 1442 1556 1678 1807 1895 1942 1894 1753 1543 1263 1068 957 884 847 813 780 755 737 719 700 681 663 637 605 582 570 560 551 553 565 575 583 565 524 513 532 500 417 347 289 258 255 247 234 231 239 260 297 327 352 369 378 386 394 396 394 387 378 366 352 335 313 292 273 246 213 189 172 152 129 107 86 72 66 55 42 26 7 -2 -2 10 47 100 169 219 249 279 308 333 353 374 396 438 500 548 580 606 627 617 577 554 546 565 612 628 611 609 619 623 621 611 595 560 507 463 430 405 390 366 334 290 234 199 187 161 122 61 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 155 454 785 1023 1166 1288 1388 1472 1540 1511 1386 1280 1195 1156 1165 1181 1204 1286 1424 1553 1670 1794 1924 1958 1897 1718 1420 1188 1023 916 866 824 789 764 749 732 715 699 683 664 641 622 607 589 569 566 580 592 602 586 546 533 546 527 475 411 334 286 269 254 242 236 236 256 295 329 357 376 385 394 404 407 403 399 395 386 372 353 330 310 294 270 236 207 181 155 130 112 104 96 88 78 66 57 51 47 44 59 92 138 195 238 265 293 320 342 359 378 399 440 501 545 571 593 609 598 559 531 512 527 575 582 548 535 542 542 533 519 497 464 418 380 349 327 313 281 230 170 103 77 93 99 94 51 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 12 285 481 612 677 818 1035 1248 1458 1537 1485 1396 1270 1188 1148 1112 1079 1140 1296 1436 1558 1683 1809 1880 1893 1791 1572 1342 1103 944 868 812 778 754 741 730 722 714 704 700 701 685 653 623 594 582 589 598 610 603 576 553 534 526 528 488 405 337 284 254 249 244 239 256 295 329 358 375 378 385 396 400 398 399 404 398 382 363 339 323 315 297 269 236 197 162 133 123 132 128 112 100 92 100 125 134 127 138 168 199 234 262 284 309 338 362 382 402 422 453 496 529 551 568 580 577 561 539 511 500 507 476 407 371 367 352 325 302 285 261 230 207 190 178 170 138 82 21 -2 -2 22 70 98 55 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 -1 210 374 441 552 708 906 1146 1283 1317 1300 1232 1197 1193 1151 1070 1101 1244 1371 1482 1591 1698 1762 1781 1739 1637 1448 1174 993 907 844 806 789 793 794 790 783 772 765 762 744 710 678 646 626 617 613 615 610 598 572 532 520 535 508 438 373 312 273 258 250 250 268 301 329 352 367 375 384 396 403 407 413 423 417 393 367 336 326 336 326 297 265 229 199 173 168 182 181 164 151 143 156 192 207 199 206 226 245 262 280 299 323 352 377 396 413 428 445 461 483 509 529 544 546 534 505 458 417 383 318 223 175 173 155 121 110 123 118 95 73 52 37 27 -2 -2 -2 -3 -2 39 106 124 73 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 303 449 484 407 449 611 758 891 1000 1085 1185 1299 1296 1175 1164 1265 1357 1440 1518 1590 1605 1563 1568 1618 1508 1237 1062 983 920 872 867 903 920 916 904 885 858 825 797 777 754 727 697 664 637 616 608 612 589 540 510 498 473 434 394 353 310 266 253 271 291 314 329 339 354 375 392 404 416 428 440 453 441 404 364 322 319 355 356 321 295 279 263 248 245 254 254 245 233 218 225 254 266 260 261 268 275 281 293 311 335 363 385 400 412 419 415 397 407 444 476 502 503 479 430 355 280 203 110 -2 -2 -2 -2 -2 -2 9 32 11 -2 -2 -2 -2 -3 -3 -3 -3 -2 142 205 170 106 12 -2 -2 -2 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 227 319 226 215 288 396 541 734 975 1185 1363 1362 1181 1125 1193 1254 1306 1362 1422 1434 1399 1435 1543 1515 1350 1213 1102 1016 954 933 954 967 973 959 926 886 838 812 807 791 765 730 688 654 629 621 629 605 548 507 484 464 447 425 398 351 283 262 286 307 326 336 338 349 371 388 402 418 435 452 469 453 404 350 292 278 308 312 291 290 311 317 309 307 312 310 301 287 268 269 289 297 293 292 295 296 298 311 336 360 382 400 415 426 436 414 361 350 382 422 470 463 403 337 263 196 136 72 4 -2 -2 -2 -2 -3 -2 -2 -2 -3 -3 -3 -3 -3 -3 -3 -2 67 226 276 219 155 85 46 40 1 -2 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 61 161 197 171 193 266 502 902 1197 1386 1351 1092 986 1032 1064 1082 1126 1196 1249 1286 1341 1414 1471 1513 1444 1263 1132 1050 988 946 938 963 950 899 850 804 787 800 792 762 727 688 663 652 647 649 618 555 513 492 479 474 464 447 395 309 275 295 316 338 348 348 353 362 374 390 408 428 449 472 453 393 324 247 205 196 197 208 251 326 361 356 355 358 351 332 314 295 290 297 300 298 300 306 310 313 334 375 399 409 421 438 457 476 441 350 311 322 367 446 426 308 226 181 164 177 200 233 244 234 168 45 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -2 48 179 291 320 269 219 171 137 118 58 -2 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 16 174 194 185 149 367 838 1143 1280 1214 946 830 866 891 906 959 1052 1146 1240 1305 1340 1440 1604 1592 1404 1253 1141 1057 1001 980 993 966 901 847 806 789 797 790 769 740 702 682 679 673 662 629 575 537 517 504 498 486 470 418 330 292 303 324 357 372 369 369 372 380 395 408 418 421 419 385 321 258 197 153 126 122 142 195 279 333 357 376 392 389 369 350 332 322 320 312 300 300 313 322 329 353 393 415 419 432 453 468 477 439 356 335 376 410 436 389 268 199 180 188 223 273 338 346 296 209 85 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -2 48 167 238 254 214 183 161 139 118 65 -2 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 145 353 367 186 325 784 1024 1047 953 743 657 695 734 774 858 987 1121 1259 1326 1320 1420 1625 1660 1524 1379 1225 1138 1118 1092 1060 1007 932 877 843 816 798 788 786 767 731 712 712 697 669 639 605 579 559 538 517 493 468 420 349 313 309 333 383 406 400 398 398 405 418 418 405 369 311 251 190 153 140 121 97 87 93 120 170 234 313 372 413 426 412 396 380 366 355 333 300 294 315 333 347 366 392 408 415 432 458 460 437 410 378 421 541 546 439 351 283 252 258 265 274 294 324 285 175 88 22 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -2 35 72 79 57 51 59 56 42 25 3 -2 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 38 331 405 260 404 836 999 891 751 577 512 556 621 707 812 937 1086 1260 1354 1369 1473 1664 1714 1623 1506 1364 1304 1327 1291 1196 1099 998 927 886 850 821 806 806 797 777 765 762 741 702 667 634 606 582 561 543 513 471 421 361 327 318 342 398 422 413 407 406 407 411 401 378 336 273 224 187 174 186 174 139 115 103 110 136 191 275 342 392 414 410 400 384 367 348 325 297 295 318 336 349 361 371 379 386 409 448 445 399 361 332 382 509 519 410 341 310 293 291 288 284 285 291 233 111 33 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -2 -2 -2 -2 -2 -2 -2 -2 -2 -2 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 133 303 369 599 993 1063 810 604 445 393 447 550 703 820 900 1041 1243 1391 1485 1594 1720 1756 1701 1634 1556 1553 1626 1575 1399 1240 1097 996 935 892 865 844 830 828 839 840 831 804 760 712 661 619 586 571 575 545 481 421 365 334 328 351 403 422 408 399 394 386 375 359 339 320 304 300 308 318 330 307 249 203 170 161 176 204 243 285 329 356 366 363 347 326 300 288 289 301 321 334 337 337 331 329 331 363 424 423 361 294 221 219 289 333 352 356 347 322 281 258 254 247 238 190 103 43 12 -2 -2 -2 -2 -3 -3 -3 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 48 262 400 633 962 996 736 553 446 439 532 671 856 970 1012 1144 1367 1538 1659 1760 1841 1852 1793 1746 1712 1743 1840 1780 1565 1373 1207 1088 1017 968 942 917 892 891 913 911 887 849 797 742 682 632 591 575 584 551 477 425 396 369 345 353 395 408 393 380 369 358 347 337 329 332 346 367 393 405 402 364 291 234 191 176 187 203 224 245 267 283 293 293 284 270 251 257 288 317 343 347 329 308 284 271 266 290 341 335 273 215 161 164 223 289 360 385 363 319 252 216 210 198 179 144 93 55 29 17 18 14 4 -2 -2 -2 21 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 75 279 354 510 748 801 668 594 576 647 807 979 1163 1260 1268 1390 1626 1792 1889 1967 2025 2003 1899 1843 1834 1876 1971 1910 1695 1500 1326 1203 1128 1078 1050 1022 992 983 996 978 931 877 815 756 698 645 597 573 571 534 460 433 452 431 368 349 374 380 368 352 333 324 327 335 348 369 401 425 443 436 403 347 268 208 168 155 170 191 216 221 205 195 192 192 196 199 201 233 292 342 381 374 322 275 231 204 192 191 201 182 134 124 153 215 310 383 433 425 360 287 206 162 154 137 114 96 83 68 50 44 51 55 55 45 25 6 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 95 302 397 541 732 808 768 764 797 903 1084 1214 1293 1342 1360 1507 1785 1965 2047 2110 2154 2116 1996 1941 1951 2014 2130 2097 1913 1699 1454 1344 1367 1323 1212 1141 1111 1101 1113 1080 1003 921 836 763 703 648 595 566 559 521 452 439 483 473 408 374 369 360 348 332 314 308 316 328 342 367 401 423 433 415 368 309 236 183 150 152 189 220 243 233 190 159 143 142 158 177 199 235 285 329 368 356 296 241 192 164 157 166 193 179 125 133 202 288 389 439 435 389 300 220 149 105 89 67 42 43 70 78 66 58 56 50 42 27 4 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 108 331 528 721 910 1013 1031 1062 1106 1206 1363 1378 1251 1222 1292 1500 1846 2057 2134 2190 2228 2192 2084 2041 2063 2155 2318 2338 2218 1968 1590 1511 1730 1702 1426 1274 1247 1244 1263 1216 1102 982 858 764 700 641 586 554 546 512 452 444 488 495 464 425 380 349 331 319 312 310 314 315 314 325 349 363 365 344 299 250 195 158 138 166 243 289 304 281 219 174 144 143 171 204 242 263 266 280 304 294 249 206 165 150 160 213 311 321 242 238 308 383 462 457 369 279 186 121 81 46 16 -2 -2 -2 56 86 77 59 32 1 -2 -2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 141 400 683 917 1102 1206 1231 1264 1304 1373 1470 1420 1224 1152 1205 1412 1774 2004 2102 2153 2156 2101 1987 1970 2049 2191 2397 2480 2439 2188 1728 1626 1882 1860 1562 1398 1368 1349 1342 1283 1172 1044 898 795 734 674 615 575 553 516 462 449 479 489 480 451 402 365 339 326 326 326 328 321 306 305 319 325 323 304 270 226 175 146 140 180 266 309 309 283 229 187 156 159 196 237 280 280 238 220 226 213 183 157 135 147 194 278 400 411 312 295 362 411 442 396 272 168 84 30 6 -2 -2 -3 -3 -2 26 57 40 13 -2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 194 507 863 1130 1307 1387 1370 1373 1395 1408 1409 1344 1211 1130 1099 1246 1572 1808 1956 2001 1943 1846 1709 1731 1911 2125 2372 2523 2579 2360 1867 1690 1828 1806 1623 1512 1472 1418 1350 1282 1213 1105 956 856 804 746 683 627 580 531 481 456 456 457 458 451 437 410 371 353 355 356 358 345 318 306 310 310 306 296 278 237 173 146 157 194 260 281 260 239 219 198 176 189 235 276 313 288 202 150 133 115 97 92 101 156 258 359 459 452 336 307 364 373 333 257 145 57 -2 -2 -2 -3 -3 -3 -3 -3 -2 -2 -2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 302 635 992 1252 1414 1490 1481 1477 1479 1462 1427 1366 1280 1216 1176 1253 1449 1617 1757 1801 1749 1678 1590 1651 1864 2093 2338 2501 2580 2409 1986 1803 1859 1838 1740 1662 1605 1518 1402 1315 1257 1164 1037 947 895 833 761 694 630 571 516 478 457 444 438 437 442 424 383 363 363 361 357 342 317 303 298 294 291 285 277 239 171 145 162 197 250 266 245 231 224 210 190 199 237 269 294 271 202 167 168 161 147 146 156 216 326 413 478 455 345 307 340 319 243 156 57 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 120 465 782 1070 1284 1424 1518 1565 1577 1554 1535 1520 1484 1427 1409 1431 1429 1404 1429 1505 1553 1573 1597 1625 1728 1905 2095 2297 2415 2447 2337 2084 1963 1974 1956 1911 1847 1766 1649 1496 1380 1301 1222 1141 1069 1006 933 851 774 704 635 567 516 481 449 419 409 420 408 376 357 351 341 326 314 304 294 285 279 276 272 266 231 167 142 157 189 238 263 264 257 243 223 197 191 205 216 224 231 236 269 328 348 330 313 299 327 397 440 456 422 339 295 290 250 174 93 9 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 105 577 923 1143 1307 1413 1511 1599 1638 1628 1602 1561 1533 1518 1543 1608 1601 1521 1488 1501 1509 1512 1539 1590 1717 1918 2093 2242 2314 2309 2246 2124 2065 2066 2071 2079 2033 1932 1785 1590 1444 1344 1262 1197 1131 1064 988 903 824 749 676 603 545 500 455 409 391 401 394 371 351 334 317 298 286 280 272 262 257 255 252 248 221 173 157 171 198 239 262 269 262 243 223 201 195 203 212 221 250 298 360 437 464 440 413 382 387 429 437 411 365 299 252 222 176 113 51 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 640 1060 1211 1319 1382 1471 1584 1661 1700 1663 1551 1515 1554 1619 1710 1769 1797 1787 1739 1665 1564 1505 1487 1620 1903 2088 2173 2199 2166 2135 2107 2108 2137 2183 2245 2219 2104 1926 1685 1504 1384 1285 1207 1135 1069 998 920 843 768 695 625 564 513 461 407 383 387 382 368 345 312 288 274 260 246 237 231 228 230 227 222 209 190 188 203 225 253 264 259 245 223 209 203 210 231 256 284 328 386 443 497 509 480 446 406 398 423 404 343 284 227 177 135 97 62 28 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 638 1054 1093 1186 1333 1464 1578 1648 1673 1630 1521 1500 1567 1648 1743 1834 1921 1926 1849 1727 1559 1468 1454 1607 1928 2131 2215 2206 2102 2057 2072 2115 2188 2282 2397 2386 2248 2029 1727 1518 1401 1299 1213 1134 1060 985 910 835 763 694 628 569 515 461 407 376 368 361 356 337 302 277 262 245 225 213 210 209 211 212 211 207 201 207 222 240 261 267 261 250 234 229 234 246 265 290 320 364 421 470 511 508 460 415 374 355 359 325 254 194 146 102 62 32 14 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 572 910 793 912 1267 1490 1580 1599 1548 1506 1471 1489 1557 1631 1709 1799 1899 1911 1834 1696 1496 1427 1489 1677 1992 2221 2366 2331 2115 2010 2017 2087 2219 2369 2536 2536 2367 2095 1720 1486 1393 1303 1216 1127 1035 950 872 800 736 674 615 558 505 455 408 371 344 332 335 326 303 283 265 242 215 200 198 198 201 206 213 214 209 214 228 244 261 271 273 274 274 280 292 301 306 315 329 359 402 443 481 460 380 322 286 259 239 201 143 95 59 28 2 -2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 373 742 594 698 1057 1339 1546 1604 1515 1460 1442 1491 1606 1700 1774 1851 1932 1943 1887 1748 1529 1458 1538 1730 2037 2239 2338 2283 2075 1982 2004 2109 2298 2492 2690 2692 2498 2197 1788 1537 1444 1347 1246 1143 1038 943 857 780 712 648 590 536 487 443 404 367 331 314 315 307 289 273 258 238 211 195 190 190 193 200 209 212 207 212 229 246 264 274 277 283 291 300 309 313 312 320 336 376 439 465 454 402 311 247 212 178 146 109 68 33 4 -2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 42 551 494 545 705 1016 1478 1662 1569 1493 1433 1506 1711 1854 1935 1989 2018 2023 2005 1882 1654 1560 1600 1768 2065 2186 2133 2066 1984 1972 2030 2181 2425 2650 2858 2855 2641 2332 1928 1668 1552 1430 1304 1183 1069 963 865 775 690 617 554 502 460 425 395 364 331 308 297 280 258 246 244 232 212 197 187 184 188 193 199 199 194 203 226 247 267 276 274 277 286 288 283 282 285 304 340 415 528 533 429 336 253 191 149 112 78 50 29 6 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 244 339 399 423 731 1322 1641 1686 1653 1542 1589 1796 1937 2014 2040 2015 2015 2038 1948 1745 1671 1726 1873 2112 2142 1964 1879 1889 1944 2045 2232 2503 2736 2930 2917 2697 2382 1970 1699 1569 1441 1315 1194 1079 970 868 772 683 606 543 490 448 417 396 368 333 306 287 267 246 237 238 231 217 202 185 177 178 179 181 180 176 188 214 236 253 262 263 269 278 276 264 265 280 328 410 506 615 587 420 292 201 135 94 61 34 15 1 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 130 259 208 483 1081 1542 1865 1940 1765 1739 1860 1952 2015 2007 1927 1921 1989 1950 1802 1790 1916 2045 2177 2105 1828 1723 1790 1900 2051 2262 2534 2749 2908 2881 2670 2347 1914 1631 1499 1382 1282 1177 1068 964 865 774 689 616 555 500 452 420 405 378 337 307 286 268 253 243 240 234 227 211 186 169 162 158 156 155 153 167 195 213 223 234 246 257 267 265 251 261 296 390 544 648 700 626 426 270 156 82 47 25 15 2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 157 124 333 786 1287 1836 2061 1959 1894 1865 1880 1937 1914 1812 1794 1860 1856 1782 1835 2015 2112 2125 1996 1725 1641 1742 1892 2091 2326 2597 2781 2879 2837 2655 2349 1920 1635 1494 1374 1274 1168 1055 952 859 773 692 620 556 498 446 413 400 373 330 301 286 277 273 271 270 266 258 238 204 177 156 144 142 141 140 154 182 203 219 235 254 269 280 286 285 317 381 484 625 686 668 563 373 225 119 51 21 5 2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 94 166 281 439 880 1604 2019 2125 2056 1813 1721 1781 1765 1673 1635 1653 1670 1688 1806 2026 2076 1957 1817 1656 1631 1741 1920 2167 2424 2691 2831 2844 2784 2653 2386 1985 1707 1554 1415 1291 1166 1039 934 850 769 691 617 546 484 432 397 381 353 312 290 285 291 308 320 328 325 310 281 240 199 160 139 138 137 137 150 175 205 240 266 285 302 318 339 365 431 535 609 652 622 521 400 260 157 90 43 16 -2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 64 260 271 580 1185 1684 2076 2081 1699 1514 1527 1524 1504 1457 1381 1415 1558 1736 1950 1979 1824 1724 1678 1696 1779 1914 2103 2316 2553 2683 2707 2688 2627 2415 2050 1784 1617 1457 1305 1163 1030 924 844 763 682 602 522 456 405 370 351 323 287 277 293 313 336 346 343 330 308 273 227 184 145 128 133 138 144 157 178 212 258 295 321 344 363 399 453 535 647 679 630 538 402 285 188 116 70 36 14 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 270 279 384 584 1062 1818 1973 1525 1260 1178 1194 1308 1258 1046 1091 1392 1625 1789 1823 1727 1716 1791 1836 1852 1874 1903 2007 2187 2341 2469 2548 2578 2434 2116 1866 1683 1500 1316 1159 1029 923 840 754 665 575 483 414 366 331 309 283 256 264 309 340 359 351 315 283 253 214 165 132 114 112 128 144 160 176 191 223 274 320 362 394 415 466 548 631 717 693 561 434 310 217 154 102 61 31 13 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 93 240 303 282 683 1505 1718 1322 1060 933 966 1158 1134 894 956 1321 1576 1721 1767 1714 1732 1822 1878 1900 1901 1881 1923 2026 2140 2266 2368 2446 2338 2044 1808 1629 1456 1288 1146 1029 927 838 746 651 558 468 400 352 314 286 260 235 248 299 335 353 339 290 245 203 161 121 100 98 108 129 153 180 200 213 248 306 351 385 436 507 570 626 658 664 595 452 332 237 168 124 84 49 25 11 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 155 334 273 540 1137 1320 1089 913 791 839 1056 1083 921 1008 1344 1589 1743 1808 1783 1771 1773 1823 1921 1992 2033 2058 2065 2077 2095 2147 2232 2129 1838 1614 1458 1326 1220 1122 1031 936 838 739 639 551 476 413 362 318 283 251 223 228 266 296 318 309 268 217 156 115 93 87 98 114 135 165 202 229 245 287 354 388 389 472 637 710 689 616 490 385 301 234 182 136 97 63 36 17 7 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 274 310 516 894 1042 958 872 784 801 924 932 825 924 1228 1465 1635 1735 1764 1773 1760 1815 1937 2041 2126 2139 2078 2023 1974 1985 2056 1954 1680 1484 1367 1269 1193 1111 1024 921 801 692 595 515 455 402 355 313 275 245 222 225 254 273 282 266 225 175 117 83 74 80 101 121 139 168 208 238 259 297 354 386 390 470 624 669 604 495 343 245 199 161 131 100 69 44 23 9 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 124 392 608 774 880 928 937 909 851 765 684 609 706 976 1207 1398 1549 1660 1738 1783 1853 1947 2050 2162 2168 2067 1978 1901 1880 1916 1813 1571 1418 1355 1284 1204 1112 1009 881 729 608 519 451 406 366 331 297 264 242 231 238 264 267 245 210 161 119 84 66 65 78 106 127 139 163 199 229 254 280 308 344 390 432 471 451 374 298 223 172 144 114 83 59 42 26 12 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 92 355 489 609 712 801 876 815 620 500 455 538 747 926 1075 1229 1388 1529 1651 1785 1929 2058 2171 2165 2039 1921 1808 1781 1838 1738 1480 1342 1323 1271 1186 1090 984 849 686 562 476 414 373 338 308 277 245 225 214 216 230 222 192 156 112 81 63 55 57 74 106 124 127 144 175 205 235 259 279 312 358 369 345 299 230 179 148 121 100 76 49 30 19 7 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 -1 44 228 315 469 688 695 490 380 363 417 540 623 666 776 953 1150 1368 1613 1885 2066 2155 2131 1995 1850 1696 1687 1822 1729 1408 1256 1272 1233 1140 1045 948 824 672 553 467 401 356 317 284 252 220 194 173 159 151 139 123 103 79 62 53 48 49 67 101 113 104 112 138 168 201 235 269 290 297 283 247 209 169 138 117 93 67 45 27 12 2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 -1 20 277 593 631 390 271 272 310 385 439 473 566 718 930 1202 1464 1718 1892 1986 1973 1854 1720 1572 1585 1760 1684 1357 1200 1212 1174 1084 994 903 795 669 565 482 415 362 315 271 232 196 168 148 129 111 96 86 74 61 51 43 43 49 69 102 110 92 92 108 132 164 198 233 247 240 217 179 148 125 104 87 65 40 22 12 -2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 223 590 622 320 172 180 216 281 372 490 593 682 868 1152 1340 1432 1540 1665 1691 1619 1533 1434 1475 1654 1605 1326 1173 1145 1094 1019 937 848 761 676 596 522 453 391 330 269 217 173 147 140 127 108 92 79 68 57 46 35 38 56 80 109 113 93 83 84 98 124 148 172 185 187 172 140 115 98 79 57 37 18 8 4 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 359 519 345 220 143 134 192 308 481 621 728 915 1182 1320 1328 1386 1494 1517 1456 1398 1344 1389 1534 1503 1296 1152 1071 1003 948 886 817 748 679 611 542 476 412 342 267 206 159 133 128 118 102 88 76 64 53 43 34 42 67 89 108 106 86 74 71 80 100 116 130 138 141 132 112 94 78 59 36 17 3 -2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 324 465 411 160 63 118 246 446 649 856 1070 1293 1404 1403 1425 1469 1449 1365 1315 1299 1327 1400 1380 1266 1136 989 902 872 841 809 754 678 608 544 483 425 352 263 197 153 126 114 104 95 85 76 64 49 40 39 53 82 97 98 90 72 65 70 79 92 101 106 107 103 99 95 84 65 45 22 5 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 442 515 173 16 42 160 369 596 842 1069 1278 1385 1390 1425 1488 1468 1365 1310 1302 1310 1333 1326 1289 1194 1041 936 880 831 791 740 680 620 561 499 434 352 254 184 142 114 99 88 80 72 65 54 39 33 36 49 73 82 76 66 53 49 56 63 70 74 76 75 71 71 74 68 53 35 14 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 279 533 183 -1 -1 50 251 463 688 913 1140 1266 1291 1386 1550 1573 1455 1382 1354 1337 1331 1340 1364 1325 1223 1105 970 856 763 707 685 647 593 523 438 344 240 167 125 97 82 69 59 49 41 33 25 22 23 29 40 44 42 36 28 26 30 32 34 37 41 44 47 49 49 47 41 29 11 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 366 187 41 -1 -1 134 327 539 748 955 1084 1135 1301 1582 1686 1614 1545 1480 1416 1355 1334 1353 1325 1249 1141 1002 862 719 643 632 604 560 493 403 309 211 143 105 78 62 48 37 28 20 15 12 11 12 15 18 19 17 10 -2 -2 -2 -2 -2 -2 -2 13 20 25 26 28 31 25 10 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 15 185 157 -1 -1 20 190 394 572 723 840 923 1172 1585 1808 1841 1798 1679 1548 1404 1307 1258 1195 1121 1048 979 849 658 549 520 491 463 408 328 248 169 114 81 56 37 24 15 8 3 -2 -2 1 3 5 6 5 2 -2 -3 -3 -3 -3 -3 -3 -3 -2 -2 -2 4 12 23 22 11 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 84 191 27 -1 -1 48 229 385 518 649 778 1084 1568 1869 1988 1970 1817 1636 1430 1304 1258 1198 1122 1080 1071 938 680 514 439 387 360 313 248 186 127 83 55 32 15 3 -2 -2 -2 -3 -3 -2 -2 -2 -2 -2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -2 -2 15 20 14 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 146 216 146 -1 -1 43 189 340 510 699 1039 1532 1870 2055 2063 1892 1682 1433 1323 1354 1330 1251 1233 1278 1128 783 536 388 292 250 207 164 123 83 51 26 8 -2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -2 9 18 19 4 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 110 285 236 -1 -3 -1 -1 113 352 558 911 1411 1795 2061 2104 1922 1709 1462 1366 1421 1404 1316 1311 1386 1229 838 551 367 249 196 154 125 91 54 21 -2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -2 3 16 21 11 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 84 236 219 35 -1 -3 -3 -1 174 357 702 1208 1643 2006 2094 1908 1715 1517 1431 1458 1421 1321 1312 1397 1241 846 557 375 255 196 154 130 91 38 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -2 12 20 16 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 -1 131 100 -1 -3 -3 -3 -1 110 481 929 1378 1830 2030 1979 1857 1663 1541 1490 1412 1308 1290 1359 1239 931 679 483 331 222 153 124 82 28 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -2 4 14 14 5 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 157 28 -1 -3 -3 -3 -1 248 573 1002 1534 1911 2135 2131 1899 1694 1516 1377 1279 1244 1273 1222 1092 914 690 477 275 152 107 63 21 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -2 5 8 3 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 89 -1 -3 -3 -3 -3 -1 236 673 1208 1694 2130 2249 2048 1836 1614 1443 1322 1265 1272 1277 1281 1184 986 715 370 168 109 60 20 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -2 2 1 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 18 -1 -3 -3 -3 -3 -1 392 853 1378 1967 2211 2111 1969 1785 1607 1437 1352 1353 1402 1498 1488 1372 1045 505 201 130 72 24 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 29 -1 -3 -3 -3 -3 -3 -1 457 1009 1655 2029 2129 2095 1927 1763 1602 1513 1496 1550 1678 1713 1654 1307 672 298 187 96 26 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 -3 -3 -3 -3 -3 -3 -1 21 587 1197 1702 2101 2213 2040 1909 1818 1748 1699 1723 1822 1859 1835 1504 869 460 279 134 26 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 101 689 1283 1880 2140 2061 2013 1994 1947 1873 1871 1939 1951 1906 1607 1054 641 368 155 2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 131 771 1469 1876 1991 2075 2129 2110 2020 1993 2029 1989 1871 1618 1229 842 455 160 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 260 961 1467 1779 2001 2133 2171 2113 2086 2090 2000 1815 1553 1216 841 429 133 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 355 914 1426 1791 2009 2130 2155 2152 2123 1985 1737 1414 1017 643 292 76 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 556 1149 1582 1858 2029 2097 2130 2126 2000 1752 1418 998 614 264 67 23 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 391 946 1376 1680 1869 1943 2020 2101 2047 1859 1563 1159 753 344 105 35 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -2 -2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 327 920 1342 1592 1758 1838 1927 2026 2029 1937 1741 1442 1090 684 374 159 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -2 -2 -2 2 3 1 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 363 1069 1479 1595 1696 1782 1851 1903 1948 1987 1952 1845 1621 1281 872 393 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -2 1 17 21 15 9 3 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 872 1376 1490 1591 1678 1755 1821 1903 2001 2084 2152 2069 1835 1462 949 402 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -2 21 47 52 34 19 7 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 335 1034 1279 1443 1527 1639 1780 1894 1980 2137 2366 2436 2347 2143 1823 1242 400 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -2 10 43 84 90 60 34 12 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 177 723 1072 1225 1371 1511 1620 1696 1878 2167 2311 2313 2256 2141 1619 689 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -2 29 69 119 120 74 -2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 -1 479 774 953 1017 1083 1151 1310 1558 1700 1737 1807 1910 1537 689 108 -2 -2 -2 -2 -2 -2 -2 -2 -2 22 58 101 152 144 76 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 -1 91 307 548 814 1041 1228 1368 1460 1615 1836 1607 929 466 217 83 63 58 69 81 92 88 69 69 90 124 173 158 80 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 -1 13 681 1069 1175 1311 1478 1680 1918 1827 1408 940 425 165 160 174 207 241 275 256 184 140 125 139 181 164 88 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 -1 226 665 966 1127 1385 1738 1824 1642 1239 615 293 274 304 382 466 556 537 411 295 189 163 217 198 107 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 -1 333 411 733 1299 1599 1633 1362 787 468 405 447 594 757 934 931 749 532 280 196 278 260 140 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 -1 -1 58 456 645 555 188 51 144 298 514 767 1056 1173 1116 912 562 388 391 331 209 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 -1 -1 -1 -1 -1 -1 -1 143 498 926 1264 1512 1435 1034 740 553 412 317 178 -2 -2 -2 -2 -2 -2 -2 -2 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 -1 510 1009 1432 1498 1207 946 712 566 506 512 586 639 672 627 505 347 153 41 13 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 412 878 1103 1086 1007 868 790 776 806 882 903 871 768 594 421 250 130 60 14 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 -1 416 635 741 733 735 745 791 873 913 911 828 665 491 306 168 76 16 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 -1 148 311 401 416 470 561 668 790 808 721 559 322 155 60 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 -1 -1 -1 87 251 418 587 666 653 533 306 145 50 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 -1 162 303 403 464 416 260 135 44 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 -1 209 297 310 248 146 3 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 82 152 216 271 175 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 -1 191 310 228 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 236 363 303 58 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 200 329 300 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 306 672 525 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
    -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -1 294 858 855 285 -2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
  ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2007 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2007).  NetLogo Continental Divide model.
; http://ccl.northwestern.edu/netlogo/models/ContinentalDivide.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2007 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/ContinentalDivide
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model demonstrates one way to locate a continental divide.  A continental divide separates a continent into two regions based on two bodies of water.  Rain in one region flows into one body of water and rain in the other region flows into the other.

In the example data, the continent is North America and the two bodies of water used to calculate the divide are the Pacific and Atlantic oceans.


HOW IT WORKS
------------
The model is initialized with an elevation map.  Then both oceans systematically rise, bit by bit.  The two floods run towards each other over the continent and eventually crash.  The continental divide is precisely where the two floods collide.


HOW TO USE IT
-------------
SETUP initializes the model.  Elevations are stored in the patches and they are colored appropriately. Also, the two floods are started off on the coasts.

GO runs the model.  When the floods cannot advance any more with the given height of the water, the water level is raised a little bit.  Eventually, when the whole continent has been flooded and the continental divide has been found, the model stops automatically.


THINGS TO NOTICE
----------------
The two floods move at different rates.

The first 100 meters of flood covers more land than the last 100 meters.  What about in between?

Land that's flooded later isn't necessarily higher elevation. (Why?)


THINGS TO TRY
-------------
Use the speed slider to slow the model down and watch what happens in more detail.

Increase the patch-size to get a better view of the action.  (Because the elevation data assumes specific dimensions, you can't change the number of patches in the model.)


EXTENDING THE MODEL
-------------------
Make a slider to control how much water-height changes when the flooding at a given water-height has stopped.

Make a slider for controlling how many colors from FLOODED-GROUND-COLOR-LIST get used.  With a smaller number, the flooded land's elevation is easier to see.  With a larger number, the progression of flooding is easier to see.

Is there a difference if NEIGHBORS is used instead of NEIGHBORS4? Make a switch to toggle between the two options and compare them.

Try the model with a more detailed dataset.

Allow the user of the model to specify different bodies of water than the Atlantic and Pacific oceans.  For example, it'd be interesting to see which water flows into the Gulf of Mexico and which flows into the Atlantic.

Allow the user to import maps of other parts of the world.


NETLOGO FEATURES
----------------
Note the use of turtles to represent the edges of the flood.  Instead of asking all the patches to find the ones on each edge, we only need to ask the turtles to act.  Since at any given moment only a few patches are at a flood edge, this is much faster.

Note the used of FOREACH on multiple lists to initialize the elevation data in the patches.


RELATED MODELS
--------------
Grand Canyon


CREDITS AND REFERENCES
----------------------
This model was inspired by Brian Hayes' article ""Dividing the Continent"" in American Scientist, Volume 88, Number 6, page 481.  An online version can be found here: http://www.americanscientist.org/template/AssetDetail/assetid/20828?&print=yes

Thanks to Josh Unterman for his work on this model.

To refer to this model in academic publications, please use:  Wilensky, U. (2007).  NetLogo Continental Divide model.  http://ccl.northwestern.edu/netlogo/models/ContinentalDivide.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2007 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/ContinentalDivide for terms of use.
"
Erosion,/models/Sample Models/Earth Science,"globals [
  show-water?     ;; whether the water is visible
  drains          ;; agentset of all edge patches where the water drains off
  land            ;; agentset of all non-edge patches
]

patches-own [
  elevation       ;; elevation here (may be negative)
  water           ;; depth of water here
  drain?          ;; is this an edge patch?
]

to setup
  clear-all
  set show-water? true
  ask patches [
    ifelse bumpy?
       [ ifelse hill?
           [ set elevation -100 * (distancexy 0 0 / max-pxcor) + 100 + random 100 ]
           [ set elevation random 125 ] ]
       [ set elevation 100 ]
    set water 0
    set drain? false
  ]
  ;; the DIFFUSE command is useful for smoothing out the terrain
  if bumpy? [
    repeat terrain-smoothness [ diffuse elevation 0.5 ]
  ]
  ;; make the drain around the edge
  ask patches with [count neighbors != 8]
    [ set drain? true
      set elevation -10000000 ]
  set drains patches with [drain?]
  set land patches with [not drain?]
  ;; display the terrain
  ask land [ recolor ]
end

to recolor  ;; patch procedure
  ifelse water = 0 or not show-water?
    [ set pcolor scale-color white elevation -250 100 ]
    [ set pcolor scale-color blue (min list water 75) 100 -10 ]
end

to show-water
  set show-water? true
  ask land [ recolor ]
end

to hide-water
  set show-water? false
  ask land [ recolor ]
end

to go
  ;; first do rainfall
  ask land [
    if random-float 1.0 < rainfall [
      set water water + 1
    ]
  ]
  ;; then do flow;  we don't want to bias the flow in any
  ;; particular direction, so we need to shuffle the execution
  ;; order of the patches each time; using an agentset does
  ;; this automatically.
  ask land [ if water > 0 [ flow ] ]

  ;; reset the drains to their initial state
  ask drains [
    set water 0
    set elevation -10000000
  ]
  ;; update the patch colors
  ask land [ recolor ]
  ;; update the clock
  tick
end

to flow  ;; patch procedure
  ;; find the neighboring patch where the water is lowest
  let target min-one-of neighbors [elevation + water]
  ;; the amount of flow is half the level difference, unless
  ;; that much water isn't available
  let amount min list water (0.5 * (elevation + water - [elevation] of target - [water] of target))
  ;; don't flow unless the water is higher here
  if amount > 0 [
    ;; first erode
    let erosion amount * (1 - soil-hardness)
    set elevation elevation - erosion
    ;; but now the erosion has changed the amount of flow needed to equalize the level,
    ;; so we have to recalculate the flow amount
    set amount min list water (0.5 * (elevation + water - [elevation] of target - [water] of target))
    set water water - amount
    ask target [ set water water + amount ]
  ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2004 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Dunham, G., Tisue, S. and Wilensky, U. (2004). NetLogo Erosion model.
; http://ccl.northwestern.edu/netlogo/models/Erosion.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2004 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Erosion
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model is a simulation of soil erosion by water.  The user is presented with an empty terrain.  Rain falls on the terrain and starts to flow downhill.  As it flows, it erodes the terrain below.  The patterns of water flow change as the terrain is reshaped by erosion.  Eventually, a river system emerges.


HOW IT WORKS
------------
The soil is represented by gray patches.  The lighter the patch, the higher the elevation. Water is represented by blue patches.  Deeper water is represented by a darker blue.  Around the edge of the world is a ""drain"" into which water and sediment disappear.

Each patch has a certain chance per time step of receiving rain.  If it does receive rain, its water depth increases by one.

The model uses the following naive model of flowing water.  Water flows to the adjacent patch where the water level is lowest, as long as that patch is lower than the source.  The amount of flow is proportional to the difference in level, so that the water level on the two patches is (if possible) equalized.

Erosion is represented by decreasing the elevation of the source patch a bit when flow occurs.  The amount of erosion is proportional to the amount of flow.


HOW TO USE IT
-------------
The SETUP button generates a terrain.  The smoothness of the terrain is controlled by the TERRAIN-SMOOTHNESS slider.  Lower values give rougher terrain, with more variation in elevation.  If you want a perfectly flat terrain, turn off the BUMPY? switch.  If you want to start out with a hill in the middle, turn on the HILL? switch.

The GO button runs the erosion simulation.

You can use the HIDE-WATER button to make the water vanish so you can see the terrain beneath.

The RAINFALL slider controls how much rain falls.  For example, if RAINFALL is 0.1, then each patch has a 10% chance of being rained on at each time step.

The SOIL-HARDNESS slider controls how ""hard"" or resistant to erosion the soil is.  Higher values will cause the soil to be harder, and less likely to erode, while lower values will cause the soil to erode more quickly.  A value of 1.0 means that the soil will not erode at all.


THINGS TO NOTICE
----------------
Initially, the world is covered by lakes.  Then rivers start to form at the edge of the world.  Gradually, these rivers grow until they have drained all the lakes.


THINGS TO TRY
-------------
Use the HIDE-WATER button to make the water invisible, and observe the terrain.

Experiment with the effect of the different sliders on the appearance of the resulting rivers.

See what happens when you start with a perfectly flat terrain.  (Is what happens realistic, or does it reveal limitations of the model?)

See what happens when you start with a hill.


EXTENDING THE MODEL
-------------------
Add evaporation.  Does this alter the behavior of the system in interesting ways?

Add ""springs"" -- point sources from which new water flows.

Add indicator turtles to show the direction and magnitude of flow on each patch.

Experiment with the rules for water flow.  Currently, all of the water simply flows to the lowest neighbor.  Would a more elaborate rule produce different results?

Add multiple soil types to the terrain, so that the land is of varying hardness, that is, varying speed of erosion.

What would it take to get river deltas to form?  You'd need to model sediment being carried by water and then deposited.


NETLOGO FEATURES
----------------
Only patches are used, no turtles.

The code depends on agentsets always being randomly ordered.


CREDITS AND REFERENCES
----------------------
Here is an eroded volcano in Kamchatka with a strong resemblance to this model:
http://maps.google.com/?t=k&ll=52.544312,157.338467&spn=0.070884,0.118103&t=k

Thanks to Greg Dunham and Seth Tisue for their work on this model.

To refer to this model in academic publications, please use:  Dunham, G., Tisue, S. and Wilensky, U. (2004).  NetLogo Erosion model.  http://ccl.northwestern.edu/netlogo/models/Erosion.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2004 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Erosion for terms of use.
"
Fire,/models/Sample Models/Earth Science,"globals [
  initial-trees   ;; how many trees (green patches) we started with
  burned-trees    ;; how many have burned so far
]

breed [fires fire]    ;; bright red turtles -- the leading edge of the fire
breed [embers ember]  ;; turtles gradually fading from red to near black

to setup
  clear-all
  set-default-shape turtles ""square""
  ;; make some green trees
  ask patches with [(random-float 100) < density]
    [ set pcolor green ]
  ;; make a column of burning trees
  ask patches with [pxcor = min-pxcor]
    [ ignite ]
  ;; set tree counts
  set initial-trees count patches with [pcolor = green]
  set burned-trees 0
end

to go
  if not any? turtles  ;; either fires or embers
    [ stop ]
  ask fires
    [ ask neighbors4 with [pcolor = green]
        [ ignite ]
      set breed embers ]
  fade-embers
  tick
end

;; creates the fire turtles
to ignite  ;; patch procedure
  sprout-fires 1
    [ set color red ]
  set pcolor black
  set burned-trees burned-trees + 1
end

;; achieve fading color effect for the fire as it burns
to fade-embers
  ask embers
    [ set color color - 0.3  ;; make red darker
      if color < red - 3.5     ;; are we almost at black?
        [ set pcolor color
          die ] ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Fire model.
; http://ccl.northwestern.edu/netlogo/models/Fire.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Fire
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This project simulates the spread of a fire through a forest.  It shows that the fire's chance of reaching the right edge of the forest depends critically on the density of trees. This is an example of a common feature of complex systems, the presence of a non-linear threshold or critical parameter.


HOW IT WORKS
------------
The fire starts on the left edge of the forest, and spreads to neighboring trees. The fire spreads in four directions: north, east, south, and west.

The model assumes there is no wind.  So, the fire must have trees along its path in order to advance.  That is, the fire cannot skip over an unwooded area (patch), so such a patch blocks the fire's motion in that direction.


HOW TO USE IT
-------------
Click the SETUP button to set up the trees (green) and fire (red on the left-hand side).

Click the GO button to start the simulation.

The DENSITY slider controls the density of trees in the forest. (Note: Changes in the DENSITY slider do not take effect until the next SETUP.)


THINGS TO NOTICE
----------------
When you run the model, how much of the forest burns. If you run it again with the same settings, do the same trees burn? How similar is the burn from run to run?

Each turtle that represents a piece of the fire is born and then dies without ever moving.  If the fire is made of turtles but no turtles are moving, what does it mean to say that the fire moves?  This is an example of different levels in a system: at the level of the individual turtles, there is no motion, but at the level of the turtles collectively over time, the fire moves.


THINGS TO TRY
-------------
Set the density of trees to 55%. At this setting, there is virtually no chance that the fire will reach the right edge of the forest. Set the density of trees to 70%. At this setting, it is almost certain that the fire will reach the right edge. There is a sharp transition around 59% density. At 59% density, the fire has a 50/50 chance of reaching the right edge.

Try setting up and running a BehaviorSpace experiment (see Tools menu) to analyze the percent burned at different tree density levels.


EXTENDING THE MODEL
-------------------
What if the fire could spread in eight directions (including diagonals)? To do that, use ""neighbors"" instead of ""neighbors4"". How would that change the fire's chances of reaching the right edge? In this model, what ""critical density"" of trees is needed for the fire to propagate?

Add wind to the model so that the fire can ""jump"" greater distances in certain directions.


NETLOGO FEATURES
-----------------
Unburned trees are represented by green patches; burning trees are represented by turtles.  Two breeds of turtles are used, ""fires"" and ""embers"".  When a tree catches fire, a new fire turtle is created; a fire turns into an ember on the next turn.  Notice how the program gradually darkens the color of embers to achieve the visual effect of burning out.

The ""neighbors4"" primitive is used to spread the fire.

You could also write the model without turtles by just having the patches spread the fire, and doing it that way makes the code a little simpler.   Written that way, the model would run much slower, since all of the patches would always be active.  By using turtles, it's much easier to restrict the model's activity to just the area around the leading edge of the fire.

See the ""CA 1D Rule 30"" and ""CA 1D Rule 30 Turtle"" for an example of a model written both with and without turtles.


RELATED MODELS
--------------
Percolation, Rumor Mill


CREDITS AND REFERENCES
----------------------
This model was developed at the MIT Media Lab.  See Resnick, M. (1994) ""Turtles, Termites and Traffic Jams: Explorations in Massively Parallel Microworlds.""  Cambridge, MA: MIT Press.  Adapted to StarLogoT, 1998, as part of the Connected Mathematics Project.  Adapted to NetLogo, 2001, as part of the Participatory Simulations Project.

To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Fire model.  http://ccl.northwestern.edu/netlogo/models/Fire.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Fire for terms of use.
"
Climate Change,/models/Sample Models/Earth Science/Unverified,"breed [clouds cloud]
breed [sunrays sunray]
breed [IRs IR]
breed [heats heat]
breed [people person]
breed [factories factory]
breed [CO2s CO2]

clouds-own [ cloud-num ]
globals [ sky-top earth-top temperature num-CO2 num-clouds starter ]

to setup
  clear-all
  setup-world
  set temperature 12
  plot temperature
  set-default-shape sunrays ""sunray""
  set-default-shape IRs ""sunray""
end

to go
  if starter = 0 [
    set starter 1
    setup-world
  ]
  ask clouds [ fd .3 * (0.1 + (3 + cloud-num) / 10) ]  ; move clouds along
  run-sunshine
  ask patches [ update-albedo ]
  run-heat  ;; moves heat dots
  run-IR    ;; moves the IR arrowheads
  run-CO2   ;; moves CO2 molecules
  tick
  plot temperature
end

to update-albedo
  if pycor = earth-top [ set pcolor 50 + 9 * albedo ]
end

to setup-world
  set sky-top max-pycor - 5
  set earth-top 8 + min-pycor
  ask patches [                           ;; set colors of the world
    if pycor = max-pycor [ set pcolor black ]
    if pycor < max-pycor and pycor > sky-top [
      set pcolor 9 - scale-color white pycor sky-top max-pycor
    ]
    if pycor <= sky-top and pycor > earth-top [
      set pcolor blue + 2 * (pycor + max-pycor) / max-pycor
    ]
    if (pycor < earth-top) [ set pcolor red + 3 ]
    update-albedo
  ]
end

to add-cloud            ;; erase clouds and then create new ones, plus one
  set num-clouds num-clouds + 1
  setup-clouds num-clouds
end

to remove-cloud       ;; erase clouds and then create new ones, minus one
  if (num-clouds > 0 ) [
    set num-clouds num-clouds - 1
    setup-clouds num-clouds
  ]
end

to setup-clouds [n] ;; creates clouds
  ask clouds [ die ]
  let i 0
  repeat n [
    make-cloud i n
    set i i + 1
  ]
end

to make-cloud [k n]                   ;; makes cloud number k out of n total
  let width sky-top - earth-top
  let mid (sky-top + earth-top) / 2
  let y mid + width * (k / n - 0.3) - 2  ;; the ratio k/n determines its altitude
  if k = 0 [set y 6 ]
  let x 2 * (random max-pxcor ) + min-pxcor
  repeat 3 + random 20 [
    create-clouds 1 [ ;; lots of turtles make up a cloud
      set cloud-num k
      setxy x + random 9 - 4
            y + random random 5
      set color white
      set size 2 + random 2
      set heading 90
      set shape ""cloud""
    ]
  ]
end

to run-sunshine
  ask sunrays [
    fd .3    ;; move sunrays forward
    if heading = 20 and ycor = max-pycor [ die ]  ;; kill rays leaving upward
  ]
  create-sunshine  ;; start new sun rays from top
  reflect-sunrays-from-clouds  ;; check for reflection off clouds
  encounter-earth   ;; check for reflection off earth and absorption
 end

to create-sunshine
  if 10 * sun-brightness > random 50 [
    create-sunrays 1 [
      set heading 160
      set color yellow
      setxy (random 10) + min-pxcor  max-pycor
    ]
  ]
end

to reflect-sunrays-from-clouds
 ask sunrays [
   if any? clouds-here [   ;; if sunray shares patch with a cloud
     set heading 180 - heading   ;; turn the sunray around
   ]
 ]
end

to encounter-earth
  ask sunrays [
    if ycor <= earth-top [
      ifelse 100 * albedo > random 100
        [ set heading 20  ]           ;; reflect
        [ set heading 95 + random 170 ;; morph into heat energy
          set color 13 + random 4
          set breed heats
          set shape ""dot"" ]
    ]
  ]
end

to run-heat    ;; advances the heat energy turtles
  ;; the temperature is related to the number of heat turtles
  set temperature .99 * temperature + .01 * (12 + .1 * count heats)
  ask heats [
    fd .5 * random 11 / 10
    if ycor <= 0 + min-pycor [ set heading 70 - random 170 ] ;; if heading into the earth's core, bounce
    if ycor >= earth-top [  ;; if heading back into sky
      ifelse ((temperature > 20 + random 40) and    ;; select more if it is hot
          (( xcor < max-pxcor - 8 )  and (xcor + 5 > 0 )))  ;; select some to escape
        [ set breed IRs                    ;; let them escape as IR
          set heading 20
          set color magenta ]
        [ set heading 100 + random 160 ] ;; return them to earth
    ]
  ]
end

to run-IR
  ask IRs [
    fd .3
    if ycor >= max-pycor [ die ]
    if ycor <= earth-top [   ;; convert to heat
      set breed heats
      set heading 95 + random 170
      set color 13 + random 4
      set shape ""dot""
    ]
    if any? CO2s-here    ;; check for collision with CO2
      [ set heading 180 - heading ]
  ]
end

to add-CO2  ;; randomly adds 25 CO2 molecules to atmosphere
  let width sky-top - earth-top
  if num-CO2 < 150 [  ;; stop adding CO2 at 150 molecules--more slow the model too much
    repeat 25 [
      create-CO2s 1 [
        set color green
        set shape ""CO2-molecule""
        setxy random (2 * max-pxcor) + min-pxcor earth-top + random width
        set heading random 360  ;; heading is used to spin molecule
      ]
    ]
    set num-CO2 count CO2s
  ]
end

to remove-CO2 ;; randomly remove 25 CO2 molecules
  repeat 25 [
    if any? CO2s [
      ask one-of CO2s [ die ]
    ]
  ]
  set num-CO2 count CO2s
end

to run-CO2
  ask CO2s [
    set heading heading + random 51 - 25 ;; turn a bit
    fd .01 * (5 + random 10) ;; move forward a bit
    if ycor <= earth-top + 1 [ set heading 45 - random 90 ] ;; bounce off earth
    if ycor >= sky-top [ set heading 135 + random 90 ]  ;; bounce off sky top
  ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2007 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2007).  NetLogo Climate Change model.
; http://ccl.northwestern.edu/netlogo/models/ClimateChange.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2007 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/ClimateChange
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This is a model of energy flow in the earth, particularly heat energy. It shows the earth as rose colored, and the surface of the planet is represented by a black strip. Above the strip there is a blue atmosphere and black space at the top. Clouds and carbon dioxide (CO2) molecules can be added to the atmosphere. The CO2 molecules represent greenhouse gases that block infrared light which emitted by the earth. Clouds block incoming or outgoing sun rays, influencing the heating up or cooling down of the planet.


HOW IT WORKS
------------
Yellow arrowheads stream downward representing sunlight energy. Some of the sunlight reflects off clouds and more can reflect off the earth's surface.

If sunlight is absorbed by the earth, it turns into a red dot, representing heat energy. Each dot represents the energy of one yellow sunlight arrowhead. The red dots randomly move around the earth, and its temperature is related to the total number of red dots.

Sometimes the red dots transform themselves into infrared (IR) light that heads toward space, carrying off energy. The probability of a red dot becoming IR light depends on the earth's temperature. When the earth is cold, few red dots generate IR light; when it is hot, most do. The IR energy is represented by a magenta arrowhead. Each carries the same energy as a yellow arrowhead and as a red dot. The IR light goes through clouds but can bounce off CO2 molecules.

There is a relation between the number of red dots in the earth and the temperature of the earth. This is because the earth temperature goes up as the total thermal energy is increased. Thermal energy is added by sunlight that reaches the earth as well as from infrared (IR) light reflected down to the earth. Thermal energy is removed by IR emitted by the earth. The balance of these determines the energy in the earth which is proportional to its temperature.

There are, of course, many simplifications in this model. The earth is not a single temperature, does not have a single albedo, and does not have a single heat capacity. Visible light is somewhat absorbed by CO2 and some IR light does bounce off clouds. No model is completely accurate. What is important, is that a model react in some ways like the system it is supposed to model. This model does that, showing how the greenhouse effect is caused by CO2 and other gases that absorb IR.


HOW TO USE IT
-------------
The SUN-BRIGHTNESS slider controls how much sun energy enters the earth's atmosphere. A value of 1.0 corresponds to our sun. Higher values allow you to see what would happen if the earth was closer to the sun, or if the sun got brighter.

The ALBEDO slider controls how much of the sun energy hitting the earth is absorbed.
If the albedo is 1.0, the earth reflects all sunlight. This could happen if the earth froze, and it is indicated by a white surface. If the albedo is zero, the earth absorbs all sunlight. This is indicated as a black surface. The earth's albedo is about 0.6.

You can add and remove clouds with buttons. Clouds block sunlight but not IR.

You can add and remove greenhouse gases, represented as CO2 molecules. CO2 blocks IR light but not sunlight. The buttons add and subtract molecules in groups of 25 up to 150.

The temperature of the earth is related to the amount of heat in the earth. The more red dots you see, the hotter it is.


THINGS TO NOTICE
----------------
Watch a single sunlight arrowhead. This is easier if you slow down the model using the slider at the top of the model.  You can also use the WATCH SUN RAY button.

What happens to the arrowhead when it hits the earth? Describe its later path. Does it escape the earth? What happens then? Do all arrowheads follow similar paths?


THINGS TO TRY
-------------
1. Play with the model. Change the albedo and run the model.
Add clouds and CO2 to the model and then watch a single sunlight arrowhead.
What is the highest earth temperature you can produce?

2. Run the model with a bright sun but no clouds and no CO2. What happens to the temperature? It should rise quickly and then settle down around 50 degrees. Why does it stop rising? Why does the temperature continue to bounce around? Remember, the temperature reflects the number of red dots in the earth. When the temperature is constant, there are about as many incoming yellow arrowheads as outgoing IR ones. Why?

3. Explore the effect of albedo holding everything else constant. Does increasing the albedo increase or decrease the earth temperature? When you experiment, be sure to run the model long enough for the temperature to settle down.

4. Explore the effect of clouds holding everything else constant.

5. Explore the effect of adding 100 CO2 molecules. What is the cause of the change you observe? Follow one sunlight arrowhead now.


EXTENDING THE MODEL
-------------------
Try to add some other factors influencing the earth's temperature. For example, you could add patches of vegetation and then see what happens as they are consumed for human occupation. Also, you could try to add variable albedo to the model, instead of having one value for the whole planet. You could have glaciers with high albedo, and seas with low albedo, and then evaluate what happens when the glaciers melt into the seas.


NETLOGO FEATURES
----------------
Note that clouds are actually made up of lots of small circular turtles. Also, to add or remove clouds, the model deletes all previous clouds, and recreates them in the new amount.


RELATED MODELS
--------------
Climate Change Population


CREDITS AND REFERENCES
----------------------
This model is based on an earlier version created in 2005 by Robert Tinker for the TELS project.

To refer to this model in academic publications, please use:  Wilensky, U. (2007).  NetLogo Climate Change model.  http://ccl.northwestern.edu/netlogo/models/ClimateChange.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2007 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/ClimateChange for terms of use.
"
Grand Canyon,/models/Sample Models/Earth Science,"breed [waters water]
breed [raindrops raindrop]

patches-own [
  elevation
]

globals [
  color-min
  color-max
  old-show-water?
  water-height    ;; how many feet tall one unit of water is
  border          ;; keep the patches around the edge in a global
                  ;; so we don't ever have to ask patches in go
]

;;
;; Setup Procedures
;;

;; reading the external file is startup rather
;; than setup so we only do it once in the model
;; running the model does not change the elevations

to startup
  ;; read the elevations from an external file
  ;; note that the file is formatted as a list
  ;; so we only have to read once into a local variable.
  file-open ""Grand Canyon data.txt""
  let patch-elevations file-read
  file-close
  set color-max max patch-elevations + 200 ;; put a little padding on the upper bound so we don't get too much
                                           ;; white and higher elevations have a little more variation.
  let min-elevation min patch-elevations
  ;; adjust the color-min a little so patches don't end up black
  set color-min min-elevation - ((color-max - min-elevation) / 10)
  ;; transfer the date from the file into the sorted patches
  ( foreach sort patches patch-elevations
    [ ask ?1 [ set elevation ?2 ] ] )
  set-default-shape turtles ""circle""
  setup
end

;; just clean up the marks that the raindrops have made
;; and set some global variable to defaults
to setup
  cd
  ct
  ask patches
    [ set pcolor scale-color brown elevation color-min color-max ]
  set water-height 10
  set border patches with [ count neighbors != 8 ]
end

;;
;; Runtime Procedures
;;
to go
  ;; check for mouse clicks on empty patches.
  ;; if we've got a winner make a manual raindrop that
  ;; is red.
  if mouse-down? and not any? turtles-on patch mouse-xcor mouse-ycor
  [
    ;; even when raindrops are hidden
    ;; newly created manual drops will
    ;; be visible
    create-raindrops 1
    [ setxy mouse-xcor mouse-ycor
      set size 2
      set color red
    ]
  ]
  ;; make rain-rate drops randomly
  create-raindrops rain-rate
  [ move-to one-of patches
    set size 2
    set color blue ]

  ifelse draw?
    [ ask turtles [ pd ] ]
    [ ask turtles [ pu ] ]

  ask raindrops [ flow ]

  ask border
  [
    ;; when raindrops reach the edge of the world
    ;; kill them so they exit the system and we
    ;; don't get pooling at the edges
    ask turtles-here [ die ]
  ]
  tick
end

to flow ;; turtle procedure
  ;; get the lowest neighboring patch taking into account
  ;; how much water is on each patch.
  let target min-one-of neighbors [ elevation + (count turtles-here * water-height) ]
  ;; if the elevation + water on the neighboring patch is
  ;; lower than here move to that patch.
  ifelse [elevation + (count turtles-here * water-height)] of target
     < (elevation + (count turtles-here * water-height))
    [ move-to target ]
    [ set breed waters ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2006 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2006).  NetLogo Grand Canyon model.
; http://ccl.northwestern.edu/netlogo/models/GrandCanyon.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2006 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/GrandCanyon
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model simulates rainfall on a patch of terrain on the eastern end of the Grand Canyon, approximately 6 miles (9.7 km) on each side, where Crazy Jug Canyon and Saddle Canyon meet to form Tapeats Canyon. Each patch represents an area approximately 105 feet (32 m) on each side. The model was created as an experiment in using NetLogo with My World GIS.

The elevation data comes from the National Elevation Dataset available at http://seamless.usgs.gov. It was converted from an ESRI Grid into an ASCII grid file using ArcGIS, then resampled to its current resolution and rescaled to lie in the range 0-999 using My World GIS.


HOW IT WORKS
------------
Raindrops fall in random locations or at locations selected by the user, then flow downhill.  If no nearby patch has a lower elevation, the raindrop stays where it is.  Raindrops pool until they flow over the land nearby. Some raindrops may always stay in these pools at higher ground. Others will flow out of the system at the edges.


HOW TO USE IT
-------------
When you open the model, the STARTUP procedure automatically runs and imports the data from an external file.  Press SETUP to color the patches according to their elevation, and to remove raindrops and drawings from previous runs. Press the GO button to start the simulation.  With each tick, RAIN-RATE raindrops will fall at random locations, traveling downhill across the landscape.

As the simulation runs, you may click anywhere on the map to create raindrops. Manually placed raindrops are red, while those created randomly by the model are blue.  The WATCH RANDOM RAINDROP button sets the perspective to watch a randomly selected raindrop (of any type). The WATCH MY RAINDROP button watches a red raindrop, if one exists.

When the DRAW? switch is turned on each raindrop marks its path in the drawing layer.


THINGS TO NOTICE
----------------
Elevations are represented by lighter and darker colors. The higher the elevation, the lighter the color used to draw that patch. Raindrops flow from high to low elevations, meaning that they flow toward darker patches.

When you let the model run for a long time, you will see pools start to form at certain locations where a bit of low land is surrounded by higher land.  If you let the model run long enough, the water will eventually overflow from these dips, flowing to the rivers below.


THINGS TO TRY
-------------
Put the turtle pens down (by turning on the DRAW? switch), and see the kinds of patterns that emerge.

Try to place all of the raindrops manually.  Trace the path of one drop all the way down the landscape.

Find more GIS data and import different data sets.


EXTENDING THE MODEL
-------------------
Add erosion to the model, so the raindrops pick up or deposit some amount of elevation from the patches they travel over.


NETLOGO FEATURES
----------------
When there is no lower neighboring patch, raindrops change breed (from raindrop to waters) so they will no longer move.

Elevation data is read only once, when the model is loaded, in the STARTUP procedure.  The external data file (Grand Canyon data.txt) is formatted such that its contents can be assigned (with FILE-READ) to a NetLogo variable.


RELATED MODELS
--------------
Erosion


CREDITS AND REFERENCES
----------------------
National Elevation Dataset: http://seamless.usgs.gov
ArcGIS: http://esri.com/software/arcgis/
My World GIS: http://myworldgis.org/myworld

Thanks to Eric Russell for his work on this model.

To refer to this model in academic publications, please use:  Wilensky, U. (2006).  NetLogo Grand Canyon model.  http://ccl.northwestern.edu/netlogo/models/GrandCanyon.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2006 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/GrandCanyon for terms of use.
"
Percolation,/models/Sample Models/Earth Science,"globals [
  current-row     ;; agentset of patches in current row
  total-oil       ;; keeps track of how much ground has been saturated
                  ;; since the simulation began.
]

to setup
  clear-all
  set total-oil 0
  ;; start with all unsaturated soil
  ask patches [ set pcolor brown ]
  ;; set up top row
  set current-row patches with [pycor = max-pycor]
  ask current-row [
    if pxcor mod 2 = 0
      [ set pcolor red ]  ;; This code initializes the ""oil spill"".  Red
                          ;; patches represent the leading edge of the spill.
  ]
  do-plot
end

to go
  if all? current-row [pcolor = brown]
    [ stop ]
  percolate
  tick
  do-plot
  wrap-oil
end

to percolate
  ask current-row with [pcolor = red] [
    ;; oil percolates to the two patches southwest and southeast
    ask patches at-points [[-1 -1] [1 -1]]
      [ if (pcolor = brown) and (random-float 100 < porosity)
          [ set pcolor red ] ]
    set pcolor black
    set total-oil total-oil + 1
  ]
  ;; advance to the next row
  set current-row patch-set [patch-at 0 -1] of current-row
end

to wrap-oil
  if [pycor = max-pycor] of one-of current-row
    [ ask patches with [pcolor = black]
        [ set pcolor brown ] ]
end

to do-plot
  ;; This plot displays the number of patches that are red (percolating oil).
  set-current-plot ""Percolating Oil""
  plot count current-row with [pcolor = red]
  ;; This plot displays the number of patches that are black (saturated soil).
  set-current-plot ""Saturated Soil""
  plot total-oil
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Percolation model.
; http://ccl.northwestern.edu/netlogo/models/Percolation.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Percolation
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model shows how an oil spill can percolate down through permeable soil.  It was inspired by a similar model meant to be done by hand on graph paper (see ""Forest Fires, Oil Spills, and Fractal Geometry"", Mathematics Teacher, Nov. 1998, p. 684-5).


HOW TO USE IT
-------------
Push the SETUP button.  The oil spill is represented by red patches, which start at the top row of patches.  (The model represents an oil spill as a finite number of oil ""particles"", or simply oil drops.

The oil drops sink downward through the soil by moving diagonally to the right or left. The patches through which the drops spread represent the empty spaces in the soil and the POROSITY slider represents the soil's porosity (it's ""holeyness"").  Each drop's chance of actually moving on down is contingent on a certain probability, set by the POROSITY slider.  That is, the higher the porosity, the higher the chance of a drop to percolate through it.  This models the fact that in more porous soil, oil has a greater chance of continuing downward.

Press the GO button to run the model.

It can be run as long as you like; it resets to the top row of patches when it reaches the bottom.  It stops automatically when the oil spill stops advancing.

The two plots show how large the leading edge of the spill is (red) and how much soil has been saturated (black).


THINGS TO NOTICE
-----------------
Try different settings for the porosity.  What do you notice about the pattern of affected soil?  Can you find a setting where the oil just keeps sinking, and  a setting where it just stops?

If percolation stops at a certain porosity, it's still possible that it would percolate further at that porosity given a wider view.

Note the plot of the size of the leading edge of oil.  Does the value settle down roughly to a constant?  How does this value depend on the porosity?


EXTENDING THE MODEL
-------------------
Give the soil different porosity at different depths.  How does it affect the flow?  In a real situation, if you took soil samples, Could you reliably predict how deep an oil spill would go or be likely to go?

Currently, the model is set so that the user has no control over how much oil will spill.  Try adding a feature that will allow the user to specify precisely, when s/he presses SETUP, the amount of oil that will spill on that go.  For instance, a slider may be useful here, but you'd have to modify the code to accommodate this new slider.  Such control over the to-be-spilled amount of oil gives the user a basis to predict how deep the oil will eventually percolate (i.e. how many empty spaces it will fill up).  But then again, the depth of the spill is related to the soil's porosity.  Can you predict the depth of the spill before you press GO?


NETLOGO FEATURES
----------------
This is a good example of a cellular automaton model, because it uses only patches.  It also uses a simple random-number generator to give a probability, which in turn determines the average large-scale behavior.

This is also a simple example of how plots can be used to reveal, graphically, the average behavior of a model as it unfolds.


RELATED MODELS
--------------
""Fire"" is a similar model.  In both cases, there is a rather sharp cutoff between halting and spreading forever.

This model qualifies as a ""stochastic"" or ""probabilistic"" one-dimension cellular automaton.  For more information, see the ""CA Stochastic"" model.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Percolation model.  http://ccl.northwestern.edu/netlogo/models/Percolation.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Percolation for terms of use.
"
MaterialSim Grain Growth,/models/Sample Models/Chemistry & Physics/MaterialSim/Unverified,";; two different materials or phases
breed [ element1s element1 ]  ;; element1 is the main material
breed [ element2s element1 ]  ;; element2 is the materials which is
;; dispersed inside element1 (second-phase particles)


element1s-own
[
  neighbors-6   ;; agentset of 6 neighboring cells
  n             ;; used to store a count of second-phase neighbors
]

turtles-own
[
  temp                 ;; atom's temperature
  neighboring-turtles  ;; agentset of surrounding atoms
  sides-exposed        ;; number of sides exposed to walls  (between 0 and 4)
]

globals
[
  logtime                 ;; log of time
  colors                  ;; used both to color turtles, and for histogram
  xmax                    ;; max x size
  ymax                    ;; max y size
  intercepts              ;; used to calculate grain size (1/intercepts = average grain size)
  average-grain-size      ;; average grain size
  logaverage-grain-size   ;; log of average grain size (for plotting)
  orientation-for-intercept-count  ;; for grain size calculation (normally 90 degrees)
  initial-loggrain-size   ;; For grain growth exponent calculation and graphing
  initial-logtime         ;; For grain growth exponent calculation and graphing
  grain-growth-exponent   ;; Grain growth exponent
  total-atoms            ;; Total number of atoms in the system
]


to setup-hex-grid
  ;; setup the hexagonal grid in which atoms will be placed
  ;; and creates turtles
  set-default-shape element2s ""square""

  ask patches
  [
    sprout 1
    [
      ifelse (fraction-element2 > random-float 100)
      ;; if there is a second element, create the corresponding atoms
      [
        ;; element2 is the fixed second-phase particle
        set breed element2s
        set color white
        set heading 360
      ]
      [
        ;; element1 is the main material, which grains growth
        set breed element1s
        set shape atom-shape
        set color random 139
        set heading color
      ]

      ;; shift even columns down
      if pxcor mod 2 = 0
      [ set ycor ycor - 0.5 ] ] ]

  ; ask element1s [ set shape3d ""sphere"" ]
  ; ask element2s [ set shape3d ""cube"" ]
  ; the two above lines are for NetLogo 3D. Uncomment them if you use that version.

  ;; now set up the neighbors6 agentsets

  ask element1s
  ;; define neighborhood of atoms
  [ ifelse pxcor mod 2 = 0
      [ set neighbors-6 element1s-on patches at-points [[0 1] [1 0] [1 -1] [0 -1] [-1 -1] [-1 0]] ]
    [ set neighbors-6 element1s-on patches at-points [[0 1] [1 1] [1  0] [0 -1] [-1  0] [-1 1]] ] ]
end

;; makes initial box for image import
to makes-initial-box
  reset-ticks
  setup-hex-grid
end

;; makes initial box for random arrangement
to makes-initial-box-random
  ca
  setup-hex-grid
end

;; import image into turtles
to import-image

  ca
  let file user-file
  if file = false [ stop ]
  ;; imports image into patches
  import-pcolors file
  ;; generates a white border around the image to avoid wrapping
  ;; converts the square grid to an hex grid
  makes-initial-box

  ;; transfers the image to the turtles. Rounds the color values to be integers.
  ask turtles
  [
    set color round pcolor
    set heading color
  ]

  ;; erases the patches (sets their color back to black),
  ask patches [ set pcolor black ]

end


to define-neighboring-turtles
  ;; defines neighboring turtles

  ask turtles
  [
    set neighboring-turtles (turtles at-points [[-1  1] [ 0  1] [1  1]
            [-1  0] [ 0  0] [1  0]
          [-1 -1] [ 0 -1] [1 -1]])


  ]

end

to grain-count
  ;; count number of grains based on the number of linear intercepts

  set orientation-for-intercept-count 90 ;; direction of intercepts count
  set intercepts 0
  set total-atoms count turtles

  ;;  ask patches

  ask turtles
  [
    ;; checks if turtle is before the last 'x' column and 'y' row
    if  ((xcor != (xmax - 1)) and (who < ((width * height) - 1)) and (who < total-atoms))
    [
      ;; checks if there is a turtle to the right for the intercept calculation
      let target-patch patch-at-heading-and-distance orientation-for-intercept-count 1
      ifelse target-patch != nobody and any? turtles-on target-patch
      [
        ;; If there is a turtle, checks if the heading is different.
        let right-neighbor-heading [heading] of
        (one-of
            turtles-on (patch-at-heading-and-distance
                orientation-for-intercept-count
                1))
        if (heading != (right-neighbor-heading))
        [
          ;; If heading is different, add 1 to 'intercepts'.
          set intercepts (intercepts + 1)
        ]
      ]
      [
        ;; if there is no turtle, simply add 1 to 'intercepts'.
        ;; A turtle/nothing interface is considered as grain boundary.
        set intercepts (intercepts + 1)
      ]
    ]
  ]
  ifelse intercepts = 0
    [set average-grain-size (total-atoms)] ;; grain size = area of the whole sample (to avoid division by zero)
    [set average-grain-size ((total-atoms) / intercepts)] ;; grain size = area / grain-grain interface
end

to do-plots

  set-current-plot ""Grain Size (log-log)""
  plotxy logtime logaverage-grain-size

end


to go
  ;;initiates grain growth

  set total-atoms count turtles

  if average-grain-size >= total-atoms [stop]
  ;; stops when there is just one grain

  repeat (total-atoms)
  [
    ;;limits grain growth to element1, element2 represent the stationary second-phase particles
    ask one-of element1s [grain-growth]
  ]

  ;; advance Monte Carlo Steps (simulation time)
  ;; one Monte Carlo Step represents 'n' reorientation attemps,
  ;; where 'n' is the total number of atoms
  tick

  if remainder ticks measurement-frequency = 0
  ;; calculates grain size at a given frequency

  [
    set logtime log ticks 10
    grain-count
    if average-grain-size != 0
    [
      set logaverage-grain-size (log (average-grain-size) 10)
    ]
    ;; grain growth is better plotted on log-log scale
    do-plots
    if ticks = 20 [
      set initial-logtime logtime
      set initial-loggrain-size logaverage-grain-size
    ]
    ;; only initiates grain size calculation after MCS = 20
    if ticks > 20 [
      ;; calculate the angular coefficient of the grain growth curve
      ;; since it is a log-log plot, it's the grain growth exponent
      set grain-growth-exponent (-1 * ((logaverage-grain-size - initial-loggrain-size) /
              (initial-logtime - logtime)))
    ]
  ]

end

;; Grain growth procedure - free energy minimization
;; if another random crystallographic heading minimizes energy, switches headings, otherwise keeps the same.
to grain-growth
  ;; calculates the PRESENT free energy
  let present-heading (heading)
  let present-free-energy count neighbors-6 with [heading != present-heading]

  ;; chooses a random orientation
  let future-heading ([heading] of (one-of neighbors-6))

  ;; calculates the FUTURE free energy, with the random orientation just chosen
  let future-free-energy count neighbors-6 with [heading != future-heading]

  ;; compares PRESENT and FUTURE free-energies; the lower value ""wins""
  ifelse future-free-energy <= present-free-energy
    [set heading future-heading]
    [if (annealing-temperature > random-float 100) [set heading (future-heading)]]
  ;; this last line simulates thermal agitation (adds more randomness to the simulation)

  ;;update the color of the atoms
  set color heading
end

;; drawing procedure
to turtle-draw
  if mouse-down?     ;; reports true or false to indicate whether mouse button is down
  [
    ask patch mouse-xcor mouse-ycor
      [ask turtles in-radius brush-size [set color draw-color set heading color]]
  ]
end

;; in the drawing mode, erases the whole ""canvas"" with red
to erase-all

  ask turtles [if pcolor != white [set color red set heading color]]

end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2005 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Blikstein, P. and Wilensky, U. (2005). NetLogo MaterialSim Grain Growth model.
; http://ccl.northwestern.edu/netlogo/models/MaterialSimGrainGrowth.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2005 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/MaterialSimGrainGrowth
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
Most materials are not continuous arrangements of atoms, but rather composed of thousands or millions of microscopic crystals, known as grains.  This model shows how the configuration and sizes of these grains change over time.  Grain size is a very important characteristic for evaluating the mechanical properties of materials; it is exhaustively studied in metallurgy and materials science.

Usually this kind of study is made by careful analysis and comparison of pictures taken in microscopes, sometimes with the help of image analysis software.  Recently, as the processing power of computers has increased, a new and promising approach has been made possible: computer simulation of grain growth.  Anderson, Srolovitz et al. proposed the most widely known and employed theory for computer modeling and simulation of grain growth, using the Monte Carlo method.  Instead of considering the grains as spheres, and being obliged to make numerous geometrical approximations, Anderson proposed that the computer would simulate the behavior of each individual atom in the system. Each atom would follow a very simple rule: it will always try to have, in its immediate neighborhood, as many atoms as possible with the same orientation as it.

This model is part of the MaterialSim (Blikstein & Wilensky, 2004) curricular package. To learn more about MaterialSim, see http://ccl.northwestern.edu/materialsim/.


HOW IT WORKS
------------
The basic algorithm of the simulation is simple: atoms are trying to be as stable as possible.  Their stability is based on the number of equal neighbors: the more equal neighbors (i.e. atoms with the same orientation) an atom has, the more stable it is.  If it has many different neighbors, it is unstable, and not likely to be in that position for long, because during the simulation atoms will try to relocate to more stable positions.  Therefore, the steps are:

1) Choose a random atom.
2) Calculate its present energy (which is correlated with the stability).  This calculation is done by simply counting the number of different neighbors.
3) Randomly choose a new orientation for the chosen atom, amongst the orientations of its neighbors.  We still don't know if that new attempted orientation will be maintained.  We have to calculate the energy in this new situation in order to know.
4) Calculate the free energy of the chosen element with the new, tentative orientation.  Again, we just count the number of different neighbors.
5) Comparison of the two values for free energy: the lowest value ""wins"", i.e., the less different neighbors an atom have, more stable it is.
6) Repeat steps 1-6.

The ANNEALING-TEMPERATURE slider controls the probability of maintaining an re-orientation which yields more instability.  The FRACTION-ELEMENT-2 slider defines the percentage of second-phase particles to be created when the user setups the simulation.  Those particles and not movable and are not subject to grain growth. Atoms see those particles as a different neighbor.

Note that the actual number of atoms is small compared to a real metal sample.  Also, real materials are three-dimensional, while this model is 2D.


HOW TO USE IT
-------------
(1) Simulation starting point:
IMPORT IMAGE: Resets the simulation, and imports an image file in the JPG, BMP, GIF or PNG file formats.  The image will be automatically resized to fit into the world, but maintaining its original aspect ratio. Note that the image MUST HAVE THE SAME ASPECT RATIO AS THE WORLD. In other words, if the world is square, the image should be square as well. Prior to importing the image, it is recommended to clean it up using an image editing software (increase contrast, remove noise).  Try to experiment various combinations of values for the WIDTH and HEIGHT sliders, the view's size and the patch size to get the best results.
START WITH RANDOM ARRANGEMENT: Resets the simulation, and starts it with a random orientation for each atom.
GO-ONCE: Runs the simulation, one time step at a time.
GO: Runs the simulation continuously until either the GO button is pressed again, or just one grain survives.

(2) Change the shape of the atoms
The ATOM-SHAPE chooser has many different shapes, such as circle, hexagon, line, circle with spikes, thin line, and square.
After choosing the ATOM-SHAPE, click on APPLY to change the shape.  This can also be done during the simulation.

(3) Draw grains
You can draw grains with the mouse, using different brush sizes and colors.  The DRAW button activates drawing, the ERASE ALL button erases the view and sets all the atoms to red, the BRUSH-SIZE slider controls the radius of the brush and the DRAW-COLOR chooser changes the numeric value of the drawing color.

(4) Run simulation
GO: runs the simulation continuously
GO ONCE: runs the simulation, one step at a time.

Simulation size
WIDTH: x (horizontal) dimension of the sample.
HEIGHT: y (vertical) dimension of the sample

Special features
ANNEALING-TEMP: changes the probability of non-favorable orientation flips to happen.  A 10% value, for instance, means that 10% of non-favorable flips will be maintained.  This mimics the effect of higher temperatures.
FRACTION-ELEMENT2: This slider controls the amount of dispersed second-phase particles throughout the sample. Those particles slow down or stop grain growth.

Grain measurement
MEASUREMENT-FREQUENCY: to increase the model's speed, the user can choose not to calculate grain size at every time step.  If grain size is calculated at every ten time units (20, 30, 40 etc.), the performance is slightly increased.  This only affects the plot and the monitors, but not the actual simulation.
MEASURE GRAINS NOW: if the MEASUREMENT-FREQUENCY is too large, and the user wants to evaluate grain size at a specific moment, this button can be used. Note that this does not alter the plot.

Plots and monitors
Grain Size (log-log): Grain size vs. time, in a log-log scale.  Under normal conditions (ANNEALING-TEMP = 0 and FRACTION-ELEMENT-2 = 0), this plot should be a straight line with an angular coefficient of approximately 0.5.
SIMULATION TIME and LOG TIME: time steps of the simulation so far (and its log)
GRAIN SIZE and LOG GRAIN SIZE: grain size (is atoms) and its log.
GROWTH EXPONENT: the angular coefficient of the GRAIN SIZE plot.  This number should approach 0.5 with ANNEALING-TEMP = 0 and FRACTION-ELEMENT2 = 0.


THINGS TO NOTICE
----------------
When you setup with a random orientation and run the simulation, notice that the speed of growth decreases with time.  Toward the end of the simulation, you might see just two or three grains that fight with each other for along time.  One will eventually prevail, but this logarithmic decrease of speed is an important characteristic of grain growth.  That is why the GRAIN SIZE plot is a straight line in a ""log-log"" scale.
Notice also that if you draw two grains, one concave and one convex, their boundary will tend to be a straight line, if you let the simulation run long enough.  Every curved boundary is unstable because many atoms at its interface will have more different than equal neighbors.


THINGS TO TRY
-------------
Increase the value of the ANNEALING-TEMP slider. What happens to the GRAIN SIZE plot, and to the boundaries' shapes?

Try to increase the FRACTION-ELEMENT2 slider to 5%.  Then press START WITH RANDOM ARRANGEMENT and GO.  What happens to grain growth? Now try several values (1, 3, 5, 7, 9%), for instance.  What happens with the final grain size? What about the GRAIN SIZE plot and the GROWTH EXPONENT?

One advanced use of this model would be to get a digital picture of a real metallic sample, reduce noice and increase contrast with image editing programs, and load into this model using the IMPORT IMAGE button.  Don't forget to update the WIDTH and HEIGHT sliders and the view's size to accommodate the picture, and also to change the patch size in order to be able to see the whole sample.


EXTENDING THE MODEL
-------------------
This models assumes that the misorientation between two grains has no effect on their growth rates.  Two grains with a very similar crystallographic orientation have the same growth rate as grains which orientations differ by a lot.  Try to take the angular misorientation into consideration.

When we insert second-phase particles, all of them have the same size.  Try to create a slider that changes the size of the particles.


NETLOGO FEATURES
----------------
This model uses some special features:
It uses a hexagonal grid (as opposed to a square one)
it uses different shapes for different visualization purposes
and it uses the import-pcolors primitive to enable the image import capability.


RELATED MODELS
--------------
Crystallization Basic
Crystallization Directed


CREDITS AND REFERENCES
----------------------
This model is part of the MaterialSim (Blikstein & Wilensky, 2004) curricular package. To learn more about MaterialSim, see http://ccl.northwestern.edu/materialsim/.

Two papers describing the use of this model in education are:
Blikstein, P. & Wilensky, U. (2005) Less is More: Agent-Based Simulation as a Powerful Learning Tool in Materials Science.  The IV International Conference on Autonomous Agents and Multiagent Systems. Utrecht, Netherlands.

Blikstein, P. & Wilensky, U. (2004) MaterialSim: An agent-based simulation toolkit for Materials Science learning. (PDF, 1.5 MB) Proceedings of the International Conference on Engineering Education. Gainesville, Florida.

The core algorithm of the model was developed at the University of Sao Paulo and published in:  Blikstein, P. and Tschiptschin, A. P. Monte Carlo simulation of grain growth (II). Materials Research, Sao Carlos, 2 (3), p. 133-138, jul. 1999.
Available for download at: http://www.blikstein.com/paulo/documents/papers/BliksteinTschiptschin-MonteCarlo-MaterialsResearch1999.pdf. See also http://www.pmt.usp.br/paulob/montecarlo for more information (in Portuguese).

To refer to this model in academic publications, please use:  Blikstein, P. and Wilensky, U. (2005).  NetLogo MaterialSim Grain Growth model.  http://ccl.northwestern.edu/netlogo/models/MaterialSimGrainGrowth.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2005 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/MaterialSimGrainGrowth for terms of use.
"
Ising,/models/Sample Models/Chemistry & Physics/Electromagnetism,"globals [
  sum-of-spins   ;; sum of all the spins -- keeping track of this
                 ;; means that we can always instantly calculate
                 ;; the magnetization (which is the average spin)
]

patches-own [
  spin           ;; holds -1 or 1
]

to setup [initial-magnetization]
  clear-all
  ask patches
    [ ifelse initial-magnetization = 0
        [ set spin one-of [-1 1] ]
        [ set spin initial-magnetization ]
      recolor ]
  set sum-of-spins sum [spin] of patches
  setup-plot
  plotxy 0 magnetization
end

to go
  ask one-of patches [ update ]
  tick
  if ticks mod plotting-interval = 0
    [ plotxy ticks magnetization ]
end

to update  ;; patch procedure
  ;; flipping changes the sign on our energy, so the difference in energy
  ;; if we flip is -2 times our current energy
  let Ediff 2 * spin * sum [spin] of neighbors4
  if (Ediff <= 0) or
     (temperature > 0 and (random-float 1.0 < exp ((- Ediff) / temperature)))
    [ set spin (- spin)
      set sum-of-spins sum-of-spins + 2 * spin
      recolor ]
end

to recolor  ;; patch procedure
  ifelse spin = 1
    [ set pcolor blue + 2 ]
    [ set pcolor blue - 2 ]
end

to-report magnetization
  report sum-of-spins / count patches
end

;;; plotting procedures

to setup-plot
  set-current-plot ""Magnetization""
  ;; draw a horizontal line to show the x axis
  set-current-plot-pen ""axis""
  auto-plot-off
  plotxy 0 0
  plotxy 100000000000000000 0
  auto-plot-on
  set-current-plot-pen ""average spin""
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2003 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2003).  NetLogo Ising model.
; http://ccl.northwestern.edu/netlogo/models/Ising.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2003 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Ising
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This is a model of a magnet at the microscopic level.  The magnetic moments (spins) of the atoms in the magnet can either be up or down.  Spins can change as a result of being influenced by neighboring spins and by the ambient temperature.  The overall behavior of the system will vary depending on the temperature.

When the temperature is low, there is spontaneous magnetization, and we say that the system is in the ferromagnetic phase.  When the temperature is high, there is no spontaneous magnetization, and we say that the system is in the paramagnetic phase.  (At room temperature, a refrigerator magnet is ferromagnetic, but an ordinary piece of iron is paramagnetic.)

This very abstract model can be interpreted in other ways as well, for example as a model of liquid/gas phase transitions (where the two states are liquid and gas, instead of two magnetic spin states).  It has also been used as a basis for simulating phenomena in the social sciences that involve phase-transition-like behavior.


HOW IT WORKS
------------
We represent the two possible spin states with the numbers +1 or -1.  Spins of +1 are shown in light blue, spins of -1 in dark blue.

The energy at each spin is defined as the negative of the sum of the products of the spin with each of its neighboring four spins.  So for example if a spin is surrounded by four opposing spins, then the energy is 4, the maximum possible.  But if a spin is surrounded by four like spins, then the energy is -4, the minimum possible.  Basically, the energy measures how many like or opposite neighbors the spin has.

A spin decides whether to ""flip"" to its opposite as follows.  The spins are seeking a low energy state, so a spin will always flip if flipping would decrease its energy.  But the spins sometimes also flip into a higher energy state.  We calculate the exact probability of flipping using the Metropolis algorithm, which works as follows.  Call the potential gain in energy Ediff.  Then the probability of flipping is e ^ (-Ediff/temperature).

The gist of this formula is that as the temperature increases, flipping to a higher energy state becomes increasingly likely, but as the energy to be gained by flipping increases, the likelihood of flipping decreases.  You could use a different formula with the same gist, but the Metropolis algorithm is most commonly used.

To run the model, we repeatedly pick a single random spin and give it the chance to flip.


HOW TO USE IT
-------------
Choose an initial temperature with the TEMPERATURE slider, then press SETUP to set up the grid and give each spin a random initial state.  (Or, if you want to start with all the spins set to the same state, press SETUP -1 or SETUP +1.)

Then press GO to watch the model run.

You can move the TEMPERATURE slider as the model runs if you want.

The magnetization of the system is the average (mean) of all the spins.  The MAGNETIZATION monitor and plot show you the current magnetization and how it has varied so far over time.

The default speed of the model is fairly slow.  If you move the speed slider to the right, you'll see a dramatic speedup (because NetLogo will spend more of its time computing and less of its time redrawing the grid).

You can also speed up the model with the PLOTTING-INTERVAL slider.  If the slider is set to 1, we plot a point every tick.  If the slider is set to 100 (default), we plot a point every 100 ticks.  The less plotting takes place, the faster the model runs.


THINGS TO NOTICE
----------------
In the default settings for the model, the temperature is set fairly low.  What happens to the system?



THINGS TO TRY
-------------
What happens when the temperature slider is very high?  (This is called the ""paramagnetic"" state.)  Try this with all three setup buttons.

What happens when the temperature slider is set very low?  (This is called the ""ferromagnetic"" state.)  Again, try this with all three setup buttons.

Between these two very different behaviors is a transition point.  On an infinite grid, the transition point can be proved to be 2 / ln (1 + sqrt 2), which is about 2.27.  On a large enough finite toroidal grid, the transition point is near this number.

What happens when the temperature is near, but above the transition point?  What happens when the temperature is near, but below the transition point?  Note that the nearer you are to the transition point, the longer the system takes to exhibit its characteristic behavior -- in such cases, we say that the system has a long ""correlation length"".  So near the transition point, you'll need to do more and longer runs in order to be sure you understand what the typical behavior of the system is.

When the temperature is low, the system should quickly reach a fully magnetized state.  Note that if you set the temperature very low, sometimes fairly stable thick ""stripes"" of opposite colors can form, preventing the system from reaching full magnetization.  This is an effect of the finite size and toroidal shape of the grid.


EXTENDING THE MODEL
-------------------
The formula for Ediff given above can be modified by multiplying the result by a ""coupling constant"" (if we don't do this, effectively we are using a coupling constant of 1).  Using a negative coupling constant changes the model into its ""antiferromagnetic"" variant.  Experiment with the effect of varying the coupling constant.

Can you eliminate the exponential formula for the probability of flipping and replace it with a simple discrete rule that gives similar behavior?

How could you relate TEMPERATURE in this model to temperature in Fahrenheit, Celsius or Kelvin?

If you think of the two grid states as ""present"" and ""absent"", then this model can be changed slightly to be a model of the motion of particles if you add a rule that states can only flip in pairs, so that the total number of particles is conserved.  Add this rule and see what behaviors result.

At each iteration, we give only one spin a chance to flip.  There are other possible methods, for example, the ""checkerboard"" update rule: if you imagine the rectangular lattice as being made of alternating white and black squares like a checkerboard, then at each iteration first all the white squares update simultaneously, then all the black squares update simultaneously.  On a parallel computer with many processors, and a programming language which takes advantage of them, the checkerboard rule would run much much faster.  Since NetLogo only simulates parallelism using a single processor, the checkerboard rule does not run dramatically faster.  (Note that if you use the checkerboard rule, the grid of spins must have even dimensions.)

NETLOGO FEATURES
----------------
Because only a very small amount happens during each tick, this is a model where the speed slider is especially important, since it lets the user speed the model up by not updating the view every tick.


RELATED MODELS
--------------
Voting (a social science model, but the update rules are very similar, except that there is no concept of ""temperature"")


CREDITS AND REFERENCES
----------------------
Thanks to Seth Tisue for his work on this model and to Sara Solla and Kan Chen for their assistance.

The Ising model was first proposed by Wilhelm Lenz in 1920.  It is named after his student Ernst Ising, who also studied it.  This NetLogo model implements the Monte Carlo simulation of the Metropolis algorithm for the two dimensional Ising model.  The Metropolis algorithm comes from a 1953 paper by Nicholas Metropolis et al.

There are many web pages which explore the Ising model in greater detail than attempted here.  Here are a few:
http://bartok.ucsc.edu/peter/java/ising/keep/ising.html
http://oscar.cacr.caltech.edu/Hrothgar/Ising/references.html
http://www.physics.cornell.edu/sethna/teaching/sss/ising/intro.htm
http://physics.syr.edu/courses/ijmp_c/Ising.html
http://www.npac.syr.edu/users/paulc/lectures/montecarlo/

To refer to this model in academic publications, please use:  Wilensky, U. (2003).  NetLogo Ising model.  http://ccl.northwestern.edu/netlogo/models/Ising.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2003 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Ising for terms of use.
"
Electrostatics,/models/Sample Models/Chemistry & Physics/Electromagnetism/NIELS/Unverified,"breed [ particles particle ]
breed [ centers center ]

particles-own
[ fx     ;; x-component of force vector
  fy     ;; y-component of force vector
  vx     ;; x-component of velocity vector
  vy     ;; y-component of velocity vector
  xc     ;; real x-coordinate (in case particle leaves world)
  yc     ;; real y-coordinate (in case particle leaves world)
  r-sqrd ;; square of the distance to the mouse

]

globals
[ m-xc       ;; x-coordinate of acting mass
  m-yc       ;; y-coordinate of acting mass
  r          ;; square root of r-sqrd
  potential  ;; potential energy of electron
  force      ;; modulus of force vector
  modcharge  ;; modulus of charge
  c^2        ;; square of the charge
  previous-permittivity ;; the last recorded value of permittivity
  c-charge
]

;;;;;;;;;;;;;;;;;;;;;;;;
;;; Setup Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;

to setup
  ca
  setup-plots
  set-default-shape turtles ""circle""
  if permittivity != previous-permittivity   ;; changes color of the patches as the permittivity changes
  [
    ask patches [ set pcolor permittivity * 8 + 5 ]
    set previous-permittivity permittivity
  ]
  ifelse charge < 0 [ set c-charge (0 - charge) ]
    [ set c-charge charge ]
  create-centers 1 [ set size 20
    ht
    set label ""+1"" ]
  create-particles 1
  [
    set color blue
    set size 10
    fd (random-float (max-pxcor - 6))
    set vx 0
    set vy 0
    set xc xcor
    set yc ycor
    set c^2 charge * charge
    set modcharge sqrt c^2
  ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Runtime Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

to go
  if not any? particles [ stop ]
  ;; label the particles with the appropriate charge
  ask particles
  [
    ifelse charge > 0
      [ set label charge ]
      [ set label charge ]
  ]
  ;; color the patches for the appropriate permittivity
  ;; if the permittivity slider has changed
  if permittivity != previous-permittivity
  [
    ask patches with [true] [ set pcolor permittivity * 8 + 5]
    set previous-permittivity permittivity
  ]
  ifelse charge < 0
  [ set c-charge (0 - charge) ]
  [ set c-charge charge ]
  if mouse-down?
  [
    ask centers [ show-turtle ]
    every 0.1
    [
      ;; Get the mouse(mass) position.
      set m-xc mouse-xcor
      set m-yc mouse-ycor
      ask centers
      [
        setxy m-xc m-yc
        ifelse charge < 0
          [ set label (0 - charge) ]
          [ set label charge ]
      ]
      ask particles[ gravitate ]
      ask particles[ calculate-potential-energy]
      fade-patches
      tick
      do-plots
    ]
  ]
end

to gravitate ;; Turtle Procedure
  update-force
  update-velocity
  update-position
end

to update-force ;; Turtle Procedure
  ;; Similar to 'distancexy', except using an unbounded plane. rather than the
  ;; built in box topology
  set r-sqrd (((xc - m-xc) * (xc - m-xc)) + ((yc - m-yc) * (yc - m-yc)))

  ;; prevents divide by zero
  ifelse (r-sqrd != 0)
  [
    ;; Calculate component forces using inverse square law
    set fx ((cos (atan (m-yc - yc) (m-xc - xc))) * (- (charge) * c-charge / r-sqrd))
    set fy ((sin (atan (m-yc - yc) (m-xc - xc))) * (- (charge) * c-charge / r-sqrd))
    set force sqrt(fx * fx + fy * fy)
  ]
  [
    ;; if r-sqrd = 0, then it's at the mass, and then the model stops
    stop
  ]
end

to update-velocity ;; Turtle Procedure
  ;; Now we update each particle's velocity, by taking the old velocity and
  ;; adding the force to it.
  set vx (vx + (fx * permittivity))
  set vy (vy + (fy * permittivity))
end

to update-position ;; Turtle Procedure
  set xc (xc + vx)
  set yc (yc + vy)
  facexy xc yc
  ifelse can-move? distancexy xc yc
  [
    setxy xc yc
    if (fade-rate != 100)
      [ set pcolor permittivity * 8 ]
  ]
    [ die ]
end

to fade-patches
  ask patches with [pcolor != (permittivity * 8 + 5)]
  [ ifelse (fade-rate = 100)
      [ set pcolor black ]
    [ if (fade-rate != 0)
        [ fade ]
    ]
  ]
end

to fade ;; Patch Procedure
  let new-color min( list (pcolor + 0.2) (permittivity * 8 + 5))
  ;; if the new-color is no longer the same shade then it's faded to black.
  set pcolor new-color
end

to calculate-potential-energy
  set r-sqrd (((xc - m-xc) * (xc - m-xc)) + ((yc - m-yc) * (yc - m-yc)))
  set r sqrt r-sqrd
  set potential charge / r
end

to setup-plots
  set-current-plot ""Potential Energy""
  set-current-plot ""Distance (r)""
  set-current-plot ""Coulomb's Force""
end

to do-plots
  set-current-plot ""Potential Energy""
  set-current-plot-pen ""potential""
  plot potential
  set-current-plot ""Distance (r)""
  set-current-plot-pen ""r""
  plot r
  set-current-plot ""Coulomb's Force""
  set-current-plot-pen ""force""
  plot force
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2005 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2005).  NetLogo Electrostatics model.
; http://ccl.northwestern.edu/netlogo/models/Electrostatics.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2005 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Electrostatics
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model displays the common natural phenomenon expressed by the Coulomb's inverse-square law.  It shows what happens when the strength of the force between two charges varies inversely with the square of the distance between them.

This model is a part of the NIELS (NetLogo Investigations in Electromagnetism) curriculum.  The NIELS curriculum is currently under development at the CCL.


HOW IT WORKS
-------------
In this model the formula used to guide each charge's behavior is the standard formula for Coulomb's law:

F = (q1 * q2 * Permittivity) / (r^2)

In this formula:
- ""F"" is the force between the two charges q1 and q2.
- ""Permittivity"", the constant of proportionality here, is a property of the medium in which the two charges q1 and q2 are situated.
- ""r"" is the distance between the centers of the two charges.

This is a single force two body model, where we have a charge q1 (the blue particle that is created when you press SETUP) and a proton (q2) (the gray particle that appears  when you press the mouse button in the view).  The force is entirely one-way: only q1 is attracted towards (or repelled from) the proton (q2), while the proton (q2) remains unaffected.  Note that this is purely for purposes of simulation.  In the real world, Coulomb's force acts on all bodies around it.

Gravity is another example of an inverse square force.  Roughly speaking, our solar system resembles a nucleus (sun) with electrons (planets) orbiting around it.

For certain values of q1 (which you can control by using the CHARGE slider), you can watch q1 form elliptic orbits around the mouse pointer (q2), or watch q1 slingshot around q2, similar to how a comet streaks past our sun. The charges q1 and q2 are always set equal in magnitude to each other, although they can differ in their sign.


HOW TO USE IT
-------------
When you press the SETUP button, the charge q1 is created in a medium determined by the permittivity value from the PERMITTIVITY slider. When you click and hold down the mouse anywhere within the view, the model creates a unit of positive charge (q2) at the position of the mouse.

The CHARGE slider sets the value of the charge on q1.  First, select the value of CHARGE on q1.  (For simulation ease, value of the Charge on q2 is set to be +1 unit.  Thus, it also determines at what distances the particles can safely orbit before they get sucked in by an overwhelming force.)

The FADE-RATE slider controls how fast the paths marked by the particles fade.  At 100% there won't be any paths as they fade immediately, and at 0% the paths won't fade at all.

The PERMITTIVITY slider allows you to change values of the constant of proportionality in Coulomb's law. What does this variable depend on -- the charges, or the medium in which the charges are immersed?

When the sliders have been set to desirable levels, press the GO button to begin the simulation.  Move the mouse to where you wish q2 to begin, and click and hold the mouse button. This will start the particles moving. If you wish to stop the simulation (say, to change the value of CHARGE), release the mouse button and the particles will stop moving.  You may then change any settings you wish.  Then, to continue the simulation, simply put your mouse in the window again and click and hold. Objects in the window will only move while the mouse button is pressed down within the window.


THINGS TO NOTICE
----------------
The most important thing to observe is the behavior of the q1 (the blue charge).

What is the initial velocity for q1?

What happens as you change the value of q1 from negative to positive?

As you run the model, watch the graphs on the right hand side of the world. What can you infer from the graphs about the relationship between potential energy and distance between charges? What can you say about the relationship between Coulomb's force and distance between the charges from the graphs?

Move the mouse around -- watch what happens if you move it quickly or slowly. Jiggle it around in a single place, or let it sit still.  Observe what patterns the particles fall into.  (You may keep FADE-RATE low to watch this explicitly.)


THINGS TO TRY
-------------
Run the simulation playing with different values of:
a) charge -- make sure to watch how different values of the CHARGE slider impact the model for any fixed value of permittivity.
b) permittivity -- make sure to watch how different values of the PERMITTIVITY slider impact the model for any fixed value of charge.

Can you make q1 revolve around q2?  Imagine, if q1 would be an electron and q2 a proton, then you have just built a hydrogen atom...

As the simulation progresses, you can take data on how
a) Force between the two charges varies with distance between charges;
b) Potential energy changes with distance between charges;
c) Force depends on permittivity.

In each case, take 8 to 10 data points.  Plot your results by hand or by any plotting program.


EXTENDING THE MODEL
-------------------
Assign a fixed position to the proton (q1), i.e., make it independent of the mouse position.  Assign a variable to its magnitude.

Now create another charge of the breed ""centers"", and assign a fixed position to it in the graphics window.  Run the model for different positions, magnitude and signs (i.e., ""+""ve or ""-""ve) of the new ""center"".

Create many test-charges.  Then place the two ""centers"", of opposite signs and comparable magnitudes, near the two horizontal edges of the world.  Now run the model.


RELATED MODELS
--------------
Gravitation


NETLOGO FEATURES
-----------------
When a particle moves off of the edge of the world, it doesn't re-appear by wrapping onto the other side (as in most other NetLogo models). The model stops when the particle exits the world.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (2005).  NetLogo Electrostatics model.  http://ccl.northwestern.edu/netlogo/models/Electrostatics.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2005 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Electrostatics for terms of use.
"
Series Circuit,/models/Sample Models/Chemistry & Physics/Electromagnetism/NIELS/Unverified,"breed [electrons electron]
globals [x l-curr left-current r-curr right-current ]
;;;;;;;;;;;;;;;;;;;;;;;;
;;; Setup Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;

to setup
  clear-all
  ;; normalization factor for calculating the effective voltage and number of electrons in each wire
  set x (collision-rate-with-atoms-left + collision-rate-with-atoms-right)
  set-default-shape electrons ""circle 2""  ;; circle with a border
  ;; create left wire
  ask patches with [pxcor < 0]
    [ set pcolor gray ]
  ;; create the right wire
  ask patches with [pxcor >= 0]
    [ set pcolor gray + 3 ]  ;; light gray
  ;; set up battery negative
  ask patches with [pxcor >= max-pxcor - 4]
    [ set pcolor red ]
  ask patch (max-pxcor - 1) 0
    [ set plabel ""-"" ]
  ;; set up battery positive
  ask patches with [pxcor <= min-pxcor + 4]
    [ set pcolor black ]
  ask patch (min-pxcor + 4) 0
    [ set plabel ""+"" ]
  ;; create white strip between two wires for calculating current out of the right-wire
  ask patches with [pxcor < 1 and pxcor > -1]
  [ set pcolor white ]
  ;; make sure that no electrons are on the Battery-positive - move them over
  ;; to the battery-negative by making them wrap around
  ask electrons [if pcolor = black [ set xcor xcor - 7 ] ]
  ask electrons [if pcolor = white [ set xcor xcor - 2 ] ]
  ;; create electrons in left wire
  ask n-of (600 * collision-rate-with-atoms-left
             / x)
           patches with [pcolor = gray + 3]
    [ sprout-electron ]
  ;; create electrons in right wire
  ask n-of (600 * collision-rate-with-atoms-right
             / x)
           patches with [pcolor = gray ]
    [ sprout-electron ]
  ;; plot the initial state of the system
  update-plots
end

to sprout-electron  ;; patch procedure
  sprout-electrons 1
  [
    set color orange - 2  ;; dark orange
    set size 1.5
  ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Runtime Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

to go
  ask electrons
  [
    if pcolor = gray + 3 [ move-electron collision-rate-with-atoms-right ]
    if pcolor = gray [ move-electron collision-rate-with-atoms-left  ]
    ;; if electrons are on the Battery-negative, move them into the right wire
    ;; with the same speed that the electrons have inside the right wire
    if pcolor = red [ set xcor xcor - Voltage * collision-rate-with-atoms-right ]
    ;; count number of electrons arriving at the battery-positive per tick
    if pcolor = black [ ht set l-curr l-curr + 1 set xcor xcor - 6 st ]
    set left-current l-curr / (ticks + 1)

    ;; count number of electrons leaving the right-wire and entering the left-wire per tick
    if pcolor = white [ ht set r-curr r-curr + 1 set xcor xcor - 2 st ]
    set right-current r-curr / (ticks + 1)
  ]
  ;; normalization factor for calculating the effective voltage and number of electrons in each wire
  set x (collision-rate-with-atoms-left + collision-rate-with-atoms-right)
  tick
  update-plots
end

;; wiggle randomly, performing simple point collisions
;; with invisible nuclei in the wire and steadily drifting
;; forward due to the electric field
to move-electron [collision-rate]
  ;; perform collisions with (invisible) atoms in the wire
  if random-float 1.0 < collision-rate [ rt random 360 ] fd 0.3
  ;; drift due to electric field towards the battery positive
  set xcor xcor - voltage * (collision-rate / x)
end

;;;;;;;;;;;;;;;;;;;;;;;
;; Plotting procedures
;;;;;;;;;;;;;;;;;;;;;;;

to update-plots
  set-current-plot ""Current in right wire""
  plotxy ticks right-current
  set-current-plot ""Current in left wire""
  plotxy ticks left-current
end




; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2007 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Sengupta, P. and Wilensky, U. (2007). NetLogo Series Circuit model.
; http://ccl.northwestern.edu/netlogo/models/SeriesCircuit.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2007 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/SeriesCircuit
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model shows a microscopic view of free electrons in two conducting wires that are connected in series between two terminals of a battery.

This model shows what occurs when two wires are connected in series between two ends of a battery terminal.  It illustrates how current in one wire is always equal to current in the other, even when the wires have different resistances.   It also displays how changing resistance in a single wire affects the magnitude of current in both wires.


HOW IT WORKS
------------
Each wire in the model is made up of atoms, which in turn are made of negatively charged electrons and positively charged nuclei.  According to the Bohr model of the atom, these electrons revolve in concentric shells around the nucleus.  However, in each atom, the electrons that are farthest away from the nucleus (i.e., the electrons that are in the outermost shell of each atom) behave as if they are free from the nuclear attraction.  These outermost electrons from each atom are called ""free electrons"".

These free electrons obey rules as follows. The applied electric field due to the battery imparts a steady velocity to the electrons towards the positive terminal.  (The positive battery terminal (black area) is an enormous collection of positive charges, whereas the negative battery terminal, (red area) is a huge source of negative charges or electrons.  The positive terminal therefore acts as a sink for negative charges or electrons.  The resultant pull of the electrons towards the battery positive gives rise to the ""voltage"" or ""potential difference"".)   In addition, the electrons also collide with the atomic nuclei in the wire, giving rise to ""resistance"".  However, to reduce the complexity of the model, these nuclei are not shown in the model.



HOW TO USE IT
-------------
The TOTAL-ELECTRONS slider allows you to select the total number of free electrons in both the wires. This number is maintained constant throughout a single run of the model.

The VOLTAGE slider imparts a steady velocity to the electrons.  However, this velocity is also inversely proportional to the rate at which the electrons collide with the atomic nuclei in the wires.

The sliders COLLISION-RATE-WITH-NUCELI-LEFT and COLLISION-RATE-WITH-NUCLEI-RIGHT indicate how far an electron can travel before colliding with atomic nuclei in the wires colored light gray and dark gray respectively.  The electrons collision rate in a wire gives rise to resistance.  The collision rate in each wire affects the motion of electrons in it in two ways:

1.  If the slider has a value 5, it means that an electron can travel a distance of 5 units before it will collide with a nucleus in the wire.  Since the collisions are elastic, it will travel another 5 units after colliding in its new direction of motion.

2.  The velocity of the electron due to the electric field is also slowed down by the collision rate. The velocity of the electron due to the electric field is the voltage divided by the collision rate with nuclei. This means that a higher collision rate will lead to a lower velocity of the electron.

The TRACE AND WATCH A SINGLE ELECTRON button highlights an electron and traces its path.  The WATCH A SINGLE ELECTRON button is the same, but without the trace.  Press STOP WATCHING AND TRACING to remove the highlighting.  (To clear traces, start over by pressing SETUP.)


THINGS TO NOTICE
----------------
When you observe the trace of the path of an electron, how does it differ in the two wires?  Why?

What happens to the number of electrons in each wire when you change the collision rate of electrons in either of the wires?


THINGS TO TRY
-------------
1. Run the model with the default settings.  Observe the current in both the wires.  Are these values equal? What about the number of electrons in each wire?

2. Increase the collision-rate in one of the wires.  Note the current in both the wires. Is current in each wire still equal to each other?  What about the number of electrons in each wire?

3. Increase the collision rate in both the wires at the same time. Compare the current in both the wires.  Does the current in both wire sections remain equal ?  What about the number of electrons in each wire?

4. Press WATCH A SINGLE ELECTRON.  Using the tick counter, write down how many ticks of model time the electron takes to travel through each wire.  Repeat this observation several times for different values of the collision-rates in each wire.
a) What do you notice?
b) Given the total number of electrons in each wire and the length of the wires, how can you calculate current in each wire with the time an electron takes to travel through the wire?

5. Look in the section titled ""Procedures for measuring current"" in the Procedures tab. How is current in each wire calculated in this model?  Are this method and 3(b) equivalent?

6. How would you calculate the total current in the circuit?
Is it the same as current in each wire?
Or is it the sum of the two currents?
What are the reasons for your answers?


EXTENDING THE MODEL
-------------------
Can you create another wire in series with these two wires?


NETLOGO FEATURES
----------------
Electrons wrap around the world both vertically and horizontally.


RELATED MODELS
--------------
Electrostatics
Polarization
Charged Particles
Moving Electrons
Ohm's Law
Lines of Force
Parallel Circuit


CREDITS AND REFERENCES
----------------------
This model is a part of the NIELS curriculum. The NIELS curriculum is currently under development at Northwestern's Center for Connected Learning and Computer-Based Modeling. For more information about the NIELS curriculum please refer to http://ccl.northwestern.edu/NIELS.

Thanks to Daniel Kornhauser for his work on the design of this model.

To refer to this model in academic publications, please use:  Sengupta, P. and Wilensky, U. (2007).  NetLogo Series Circuit model.  http://ccl.northwestern.edu/netlogo/models/SeriesCircuit.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2007 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/SeriesCircuit for terms of use.
"
Ohm's Law,/models/Sample Models/Chemistry & Physics/Electromagnetism/NIELS/Unverified,"breed [electrons electron]
globals [ vel current cur]

;;;;;;;;;;;;;;;;;;;;;;;;
;;; Setup Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;
to setup
  clear-all
  set-default-shape electrons ""circle 2""

  ;; create wire & terminals
  ask patches
    [ set pcolor gray ]
  ask patches with [pxcor >= max-pxcor - 4 ]
    [ set pcolor red ]
  ask patches with [pxcor <= min-pxcor + 4 ]
    [ set pcolor black ]

  ;; create electrons
  create-electrons total-electrons
  [
    setxy random-xcor random-ycor
    set color orange - 2
    set size 1.5
  ]

  ;; create labels for the battery terminals
  ask patch (min-pxcor + 4) 0
    [ set plabel ""+"" ]
  ask patch (max-pxcor - 1) 0
    [ set plabel ""-"" ]

  ;; since the battery-positive  is a sink for negative charges,
  ;; move electrons immediately to the battery-negative
  ask electrons [if pcolor = black [ set xcor xcor - 7 ] ]

  ;; plot the initial state of the system
  do-plot
end


;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Runtime Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;
to go

  ;; Rules for electrons
  ask electrons
  [
    ;; wiggle randomly, performing simple point collisions with invisible
    ;; nuclei in the wire and steadily drifting forward due to the electric field
    move

    ;; report current
    report-current

  ]

  ;; advance tick counter and update the view
  tick

  ;; Keep plotting
  do-plot
end


;;;;;;;;;;;;;;;;;;;;;;;;;
;; rules for electrons ;;
;;;;;;;;;;;;;;;;;;;;;;;;;
to move
  ;; perform collisions with (invisible) atoms
  if random-float 1.0 < collision-rate-with-nuclei [ rt random 360 ] fd 0.3
  ;; drift due to electric field towards the battery-positive
  set xcor xcor - vel
  set vel 0.5 * voltage / collision-rate-with-nuclei
end


;;;;;;;;;;;;;;;;;;;;;;;;;
;; Plotting procedures ;;
;;;;;;;;;;;;;;;;;;;;;;;;;
to do-plot
  set-current-plot ""Current""
  plotxy ticks current
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Procedures for measuring current ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to report-current
;; count number of electrons arriving at the battery-positive per tick
    if pcolor = black [ ht set cur cur + 1 set xcor xcor - 6 st ]
    set current cur / (ticks + 1)
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2007 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Sengupta, P. and Wilensky, U. (2007). NetLogo Ohm's Law model.
; http://ccl.northwestern.edu/netlogo/models/Ohm'sLaw.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2007 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Ohm'sLaw
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model illustrates how a steady current as well as resistance emerge from simple interactions between electrons and atoms in a wire and battery terminals.  It shows how the linear relationship between current (I), resistance(R) and voltage (V) as expressed in Ohm's Law (i.e., V = I * R) emerges due to the interactions between individual electrons and atoms.


HOW IT WORKS
------------
The wire in this model (gray region) is composed of atoms, which in turn are made of negatively charged electrons and positively charged nuclei.  According to the Bohr model of the atom, these electrons revolve in concentric shells around the nucleus.  However, in each atom, the electrons that are farthest away from the nucleus (i.e., the electrons that are in the outermost shell of each atom) behave as if they are free from the nuclear attraction.  These outermost electrons from each atom are called ""free electrons"".   These free electrons obey some rules that are specified in the Procedures tab of the model.  The applied electric field due to the battery imparts a steady velocity to the electrons in the direction of the positive terminal.  The positive battery terminal (black region), which is actually an enormous collection of positive charges, acts as an enormous sink for negative charges or electron, whereas, the negative battery terminal (red region) is a large source of negative charges or electrons.

Note that electrons reappear on the other side at the negative terminal after crossing into the positive terminal of the battery.  This is a greatly simplified representation of the continuous process of charge generation in the battery maintaining a constant voltage (or potential difference) between the two terminals.

Voltage in the battery gives rise to a constant electric field throughout the wire, imparting a steady drift to the electrons while they move in the wire connecting the two terminals.   In addition to this drift, the electrons also collide with the atomic nuclei in the wire, giving rise to electrical resistance in the wire.  However, to reduce the complexity of the model, these nuclei are not shown in the model.


HOW TO USE IT
-------------
The TOTAL-ELECTRONS slider allows selecting the total number of free electrons in both the wires. This number is kept constant throughout a single run of the model.

The VOLTAGE slider indicates the magnitude of voltage between the battery terminals.  It imparts a steady velocity to the electrons. However, as the next paragraph explains, this velocity depends on the rate at which the electron collides with the atomic nuclei in the wires.

The COLLISION-RATE-WITH-NUCLEI slider indicates how far an electron can travel without colliding with atomic nuclei. The collision rate of electrons in a wire causes resistance. The collision-rate affects the motion of electrons in it in two ways:
1. For example, if this slider has a value 5, it means that an electron can travel a distance of 5 units before it will collide with a nucleus in the wire.  Since the collisions are elastic, it will travel another 5 units after collision in its new direction of motion.
2. In addition, the velocity of the electron due to the electric field is also reduced by the collision rate.  The velocity of the electron due to the electric field is given by E-Field / collision-rate-with-nuclei.  This means that a higher collision rate will lead to a lower velocity of the electron.

The button COLOR & TRACE ONE ELECTRON asks an electron to set its color purple and traces its path.  If you want to go back to the default settings (with all electrons red and no traces), you need to press SETUP again.

The button WATCH ONE ELECTRON highlights a single electron (chosen randomly) so that you can observe its motion in particular.  If you want to go back to the default settings (with all electrons red and no traces), you need to press SETUP again.


THINGS TO NOTICE
----------------
When you observe the trace of the path of an electron by pressing the COLOR & TRACE ONE ELECTRON button, how does the path change when you increase or decrease the COLLISION-RATE-WITH-NUCLEI ?


THINGS TO TRY
-------------
1) Run the model with the default settings. Note the current and number of electrons in the wire.

2a) Increase the collision-rate of electrons with the nuclei. How does the value of current in the wire change? How does the motion of electrons change?
2b) Reduce the collision-rate of electrons with the nuclei. How does the value of current in the wire change? How does the motion of electrons change?

3a) Press WATCH ONE ELECTRON. Using the tick counter, note how much model time the electron takes to travel through the wire. Repeat this observation several times for the same value of collision-rate-with-nuclei. Now calculate the average speed of the electron from these observations.
3b) Repeat 3a for a few different values of the slider COLLISION-RATE-WITH-NUCLEI. What do you notice?
3c) How can you calculate current in the wire from the average speed of an electron through it?

4) Look for the ""Procedures for measuring current"" section in the Procedures tab. How is current in each wire calculated in this model?  Are this method and 3(b) equivalent to each other?

5) Based on your interactions with the model, how would now explain the concepts of current and resistance?


EXTENDING THE MODEL
-------------------
Can you create a series circuit (with two wires in series) by extending this model?


NETLOGO FEATURES
----------------
Electrons wrap around the world both vertically and horizontally.


RELATED MODELS
--------------
Electrostatics
Polarization
Charged Particles
Conductor
Lines of Force
Parallel Circuit
Series Circuit


CREDITS AND REFERENCES
----------------------
This model is a part of the NIELS curriculum. The NIELS curriculum is currently under development at Northwestern's Center for Connected Learning and Computer-Based Modeling. For more information about the NIELS curriculum please refer to http://ccl.northwestern.edu/NIELS.

Thanks to Daniel Kornhauser for his work on the design of this model.

To refer to this model in academic publications, please use:  Sengupta, P. and Wilensky, U. (2007).  NetLogo Ohm's Law model.  http://ccl.northwestern.edu/netlogo/models/Ohm'sLaw.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2007 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Ohm'sLaw for terms of use.
"
Parallel Circuit,/models/Sample Models/Chemistry & Physics/Electromagnetism/NIELS/Unverified,"breed [top-electrons top-electron]
breed [bottom-electrons bottom-electron]

;;;;;;;;;;;;;;;;;;;;;;;;
;;; Setup Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;

to setup
  clear-all
  set-default-shape top-electrons ""circle 2""
  set-default-shape bottom-electrons ""circle 2""

  ;; create the top wire
  ask patches with [top-wire?]
    [ set pcolor gray ]
  ;; create the bottom wire
  ask patches with [not top-wire?]
    [ set pcolor gray + 3 ]

  ;; set up battery negative
  ask patches with [pxcor >= max-pxcor - 4]
    [ set pcolor red ]
  ask patch (max-pxcor - 1) (max-pycor / 2)
    [ set plabel ""-"" ]

  ;; set up battery positive
  ask patches with [pxcor <= min-pxcor + 4]
    [ set pcolor black ]
  ask patch (min-pxcor + 4) (max-pycor / 2)
    [ set plabel ""+"" ]

  ;; create electrons in top wire
  ask n-of (total-electrons / 2) patches with [top-wire?]
    [ sprout-top-electrons 1 [
        set color orange - 2
        set size 1.5
      ] ]
  ;; create electrons in bottom wire
  ask n-of (total-electrons / 2) patches with [not top-wire?]
    [ sprout-bottom-electrons 1 [
        set color orange - 2
        set size 1.5
      ] ]
end

to-report top-wire?  ;; turtle or patch procedure
  report pycor > max-pycor / 2
end

;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Runtime Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

to go
  ask top-electrons
    [ move-electron resistance-top-wire ]
  ask bottom-electrons
    [ move-electron resistance-bottom-wire ]
  tick
  update-plots
end

;; wiggle randomly, performing simple point collisions
;; with invisible nuclei in the wire and steadily drifting
;; forward due to the electric field
to move-electron [collision-rate]
  let old-patch patch-here
  ;; perform collisions with (invisible) atoms
  rt random 360
  fd collision-rate
  ;; drift due to electric field towards the battery-positive
  set xcor xcor - voltage / collision-rate
  ;; have we entered the wrong wire? if so, wrap
  if top-wire? != [top-wire?] of old-patch
    [ set ycor ycor + (max-pycor + 1) / 2 ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;
;; Plotting Procedures ;;
;;;;;;;;;;;;;;;;;;;;;;;;;

to update-plots
  set-current-plot ""Current in top wire""
  plotxy ticks top-current
  set-current-plot ""Current in bottom wire""
  plotxy ticks bottom-current
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Procedures for measuring current
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; measure current in the top wire
to-report top-current
  report (count top-electrons - count top-electrons with [pcolor = red])
         * (voltage / resistance-top-wire)
         / 1000
end

;; measure current in the bottom wire
to-report bottom-current
  report (count bottom-electrons - count bottom-electrons with [pcolor = red])
         * (voltage / resistance-bottom-wire)
         / 1000
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2007 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Sengupta, P. and Wilensky, U. (2007). NetLogo Parallel Circuit model.
; http://ccl.northwestern.edu/netlogo/models/ParallelCircuit.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2007 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/ParallelCircuit
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model offers a microscopic view of free electrons in two conducting wires that are connected in parallel to each other across two terminals of a battery.

This model shows what happens when two such wires are connected in parallel to each other across two ends of a battery terminal. It shows that current in each wire is not always equal to current in the other wire, unlike in a series circuit (see Series Circuit model). However, since each of the wires is connected across the same battery terminals, voltage is the same in each wire.


HOW IT WORKS
------------
Each wire in the model is made up of atoms, which in turn are made of negatively charged electrons and positively charged nuclei. According to the Bohr model of the atom, these electrons revolve in concentric shells around the nucleus. However, in each atom, the electrons that are farthest away from the nucleus (i.e., the electrons that are in the outermost shell of each atom) behave as if they are free from the nuclear attraction. These outermost electrons from each atom are called ""free electrons"".

These free electrons obey some simple rules. The applied electric field (due to the voltage in the battery) imparts a steady velocity to the electrons in the direction of the positive terminal. (The positive battery terminal, indicated by the black area in the model, is a large sink for negative charges, whereas the negative battery terminal, indicated by the red area, is a large source of negative charges or electrons.) However, the electrons also collide with the atomic nuclei in the wire, and this mechanism gives rise to resistance. However, to reduce the complexity of the model, these nuclei are not explicitly shown.

When an electron reaches the battery-positive, it reappears at the battery-negative. This is a simplified representation of how a battery works -- by maintaining a constant voltage (or potential difference) between its two terminals.

Electrons from one wire do not cross over into the other wire.


HOW TO USE IT
-------------
The TOTAL-ELECTRONS slider allows you to select the total number of free electrons in both wires. This number is constant for a single run of the model.

The VOLTAGE slider controls the potential difference across the two battery terminals. This imparts a steady velocity to the electrons. However, this velocity is also dependent on the rate at which the electrons collide with the atomic nuclei in the wires.

The RESISTANCE-TOP-WIRE and RESISTANCE-BOTTOM-WIRE sliders control how far an electron can travel before colliding with atomic nuclei in the top and bottom wires respectively. The collision rate of electrons in a wire gives rise to resistance. The collision rate in each wire affects the motion of electrons in it in two ways:

1. For example, if this slider has a value 5, it means that an electron can travel a distance of 5 units before it will collide with a nucleus in the wire. Since the collisions are elastic, it will travel another 5 units after collision in its new direction of motion.

2. In addition, the velocity of the electron due to the electric field is also slowed down by the collision rate. The velocity of the electron due to the electric field is given by E-Field divided by collision rate. This means that a higher collision rate will lead to a lower velocity of the electron towards the battery-positive.


THINGS TO NOTICE
----------------
When you observe the trace of the path of an electron, how does it differ in the two wires? Why?

What happens to the number of electrons in each wire when you change the collision rate of electrons in either of the wires?


THINGS TO TRY
-------------
1. Run the model with the default settings. Note the current in both the wires. Are these values equal? What about the number of electrons in each wire?

2. Increase the collision rate in one of the wires. Note the current in both the wires. Then increase the collision rate in both the wires at the same time. Note the current in both the wires. Is current in each wire still equal to each other? What about the number of electrons in each wire?

3. Watch a single electron in the top wire by pressing the top WATCH AN ELECTRON button. Now watch the tick counter and note how much model time the electron takes to travel through the wire. Repeat this observation several times for different values of the collision rates in each wire.
a) What do you notice?
b) Given the total number of electrons in each wire and the length of the wires, how can you calculate current in each wire by noting the time an electron takes to travel through the wire?

4. Following step 3 above, now calculate the current in the bottom wire.

5. Look in the section titled ""Procedures for Counting Current"" in the Procedures tab. How is current in each wire calculated in this model? Is this method and 3(b) equivalent to each other?

6. How would you calculate the total current in the circuit?


EXTENDING THE MODEL
-------------------
Can you create another wire in series with these two wires?


NETLOGO FEATURES
----------------
Electrons wrap around the world horizontally. Special vertical wrap code is used to keep electrons from changing wires.


RELATED MODELS
--------------
Electrostatics, Polarization, Charged Particles, Moving Electrons, Ohm's Law, Lines of Force, Series Circuit


CREDITS AND REFERENCES
----------------------
Thanks to Daniel Kornhauser for his work on the design of this model.

To refer to this model in academic publications, please use:  Sengupta, P. and Wilensky, U. (2007).  NetLogo Parallel Circuit model.  http://ccl.northwestern.edu/netlogo/models/ParallelCircuit.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2007 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/ParallelCircuit for terms of use.
"
Gravitation,/models/Sample Models/Chemistry & Physics/Mechanics/Unverified,"turtles-own
[ fx     ;; x-component of force vector
  fy     ;; y-component of force vector
  vx     ;; x-component of velocity vector
  vy     ;; y-component of velocity vector
  xc     ;; real x-coordinate (in case particle leaves world)
  yc     ;; real y-coordinate (in case particle leaves world)
  r-sqrd ;; square of the distance to the mouse
]

globals
[ m-xc  ;; x-coordinate of acting mass
  m-yc  ;; y-coordinate of acting mass
  g     ;; Gravitational Constant to slow the acceleration
]

;;;;;;;;;;;;;;;;;;;;;;;;
;;; Setup Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;
to setup
  ca
  set g 0.5
  set-default-shape turtles ""circle""
  crt number
  [
    if (not colors?)
    [ set color white ]
    set size 10
    fd (random-float (max-pxcor - 6))
    set vx 0
    set vy 0
    set xc xcor
    set yc ycor
  ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Runtime Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;
to go
  if (mouse-down?)
  [
    every 0.1
    [
      ;; Get the mouse(mass) position.
      set m-xc mouse-xcor
      set m-yc mouse-ycor
      ask turtles [ gravitate ]
      fade-patches
      tick
    ]
  ]
end

to gravitate ;; Turtle Procedure
  update-force
  update-velocity
  update-position
end

to update-force ;; Turtle Procedure
  ;; Similar to 'distancexy', except using an unbounded plane.
  set r-sqrd (((xc - m-xc) * (xc - m-xc)) + ((yc - m-yc) * (yc - m-yc)))

  ;; prevents divide by zero
  ifelse (r-sqrd != 0)
  [
    ;; Calculate component forces using inverse square law
    set fx ((cos (atan (m-yc - yc) (m-xc - xc))) * (mass / r-sqrd))
    set fy ((sin (atan (m-yc - yc) (m-xc - xc))) * (mass / r-sqrd))
  ]
  [
    ;; if r-sqrd = 0, then it's at the mass, thus there's no force.
    set fx 0
    set fy 0
  ]
end

to update-velocity ;; Turtle Procedure
  ;; Now we update each particle's velocity, by taking the old velocity and
  ;; adding the force to it.
  set vx (vx + (fx * g))
  set vy (vy + (fy * g))
end

to update-position ;; Turtle Procedure
  set xc (xc + vx)
  set yc (yc + vy)

  ifelse patch-at (xc - xcor) (yc - ycor) != nobody
  [
    setxy xc yc
    ifelse (colors?)
    [
      if (color = white)
      [ set color 5 + 10 * random 14 ]
    ]
    [ set color white ]
    show-turtle
    if (fade-rate != 100)
    [ ifelse (color = white)
      [ set pcolor red + 3 ]
      [ set pcolor color + 3 ]
    ]
  ]
  [ hide-turtle ]
end

to fade-patches
  ask patches with [pcolor != black]
  [ ifelse (fade-rate = 100)
    [ set pcolor black ]
    [ if (fade-rate != 0)
      [ fade ]
    ]
  ]
end

to fade ;; Patch Procedure
  let new-color pcolor - 8 * fade-rate / 100
  ;; if the new-color is no longer the same shade then it's faded to black.
  ifelse (shade-of? pcolor new-color)
  [ set pcolor new-color ]
  [ set pcolor black ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2002.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Gravitation model.
; http://ccl.northwestern.edu/netlogo/models/Gravitation.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Gravitation
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This project displays the common natural phenomenon expressed by the inverse-square law.  Essentially this model displays what happens when the strength of the force between two objects varies inversely with the square of the distance between these two objects.


HOW IT WORKS
-------------
In this model the formula used to guide each object's behavior is the standard formula for the Law of Gravitational Attraction:

(m1 * m2 * G) / (r^2)

This is a single force 'n-body' model, where we have a certain number of small particles, and one large acting mass (the mouse pointer). The force is entirely one-way: the large mass remains unaffected by the smaller particles around it.  And the smaller particles remain unaffected by each other as well.  (Note that this is purely for purposes of simulation.  In the real world, a force such as gravity acts on all bodies around it.)

Gravity is the best example of such a force. You can watch the particles form elliptic orbits around the mouse pointer, or watch them slingshot around it, similar to how a comet streaks past our sun. Think of the individual objects as planets or other solar bodies, and see how they react to various masses that move or remain stationary.


HOW TO USE IT
-------------
First select the number of particles with the NUMBER slider. Then press the SETUP button to create and scatter them across the world.

The MASS slider sets the value of the mass of the acting force. (Thus, it also determines at what distances the particles can safely orbit before they get sucked in by an overwhelming force.)

The FADE-RATE slider controls the percent of color that the paths marked by the particles fade after each cycle.  Thus at 100% there won't be any paths as they fade immediately, and at 0% the paths won't fade at all.  With this you can see the ellipses and parabolas formed by different particles' travels.

The COLORS? switch, when set to ON, assigns different colors to the particles, otherwise they will all be white.

When the sliders have been set to desirable levels, press the GO button to begin the simulation. Move the mouse to where you wish it to begin, and click and hold the mouse button. This will start the particles moving. If you wish to stop the simulation (say, to change the value of MASS), release the mouse button and the particles will stop moving.  You may then change any settings you wish (except PARTICLES).  Then, to continue the simulation, simply put your mouse in the window again and click and hold. Objects in the window will only move while the mouse button is pressed down within the window.


THINGS TO NOTICE
----------------
The most important thing to observe is the behavior of the particles. Notice that, as the particles have no initial velocity of their own, a single motionless acting mass will just pull them all in. Even a very slight mass (MASS set to a small value) will pull in all the particles. (Due to limited precision beyond a certain point, the motive-force on a particle can become zero.)

Move the mouse around - watch what happens if you move it quickly or slowly. Jiggle it around in a single place, or let it sit still. Observe what patterns the particles fall into. (Keep FADE-RATE low to watch this explicitly.)


THINGS TO TRY
-------------
There are a few other parameters, set in the code, that affect the behavior of the model.  The force acting upon each particle is multiplied by a constant, 'g' (another global variable).  Feel free to play with their values, set in the procedure 'setup'. (Of course, the default value of g for the model, 0.5, is much higher than the value used in Newtonian Mechanics, 6.67e-11.)

Initial conditions are very important for a model such as this one. Try changing how the particles are placed during the 'setup' procedure.

Make sure to watch how different values of the MASS slider impact the model.


EXTENDING THE MODEL
-------------------
Let the particles begin with a constant velocity, or give them all a random velocity. You could add a slider that would let the user set the velocities, and thus be able to compare the effects of different speeds. Or try giving each particle a variable mass, which directly affects the strength of the acting force upon it.

The model assumes the force to be an attractive force (the particles tend to be pulled towards it). However, it should be a relatively easy change to make this into a repulsive force. Try setting up the model with a repulsive force, and observe what happens.


NETLOGO FEATURES
-----------------
This model creates the illusion of a plane of infinite size, to better model the behavior of the particles. Notice that, with path marking you can see most of the ellipse a particle draws, even though the particle periodically shoots out of bounds. This is done through a combination of the basic turtle primitives 'hide-turtle' and 'show-turtle', when a particle hits the boundary, keeping every turtle's xcor and ycor as special turtle variables 'xc' and 'yc', and calculations similar to the 'distance' function that uses 'xc' and 'yc' instead of 'xcor' and 'ycor'.

When you examine the procedure window, take note that the standard turtle primitives 'set heading', 'fd 1', etc... aren't used here. Everything is done directly to the x-coordinates and y-coordinates of the turtles.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Gravitation model.  http://ccl.northwestern.edu/netlogo/models/Gravitation.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Gravitation for terms of use.
"
N-Bodies,/models/Sample Models/Chemistry & Physics/Mechanics/Unverified,"turtles-own
[ fx     ;; x-component of force vector
  fy     ;; y-component of force vector
  vx     ;; x-component of velocity vector
  vy     ;; y-component of velocity vector
  xc     ;; real x-coordinate (in case particle leaves world)
  yc     ;; real y-coordinate (in case particle leaves world)
  mass   ;; the particle's mass
]

globals
[ center-of-mass-yc ;; y-coordinate of the center of mass
  center-of-mass-xc ;; x-coordinate of the center of mass
  g  ;; Gravitational Constant
]

;;;;;;;;;;;;;;;;;;;;;;;;
;;; Setup Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;
to setup
  ca
  set g 20
  set-default-shape turtles ""circle""
  crt number
  ifelse symmetrical-setup?
  [ zero-sum-initial-setup ]
  [ random-initial-setup ]
  if keep-centered?
  [ recenter ]
end

to random-initial-setup
  ask turtles
  [ set vx ((random-float ((2 * max-initial-speed) - 1)) - max-initial-speed)
    set vy ((random-float ((2 * max-initial-speed) - 1)) - max-initial-speed)
    set mass (random-float max-initial-mass) + 1
    set size sqrt mass
    set heading (random-float 360)
    jump (random-float (max-pxcor - 10))
    set xc xcor
    set yc ycor
  ]
end

to zero-sum-initial-setup
  ;; First we set up the initial velocities of the first half of the particles.
  ask turtles with [who < (number / 2)]
  [ set vx (random-float (((2 * max-initial-speed) - 1)) - max-initial-speed)
    set vy (random-float (((2 * max-initial-speed) - 1)) - max-initial-speed)
    setxy random-xcor random-ycor
    set xc xcor
    set yc ycor
    set mass (random-float max-initial-mass) + 1
    set size sqrt mass
  ]
  ;; Now, as we're zero-summing, we set the velocities of the second half of the
  ;; particles to be the opposites of their counterparts in the first half.
  ask turtles with [who >= (number / 2)]
  [ set vx (- ([vx] of turtle (who - (number / 2))))
    set vy (- ([vy] of turtle (who - (number / 2))))
    set xc (- ([xc] of turtle (who - (number / 2))))
    set yc (- ([yc] of turtle (who - (number / 2))))
    setxy xc yc
    set mass [mass] of turtle (who - (number / 2))
    set size sqrt mass
  ]
  set center-of-mass-xc 0
  set center-of-mass-yc 0
end

to create-particle
  if mouse-down?
  [ let mx mouse-xcor
    let my mouse-ycor
    if (not any? turtles-on patch mx my)
    [
      crt 1
      [ set xc mx ;initial-position-x
        set yc my ;initial-position-y
        setxy xc yc
        set vx initial-velocity-x
        set vy initial-velocity-y
        set mass initial-mass
        set size sqrt mass
        set color particle-color
      ]
      display
    ]
  ]
  while [mouse-down?]
  []
  if keep-centered?
  [
    recenter
    display
  ]
end

to setup-two-planet
  set number 0
  setup
  crt 1
  [ set color yellow
    set mass 200
    set size sqrt mass
  ]
  crt 1
  [ set color blue
    set mass 5
    set size sqrt mass
    set xc 50
    set yc 0
    setxy xc yc
    set vx 0
    set vy 9
  ]
  crt 1
  [ set color red
    set mass 5
    set size sqrt mass
    set xc 90
    set yc 0
    setxy xc yc
    set vx 0
    set vy 7
  ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Runtime Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;
to go
  ask turtles
  [ set fx 0
    set fy 0
  ]
  ;; must do all of these steps separately to get correct results
  ;; since all turtles interact with one another
  ask turtles [ check-for-collisions ]
  ask turtles [ update-force ]
  ask turtles [ update-velocity ]
  ask turtles [ update-position ]
  if keep-centered?
  [ recenter ]
  fade-patches
  tick
end

to check-for-collisions
  if any? other turtles-here
  [
    ask other turtles-here
    [
      set vx vx + [vx] of myself
      set vy vy + [vy] of myself
      set mass mass + [mass] of myself
      set size sqrt mass
    ]
    die
  ]
end

to update-force ;; Turtle Procedure
  ;; This is recursive over all the turtles, each turtle asks this of all other turtles
  ask other turtles [ sum-its-force-on-me myself ]
end

to sum-its-force-on-me [it] ;; Turtle Procedure
  let xd xc - [xc] of it
  let yd yc - [yc] of it
  let d sqrt ((xd * xd) + (yd * yd))
  set fx fx + (cos (atan (- yd) (- xd))) * ([mass] of it * mass) / (d * d)
  set fy fy + (sin (atan (- yd) (- xd))) * ([mass] of it * mass) / (d * d)
end

to update-velocity ;; Turtle Procedure
  ;; Now we update each particle's velocity, by taking last time-step's velocity
  ;; and adding the effect of the force to it.
  set vx (vx + (fx * g / mass))
  set vy (vy + (fy * g / mass))
end

to update-position ;; Turtle Procedure
  ;; As our system is closed, we can safely recenter the center of mass to the origin.
  set xc (xc + vx)
  set yc (yc + vy)
  adjust-position
end

to adjust-position ;; Turtle Procedure
  ;; If we're in the visible world (the world inside the view)
  ;; update our x and y coordinates.
  ;; if there is no patch at xc yc that means it is outside the world
  ;; and the turtle should just be hidden until it returns to the
  ;; viewable world.
  ifelse patch-at (xc - xcor) (yc - ycor) != nobody
  [ setxy xc yc
    show-turtle
    if (fade-rate != 100)
    [ set pcolor color + 3 ]
  ]
  [ hide-turtle ]
end

;; Center of Mass
to recenter
  find-center-of-mass
  ask turtles
  [ set xc (xc - center-of-mass-xc)
    set yc (yc - center-of-mass-yc)
    adjust-position
  ]
end

to find-center-of-mass
  if any? turtles
  [ set center-of-mass-xc sum [mass * xc] of turtles / sum [mass] of turtles
    set center-of-mass-yc sum [mass * yc] of turtles / sum [mass] of turtles
  ]
end

to fade-patches
  ask patches with [pcolor != black]
  [ ifelse (fade-rate = 100)
    [ set pcolor black ]
    [ if (fade-rate != 0)
      [ fade ]
    ]
  ]
end

to fade ;; Patch Procedure
  let new-color pcolor - 8 * fade-rate / 100
  ;; if the new-color is no longer the same shade then it's faded to black.
  ifelse (shade-of? pcolor new-color)
  [ set pcolor new-color ]
  [ set pcolor black ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2002.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo N-Bodies model.
; http://ccl.northwestern.edu/netlogo/models/N-Bodies.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/N-Bodies
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This project displays the common natural phenomenon expressed by the inverse-square law.  Essentially this displays what happens when the strength of the force between two objects varies inversely with the square of the distance between these two objects.  In this case, the formula used is the standard formula for the Law of Gravitational Attraction:

(m1 * m2 * G) / (r^2).

This particular model demonstrates the effect of gravity upon a system of interdependent particles. You will see each particle in the collection of small masses (each of the n bodies, n being the total number of particles present in the system) exert gravitational pull upon all others, resulting in unpredictable, chaotic behavior.


HOW TO USE IT
-------------
First select the number of particles with the NUMBER slider.

The SYMMETRICAL-SETUP? switch determines whether or not the particles' initial velocities will sum to zero.  If On, they will. Their initial positions will also be randomly, but symmetrically, distributed across the world.  If SYMMETRICAL-SETUP? is Off, each particle will have a randomly determined mass, initial velocity, and initial position.

MAX-INITIAL-MASS and MAX-INITIAL-SPEED determine the maximum initial values of each particle's mass and velocity.  The actual initial values will be randomly distributed in the range from zero to the values specified.

The FADE-RATE slider controls the percent of color that the paths marked by the particles fade after each cycle.  Thus at 100% there won't be any paths as they fade immediately, and at 0% the paths won't fade at all.  With this you can see the ellipses and parabolas formed by different particles' travels.

The KEEP-CENTERED? switch controls whether the simulation will re-center itself after each cycle.  When On, the system will shift the positions of the particles so that the center of mass is at the origin (0, 0).

If you want to design your own custom system, press SETUP to initialize the model, and then use the CREATE-PARTICLE button to create a particle with the settings set with the INITIAL-VELOCITY-X, INITIAL-VELOCITY-Y, INITIAL-MASS, and PARTICLE-COLOR sliders.  Particles are created by clicking in the View where you want to place the particle while the CREATE-PARTICLE button is running.  (Note, if KEEP-CENTERED? is On the particles will always move so that the center of mass is at the origin.)


THINGS TO TRY
-------------
After you have set the sliders to the desired levels, press SETUP to initialize all particles, or SETUP TWO-PLANET to setup a predesigned stable two-planet system.  Next, press GO to begin running the simulation. You have two choices: you can either let it run without stopping (the GO forever button), or you can just advance the simulation by one time-step (the GO ONCE button). It may be useful to step through the simulation moment by moment, so that you can carefully watch the interaction of the particles.


THINGS TO NOTICE
----------------
The most important thing to observe is the behavior of the particles. Notice how (and to what degree) the initial conditions influence the model.

Compare the two different modes of the model, with SYMMETRICAL-SETUP? On and Off. Observe the initial symmetry of the zero-summed system, and what happens to it.  Why do you think this is?

As each particle acts on all the others, the number of particles present directly affects the run of the model. Every additional body changes the center of mass of the system. Watch what happens with 2 bodies, 4 bodies, etc... How is the behavior different?

It may seem strange to think of n discrete particles exerting small forces on one other particle, determining its behavior. However, you can think of it as just one large force emanating from the center of mass of the system.  Watch as the center of mass changes over time. In the main procedure, 'go', look at the two lines of code where each body's position (xc, yc) is established- we shift each particle back towards the center of mass. As no other forces are present in the model (the n-bodies represent a closed system), our real positions are relative, defined only in relation to the center of mass itself. Recall Newton's third law, which states that for each internal force acting on a particle, it exerts an equal but opposite force on another particle. Hence the internal forces cancel out, and we have no net force acting on the center of mass. (If particle 1 exerts a force on particle 2, then particle 2 exerts the same force on particle 1. Run the model with just two particles to watch this in action.)

THINGS TO TRY
-------------
Compare this model to the other inverse square model, 'Gravitation'. Look at the paths made by the two different groups of particles. What do you notice about each group? How would you explain the types of paths made by each model?

The force acting upon each turtle is multiplied by a constant, 'g' (a global variable). In classical Newtonian Mechanics, 'g' is the universal gravitational constant, used in the equation for determining the force of gravitational attraction between any two bodies:

|     f = ((g * (mass1 * mass2)) / (distance^2))

In real life, 'g' is difficult to calculate, but is approximately 6.67e-11 (or 0.0000000000667). However, in our model, the use of 'g' keeps the forces from growing too high, so that you might better view the simulation. Feel free to play with the value of 'g' to see how changes to the gravitational constant affect the behavior of the system as a whole. 'g' is defined in the 'setup' procedure.


EXTENDING THE MODEL
-------------------
Each time-step, every turtle sums over all other turtles to determine the net acting force upon it. Thus, if we have n turtles, each one doing n operations each step, we're approximately taking what is called 'n-squared time'.  By this, we mean that the time it takes to run the model is proportional to how many particles we're using. 'n-time', also called linear time, means that the speed of the model is directly proportional to how many turtles are present for each turtle added, there is a corresponding slow-down.  But 'n-squared time' (also quadratic time or polynomial time) is worse - each turtle slows the model down much more.  The speed of the model, compared to linear time, is as the total number of turtles, squared. (So a linear time model with 100 turtles would theoretically be as fast as a quadratic time model with just 10 turtles!)

For small values of n (very few turtles), speed isn't a problem. However, we can see that the speed of the model decreases quadratically (as n-squared) as the number of turtles (n itself) increases. How could you speed this up?  (It may help you that the center of mass of the system is already being computed each new time-step.)

As the particles all can have different initial positions, masses, and velocities, it makes sense to think of the model as representational of a planetary system, with suns, moons, planets, and other astronomical bodies. Establish different breeds for these different classes- you could give each kind a separate shape and range of masses. See if you could create a model of a solar system similar to ours, or try to create a binary system (a system that orbits about two close stars instead of one).

NETLOGO FEATURES
----------------
This model creates the illusion of a plane of infinite size, to better model the behavior of the particles. Notice that with path marking you can see most of the ellipse a particle draws, even though the particle periodically shoots out of bounds. This is done through a combination of the basic turtle primitives 'hide-turtle' and 'show-turtle', keeping every turtle's xcor and ycor as special turtle variables 'xc' and 'yc', and calculations similar to the 'distance' function that uses 'xc' and 'yc' instead of 'xcor' and 'ycor'.

When you examine the procedure window, take note that the standard turtle primitives 'set heading', 'fd 1', etc... aren't used here. Everything is done directly to the x-coordinates and y-coordinates of the turtles.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo N-Bodies model.  http://ccl.northwestern.edu/netlogo/models/N-Bodies.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/N-Bodies for terms of use.
"
Random Balls,/models/Sample Models/Chemistry & Physics/Mechanics,"breed [ balls ball ]
breed [ centers-of-mass center-of-mass ]

to setup
  ca
  setup-border
  setup-balls
  setup-center
end

to setup-border
  ask patches
    [if (pxcor < 10 + min-pxcor)
       [set pcolor blue]
     if (pxcor > max-pxcor - 10)
       [set pcolor blue]
     if (pycor > max-pycor - 10)
       [set pcolor blue]
     if (pycor < 10 + min-pycor)
       [set pcolor blue]
    ]
end

to setup-balls            ;;creates and distributes the green turtles
  set-default-shape turtles ""circle""
  create-balls number
    [ set color green
      setxy (random-float (2 * (max-pxcor - 11) ) - (max-pxcor - 11))
            (random-float (2 * (max-pycor - 11) ) - (max-pycor - 11)) ]
end

to setup-center
  create-centers-of-mass 1
    [ set size 2
      move-center
      pd ]
end

to go
  ask balls [ bounce ]
  ask centers-of-mass [ move-center ]
  ifelse trace-center?
    [ ask centers-of-mass [ pd ] ]
    [ if [pen-mode] of one-of centers-of-mass != ""up"" [
        ask one-of centers-of-mass [ pu ]
        clear-drawing ]
    ]
  tick
end

to move-center  ;; center-of-mass procedure
  ;; we want a white ball that leaves a red trace, so we need
  ;; to temporarily turn the ball red when we move it
  set color red
  setxy (sum [xcor] of balls) / (count balls)
        (sum [ycor] of balls) / (count balls)
  set color white
end

to bounce            ;; balls procedure, balls bounce off the border
  if ( (round xcor) < (11 + min-pxcor))
    [set heading (- heading)]
  if ( (round xcor) > (max-pxcor - 11))
    [set heading (- heading)]
  if ( (round ycor) < (11 + min-pycor))
    [set heading (180 - heading)]
  if ( (round ycor) > (max-pycor - 11))
    [set heading (180 - heading)]
  fd 1
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Random Balls model.
; http://ccl.northwestern.edu/netlogo/models/RandomBalls.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/RandomBalls
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
Random Balls simulates a frictionless billiard table.  The balls are drawn in green. They move in straight lines and bounce off the walls but not off of each other.  The center of mass is drawn in white.  A continuous trace is optionally made of it in red.


HOW TO USE IT
-------------
Select the number of balls to be used, then push SETUP.  Push GO to run the model.


THINGS TO NOTICE
----------------
Watch how the center of mass moves for a while.  Is there a pattern?  Is there a region in the box that it stays within?


THINGS TO TRY
--------------
Run the model with a lot of turtles, then just a few.  What happens to the motion of the center of mass?  Why?

Let the model run for a while.  What do you notice about how much time the center of mass spends at different distances from the origin (its frequency distribution)?

Push SETUP, then in the command center, type ""ask balls [set heading 60]"" and press ENTER.  This points all of the turtles in the same direction.  What does the center of mass do now?  Try other headings.


EXTENDING THE MODEL
-------------------
Presently the balls don't bounce off each other.  If they did, would it make a difference in the behavior of the center of mass?  Try it.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Random Balls model.  http://ccl.northwestern.edu/netlogo/models/RandomBalls.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/RandomBalls for terms of use.
"
Rope,/models/Sample Models/Chemistry & Physics/Waves,"turtles-own [
  yvel           ;; velocity along the y axis
  ypos           ;; y position (separate from ycor since we might exceed the boundaries of
                 ;;   the world, which ycor can never do)
]

to setup
  clear-all
  set-default-shape turtles ""circle""
  create-turtles world-width [
    set xcor who
    set color red
    set size 1.5                    ;; easier to see
    if pxcor = max-pxcor
      [ set color blue ]            ;; rightmost turtle is blue
    if pxcor = min-pxcor
      [ set color green ]           ;; leftmost turtle is green
  ]
end

to go
  ask turtles with [color = green]  ;; the green turtle is the driving force
  [
    ifelse ticks > 100  ;; ramp the force up gradually to avoid spikes in the wave
       [ set ypos amplitude * sin (frequency * ticks) ]
       [ set ypos (ticks / 100) * amplitude * sin (frequency * ticks) ]
    ifelse patch-at 0 (ypos - ycor) != nobody ;; hide turtles outside the visible world
    [
      set ycor ypos
      st
    ]
    [ ht ]
  ]
  ask turtles with [color = red]  ;;the red turtles respond to their neighbors' positions
  [ ;; make your new y velocity equal to your old one + the average pos of your two neighbors
    set yvel yvel + ((([ypos] of (turtle (who - 1))) - ypos) +
                     (([ypos] of (turtle (who + 1))) - ypos))
    set yvel ((1000 - friction) / 1000) * yvel  ;; apply friction
  ]
  ;; we need two separate ask blocks here so all the turtles calculate their
  ;; new velocities before any turtles move
  ask turtles with [color = red]
  [ ;; calculate new y position
    set ypos ypos + yvel                    ;; calculate new y position
    ifelse patch-at 0 (ypos - ycor) != nobody ;; hide turtles outside the visible world
      [ set ycor ypos
        show-turtle ]
      [ hide-turtle ]
  ]
  tick
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1997 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1997).  NetLogo Rope model.
; http://ccl.northwestern.edu/netlogo/models/Rope.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1997 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Rope
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This project simulates a wave moving along a rope.  The right end of the rope (shown in blue) is fixed to a wall.  The left end of the rope (shown in green) provides an input, moving up and down in a sinusoidal motion.  This creates a wave that travels along the rope.


HOW IT WORKS
------------
The rope is made up of a line of turtles.  The turtle are fixed horizontally, but can move up and down.  Each turtle acts as it were connected to its two neighboring turtles with springs.  When a neighboring turtle is farther away, it exerts a stronger force.

When the left end of the rope (the green turtle) moves up, it ""pulls up"" the turtle to its right, which in turn pulls up the turtle to its right, and so on. In that way, a wave moves down the rope. When the wave reaches the right end of the rope (the blue turtle), the wave is reflected back to the left.


HOW TO USE IT
-------------
Click the SETUP button to set up the rope.  Click GO to make the left end of the rope (the green turtle) begin moving up and down.

The FRICTION slider controls the amount of friction in the rope.  The FREQUENCY slider controls the speed with with the left end of the rope moves up and down.  The AMPLITUDE slider controls the maximum height of the left end of the rope.


THINGS TO NOTICE
----------------
There's a connection between the frequency with which the left end of the rope goes up and down and the number of peaks that emerge.


THINGS TO TRY
------------
Change the values on the sliders and observe what happens to the waves on the rope.

Try to create a ""standing wave"", in which some points on the rope do not move at all.

Change the blue turtle to green, so that there are two driving forces. Then change one of the red turtles in the middle of the rope to blue, so that there is a fixed point in the middle. What happens to the waves?


EXTENDING THE MODEL
-------------------
Change the right end of the rope so that it moves freely, rather than being fixed. How does that change the behavior of waves in the rope?


NETLOGO FEATURES
-----------------
For this project, it does not make sense for the turtles to ""wrap"" when they get to the top or bottom of the world.  So the real y-position of the turtles is kept in a new variable (YPOS), and the turtle is hidden if YCOR, its true position it beyond the boundaries of the world.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1997).  NetLogo Rope model.  http://ccl.northwestern.edu/netlogo/models/Rope.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1997 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Rope for terms of use.
"
Wave Machine,/models/Sample Models/Chemistry & Physics/Waves,"globals [
  membrane-edge-x  ;; horizontal distance from center to edge of membrane
  membrane-edge-y  ;; vertical distance from center to edge of membrane
]

turtles-own [
  edge?            ;; are we on the edge of the membrane?
  driver?          ;; are we part of the green driving plate?
  x                ;; position on x axis in space
  y                ;; position on y axis in space
  z                ;; position on z axis in space
  velocity         ;; velocity along z axis
  neighbor-turtles ;; agentset of turtles adjacent to us
]

to setup
  clear-all
  set membrane-edge-x floor (max-pxcor / 2)
  set membrane-edge-y floor (max-pycor / 2)
  set-default-shape turtles ""circle""
  ask patches with [(abs pxcor <= membrane-edge-x) and
                    (abs pycor <= membrane-edge-y)]
    [ sprout 1
        [ set edge? (abs xcor = membrane-edge-x) or
                    (abs ycor = membrane-edge-y)
          if edge? [ set color blue ]
          set driver? (abs (xcor - driver-x) <= driver-size) and
                      (abs (ycor - driver-y) <= driver-size)
          if driver? [ set color green ]
          set x xcor
          set y ycor
          set z 0
          set velocity 0
          recolor ] ]
  ask turtles
    [ set neighbor-turtles turtles-on neighbors4 ]
  project
end

to recolor  ;; turtle procedure
  if not edge? and not driver?
    [ set color scale-color red z -20 20 ]
end

to go
  ask turtles with [not driver? and not edge?]
    [ propagate ]
  ask turtles
    [ ifelse driver?
        [ set z (driver-amplitude * (sin (0.1 * driver-frequency * ticks))) ]
        [ set z (z + velocity)
          recolor ] ]
  project
  tick
end

to propagate   ;; turtle procedure -- propagates the wave from neighboring turtles
  set velocity (velocity +
                 (stiffness * 0.01 *
                   (sum [z] of neighbor-turtles
                    - 4 * z)))
  set velocity (((1000 - friction) / 1000) * velocity)
end

;;; procedures for displaying in 2-D or 3-D

to project
  ifelse three-d?
    [ project-3d ]
    [ project-2d ]
end

to project-3d
  ask turtles [
    let xc (x + (cos view-angle) * y)
    let yc (z + (sin view-angle) * y)
    ifelse patch-at (xc - xcor) (yc - ycor) != nobody
    [ setxy  xc yc
      show-turtle ]
    [ hide-turtle ]
    recolor
  ]
end

to project-2d
  ;; Set our viewable x and y coordinates to be the same as our real
  ;; coordinates.  This is only needed for if the user turns THREE-D?
  ;; off while the model is running.
  ask turtles
    [ setxy x y
      recolor
      show-turtle ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1996 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1996).  NetLogo Wave Machine model.
; http://ccl.northwestern.edu/netlogo/models/WaveMachine.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1996 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/WaveMachine
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model simulates wave motion in a membrane. The four edges of the membrane are fixed to a frame. A green rectangular area represents a driver plate that moves up and down, exhibiting sinusoidal motion.


HOW TO USE IT
-------------
Controls of membrane properties:

The FRICTION slider controls the amount of friction or attenuation in the membrane. The STIFFNESS slider controls the force exerted on a turtle by a unit deflection difference between the turtle and its four neighbors.

Controls of the driving force:

The DRIVER-FREQUENCY slider controls the frequency at which the green area of the membrane (the driving force) moves up and down. The DRIVER-AMPLITUDE slider controls the maximum height of the green area of the membrane.

The DRIVER-X and DRIVER-Y sliders control the position of the driver. The DRIVER-SIZE slider controls the size of the driver.

Controls for viewing:

The THREE-D? switch controls the view point of the projection.  OFF is for the top view (2-D looking down), and ON gives an isometric view, at an angle chosen with the VIEW-ANGLE slider.


THINGS TO TRY
-------------
Click the SETUP button to set up the membrane. Click GO to make the selected area of the membrane (the green turtles) begin moving up and down.


THINGS TO NOTICE
----------------
The membrane is made up of lines of turtles. Each turtle acts as it were connected to its four neighboring turtles by springs. In this model, turtles move only up and down -- the force's direction IS only up and down. The greater the distance between a turtle and its neighbors, the stronger the force.

When the green turtles move up, they ""pull up"" the turtles which are their neighbors, which in turn pull up the turtles which are their neighbors, and so on. In that way, a wave moves along the membrane. When the wave reaches the edges of the membrane (the blue turtles), the wave is reflected back to the center of the membrane.

The amplitude of the green turtles is fixed regardless of the stiffness of the membrane. However, moving a stiff membrane requires a lot more force to move it the same amount as an unstiff membrane. So even as the stiffness of the membrane is increased, the wave height will remain the same because the amplitude is kept the same.


THINGS TO TRY
-------------
Try different membranes. Soft membranes have smaller stiffness values and hard membranes have larger stiffness values.

Try different driving forces, or try changing the frequency or amplitude. It is very interesting to change the size and the position of the driving force to see symmetrical and asymmetrical wave motions.

Try to create a ""standing wave,"" in which some points in the membrane do not move at all.


EXTENDING THE MODEL
-------------------
In this model, the movement of the turtles is only in the vertical direction, perpendicular to the membrane. Modify the model such that the movement is within the membrane plane, i.e. the x-y plane.

You can also try to add additional driving forces to make a multi-input membrane model. Another thing you can try is to apply different waveforms to the driving-force to see how the membrane reacts to different inputs. Try changing the overall shape of the driving force.

Try to build a solid model, that is, a model of waveforms within all three dimensions.

Instead of using amplitude to create the wave, change it to apply a fixed amount of force continuously.


NETLOGO FEATURES
----------------
Note the use of the TURTLES-ON reporter to find turtles on neighboring patches.

A key step in developing this model was to create an internal coordinate system. X, Y, and Z are just three turtles-own variables. You can imagine that turtles are situated in and move around in 3-space.  But to display the turtles in the view, which is two-dimensional, the turtle's three coordinates must be mapped into two.

In the 2-D view, the turtle's x and y coordinates are translated directly to NetLogo coordinates, and the z coordinate is indicated only by varying the color of the turtle using the SCALE-COLOR primitive.

In the 3-D view, an isometric projection is used to translate x, y, and z (the turtle's real position) to xcor and ycor (its position in the view).  In this projection, a  point in the world may correspond to more than one point in the 3-dimensional coordinate system.  Thus in this projection we still vary the color of the turtle according to its z position, to help the eye discriminate.

In the 3-D version, it does not make sense for the turtles to ""wrap"" if they reach the top or bottom of the world nor does it make sense for them to remain at the top of the world, so turtles are hidden if their computed ycor exceeds the boundaries of the world.


CREDITS AND REFERENCES
----------------------
Thanks to Weiguo Yang for his help with this model.

To refer to this model in academic publications, please use:  Wilensky, U. (1996).  NetLogo Wave Machine model.  http://ccl.northwestern.edu/netlogo/models/WaveMachine.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1996 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/WaveMachine for terms of use.
"
Raindrops,/models/Sample Models/Chemistry & Physics/Waves/Unverified,"turtles-own [xpos ypos zpos delta-z neighbor-turtles]
globals [drop-width k]

to setup
  clear-all
  set-default-shape turtles ""circle""
  crt (max-pxcor * max-pycor) [
    set ypos (floor (who / max-pxcor))    ;Line up the turtles according to their ID
    set xpos (who - (max-pxcor * ypos))
    set xpos (xpos - (.5 * max-pxcor))    ;Center the resulting box
    set ypos (ypos - (.5 * max-pycor))
    set xcor xpos
    set ycor ypos
    set color blue
    set zpos 0
    set delta-z 0
  ]
  ask turtles [
    set neighbor-turtles turtles-on neighbors4
  ]
  set drop-width 2
end

to go    ;Listen for mouse clicks that indicating drops, while propagating waves
  if (mouse-down?)
    [ask turtles [release-drop mouse-xcor mouse-ycor]]
  ask turtles [compute-delta-z]
  ask turtles [update-position-and-color]
  tick
end

to release-drop    [drop-xpos drop-ypos]    ;Turtle procedure for releasing a drop onto the pond
  if (((xpos - drop-xpos) ^ 2) + ((ypos - drop-ypos) ^ 2) <= ((.5 * drop-width) ^ 2))
      [set delta-z (delta-z + (k * ((sum [zpos] of neighbor-turtles) -
                    ((count neighbor-turtles) * zpos) - impact)))]
end

to compute-delta-z    ;Turtle procedure
  set k (1 - (.01 * surface-tension))        ;k determines the degree to which neighbor-turtles'
  set delta-z (delta-z + (k * ((sum [zpos] of neighbor-turtles) - ((count neighbor-turtles) * zpos))))
end

to update-position-and-color  ;Turtle procedure
  set zpos ((zpos + delta-z) * (.01 * friction))    ;Steal energy by pulling the turtle closer
  set color scale-color blue zpos -40 40            ;to ground level
  ifelse three-D?
   [
     let y (zpos + (ypos * sin angle))
     let x (xpos + (ypos * cos angle))
     ifelse patch-at (x - xcor) (y - ycor) != nobody
      [ setxy x y st ]
      [ ht ]]
   [
     ifelse patch-at (xpos - xcor) (ypos - ycor) != nobody
      [ setxy xpos ypos
      st ]
      [ ht ]]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Raindrops model.
; http://ccl.northwestern.edu/netlogo/models/Raindrops.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Raindrops
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model simulates raindrops falling on the surface of a pond and the waves they produce.


HOW TO USE IT
-------------
SETUP initializes the model.  GO continuously propagates waves in the water while listening for drops caused by the user.  To release a drop, hold your mouse button down briefly on any point within the pond (the blue region).  That point is where the drop will land.

The FRICTION slider controls the amount of force that pulls the water particles back towards ground level, dampening waves.  SURFACE-TENSION controls how much effect the neighbors of a water particle exert on it vertically.  The greater the surface tension, the slower waves travel through the water.  This is implemented in the model as a weight coefficient on the difference in height between a turtle and its neighbors.  The resulting weighted value is added to the turtles current vertical velocity (represented by the incremental value dz) and its current position to determine its next position.  To translate the earlier statement, then, the greater the surface tension, the more a particle's neighbors can pull it towards them, thus quickening the pace of a wave through the surface.

The IMPACT slider determines how much force a drop carries.  Drops with greater impact cause larger waves.

The THREE-D switch allows you to view the pond either from above or from an angle set by ANGLE.


THINGS TO NOTICE
----------------
The pond is made up of a grid of turtles, each of whom, like in Wave Machine, behaves like it is connected to its neighbors by springs.  Each turtle has a vertical position and velocity, which determine how high above the sides of the pond it is or how far below, and how much that distance will change at the next time step.

When drops are released they decrease the vertical velocity of the particles under them, causing them to move downwards.  As they fall, they pull down their neighbors, who at the same time pull them up. This exchange creates a wave within the pond, centered on where the drop fell.

As the waves hit the walls, they are reflected back towards the middle, as the walls don't move up or down.  Friction causes the waves to eventually decline by pulling them closer to the surface level.


THINGS TO TRY
-------------
Try creating multiple drops in the pool to see how they interact.  Do they cancel each other out or reinforce each other?

Change the surface tension to see how it affects the speed of waves.  Why does water with low surface tension move so slowly?  What sort of liquids in real life is it similar to?

Set friction to 100 and release some drops.  Do the waves ever dissipate?  How can the waves rise above the sides of the pond (have positive zpos's) when only downward moving forces are exerted on them?  How is a turtle's movement similar to that of a spring.  Is the friction used in this model analogous to that in a spring?


EXTENDING THE MODEL
-------------------
This model doesn't take into account water pressure.  When part of the water is pushed down on the impact of a drop, the rest of the water should feel a push from beneath.  Try adding in this mechanism.

The walls in this model don't affect waves at all.  Extend the model so that the walls impose friction on waves that brush against them, causing them to dampen.


NETLOGO FEATURES
------------------
In order to create the visual impression of a wave, it is necessary for water above the sides of the pond (above water level) to appear more white, while water below to appear more blue.  This was accomplished using the ""scale-color"" primitive, which takes a color to assign, a variable, and a minimum and maximum value.  It works by comparing the value of the variable for each turtle to the two values, and the closer it is to the maximum, the lighter the shade of the color assigned to that turtle.

Water particles that fly off the top or bottom of the world are ignored in the model, which is done by using the commands hide-turtle (ht) and show-turtles (st).  Hide turtle doesn't cause the turtle to die or change in any way, but merely stops it from being drawn.  Show turtle causes it to begin being displayed again.

The model listens for raindrops using NetLogo's mouse primitives.  GO repeatedly calls mouse-down? to register when the user has clicked over the pond.  When this condition reports true, it uses two reporters, mouse-xcor and mouse-ycor, to record the current coordinates of the mouse so that a drop can be released in the appropriate place.


RELATED MODELS
--------------
For another model that demonstrates how turtles behave as a surface, see Wave Machine.  In it, turtles are connected in the same manner as outlined above, but their movement is governed by the regular sinusoidal motion of part of the surface.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Raindrops model.  http://ccl.northwestern.edu/netlogo/models/Raindrops.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Raindrops for terms of use.
"
Doppler,/models/Sample Models/Chemistry & Physics/Waves/Unverified,"breed [ planes plane ]
breed [ listeners listener ]
breed [ wave-components wave-component ]

wave-components-own [
  amplitude
  wave-id ;; the wave-id identifies which wave this
          ;; component is a part of
]

listeners-own [
  wave-ids-heard ;; which wave-ids the listener just heard
                 ;; computed to avoid double-counting
]

globals [
  speed-of-sound  ;; constant
  next-wave-id ;; counters
  wave-interval ;; how many ticks between each wave?
  initial-wave-amplitude
]

to setup
  ca
  set-default-shape wave-components ""wave particle""
  set-default-shape planes ""airplane""
  set-default-shape listeners ""person""

  set speed-of-sound 757
  set initial-wave-amplitude 20
  set wave-interval 3

  ;; initialize counters
  set next-wave-id 0

  ;; create the airplane
  create-planes 1 [
    set heading 90
    set ycor 3 + min-pycor
    set xcor 14 + min-pxcor
    set size 4
    set color white
  ]

  ;; create the listener
  create-listeners 1 [
    set size 3
    set color blue
  ]
end

to go
  ask planes [ fd 1 * plane-speed / speed-of-sound ]      ;; move the plane
  if ticks mod wave-interval = 0 [ ask planes [ emit-wave ] ] ;; emit the sound wave

  ;; move waves
  ask wave-components [
    if not can-move? 1 [ die ]
    fd 1
    set amplitude amplitude - 1
    set color scale-color yellow amplitude 0 initial-wave-amplitude
    if amplitude < 1 [ die ]
  ]

  ;; listen and plot
  ask listeners [
    let amp amplitude-here wave-ids-heard
    plotxy ticks amp
    plotxy (ticks + 0.5) 0
    set wave-ids-heard
      remove-duplicates
        [ wave-id ] of wave-components-here
  ]

  ;; draw
  ifelse show-amplitudes? [
    ;; hide the wave and show total amplitude on each patch
    ask wave-components [ ht ]
    ask patches with [ pcolor != gray ] [
      let amp amplitude-here []
      ifelse amp > 0
        [ set plabel amp ]
        [ set plabel """" ]
      set pcolor scale-color green amp 0 60
      set plabel-color black
    ]
  ] [
    ;; show the wave and paint patches black
    ask wave-components [ st ]
     ask patches with [ pcolor != gray ] [
       set pcolor black
       set plabel """"
    ]
  ]
  tick
end


;; patch procedure
;; counts the total amplitude of the waves on this patch,
;; making sure not to count two components of the same wave.
to-report amplitude-here [ids-to-exclude]
  let total-amplitude 0
  let components wave-components-here
  if count components > 0 [
    ;; get list of the wave-ids with components on this patch
    let wave-ids-here remove-duplicates [ wave-id ] of components
    foreach ids-to-exclude [ set wave-ids-here remove ? wave-ids-here ]

    ;; for each wave id, sum the maximum amplitude here
    foreach wave-ids-here [ set total-amplitude total-amplitude +
        [amplitude] of max-one-of components with [ wave-id = ? ]
          [ amplitude ]
    ]
  ]
  report total-amplitude
end

;; plane procedure
to emit-wave
  let j 0
  let num-wave-components 90 ;; number of components in each wave
  hatch-wave-components 360 [
    set color yellow
    set size 1
    set j j + 1
    set amplitude initial-wave-amplitude
    set wave-id next-wave-id
    set heading j * ( 360.0 / num-wave-components )
    if show-amplitudes? [ ht ]
  ]
  set next-wave-id next-wave-id + 1
end

;; reports the plane speed in Mach, or
;; number of times the speed of sound
to-report mach
  report plane-speed / speed-of-sound
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1997 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2004.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1997).  NetLogo Doppler model.
; http://ccl.northwestern.edu/netlogo/models/Doppler.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1997 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Doppler
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model demonstrates the Doppler effect, the apparent change in the frequency of a wave emitted by a source moving relative to an observer.

When the source of a wave moves towards you, the perceived frequency of the wave increases; when the source moves away from you, the perceived frequency decreases. This phenomena can be observed when a car passes you while the driver honks his horn. The pitch of the sound you hear is higher as the car approaches you and lower when the car is moving away.

In this model, a plane flies above an observer. Yellow circles represent the peaks of sound waves emitted by the plane.


HOW TO USE IT
--------------
Press the SETUP button to create a plane and a person. Press GO to start the plane moving. Adjust the PLANE-SPEED slider to control the speed of the plane. The SHOW-AMPLITUDES? switch lets you see the strength of the sound wave on each patch of air.


THINGS TO NOTICE
----------------
Set the speed to zero. When the plane is not moving, the wavelength (the distance between the peaks of each wave) is the same on both sides of the plane. As you increase the speed of the plane, the waves bunch together in front of the plane and spread apart behind the plane. So when the plane is moving towards the person, the wavelength is shorter, so the perceived frequency of the sound is higher. When the plane is moving away from the person, the wavelength is longer, so the perceived frequency of the sound is lower.

When the plane is travelling at the speed of sound (Mach 1, approximately 757mph), notice how all the sound waves overlap at one point. At this point of intersection, the constructive interference of the wave peaks creates a loud bang called a SONIC BOOM.

THINGS TO TRY
-------------

Set the plane speed to the speed of sound, 757 miles per hour (Mach 1). Notice that the peaks of the sound waves in front of the plane bunch up completely. Look at the SIGNAL plot when the plane passes the person at the speed of sound? When happens to the perceived amplitude of the sound heard by the person? This phenomena results from a shock wave -- the constructive interference of a large number of wave peaks -- and creates a very loud sound called a sonic boom.

Turn on the SHOW-AMPLITUDES? switch and adjust the plane speed to watch the constructive interference in action as the plane speed approaches Mach 1.

Increase the plane speed beyond the speed of sound. What happens to the shape of the shock wave? What does the person hear?


EXTENDING THE MODEL
--------------------
Add a second plot that displays the relative frequency heard by the person. Improve the first plot to interpolate the signal data and display the amplitude between signal peaks.

In this model, only the plane is in motion. Add controls to move the person as well.

Use the NetLogo extensions API to write a Java extension that plays a sound at a given amplitude and frequency. Have the person generate the sound he hears so you can listen to the Doppler effect in action.


NETLOGO FEATURES
----------------
This model is a vertical cylinder, the plane, moving in the x direction wraps around the world, but the sound waves exit the system when they reach the top or the bottom of the world.

The listener stands at the origin, which is off-center.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1997).  NetLogo Doppler model.  http://ccl.northwestern.edu/netlogo/models/Doppler.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1997 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Doppler for terms of use.
"
Speakers,/models/Sample Models/Chemistry & Physics/Waves/Unverified,"breed [ lefts a-left ]
breed [ rights a-right ]
breed [ sums a-sum ]

turtles-own [ yvel-old yvel-new ypos-old ypos-new time ]
globals [ listening-point ]

to setup
  ca
  set-default-shape turtles ""circle""
  ;; Create the turtles that represent the waves
  ;; We need three lines across the world, so it sets
  ;; their xcor based on their incrementing turtle id
  foreach sort patches with [pycor = 0]
    [ ask ? [ sprout-lefts 1 [ set color yellow ] ] ]
  foreach sort patches with [pycor = 0]
    [ ask ? [ sprout-rights 1 [ set color cyan ] ] ]
  foreach sort patches with [pycor = 0]
    [ ask ? [ sprout-sums 1 [ set color red ] ] ]

  ;; Initialize all variables to zero.  All of the turtles are stationary.
  set listening-point 0
  ask turtles
  [
    set yvel-old  0
    set ypos-old  0
    set time  0
  ]

  ;; The ends of the waves are special.  One side drives the wave, while
  ;; the other side anchors the waves- (prevents wrapping)
  ;; First define the driving turtles, which are colored green.
  ;; Next define the anchor turtles, which are colored blue
  ask lefts [
    if  ( xcor = max-pxcor )  [
      set color blue
    ]
    if ( xcor = min-pxcor ) [
      set color green
    ]
  ]
  ask rights [
    if  ( xcor = min-pxcor ) [
      set color blue
    ]
    if ( xcor = max-pxcor ) [
      set color green
    ]
  ]

  ;; draw the speakers, gray centered line, and listening point
  ask patches [
    if pycor = 0
      [ set pcolor gray ]
    draw-left-speaker
    draw-right-speaker
    if ( pxcor = listening-point and pycor > 0 and pycor < 4 )
      [ set pcolor white ]
  ]

  setup-plot
  if plot?
  [
    get-a-point
    plot-the-point
  ]
end


to go
  ;; Move all the wave turtles
  ask turtles [
    if  ( color = green )
      [ drive-force ]
    if  ( color = yellow or color = cyan )
      [ driven-force ]
    if  ( color = blue )
      [ update ]
    if  ( color = red )
      [ interfere ]
  ]

  tick

  ;; Update the plot
  if plot?
  [
    get-a-point
    plot-the-point
  ]

  ;; Reset the velocities
  ask turtles [
    set yvel-old yvel-new
    set ypos-old ypos-new
  ]

  ;; Check if a hide/show switch changed
  show-or-hide
end


to drive-force ;; procedure for green turtles
  set time time + 1
  ifelse (breed = lefts)
    [ set ypos-new amplitude-left * ( sin (frequency-left * 0.1 * time )) ]
    [ set ypos-new amplitude-right * ( sin (frequency-right * 0.1 * time )) ]
  set ypos-old ypos-new
  set ycor ypos-new
end

to driven-force ;; procedure for yellow and cyan turtles
  set yvel-new yvel-old + ( [ypos-old] of turtle ( who - 1 ) )
                      - ypos-old  +  ( [ypos-old] of turtle ( who + 1 ) ) - ypos-old
  set yvel-new ( ( 1000 - friction ) / 1000 ) * yvel-new
  set ypos-new ypos-old + yvel-new
  set ycor ypos-new
end

to update ;; procedure for blue turtles
  ifelse ( breed = lefts )
    [ set ypos-new [ypos-old] of turtle ( who - 1 ) ]
    [ set ypos-new [ypos-old] of turtle ( who + 1 ) ]
  set ycor ypos-new
end

to interfere ;; procedure for red turtles
  set ypos-new ( ( [ypos-new] of turtle ( who - world-width ) )
              + ( [ypos-new] of turtle ( who - ( 2 * world-width ) ) ) )
  ifelse patch-at 0 (ypos-new - ycor) != nobody and show-sum?
    [ set ycor ypos-new
      show-turtle ]
    [ hide-turtle ]
end

to setup-plot
  set-current-plot ""Speaker amplitude""
  clear-plot
  set-current-plot-pen ""left""
  set-plot-pen-color yellow
  set-current-plot-pen ""right""
  set-plot-pen-color cyan
  set-current-plot-pen ""sum""
  set-plot-pen-color red
  set-plot-y-range ( ( - amplitude-left ) - amplitude-right ) ( amplitude-left + amplitude-right )
  set-plot-x-range 0 250
  auto-plot-on
end

to plot-the-point
  if ((ticks mod 200) = 0)
    [
      ifelse (not show-only-recent-plot?)
        [ set-plot-x-range 0 (ticks + 200) ]
        [ set-plot-x-range max list 0 (ticks - 210) (ticks + 210)]
    ]

  set-current-plot-pen ""left""
  if show-left? and any? lefts with [ round xcor = listening-point ]
    [ plotxy ticks [ypos-new] of one-of lefts with [ round xcor = listening-point ] ]

  set-current-plot-pen ""right""
  if show-right? and any? rights with [ round xcor = listening-point ]
   [ plotxy ticks [ypos-new] of one-of rights with [ round xcor = listening-point ] ]

  set-current-plot-pen ""sum""
  if show-sum? and any? sums with [ round xcor = listening-point ]
      [ plotxy ticks [ypos-new] of one-of sums with [ round xcor = listening-point  ] ]
end

to get-a-point
  ;; Changes the listening-point if the mouse is down
  if mouse-down? [
    ask patches with [ pxcor = listening-point and pycor > 0 and pycor < 4 ]
      [ set pcolor black ]
    set listening-point round mouse-xcor
    ask patches with [ pxcor = listening-point and pycor > 0 and pycor < 4 ]
      [ set pcolor white ]
  ]
end

to draw-right-speaker ;; patch procedure
  if ( pxcor = max-pxcor ) and ( pycor > ( -0.1 * max-pxcor ) ) and ( pycor < ( 0.1 * max-pxcor ) )
  [
    set pcolor orange
  ]
  if ( pxcor = round ( 0.9 * max-pxcor ) ) and ( pycor > ( -0.2 * max-pxcor ) ) and ( pycor < ( 0.2 * max-pxcor ) )
  [
    set pcolor orange
  ]
end

to draw-left-speaker ;; patch procedure
  if ( pxcor = min-pxcor ) and ( pycor > ( -0.1 * max-pxcor ) ) and ( pycor < ( 0.1 * max-pxcor ) )
  [
    set pcolor orange
  ]
  if ( pxcor = round ( - ( 0.9 * max-pxcor ) ) ) and ( pycor > ( -0.2 * max-pxcor ) ) and ( pycor < ( 0.2 * max-pxcor ) )
  [
    set pcolor orange
  ]
end

to show-or-hide
    ;; The sums are hidden in the interference procedure because they may
    ;; move outside the world
    ifelse show-left?
      [
        if any? lefts with [ hidden? ]
          [ ask lefts [ st ] ]
      ]
      [
        if any? lefts with [ not hidden? ]
          [ ask lefts [ ht ] ]
      ]

     ifelse show-right?
      [
        if any? rights with [ hidden? ]
          [ ask rights [ st ] ]
      ]
      [
        if any? rights with [ not hidden? ]
          [ ask rights [ ht ] ]
      ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2002.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Speakers model.
; http://ccl.northwestern.edu/netlogo/models/Speakers.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Speakers
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model simulates sound wave interference. There is one speaker at each end. A sinusoidal signal generator powers each speaker. The yellow line represents the sound level due to the left speaker, the cyan line represents the sound level due to the right speaker, and the red line represents the sum of the sound levels due to both speakers.


HOW IT WORKS
-------------
Sound effect is due to pressure change spatially and temporally. The waveforms are made up of three lines of turtles. Each turtle acts as it were connected to its neighboring turtles with springs. When neighboring turtles are further away, they exert a stronger force.

When the left end of the sound level goes up, it ""pulls up"" the turtle to its right, which in turn pulls up the turtle to its right, and so on. In that way, a sound wave moves through the air.

The green turtles (speakers) continue to put more energy into the air. When there is no friction in the air, the waves in the air travel without losing amplitude.


HOW TO USE IT
-------------
Click the SETUP button to set up the system. Then, click GO to turn on the speakers.

The FRICTION slider controls the amount of sound damping in the air. The FREQUENCY slider controls the frequency of the signal generator. The AMPLITUDE slider controls the sound level of the speakers.

There are three buttons to hide each curve and three buttons to show each curve, so that the curves can be observed individually or collectively.

Set the PLOT? switch to on and click anywhere on the horizontal line in the View and you will be able to observe the sound level vs. time at the position you selected. The LISTENING-POINT monitor shows the x coordinate of the point.  A white vertical line in the View also shows it.  Click on the line to move the LISTENING-POINT to different position. The SPEAKER AMPLITUDE plot will plot the sound levels at this listening point.

Set the SHOW-ONLY-RECENT-PLOT? switch to on when you want to see only how the wave has looked in the recent past. With the toggle off, you can see the waves over the whole running time of the model.


THINGS TO NOTICE
----------------

How does the pattern of the left speaker wave and the right speaker wave change when you change the FREQUENCY slider? The AMPLITUDE slider?

When two speakers are turned on, the sound level at a certain point at a certain time is the sum of the sound levels produced by the two speakers at that time.  Its pattern may be quite different from either of the speaker sound patterns.


THINGS TO TRY
------------
Change the values on the sliders and observe what happens to the sum of the sound levels -- the red curve.

Try adding friction to see what it does to the waves.

Move the listening-point -- what do you observe in the plot window?

Try to create a ""standing wave,"" in which some points on the lines do not move at all, and plot one of the points to see if the sum there is zero.

Try to create a flat red curve.

Compare the relationship between frequency and wavelength.

Find a way to measure the speed of the wave such that the relationship, speed = frequency * wavelength, is true.


EXTENDING THE MODEL
-------------------
Program the red turtles to find the sum of the absolute values of the two waves.

Make it possible to ""fix"" the waves to zero at some point along the line -- as if this were a string and you put your finger on it.

Make the waves ""reflect"" from each end instead of going on.


NETLOGO FEATURES
-----------------
In order to have three independent waves, three lines of turtles are created -- yellow, then cyan, and then red -- in order from left to right.  Special turtles are created to control the ends of these waves.  One end generates the wave (green) and the other end prevents the wave motion from wrapping (dark blue).

For this project, it does not make sense for the turtles to ""wrap"" when they get to the top or bottom of the world. So the y-position of the turtles is kept in a new variable (YPOS-NEW), and the turtle is hidden if its y-position moves outside the boundary of the world.

During each iteration of GO, each turtle looks at its neighbors and calculates a new speed and position accordingly.  The order in which this is done is not obvious, since the turtles are running in parallel.  It's important that the order in which the turtles look at their neighbors doesn't matter.  Therefore temporary variables are created, ""ypos-old"", and ""yvel-old"".   Each turtle looks at its neighbors in previous state and updates its own temporary variables ""ypos-new"" and ""yvel-new"".   Then all the turtles update their states together.


A TRUE STORY
------------
A CCL member was asked by an undergraduate student to help her with some physics experiment problems:

The experiment was about wave propagation and interference.  In the experiment, two speakers are put on a straight track one meter apart and facing each other.  The speakers are connected to a 1500 Hz sinusoidal signal generator.  The student is asked to use a microphone to measure the sound level along the track between the two speakers and write down the positions where the microphone readings are a minimum.

The student is asked to explain the results and to determine if the minimum readings should be zero or not.

The results of the experiment show that the average distance between two minimum readings is about one half of the wavelength. The CCL member could not explain the results and determine if the readings should be zero or not.

The ROPE sample model helped him to answer the student. In the rope model, one end of the rope is fixed.  So the model setup is similar to the experiment setup except for the length and the frequency.  The CCL member and the student then worked together to modify the rope model and change the meaning of the y coordinate -- changing it from representing the absolute value of the deflection, because the microphone reading is the root mean square value of the sound level. When they ran the program, they got the experimental results and, more importantly, it became very clear to them why the minimum readings should be zero and the distance between any two minima is one half of the wavelength.

Isn't it amazing that such a simple program can be so helpful?

Try and repeat what the student and CCL member did and answer the physical experiment problems.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Speakers model.  http://ccl.northwestern.edu/netlogo/models/Speakers.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Speakers for terms of use.
"
Lattice Gas Automaton,/models/Sample Models/Chemistry & Physics/Waves,"globals [
  lattice   ;; only those patches where both pxcor and pycor are even
]

to setup
  clear-all
  set lattice patches with [pxcor mod 2 = 0 and pycor mod 2 = 0]
  if count lattice != count patches / 4
    [ user-message ""The world size must be even in both dimensions.""
      stop ]
  ask patches
    [ set pcolor white ]
  ask patches
    [ if random-float 100 < density
        [ set pcolor black ] ]
end

to go
  ask lattice [ do-rule  1 ]  ;; propagation
  ask lattice [ do-rule -1 ]  ;; collision
  tick
end

to go-reverse  ;; applying rules to the lattice in reverse order reverses the system
  ask lattice [ do-rule -1 ]  ;; collision
  ask lattice [ do-rule  1 ]  ;; propagation
  tick
end

;; grid = 1 if even lattice, grid = -1 if odd lattice
to do-rule [grid]
  let a self
  let b patch-at (- grid) 0
  let c patch-at 0 grid
  let d patch-at (- grid) grid

  ifelse ([pcolor] of a) != ([pcolor] of b) and
         ([pcolor] of c) != ([pcolor] of d)
    [ swap-pcolor a b
      swap-pcolor c d ]
    [ swap-pcolor a d
      swap-pcolor b c ]
end

to swap-pcolor [p1 p2]
  ask p1 [
    let temp pcolor
    set pcolor [pcolor] of p2
    ask p2 [ set pcolor temp ]
  ]
end

to draw-circle
  while [mouse-down?]
    [ ask patch mouse-xcor mouse-ycor
        [ ask patches in-radius radius
            [ set pcolor black ] ]
      display ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2002 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2002).  NetLogo Lattice Gas Automaton model.
; http://ccl.northwestern.edu/netlogo/models/LatticeGasAutomaton.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2002 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/LatticeGasAutomaton
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model demonstrates circular wave propagation using a cellular automaton on a square grid.  The behavior of the waves approximates the Navier-Stokes equation, a well established fluid dynamics equation discovered in 1823.

In the model, space is divided in to cells which are occupied by the gas particles.  Each particle has the same mass and absolute velocity (each particle will move only a single cell at each time step).  Space is broken up into neighborhoods of 2x2 cell squares.  Collisions occur when multiple particles are in the same square and occur instantaneously, conserving both mass and momentum.

The model is implemented using a Margolus neighborhood of 2x2 cell squares in which the particles belong to two separate spacetime sublattices, propagation and collision, (sometimes referred to as ""even"" and ""odd"" lattices), which evolve independently of each other.


HOW IT WORKS
------------
The CA can be summarized with the following core rules:

|    W W  ->  W W                B W  ->  W W            B W  ->  W B
|    W W      W W                W W      W B            W B      B W
|
|    B W  ->  W B                W B  ->  B B            B B  ->  B B
|    B W      W B                B B      B W            B B      B B

It applies these rules to the even lattice of 2x2 squares followed by the odd lattice of 2x2 squares.  Specifically, this means that the top left patch of four applies one of the above rules, then the bottom right patch of four does the same.  To run the model in reverse, we simply switch the order of those two operations.  No patch gets changed more then twice per tick.  That means that each patch sees only one possible even rule and one possible odd rule each iteration.


HOW TO USE IT
-------------
The basic controls for the model are:
SETUP - Sets up patches with a given percentage of particles
DENSITY - Percentage of particles in gas
GO - Run the model
REVERSE - Run the model in reverse

These controls let you ""paint"" an initial setup in the view using the mouse:
DRAW-CIRCLE - Clicking any location in the view creates a solid circle of particles
RADIUS - Controls the radius of the circles


THINGS TO NOTICE
----------------
Drawing a circle in the center of the world and clicking GO creates a circular wave that travels through the lattice.  Once the wave reaches the edges of the world, it wraps around the sides and causes the wave to collide with itself. You may stop the model by clicking GO again, and reverse the system by clicking REVERSE.  The wave will now implode and eventually return to its original starting state.

How does the density of the center of the wave vary over time? Why?

Why does the model appear to act the same when run forwards and backwards?


THINGS TO TRY
-------------
How does the density of the gas effect the propagation of the wave?  Try running the model with various DENSITY settings. Why do certain densities impede the propagation of waves?

What happens when you create multiple compressions in the gas and run the model?


EXTENDING THE MODEL
-------------------
Can you create obstacles that deflect the movement of particles?

This particular model is known as the HPP model.  The HPP model is very limited. The FHP (Frisch, Hasslacher and Pomeau) model was invented in the mid-eighties in order to improve the accuracy of the HPP model.  The underlying rules of the FHP model are similar to that of the HPP model except that the FHP model has a symmetry-group order of six.  The hexagonal lattice allows for more advanced modeling, such as hydrodynamical simulations.  Can you write a model that emulates a hexagonal lattice in NetLogo?


NETLOGO FEATURES
----------------
In order for the algorithm to operate correctly, the size of the lattice must be even in both dimensions.  That means there is no unique center patch.  Since there is no center patch, we chose to place the origin (0,0) patch in the lower left corner.  The model rules are not coordinate-based, though, so it doesn't really matter where the origin is.


CREDITS AND REFERENCES
-----------------------
Thanks to Ethan Bakshy for his work on this model.

For more information about lattice gas automata, see:

J. Hardy, Y. Pomeau & O. de Pazzis, Time evolution of two-dimensional model system. I. Invariant states and time correlation functions, J. Math. Phys. 14 (1973), pp. 1746-1759.

U. Frisch, B. Hasslacher & Y. Pomeau, Lattice-gas automata for the Navier-Stokes equation, Phys. Rev. Lett. 56 (1986), pp. 1505-1508.

T. Toffoli and N. Margolus. 1987. ""Cellular Automata Machines: A New Environment for Modeling"".

Wolfram, S. 2002. A New Kind of Science. Wolfram Media Inc.  Champaign, IL.

To refer to this model in academic publications, please use:  Wilensky, U. (2002).  NetLogo Lattice Gas Automaton model.  http://ccl.northwestern.edu/netlogo/models/LatticeGasAutomaton.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2002 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/LatticeGasAutomaton for terms of use.
"
Sand,/models/Sample Models/Chemistry & Physics,"globals [
  spout-patches    ;; set in setup so we don't have to keep recomputing it
  spout-ycor       ;; location of the spouts
  surface-ycor     ;; initial location of the surface of the sand at the bottom
]

patches-own [
  next-color       ;; patches first all decide what color to change to, then all change
]

to setup
  clear-all
  set surface-ycor -0.8 * max-pycor
  ask patches with [pycor < surface-ycor]
    [ set pcolor gray ]
  set spout-ycor round (max-pycor * 0.9)
  let spout-space round (max-pxcor * 0.6)
  ;; now set up the blue spouts at spout-space intervals
  set spout-patches patches with [(pxcor mod spout-space = 0) and
                                  (pycor = spout-ycor)]
  ask spout-patches
    [ set pcolor blue ]
end

to dump-sand
  ask patches with [(pycor < spout-ycor) and
                    (pycor > surface-ycor)]
    [ if random-float 100 < density
        [ set pcolor brown ] ]
end

to go
  spout
  move-all-sand
  tick
end

;; spouts sand particles depending on spacing (how often sand is released)
;; and the release-chance percent when the spacing interval is reached
to spout
  if ticks mod spacing = 0
    [ ask spout-patches with [random-float 100 <= release-chance]
        [ ask patch-at 0 -1 [ set pcolor brown ] ] ]
end

;; implements the four rules given in the info tab
;; to all the brown sand particles
to move-all-sand
  ask patches
    [ set next-color pcolor ]
  ask patches with [pcolor = brown]
    [ ifelse ([pcolor] of patch-at 0 -1 = black)
        [ move 0 ]
        [ ifelse ([pcolor] of patch-at -1 -1 = brown) and
                 ([pcolor] of patch-at  1 -1 = black)
           [ move 1 ]
           [ ifelse ([pcolor] of patch-at -1 -1 = black) and
                    ([pcolor] of patch-at  1 -1 = brown)
              [ move -1 ]
              [ if ([pcolor] of patch-at 1 -1 = black) and
                   ([pcolor] of patch-at -1 -1 = black)
                  [ move one-of [1 -1] ] ] ] ] ]
  ;; we do this in a separate ""ask"" so that all the patches decide
  ;; on their new colors before any of them actually change color
  ask patches
    [ set pcolor next-color ]
end

to move [x-offset];; patch procedure
  set next-color black
  ask patch-at x-offset -1 [ set next-color brown ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1996 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1996).  NetLogo Sand model.
; http://ccl.northwestern.edu/netlogo/models/Sand.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1996 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Sand
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This is a model of how sand particles interact with each other.  In this environment, all sand particles try to move down if any of the following four rules apply.  The four rules are:

1.) If there is nothing directly beneath you, move down.
2.) If there is something beneath you and to the lower right, move down and to the left.
3.) if there is something beneath you and to your lower left, move down and to the right.
4.) If there is only something directly beneath you, move down and either left or right at random.


HOW TO USE IT
-------------
GO: Starts and stops the simulation.

SETUP: Sets up the model.

RELEASE-CHANCE: Determines the percent chance that a particle of sand will fall from a spout each turn (default value of 100%).

SPACING: Determines how long a spout waits before releasing the next particle of sand.

DUMP SAND: Dumps sand on all of the model according to the density leve.  Use this only after you have pressed SETUP.

DENSITY: Sets the density of sand particles dumped in DUMP SAND (default value of 25%).  For example setting the density to 40 will, at random fill 40 percent of the patches with sand.


THINGS TO NOTICE
----------------
Observe how sand will roll down a ""mountain"" of sand particles.  Consider how this phenomenon is supported by the rules.  Notice the patterns that form when two ""mountains"" of sand grow into each other.


THINGS TO TRY
-------------
Observe how the spouts will form uniform pyramids of sand.  Try DUMP SAND at a low density once you have a relatively large pyramid shape.  How does this effect the shape of the pyramid?  Does the pyramid ever return to its original shape?

Try decreasing RELEASE-CHANCE.  What effect does this have on the growth rate of sand ""mountains""?

Set the SPACING to 1.  (You'll have to edit the slider, since the normal minimum is 2.)  What happens?  Is this just a limitation of the model rules, or does it have some plausible physical interpretation?


EXTENDING THE MODEL
-------------------
In the procedures tab, notice the variable spout-space.  Try changing the number of spouts at the top of the view by changing spout-space.

Does this model accurately reflect how sand behaves?  If not what rules could you devise to more accurately model sand's behavior?  How could they be incorporated into the model?

What effect does weight have on sand particles?  Should particles with lots of particles above them behave differently?  If so, how would this change the rules?

Try simulating erosion with this model.  How could you simulate wind?  What effect would this have on the shape of the piles?  How could you simulate rain?  What effect would this have on the shape of the piles?


NETLOGO FEATURES
------------------
Notice how the model stores an agentset in a variable, spout-patches.  It is initialized with the agentset of the patches where the spouts are located.  Subsequently this variable can be used in an ask command just like the default agentsets of ""turtles"" and ""patches.""  Since the agentset is computed once, ahead of time, the models runs faster than if the agentset were recomputed at every step.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1996).  NetLogo Sand model.  http://ccl.northwestern.edu/netlogo/models/Sand.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1996 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Sand for terms of use.
"
Scattering,/models/Sample Models/Chemistry & Physics/Unverified,"turtles-own
[
  force-x  ;; x-component of force vector
  force-y  ;; y-component of force vector
  vel-x    ;; x-component of velocity vector this time step
  vel-y    ;; y-component of velocity vector this time step
  dist     ;; the distance from the center

  ;; the following are needed to keep track of when the turtles go out of bounds:
  real-xcor
  real-ycor
]

globals
[
  scatter-angle
]

;;;
;;; setup procedures
;;;

to setup
  ca
  setup-target
  setup-particles
  setup-plots
  do-plots
end

to setup-target
  if show-target?
  [
    ask patches
    [
      if (distancexy 0 0 < radius)
        [ set pcolor yellow ]
    ]
  ]
end

to setup-particles
  crt number
  [
    colorize
    distribute
    set vel-x 0
    set vel-y velocity

    ;; turtle 0 is treated specially to help distinguish an individual's behavior
    if (who = 0)
      [ set xcor turtle-0-position ]
    set real-xcor xcor
    set real-ycor ycor
    set dist distancexy 0 0
  ]
end

to colorize ;; turtle procedure
  ifelse ( trace? )
    [ set color (who / (number - 1)) * 139 ]
    [ set color white ]
end

to distribute ;; turtle procedure
  let x ( (min-pxcor) + ( ( who - 1 ) / ( number - 2 ) ) * (world-width - 1) )

  if patch-at (x - xcor) 0 = nobody
  [
    ifelse xcor > x
    [ set x ( x + world-width ) ]
    [ set x ( x - world-width ) ]
  ]

  setxy x (min-pycor)
end

;;;
;;; main procedures
;;;

to go
  if not any? turtles
    [ stop ]
  ask turtles
    [ move-particle ] ;; if the turtles move out of the world, they die
  tick
  do-plots             ;; plots the speed and the distance from (0,0) of turtle 0
end

to move-particle  ;; turtle procedure
  calc-force
  update-velocity
  update-position
  if trace?
    [ set pcolor color ]
  if who = 0
    [ set pcolor color ]
end

;; force function:  1/(r*r+target-radius*target-radius)  repulsion
to calc-force ;; turtle procedure
  set force-x  ((cos (atan (- real-ycor) (- real-xcor))) * (charge / (dist * dist + radius * radius)))
  set force-y  ((sin (atan (- real-ycor) (- real-xcor))) * (charge / (dist * dist + radius * radius)))
end

to update-velocity ;; turtle procedure
  set vel-x (vel-x - force-x)
  set vel-y (vel-y - force-y)
end

to update-position ;; turtle procedure
  set real-xcor (real-xcor + vel-x)
  set real-ycor (real-ycor + vel-y)
  ifelse patch-at (real-xcor - xcor) (real-ycor - ycor) != nobody
    ;; if the turtle is in the visible world, update xcor, ycor, and dist
    [
      setxy real-xcor real-ycor
      set dist distancexy 0 0
      show-turtle
    ]
    ;; if the turtle has moved out of the world, die
    [ die ]
end

;;;
;;; plotting procedures
;;;

to setup-plots
  set-current-plot ""Speed""
  set-plot-y-range 0 velocity
  set-current-plot ""Distance""
  set-plot-y-range 0 max-pycor
end

;; plots the speed and the distance from (0,0) of turtle 0
to do-plots
  if turtle 0 != nobody ;; if turtle 0 hasn't died yet
  [
    set scatter-angle atan [vel-x] of turtle 0 [vel-y] of turtle 0
    set-current-plot ""Speed""
    set-current-plot-pen ""turtle 0""
    plot [sqrt (vel-x * vel-x + vel-y * vel-y)] of turtle 0
    set-current-plot ""Distance""
    set-current-plot-pen ""turtle 0""
    plot [dist] of turtle 0
  ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2002.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Scattering model.
; http://ccl.northwestern.edu/netlogo/models/Scattering.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Scattering
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This project models the scattering of particles from a target that repels them.  An example of this is the scattering of alpha particles (helium nuclei) from a heavy nucleus such as gold.  This experiment, first done by Rutherford, provided important evidence that the positive charge in an atom is concentrated in a small place.

In this model, the target is an immovable patch with a variable charge and a variable radius in the center of the world.  A parallel beam of particles is sent upward from the bottom of the world, and the path of each particle is traced.  Each particle is repelled from the target according to Coulomb's inverse square law, modified for a distributed nuclear charge.  The particles do not interact with each other.


HOW IT WORKS
------------
Each particle is given a position, a velocity, and a charge.  Every time tick, each particle calculates the force that is enacted on it by the repulsion of the central charge.  This equation is Coulomb's inverse square law.  After the force is determined, it will revise it current velocity according the equation F = M * A where M = 1.  After which, the particle's new position is found by adding its new velocity to its current position.


HOW TO USE IT
-------------
First select the number of particles with the NUMBER slider.  Set their initial velocity with the VELOCITY slider. Set the charge of the target with the CHARGE slider.  Set the radius of the target with the RADIUS slider.  Then press the SETUP button.

When the sliders have been set to a desired level and SETUP has been pressed, press the GO button to begin the simulation.

The TRACE? switch, if on, has each turtle mark out its position every time-tick.  In this way, you can see the arcs formed by different particles' travels.  When TRACE? is off, only one particle (turtle 0) marks out its position.

The TURTLE-0-POSITION slider sets the starting x-coordinate of turtle 0.  If TURTLE-0-POSITION is 0, the particle approaches the target head-on.  If it's positive, turtle 0 starts off to the right of center, and if it's negative, turtle 0 starts off to the left of center.

The SPEED of turtle 0 is displayed in a plot as well as its DISTANCE from the target.  The SCATTER-ANGLE monitor shows turtle 0's heading. (Zero is straight up, 90 is right, and so on.)

If set to on, the SHOW-TARGET? switch allows you to see the target.


THINGS TO NOTICE
----------------
Each setting gives a family of paths for particles of equivalent initial velocity but different starting positions.  What is the shape of each trajectory?  Is it the same shape approaching and leaving the target?  What is the shape of the family of curves?

Do any of the paths intersect?  Does it depend on the settings of the sliders?

If two particles start off close to each other, will they end up close to each other?

A very large nucleus represents J.J. Thompson's ""plum pudding"" model of the atom, in which the charge was thought to be spread out in a volume as large as the atom itself. A very small nucleus represents Rutherford's discovery, namely that the charge is concentrated in a very small nucleus, about 1/10000 the size of the atom.


THINGS TO TRY
-------------
You can study the trajectory of one particle by turning off TRACE?.  Change the TURTLE-0-POSITION slider to change the single particle's initial position.  This will allow you to study individual paths.  What happens to the particle's path when its velocity and the charge of the target are changed?  What needs to be true for particles to bounce almost straight backward?

The value of the SCATTER-ANGLE monitor, averaged over millions of particles, along with the particles' speed and the charge on the nucleus, is what an experimenter would actually be able to measure.  Devise an experiment that would give information about the size of the nucleus from this information alone.

If you knew the particle velocity and nuclear charge from other experiments, could you devise an experiment, using this model that would determine the size of the target?


EXTENDING THE MODEL
-------------------
Put in a different function for the force between the nucleus and the particles -- 1/r dependence, r dependence, or attraction instead of repulsion.  This can be done in the function ""calc-force"".  A repulsive force will ""scatter"" the particles, but an attractive force will put some of them into orbits.

Let the particles begin with a constant velocity, or give them all a random velocity.  Or try giving each particle a variable charge, which directly affects the strength of the acting force upon it.

Try having a lattice of targets, and vary the targets' spacing.


NETLOGO FEATURES
----------------
Notice that the procedure 'move-particle' is all turtle commands.

When you examine the procedures tab, note that the standard turtle primitives such as 'fd 1', etc... aren't used here.  Everything is done directly to the x-coordinates and y-coordinates of the turtles.


RELATED MODELS
--------------
Gravitation also calculates an inverse-square force between particles and changes their motion accordingly.  In Gravitation, each particle looks at every other particle, whereas in Scattering, each particle interacts only with the target.


CREDITS AND REFERENCES
----------------------
Martin Rocek made important modifications to this model. He writes, ""the main point of my modifications was introducing rcore (radius); it has the effect of smoothing out the target, that is, making something more like the old 'plum-pudding' model of the atom that held sway before Rutherford's experiment. When rcore is large enough, even though the scattering of particles with impact parameters significantly bigger than rcore is essentially unchanged, no particles experience large deflections. As you make rcore smaller, the hard core is restored, and large angle scattering returns.""

To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Scattering model.  http://ccl.northwestern.edu/netlogo/models/Scattering.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Scattering for terms of use.
"
Reactor Top Down,/models/Sample Models/Chemistry & Physics/Radioactivity/Unverified,"breed [ neutrons neutron ]
breed [ rods rod ]

globals
[ power
  old-power      ; list of last 5 power values - used to compute average power
  average-power
  power-change
]

;;;;;;;;;;;;;;;;;;;;;;;;
;;; Setup Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;
to setup
  clear-all
  set-default-shape turtles ""circle""
  set power 0
  set old-power [0 0 0 0 0]
  ask patches[ setup-nuclear-fuel ]
  release-neutron
  setup-plot
  plot-power
end

to setup-nuclear-fuel ;; Patch Procedure
  if (pcolor = black) and (percent-fuel > (random 100))
  [ set pcolor red ]
end

to setup-plot
  set-current-plot ""Power""
  set-plot-y-range 0 (3 * power-rated)
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Run Time Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

to react
  set power 0
  ask neutrons
  [ fd  1
    if (count neighbors != 8 or any? rods-here)
    [ die ]
    if (pcolor = red)
    [ fission ]
  ]
  calculate-power
  tick
  plot-power
end

to calculate-power
  ;;average past five most recent power readings
  set power-change (power - first old-power)
  set old-power fput power but-last old-power
  set average-power mean old-power
end

to auto-react ;; Button
  ifelse (power-change >= 0)
  [ if (power-rated <= power)
    [ add-rods ]
  ]
  [ if (power < power-rated)
    [ remove-rods ]
  ]
  react
  if not any? neutrons
  [ stop ]
end

to fission ;; Neutron Procedure
  rt (random 360)
  if (spend-fuel?)
  [ set pcolor brown ]
  let gain (1 / count neutrons-here)
  set power power + gain
  hatch ((2 + random 2) * gain)
  [ rt random 360 ]
end

to release-neutron ;; Button
  let success false
  while [not success]
  [
    create-neutrons 1
    [ set color yellow
      rt (random 360)
      setxy random-pxcor
            random-pycor
      ifelse any? rods-here
      [ die ]
      [ set success true ]
    ]
  ]
end

to add-rods ;; Button
  create-rods number
  [ set color cyan
    setxy random-pxcor
          random-pycor
  ]
end

to remove-rods ;; Button
  ifelse (number >= (count rods))
  [ ask rods [ die ] ]
  [ repeat number
    [ ask one-of rods [ die ] ]
  ]
end

to plot-power
  set-current-plot-pen ""power-rated""
  plot power-rated
  set-current-plot-pen ""avg-power""
  plot average-power
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Reactor Top Down model.
; http://ccl.northwestern.edu/netlogo/models/ReactorTopDown.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/ReactorTopDown
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This project simulates a nuclear fission reaction in a nuclear power plant. In a fission reaction, free neutrons hit uranium atoms, causing each uranium atom to generate 2 or 3 neutrons and a unit of energy. The uranium atom itself splits into two smaller atoms. The newly generated neutrons, together with the neutron that caused the reaction, keep moving and continue to hit more uranium atoms, which release more neutrons, etc. This is the chain reaction that happens inside an atomic bomb.

Most nuclear energy is used for peaceful purposes, however. Generated in a nuclear power plant, nuclear fission goes on in a much more controlled fashion. The casing of the reactor is made of thick plates of lead and concreate to absorb the neutrons and prevent them from escaping. The reaction is controlled by rods made of graphite, hafnium, cadmium, or boron which also absorb the free neutrons. The rods are added and removed from the reaction chamber in order to control the speed of the reaction. When control rods are added, fewer atoms of uranium are smashed, which in turn limits how much energy is released.

This model simulates the process of a nuclear fission reaction inside such a plant. The reactor casing seals the core, with control rods to help control the speed of the reaction. The reactor has a built-in automatic controller, and has a set of manual controls as well.

HOW TO USE IT
-------------
-- The POWER-RATED slider sets the rated power (the amount of power production that you want to hold the reactor to), which is used for automatic control.
-- The PERCENT-FUEL slider control the percent of the reactor that is filled with fuel (red patches).
-- The SPEND-FUEL switch controls whether or not the fuel is used up when a neutron hits it. (turns brown)
-- The ADD-RODS and REMOVE-RODS buttons work with the NUMBER slider to add or remove that number of rods (cyan turtles) from the reactor.
-- The RELEASE NEUTRON button introduces a neutron (yellow turtle) into the reactor. It can be used at anytime before or during the reaction.

Press the SETUP button to set up the reactor with no control rods and a single neutron.

When MANUAL is on, use the ADD-RODS and REMOVE-RODS buttons to change the number of rods in the reactor, and thus control the speed of the reaction and the amount of power generated. If they are too few rods, too few neutrons are absorbed and the reactor will generate too much power. If they are too many, all free neutrons will be absorbed, and no power will be generated.

When AUTO-REACT is on, the reactor will add and remove rods as needed (in NUMBER increments) to keep power production under control.

THE POWER monitor shows the current power output.

The POWER-CHANGE monitor shows the change in power over the last clock tick.

Look at the POWER-PLOT plot to see the power curve.

THINGS TO NOTICE
----------------
Observe the fluctuation of the power curve. The blue line is the rated-power line and the red line is the actually generated power line.

THINGS TO TRY
-------------
There are two setups, one for manual control, one for automatic control.

The manual controls are very simple.  The ADD-RODS and REMOVE-RODS buttons control how many control rods are in the reactor.

The automatic controller is basically an ON and OFF controller. It is based on 1) comparison of power generated and power rated and 2) the power change. The mechanism is described in the following table:

|                     Power > Power Rated   Power < Power Rated
|                     -------------------   -------------------
|  Power Change > 0:       Add Rods            Do Nothing
|
|  Power Change < 0:      Do nothing           Remove Rods

The controller should be fine-tuned.

* In Manual Mode:
Use the NUMBER slider to adjust the number to add or remove according to the information given through the two monitors and the plot. You want the power curve to be as flat as possible. The height of the curve should be close to the horizontal line representing the power-rate.

* In Automatic Mode:
Fine tune the controller by changing the mechanisms to get a flatter power curve and minimize the fluctuation.

The SPEND-FUEL? switch sets whether or not the fuel is used up after releasing neutrons.  If it's on then the fuel in the reactor will quickly get used up and the model will end.  Because of the short run and the need for new fuel in order to continue the reaction, with spend-fuel? on it's best to have a lot of fuel in the reactor and a low power-rating.  If it's off then the fuel will never get used up and will react every time a neutron hits it and the model will probably never stop.  Because of the reactivity and longevity of this setting, it's best to have only a little fuel (otherwise it will react out of control) and a high power-rating, so the controller doesn't have to fill the core with control rods the entire time in order to hold to the rating.

EXTENDING THE MODEL
-------------------
The automatic controller used is just an on and off controller. Try using  Proportional, Integral and Differential (PID) controllers to make the reaction more smooth. You could also use some ideas of fuzzy logic (e.g. fuzzy membership) to build a fuzzy controller.

Absorbing free neutrons to control the reaction process is only one of the control mechanisms and is not the most important one. The important factor in controlling the reaction is to keep the speed of a neutron lower than a certain level (to stimulate fission reaction). The speeds of free neutrons depend on the density of the steam. Higher density yields lower speed and vice-versa. This is by nature a negative feedback control mechanism. It works as follows. If generated power is high, then the steam temperature is high and the density of the steam is low, thus the speed of free neutrons is high and is less likely to stimulate fission reaction. Hence a lower generated power. Try to incorporate this process into the automatic controller.

Neither setting of SPEND-FUEL? is completely realistic, with it on the fuel is used up too fast and there's hardly a reaction, with it off there is too much reacting and too many rods are needed to control the reaction.
Two addition ways to deal with fuel are listed below, can you think of more?
- have there be a certain ammount of fuel at each red patch, then it won't get used up right away, but won't go on forever either.
- limit how often a patch can react, that way, with spend-fuel? off the neutrons won't react out of control in small areas.

RELATED MODELS
--------------
Together with the Reactor X-Section model you can get a decent representation of how a Nuclear Reactor might work in three dimensions.  These two models are variations of one another based off of the Fission model from StarLogoT.

NETLOGO FEATURES
-----------------
More so than most other NetLogo models, the plot of 'Nuclear Reactor' plays an active role in the simulation. When using the manual controller, it is quite helpful to watch the power curve, to tell when things are getting out of hand.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Reactor Top Down model.  http://ccl.northwestern.edu/netlogo/models/ReactorTopDown.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/ReactorTopDown for terms of use.
"
Reactor X-Section,/models/Sample Models/Chemistry & Physics/Radioactivity/Unverified,"patches-own [ x y rod? ]

globals
[ power
  old-power
  old-power-2  ; Used to compute average-power
  old-power-3  ; Used to compute average-power
  old-power-4  ; Used to compute average-power
  average-power
  power-change
  rod-length
  n-rods   ; Number of rods
  r ; Constant for half the reactor size
]


to setup
  ca
  set-default-shape turtles ""circle""
  setup-globals
  ask patches
  [ set x (abs pxcor)
    set y (abs pycor)
    set rod? false
    build-reactor
    setup-nuclear-fuel
  ]
  setup-control-rods
  setup-plot
  plot-power
end

to setup-globals
  set power   0
  set old-power  0
  set old-power-2  0
  set old-power-3  0
  set old-power-4  0
  set r (reactor-size / 2)
  set rod-length rod-depth
  set n-rods (reactor-size / (rod-spacing + 1)) - 1
end

to build-reactor ;; Patch Procedure
  if ((x = r) and (y <= r)) or ((y = r) and (x <= r))
  [ set pcolor gray
    set rod? false
  ]
end

to setup-nuclear-fuel ;; Patch Procedure
  if (pcolor = black) and (x < r) and (y < r)
  [ set pcolor red ]
end

to setup-control-rods
  if rod-depth > reactor-size [set rod-depth reactor-size]
  if (rod-spacing = 5 or rod-spacing = 6 and reactor-size = 10)
  [ user-message ""Spacing too large for reactor size.  Spacing set to 4.""
    set rod-spacing 4
    set n-rods 1
  ]
  let rod-x 1 - r + rod-spacing

  ;; Make the rods more evenly spaced at particular settings
  if (rod-spacing = 2 and reactor-size != 30 and reactor-size != 60)
  [ set rod-x rod-x + 1 ]
  if (rod-spacing = 3 and (reactor-size mod 20) != 0)
  [ set n-rods n-rods + 1
    set rod-x rod-x - 1
  ]
  if (rod-spacing = 5 and (reactor-size = 20 or reactor-size = 40 or reactor-size = 70))
  [ ifelse (reactor-size = 20)
    [ set rod-x rod-x + 1 ]
    [ set rod-x rod-x + 2 ]
  ]
  if (rod-spacing = 6 and (reactor-size mod 20) = 0)
  [ set n-rods n-rods + 1
    ifelse (reactor-size = 80)
    [ set rod-x rod-x - 2 ]
    [ set rod-x rod-x - 1 ]
  ]

  repeat n-rods
  [ ask patches with [ pxcor = rod-x ]
    [ set rod? true ]
    set rod-x rod-x + rod-spacing + 1
  ]
  ask patches [ build-reactor ]
  place-control-rods
end

to setup-plot
  set-current-plot ""power-plot""
  set-plot-y-range 0 (3 * power-rated)
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Run Time Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;Forever Button
to auto-react
  if not any? turtles
    [stop]
  ifelse power-change >= 0
  [ if (power - power-rated) >= 0
    [ set rod-length ( rod-length + 50 ) ]
  ]
  [ if (power - power-rated) < 0
    [ set rod-length ( rod-length - 10 ) ]
  ]
  if rod-length < 0
  [ set rod-length 0 ]
  if rod-length > reactor-size
  [ set rod-length reactor-size ]
  react
end

;;Forever Button
to manu-react
  if not any? turtles
    [stop]
  if rod-depth > reactor-size [set rod-depth reactor-size]
  set rod-length rod-depth
  react
end

to react
  place-control-rods
  set power 0
  ask turtles
  [ fd  1
    if (pcolor = gray)
    [ die ]
    if (pcolor = red)
    [ fission ]
  ]
  set average-power ((power + old-power + old-power-2 + old-power-3 + old-power-4) / 5)
  set power-change (power - old-power)
  set old-power-4 old-power-3
  set old-power-3 old-power-2
  set old-power-2 old-power
  set old-power power
  tick
  plot-power
end

to release-neutron ;; Button
  let whom nobody
  crt 1
  [ set color yellow
    set xcor ((random (reactor-size - 2)) - r)
    set ycor ((random (reactor-size - 2)) - r)
    set whom self
    if (pcolor = gray)
    [ die ]
  ]
  if whom = nobody
  [ release-neutron ]
end

to place-control-rods
  ask patches with [ rod? ]
  [ ifelse (pycor >= (r - rod-length))
    [ set pcolor  gray ]
    [ set pcolor black ]
  ]
end

to fission ;; Turtle Procedure
  rt random 360
  if (pcolor = red)
  [ if (spend-fuel?)
    [ set pcolor brown ]
    let gain (1 / count turtles-here)
    set power power + gain
    hatch ((2 + random 2) * gain)
      [ rt random 360 ]
  ]
end

to plot-power
  set-current-plot-pen ""power-rated""
  plot power-rated
  set-current-plot-pen ""avg-power""
  plot average-power
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Reactor X-Section model.
; http://ccl.northwestern.edu/netlogo/models/ReactorX-Section.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/ReactorX-Section
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This project simulates a nuclear fission reaction in a nuclear power plant. In a fission reaction, free neutrons hit uranium atoms, causing each uranium atom to generate 2 or 3 neutrons and a unit of energy. The uranium atom itself splits into two smaller atoms. The newly generated neutrons, together with the neutron that caused the reaction, keep moving and continue to hit more uranium atoms, which release more neutrons, etc.  This is the chain reaction that happens inside an atomic bomb.

Most nuclear energy is used for peaceful purpose, however. Generated in a nuclear power plant, nuclear fission goes on in a much more controlled fashion. Heavy metal plates made of lead help to absorb the free neutrons, thus fewer atoms of uranium are smashed, which in turn limits how much energy is released.

This model simulates the process of a nuclear fission reaction inside such a plant. The reactor core is built of concrete, with adjustable control rods to help control the speed of the reaction. The reactor has a built-in automatic controller, and has a set of manual controls as well.


HOW TO USE IT
-------------
-- The REACTOR-SIZE slider controls the size of the reactor.
-- The ROD-SPACING slider controls the distance between the control rods.
-- The SPEND-FUEL switch controls whether or not the fuel is used up when a neutron hits it.
-- The POWER-RATED slider controls the rated power, which is used for automatic control.
-- The ROD-DEPTH slider controls the rod depth when under manual control.
-- The RELEASE NEUTRON button introduces a neutron into the reactor. It can be used at anytime before or during the reaction.

Press the SETUP button to set up the reactor.

When MANUAL is on, use the ROD-DEPTH slider to control the rod depth. If they are too short, too many neutrons can escape and the reactor will generate too much power. If they are too long, all free neutrons will be absorbed, and no power will be generated.

When AUTO-REACT is on, the reactor will adjust itself as needed to keep power production under control.

The POWER monitor shows the current power output.
The POWER-CHANGE monitor shows the change in power over the last clock tick.

Look at the POWER-PLOT plot to see the power curve.


THINGS TO NOTICE
----------------
Observe the fluctuation of the power curve. The blue line is the rated-power line and the red line is the actually generated power line.


THINGS TO TRY
-------------
There are two procedures, one for manual control, one for automatic control. (Respectively called 'manu-react' and 'auto-controller'.)

The manual controls are very simple.  The ROD-DEPTH slider controls how deep the control rods are inserted into the reactor.

The automatic controller is basically an ON and OFF controller. It is based on 1) comparison of power generated and power rated and 2) the power change. The mechanism is described in the following table:

|                     Power > Power Rated   Power < Power Rated
|                     -------------------   -------------------
|  Power Change > 0:    Increase Length         Do Nothing
|
|  Power Change < 0:      Do nothing          Decrease Length

The controller should be fine-tuned, and the length to increase and decrease varies.

* In Manual Mode:
Use the slider to adjust the control rod length according to the information given through the two monitors and the plot. You want the power curve to be as flat as possible. The height of the curve should be close to the horizontal line representing the power-rate.

* In Automatic Mode:
Fine tune the controller by changing the mechanisms to get a flat power curve with the least fluctuation.


EXTENDING THE MODEL
-------------------
The automatic controller used is just an on and off controller. Try using  Proportional, Integral and Differential (PID) controllers to make the reaction more smooth. You could also use some ideas of fuzzy logic (e.g. fuzzy membership) to build a fuzzy controller.

Absorbing free neutrons to control the reaction process is only one of the control mechanisms and is not the most important one. The important factor in controlling the reaction is to keep the speed of a neutron lower than a certain level (to stimulate fission reaction). The speeds of free neutrons depend on the density of the steam. Higher density yields lower speed and vice-versa. This is by nature a negative feedback control mechanism. It works as follows. If generated power is high, then the steam temperature is high and the density of the steam is low, thus the speed of free neutrons is high and is less likely to stimulate fission reaction. Hence a lower generated power. Try to incorporate this process into the automatic controller.


RELATED MODELS
--------------
Together with the Reactor Top Down model you can get a decent representation of how a Nuclear Reactor might work in three dimensions.  These two models are variations of one another based off of the Fission model from StarLogoT.


NETLOGO FEATURES
-----------------
More so than most other NetLogo models, the plot of 'Nuclear Reactor' plays an active role in the simulation. When using the manual controller, it is quite helpful to watch the power curve, to tell when things are getting out of hand.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Reactor X-Section model.  http://ccl.northwestern.edu/netlogo/models/ReactorX-Section.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/ReactorX-Section for terms of use.
"
Decay,/models/Sample Models/Chemistry & Physics/Radioactivity,"globals [
  decays       ;; # of decays during this tick
  last-count   ;; this is the number of nuclei at the beginning --
]              ;; reset each time a red line is drawn on the plot

to setup
  clear-all
  set-default-shape turtles ""circle""
  ask n-of number-nuclei patches [
    sprout 1 [ set color cyan ]
  ]
  set last-count number-nuclei    ;; remember the starting number of nuclei
  set decays 0
  setup-plots
  update-plots
end

to go
  ;; if all the nuclei have decayed then stop the model
  if all? turtles [color = blue - 3]
    [ stop ]
  set decays 0
  ask turtles with [color = cyan]
    [ if random-float 100.0 < decay-chance
        [ set color yellow
          set decays decays + 1] ]
  display  ;; so the user sees the yellow
  ask turtles with [color = yellow]
    [ set color blue - 3 ]
  tick
  update-plots
end

to setup-plots
  set-current-plot ""Radioactive Nuclei""
  set-plot-y-range 0 number-nuclei
  set-current-plot ""Decay Rate""
  set-plot-y-range 0 ceiling (number-nuclei / 100)
end

to update-plots
  let undecayed count turtles with [color = cyan]
  ;; when half of the original nuclei have decayed draw a line to mark the half-life
  set-current-plot ""Radioactive Nuclei""
  if (last-count / 2) > undecayed
    [ set-current-plot-pen ""lines""
      draw-vertical-line ticks
      draw-horizontal-line undecayed
      set last-count undecayed ]
  set-current-plot-pen ""default""
  plot undecayed
  if ticks > 0
    [ set-current-plot ""Decay Rate""
      plot decays ]
end

;; this draws a line at the given x-coordinate
to draw-vertical-line [x-val]
  set-plot-pen-color red
  plot-pen-up
  plotxy x-val 0
  plot-pen-down
  plotxy x-val number-nuclei
end

;; this draws a line at the given y-coordinate
to draw-horizontal-line [y-val]
  set-plot-pen-color green
  plot-pen-up
  plotxy 0 y-val
  plot-pen-down
  plotxy ticks y-val
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Decay model.
; http://ccl.northwestern.edu/netlogo/models/Decay.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Decay
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model simulates the spontaneous decay of a collection of radioactive nuclei.  As they decay and become stable, the plot of the number that are still radioactive demonstrates the notion of ""half-life"".


HOW IT WORKS
------------
At each time tick, each undecayed (light blue) nucleus has a certain chance of decaying.  When a nucleus decays, it briefly flashes bright yellow (as if giving off radiation), then turns dark blue.  Eventually, if you wait long enough, all of the nuclei will have decayed and the model will stop.


HOW TO USE IT
-------------
Set the initial number of nuclei (NUMBER-NUCLEI slider) and the likelihood of decay during each time interval (DECAY-CHANCE slider). Then push the SETUP button. Push the GO button to run the model.

The number of radioactive nuclei that remain is shown in the ""Radioactive Nuclei"" plot.  Each time the number of nuclei is reduced by half, red and green lines appear on the plot to mark the place where each halfway mark was reached.  The ""Decay Rate"" plot shows the number of decays that occur during each clock tick.


THINGS TO NOTICE
----------------
What is the shape of the decay curve (Radioactive Nuclei)?  How is this affected by the initial conditions?

Why is the decay curve this shape?  Is it the same as the decay curve shown in books?

The time between red lines is called the half-life.  What is its physical meaning?  Is it constant as the number of nuclei decreases?  Is it affected by the initial number of nuclei or the decay-chance?  Do you think it's a useful way to characterize a radioactive material?

How long does it take for all the nuclei to decay?

Watch one nucleus carefully.  When will it decay?

Radioactivity depends on the number of decays per unit time (Decay Rate), because each decay event gives off radiation.  What happens to the radioactivity of this sample over time?  What is the shape of the decay rate curve?  How is it related to the shape of the decay curve?

Examine the standard equation for nuclear decay:
|     N = No (e exp -(T/tau))
No is the initial number of nuclei, N is the number at a later time T, and tau is the ""mean lifetime"".  Compare its behavior to what you see in this model.  The corresponding equation for radiation is:
|     R = Ro (e exp -(T/tau))
Why are these two equations so similar?


THINGS TO TRY
-------------
Try the extremes of the initial conditions: many or few nuclei, high or low decay-chance.  How does this affect the ""jaggedness"" of the decay rate plot?

What does the plot do when very few nuclei are left?

What instructions would you give each turtle be to make it behave like an unstable nucleus?  Check the code in the Procedures tab and see if it's what you thought it should be.

Carbon-14 dating involves comparing the ratio of a stable (C-12) to an unstable (C-14) nucleus.  Explain that method in terms of this model.


EXTENDING THE MODEL
-------------------
It is often the case in nature that two nuclei with different decay rates are present in the same sample.  Modify this model to have two or more types of nuclei.  What happens to the radiation curve?

In this model, the nuclei don't affect their neighbors when they decay -- they just disappear. Get them to emit particles that in turn cause reactions in other nuclei.  See if you can model a chain reaction.  (See the Reactor Top Down and Reactor X-Section models.)


RELATED MODELS
--------------
Reactor Top-Down, Reactor X-Section


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Decay model.  http://ccl.northwestern.edu/netlogo/models/Decay.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Decay for terms of use.
"
Turbulence,/models/Sample Models/Chemistry & Physics,"globals
[
  row      ;; this is the current row we are now calculating
  done?    ;; a flag set to allow you to press the go button multiple times
]

patches-own
[
  value    ;; this variable is a floating point number between 0 and 1.5
]


;; initializes patches and globals
to setup-general
  clear-patches
  set row max-pycor   ;; set the current row to the top
  set done? false
end


;; set up a random initial condition, parameterized by initial-turbulence
to setup-random
  setup-general
  reset-ticks
  ;; randomize the values of the current row (top row in this case)
  ask patches with [pycor = row]
  [
    set value ((3 / 2) - ((random-float initial-turbulence) / 100 * (3 / 2)))
    color-patch
  ]
end


;; this is called to copy the bottom row to the top row when the user presses
;; GO again
to setup-continue
  let value-list []
  if not done?  ;; make sure go has already been called
    [ stop ]

  ;; copy values from bottom row of patches to top row
  set value-list [value] of patches with [pycor = row]
  setup-general
  ask patches with [pycor = row]
  [
    set value item (pxcor + max-pxcor) value-list
    color-patch
  ]
  set done? false
end


;; main routine
to go
  let row-patches patches with [pycor = row]
  ;; if the end has been reached, continue from the top or stop
  if (row = min-pycor)
  [
    ifelse auto-continue?
    [
      ;; if we are stuck in an absorbing state, there is no reason to continue
      ifelse (roughness = 0.0
              and not any? row-patches with [value > 0 and value <= 1])
      [
        stop
      ]
      [
        set done? true
        display    ;; ensure everything gets drawn before we clear it
        setup-continue
        set row-patches patches with [pycor = row]
      ]
    ]
    [
      ifelse done?
      [
        ;; a run has already been completed, so continue with another
        setup-continue
        set row-patches patches with [pycor = row]
      ]
      [
        ;; otherwise just stop
        set done? true
        stop
      ]
    ]
  ]

  ask row-patches     ;; apply rule
  [
    calculate-next-value
    color-patch
  ]

  set row row - 1
  tick
end


;; calculates and sets the value of the patch immediately below self.
to calculate-next-value  ;; patch procedure
  let patch-below (patch-at 0 -1)

  ;; coupling step: diffuse values
  let value-sum ([value] of (patch-at -1 0) + [value] of (patch-at 1 0))
  let new-value
        ((1 - coupling-strength) * value + ((coupling-strength / 2) * value-sum))

  ;; set variables
  ask patch-below [
    set value new-value
    ;; scale & apply roughness
    set value scale value - roughness
    ;; if we've subtracted too much, just set the value to 0
    if value < 0 [ set value 0 ]
  ]
end


to-report scale [ x ]
  ifelse (x >= 0 and x <= 0.5)
    [ report 3 * x ]
    [
      ifelse (x > 0.5 and x <= 1)
        [ report 3 * (1 - x) ]
        [ report x ]
    ]
end


to color-patch  ;; patch procedure
  set pcolor scale-color pink value 1.5 -1.5
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2003 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2003).  NetLogo Turbulence model.
; http://ccl.northwestern.edu/netlogo/models/Turbulence.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2003 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Turbulence
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model demonstrates the transition from order, or ""laminarity"", to disorder, or ""turbulence"" in fluids.  Using a one-dimensional continuous cellular automaton, this model allows you to explore the relationship between turbulence, laminarity, and the viscosity of a fluid flowing through a ""pipe."" It also shows you how the roughness of pipes in which the fluid travels through affects the fluid's behavior.


HOW IT WORKS
------------
This model is based on a ""coupled map lattice,"" otherwise known as a continuous cellular automaton.  See CA 1D Elementary for an introduction to one-dimension cellular automata, and see CA 1D Continuous for an introduction to continuous CA's.

Each cell has a value ranging continuously from 0 to 1.5, where 0 is the greatest degree of turbulence, and 1.5 is the greatest degree of laminarity.  Cells are considered laminar when their value is greater than 1, and turbulent when their value is less than or equal to 1.

To draw each subsequent row, each cell in the previous row is updated in three steps:

1) The first step is coupling, where the cell's value ""diffuses,"" or is averaged with its nearest neighbors on each side. The degree of influence that the cells have on one another is determined by the COUPLING-STRENGTH slider.  The higher the value of the coupling strength, the more the cells will influence one another.  COUPLING-STRENGTH is a rough analog of viscosity.

2) In the second step, another function is applied in order to properly scale the result of the coupling function.

3) The third and last step is the application of friction, which is the analog of roughness (on, for instance, the inside of a pipe or the surface of a sheet of glass).  The ROUGHNESS parameter controls the amount of friction imposed upon the fluid, increasing the cell's turbulence. This may seem a bit strange, but it is important to remember turbulence is measured in terms of disorder; when the fluid's velocity is changed, these fluctuations cause more disorder.

These steps are then repeated for the next row, and so on.


HOW TO USE IT
-------------
Setup:
- SETUP initializes the model with a mix of turbulent and non-turbulent initial conditions.
- INITIAL-TURBULENCE controls the degree of initial turbulence.

Parameters:
- COUPLING-STRENGTH is the amount of ""diffusion,"" or the influence that cells have on one another.
- ROUGHNESS is the amount of turbulence that is added to each cell at every time step.
- DISPLAY-CONTINUOUS? will display state values as a gradient from dark to light (laminar and turbulent, respectively) if on, otherwise they will discretized and displayed as either black and white.

Running the model:
- If auto-continue? is off, GO runs the model until it reaches the bottom (min-ycor).  If pressed again, GO will continue the same run at the top row of patches. If auto-continue? is on, upon reaching the bottom row of patches, GO will immediately continue the run from the top.
- AUTO-CONTINUE? will cause GO to automatically wrap back to the top and continue when switched on. If the model has reached a completely laminar state, and cannot produce any more turbulence, it will not run again.


THINGS TO NOTICE
----------------
Under what circumstances do darker, more ""laminar"" patches occur?  How is this dependent on the turbulence?

Why do straight, non-budding turbulent streams eventually die out when ROUGHNESS is set to 0?
How come this doesn't occur so much when ROUGHNESS is greater than 0?


THINGS TO TRY
-------------
Set ROUGHNESS to 0:

Change the COUPLING STRENGTH until you find the ""critical value"" that the COUPLING-STRENGTH must be above in order to produce long-lived turbulence.  This transition is very fast, and occurs within a very small range of the COUPLING-STRENGTH parameter.

When the COUPLING-STRENGTH is above the critical value, what change do you see that might explain why the turbulence is able to perpetuate itself so well?

With a COUPLING-STRENGTH above the critical value, about how much INITIAL-TURBULENCE is required for the turbulence to continue indefinitely?

What happens when the COUPLING-STRENGTH is too high?  Can you give a physical interpretation of this?


Think about these questions while experimenting with ROUGHNESS values above 0:

How does ROUGHNESS affect turbulence in the fluid?

How does ROUGHNESS affect the critical value required for long-lived turbulence?

With higher ROUGHNESS values, is it necessary for there to be a certain amount of INITIAL-TURBULENCE in order to produce long-lived turbulence?  Why or why not?

Is there a difference between turbulence caused by large COUPLING-STRENGTHs and the turbulence caused by friction?  If so, how do they differ?

Can you give a physical interpretation of a ROUGHNESS of 0?


EXTENDING THE MODEL
-------------------
Although this is a continuous-valued CA, in a sense the system is discrete in that there is a sharp distinction between ""turbulent"" and ""laminar"" cells.  If you modify the COLOR-PATCH procedure to color the cells only as black or white depending on which of these two discrete states they are in, you will see a discrete ""view"" of this continuous model.

In physical systems, ""coupling strength"" is a product of various factors, such as temperature, pressure, and viscosity.  Can you come up with a way to take these factors into account in this model?

Surface tension is a subject common to fluid dynamics and turbulence.  Can you figure out a way to integrate it into the model?

There are many ways to quantitatively analyze turbulence.  Try coming up with a plot of the entropy (see 'CA Stochastic' for an example), or the average size of the laminar regions.

Can you create a turbulence model in two dimensions?


RELATED MODELS
--------------
CA 1D Elementary - the elementary two-state 1D cellular automata
CA Continuous - an elementary continuous 1D cellular automaton
CA Stochastic - a probabilistic cellular automaton that exhibits critical phase transitions similar to this model
Lattice Gas Automaton - two-dimensional wave propagation through a lattice gas
Wave Machine - wave motion in a two-dimensional membrane
Percolation - the percolation of oil through soil


CREDITS AND REFERENCES
----------------------
Criticality in cellular automata: H. Chate and P. Manneville. 1990 Physica D 45 122-135
Pattern Dynamics in Spatiotemporal Chaos: Kunihiko Kaneko. 1989 Physica D 34 1-41
Supertransients, spatiotemporal intermittency and stability of fully developed spatiotemporal chaos: Kunihiko Kaneko. 1990 Physics Letters A Vol 149, Number 2,3
Shepherd, Dennis G. 1965. Elements of Fluid Mechanics.  Harcourt, Brace, & World, Inc., New York, NY.

Thanks to Eytan Bakshy for his work on this model.

To refer to this model in academic publications, please use:  Wilensky, U. (2003).  NetLogo Turbulence model.  http://ccl.northwestern.edu/netlogo/models/Turbulence.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2003 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Turbulence for terms of use.
"
Crystallization Directed,/models/Sample Models/Chemistry & Physics/Crystallization,"turtles-own [
  temp                 ;; this turtle's temperature
  neighboring-turtles  ;; agentset of surrounding turtles
  sides-exposed        ;; number of sides exposed to cooling walls  (between 0 and 4)
]

globals [
  ave-metal-temp   ;; shows average temperature of all metal
  num-frozen       ;; keeps track of how many atoms are frozen
  temp-range       ;; for histogram
  colors           ;; used both to color turtles, and for histogram
  pens             ;; keeps track of all the histogram's pen names
]

to setup
  clear-all
  set colors sentence (white - 1) [cyan sky blue violet magenta red]
  set pens []
  set temp-range (init-metal-temp - melting-temp) / (length colors - 1)
  let ymax (height + 1) / 2
  let xmax (width + 1) / 2
  ;; create turtles everywhere inside the given box range
  ask patches [
    if ((abs pycor) < ymax) and ((abs pxcor) < xmax)
    [
      sprout 1
      [
        set shape ""T""
        set temp init-metal-temp
        set-color
      ]
    ]
  ]
  ;; set sides of box for cooling
  ask patches [
    if      (heat-top? and (pycor = ymax) and (abs pxcor <= xmax)) or
      (heat-left? and (pxcor = (- xmax)) and (abs pycor <= ymax)) or
          (heat-right? and (pxcor = xmax) and (abs pycor <= ymax)) or
    (heat-bottom? and (pycor = (- ymax)) and (abs pxcor <= xmax))
    [ set pcolor 16 ]
  ]
  ask turtles [
    set neighboring-turtles (turtles at-points [[-1  1] [ 0  1] [1  1]
                                                [-1  0] [ 0  0] [1  0]
                                                [-1 -1] [ 0 -1] [1 -1]])
    set sides-exposed (count patches at-points [[-1  1] [ 0  1] [1  1]
                                                [-1  0] [ 0  0] [1  0]
                                                [-1 -1] [ 0 -1] [1 -1]]
                       with [(not any? turtles-here) and (pcolor = black)])
  ]
  set ave-metal-temp init-metal-temp
  setup-plots
  do-plots
end


to go
  ;; stop if all turtles are below melting temp
  if (max ([temp] of turtles) < melting-temp) [ stop ]
  ;; otherwise...
  set num-frozen 0
  ask turtles [ cool-turtles ]
  ask turtles [ set-color ]
  ask turtles [ rotate ]
  set ave-metal-temp (mean [temp] of turtles)
  tick
  do-plots
end


;; turtle procedure -- if metal is liquid and it is next to a solid,
;; change its heading to that of the solid; otherwise, just rotate
;; randomly
to rotate
  if (temp >= melting-temp) [
    let frozen-neighbors (neighboring-turtles with [temp <= melting-temp])
    ifelse (any? frozen-neighbors)
      [ set heading ([heading] of (one-of frozen-neighbors)) ]
      [ rt random-float 360 ]
  ]
end


;; turtle procedure -- sets turtle's temp to ave temp of all
;; neighboring turtles and patches added turtle's own temp in twice so
;; it changes more slowly
to cool-turtles
  let total-temp ((sum [temp] of neighboring-turtles) +
                  (room-temp * sides-exposed) + temp)
  set temp (total-temp / (count neighboring-turtles + sides-exposed + 1))
end

;; turtle procedure
to set-color
  ; create index ranging from 1 to 8 for all melting colors
  let index (floor ((temp - melting-temp) / temp-range)) + 1
  ifelse (index < 1 ) [
    set color white - 1
    set num-frozen (num-frozen + 1)
  ]
  [
    if index >= length colors
      [ set index (length colors) - 1 ]
    set color item index colors
  ]
end


to setup-plots
  set-current-plot ""Average Metal Temperature""
  set-plot-y-range room-temp init-metal-temp

  set-current-plot ""Number Solidified""
  set-plot-y-range 0 count turtles

  set-current-plot ""Temperatures""
  set-plot-y-range 0 count turtles
  set-histogram-num-bars 1 + (length colors)
  make-histogram-pens
end

to make-histogram-pens
  let bottom (round room-temp)
  let top (round melting-temp)
  let index 0
  foreach colors [
    create-temporary-plot-pen (word bottom "" - "" top)
    set-plot-pen-mode 1
    set-plot-pen-color ?
    set pens lput (word bottom "" - "" top) pens

    set index index + 1
    set bottom top
    set top (round ((index * temp-range) + melting-temp))
  ]
end

to do-plots
  set-current-plot ""Average Metal Temperature""
  plot ave-metal-temp
  set-current-plot ""Number Solidified""
  plot num-frozen
  if histogram? [ do-histogram ]
end

to do-histogram
  set-current-plot ""Temperatures""
  let index 0
  foreach colors [
    set-current-plot-pen (item index pens)
    plot-pen-reset
    ;; plot each bar of histogram separately
    if any? turtles with [color = ?]
    [ plotxy index count turtles with [color = ?] ]
    set index index + 1
  ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2002 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2002).  NetLogo Crystallization Directed model.
; http://ccl.northwestern.edu/netlogo/models/CrystallizationDirected.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2002 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/CrystallizationDirected
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
Some metal applications require that a metal's grains form specific patterns. To achieve this, the metal is only cooled from certain sides.  This can be done in several ways.  For example, when molds are made of metal, wires are used to heat up the mold where they want the metal to crystallize last.  For molds made of sand, pieces of metal are put where the liquid metal should crystallize first.  The inserted metal (known as a heat sink), works to quickly suck the heat out of the liquid metal.

This model represents the cross-section of a block of liquid metal cooling in a metal mold.  The surrounding mold quickly sucks the heat out of the liquid metal.  However, you can select some of the sides to be heated, which prevents heat from escaping out of those sides.   By selecting which sides of the metal are heated, you can control the shapes of the resulting grains.  (Note that the actual number of atoms is small compared to a real metal sample and the metal is only two-dimensional.)

The rest of this text assumes the user has already read and understood the original Crystallization Basic model.


HOW TO USE IT
-------------
Buttons:
SETUP: Resets the simulation, and sets the metal to the correct size.
GO-ONCE: Runs the simulation for one time step.
GO: Runs the simulation continuously until either the GO button is pressed again, or all of the atoms are frozen.

Sliders:
WIDTH: How many atoms wide the metal is.
HEIGHT: How many atoms high the metal is.
ROOM-TEMP: Varies the temperature of the room.
INIT-METAL-TEMP: Varies the initial temperature of the metal.
MELTING-TEMP: Varies the temperature at which the metal solidifies.

Monitors:
AVE-METAL-TEMP: Monitors the average temperature of all the atoms.
TIME: Keeps track of the time that has elapsed during each run.

Switches:
HEAT-TOP?: Prevents the top side of the metal from starting to cool.
HEAT-LEFT?: Prevents the left side of the metal from starting to cool.
HEAT-RIGHT?: Prevents the right side of the metal from starting to cool.
HEAT-BOTTOM?: Prevents the bottom side of the metal from starting to cool.
HISTOGRAM?: Turns the histogram plotting on and off.  Turning off the histogram speeds up the model.

Graphs:
AVERAGE METAL TEMPERATURE: Plots the average temperature of all the metal over time.
NUMBER SOLIDIFIED: Plots how many metal atoms are below the melting temperature over time.
TEMPERATURES:  Histograms how many atoms are in each temperature range.  (Note that the colors of the histogram match the actual colors of the atoms.)


THINGS TO TRY
---------------
Set HEAT-TOP? and HEAT-RIGHT? to On and HEAT-BOTTOM? and HEAT-LEFT? to Off. Predict which atom will be the last to solidify.  Now run the model and see if your prediction was correct.

A contractor asks you to create a piece of metal for her that only has horizontal grain boundaries, and no vertical ones.  Find settings for HEAT-TOP?, HEAT-RIGHT?, HEAT-BOTTOM?, and HEAT-LEFT? that result in approximately these sorts of grain boundaries.

Set HEAT-TOP? and HEAT-BOTTOM? to Off and HEAT-LEFT? and HEAT-RIGHT to On. Run the model to completion.  How do these settings affect the grain boundaries? How would these grain boundaries affect the properties of the metal?


EXTENDING THE MODEL
-------------------
In this model, heating a side simply results in the room temperature having no affect on that side.  However, in real applications, heated sides still cool the metal, but at a slower rate.  Change the cool-turtles procedure so heated sides factor into how atoms are cooled.

As mentioned in the ""What is it"" section, molds made of sand use inserted pieces of metal to control which side of the metal should crystallize first.  The inserted metal (known as a heat sink), works to quickly suck the heat out of the liquid metal.  Change the model so instead of just having heated sides, there are also cooled sides that cause a faster cooling rate.


NETLOGO FEATURES
------------------
In the setup procedure, a turtle is created on every patch within the requested dimensions.  This is achieved by asking every patch satisfying certain conditions to SPROUT 1.

Note how we can draw a multi-colored histogram.  The HISTOGRAM primitive can only draw in one color at a time, but we work around this by calling it over and over again, plotting only one bar each time, changing the pen color each time.


RELATED MODELS
--------------
Crystallization Basic
Crystallization Moving


CREDITS AND REFERENCES
----------------------
Original implementation: Carrie Hobbs, for the Center for Connected Learning and Computer-Based Modeling.

To refer to this model in academic publications, please use:  Wilensky, U. (2002).  NetLogo Crystallization Directed model.  http://ccl.northwestern.edu/netlogo/models/CrystallizationDirected.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2002 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/CrystallizationDirected for terms of use.
"
Crystallization Moving,/models/Sample Models/Chemistry & Physics/Crystallization,"turtles-own
[
  temp               ;; specific turtle's temperature
  turtle-neighbors   ;; set of surrounding turtles
]

globals
[
  ave-metal-temp   ;; shows average temperature of all metal
  num-frozen       ;; keeps track of how many atoms are frozen
  temp-range       ;; for histogram
  colors           ;; used both to color turtles, and for histogra
  pens             ;; keeps track of all the histogram's pen names
]

to setup
  clear-all
  set colors sentence (white - 1) [cyan sky blue violet magenta red]
  set pens []
  set temp-range (init-metal-temp - melting-temp) / (length colors - 1)

  ask patches with [(abs pycor >= box-width / 2) or
                    (abs pxcor >= box-width / 2)]
  [ set pcolor white ]

  ;; fill room to desired percentage
  ask patches
  [
    if ((fill-percentage > random-float 100) and (pcolor != white))
    [
      sprout 1
      [
        set shape ""T""
        set temp init-metal-temp
        set turtle-neighbors (turtles at-points [[1 0] [0 1] [-1 0] [0 -1]])
        set-color
      ]
    ]
  ]
  set ave-metal-temp init-metal-temp
  if any? turtles [
    setup-plots
    do-plots
  ]
end


to go
  ;; stop if all turtles are below melting temp
  if (max ([temp] of turtles) < melting-temp)[ stop ]
  ;; otherwise...
  set num-frozen 0
  ask turtles [ move ]
  ask turtles [ rotate ]
  ask turtles [ cool-turtles ]
  ask turtles [ set-color ]
  set ave-metal-temp (mean [temp] of turtles)
  tick
  if any? turtles [ do-plots ]
end


;; turtles procedure -- if metal is liquid, move to a randomly
;; selected neighboring patch that is not already occupied
to move
  if (temp > melting-temp)
  [
    let move-choices neighbors4 with [(pcolor != white) and (not any? turtles-here)]
    if any? move-choices
    [
      move-to one-of move-choices
    ]
  ]
end


;; turtle procedure -- if metal is liquid and it is next to a solid,
;; change its heading to that of the solid; otherwise, just rotate
;; randomly
to rotate
  set turtle-neighbors turtles at-points [[1 0] [0 1] [-1 0] [0 -1]]
  if (temp > melting-temp)
  [
    let frozen-neighbors (turtle-neighbors with [temp <= melting-temp])
    ifelse (any? frozen-neighbors)
      [ set heading ([heading] of (one-of frozen-neighbors)) ]
      [ rt random-float 360 ]
  ]
end


;; turtle procedure -- sets turtle's temp to ave temp of all
;; neighboring turtles and patches added turtle's own temp in twice so
;; it changes more slowly
to cool-turtles
  let walled-sides neighbors4 with [pcolor = white]
  let total-temp ((sum [temp] of turtle-neighbors) +
                  (room-temp * (count walled-sides) + temp))
  let total-num ((count turtle-neighbors) + (count walled-sides) + 1)
  set temp (total-temp / total-num)
end


;; turtle procedure
to set-color
  ; create index ranging from 1 to 8 for all melting colors
  let index (floor ((temp - melting-temp) / temp-range)) + 1
  ifelse (index < 0 )
  [
    set color white - 1
    set num-frozen (num-frozen + 1)
  ]
  [
    if index >= length colors
    [ set index (length colors) - 1 ]
    set color item index colors
  ]
end


to setup-plots
  set-current-plot ""Average Metal Temperature""
  set-plot-y-range room-temp init-metal-temp

  set-current-plot ""Number Solidified""
  set-plot-y-range 0 count turtles

  set-current-plot ""Temperatures""
  set-plot-y-range 0 count turtles
  set-histogram-num-bars 1 + (length colors)
  make-histogram-pens
end

to make-histogram-pens
  let bottom (round room-temp)
  let top (round melting-temp)
  let index 0
  foreach colors
  [
    create-temporary-plot-pen (word bottom "" - "" top)
    set-plot-pen-mode 1
    set-plot-pen-color ?
    set pens lput (word bottom "" - "" top) pens

    set index index + 1
    set bottom top
    set top (round ((index * temp-range) + melting-temp))
  ]
end

to do-plots
  set-current-plot ""Average Metal Temperature""
  plot ave-metal-temp
  set-current-plot ""Number Solidified""
  plot num-frozen
  if histogram? [ do-histogram ]
end

to do-histogram
  set-current-plot ""Temperatures""
  let index 0
  foreach colors
  [
    set-current-plot-pen (item index pens)
    plot-pen-reset
    if any? turtles with [color = ?]
    [ plotxy index count turtles with [color = ?] ]
    set index index + 1
  ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2002 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2002).  NetLogo Crystallization Moving model.
; http://ccl.northwestern.edu/netlogo/models/CrystallizationMoving.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2002 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/CrystallizationMoving
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model simulates the movement of metal atoms as a system crystallizes.  It is very similar to the Crystallization Basic model, except here the atoms are free to move about.  They randomly move in any direction that is not already occupied by something else, such as another atom or a wall.  Therefore, in order to allow movement, there must be empty spaces between atoms.  Initially these empty spaces, or voids, are randomly distributed, as they would be in a liquid metal.

The first atoms to crystallize have a random orientation.  However, when a liquid atom about to crystallize is next to an already crystallized atom, the liquid atom orients itself with the solid atom, thus creating a crystal.  As more and more atoms solidify, the crystals grow.  Within each crystal, all the atoms are oriented with one another, but within the entire metal, all the crystals have random orientations.  Each individual crystal is called a grain.   When two crystals grow up next to each other, they form what is called a grain boundary.

When a metal is stressed, such as when it is pulled from both ends, deformations occur in the crystal structure.  As more stress is applied, these deformations pass through the crystal structure, allowing the metal to bend.  Grain boundaries prevent deformations from flowing through the metal.  Therefore, pieces of metal with fewer grain boundaries tend to be ductile, while pieces of metal with more grain boundaries tend to be brittle.

(Note that the actual number of atoms is small compared to a real metal sample and the metal is only two-dimensional.  In addition, the movement of the atoms is limited to discrete patch sizes.)


HOW TO USE IT
-------------
Buttons:
SETUP: Resets the simulation, and sets the metal to the correct size.
GO-ONCE: Runs the simulation for one time step.
GO: Runs the simulation continuously until either the GO button is pressed again, or all of the atoms are frozen.

Sliders:
BOX-WIDTH: How many atoms wide the metal is.
FILL-PERCENTAGE: What percentage of the box contains atoms.  Smaller values allow for more movement.
ROOM-TEMP: Varies the temperature of the room.
INIT-METAL-TEMP: Varies the initial temperature of the metal.
MELTING-TEMP: Varies the temperature at which the metal solidifies.

Monitors:
AVE-METAL-TEMP: Monitors the average temperature of all the atoms.

Switches:
HISTOGRAM?: Turns the histogram plotting on and off.  Turning off the histogram speeds up the model.

Graphs:
AVERAGE METAL TEMPERATURE: Plots the average temperature of all the metal over time.
NUMBER SOLIDIFIED: Plots how many metal atoms are below the melting temperature over time.
TEMPERATURES:  Histograms how many atoms are in each temperature range.  (Note that the colors of the histogram match the actual colors of the atoms.)


THINGS TO TRY
---------------
Set BOX-WIDTH to 15, FILL-PERCENTAGE to 85, and leave the rest of the sliders at their initial values (ROOM-TEMP at 20, INIT-METAL-TEMP at 1550, and MELTING-TEMP at 500).  Run the entire simulation by clicking on SETUP and GO, and then waiting for the metal to completely crystallize.  Repeat this several times.  What happens to the empty spaces between the atoms?  How do you think this would affect the properties of the overall metal?

Now set BOX-WIDTH to 29 and leave the rest of the settings how they were in the previous paragraph.  As before, run the entire simulation by clicking on SETUP and GO, and then waiting for the metal to completely crystallize.  What are some things that are different this time?  What stayed the same?

Set ROOM-TEMP to -20, INIT-METAL-TEMP to 1550, and MELTING-TEMP to 1500.  Leave BOX-WIDTH at 29 and FILL-PERCENTAGE at 85.  Now run the entire simulation.  What happens to the empty spaces between the atoms?  Why is this different from the previous simulations?  How do you think this would affect the properties of the overall metal?


EXTENDING THE MODEL
-------------------
This model prevents more than one atom from occupying the same space.  However, in three dimensions, atoms are able to move over one another.  Change the code so turtles can move to any space inside the boundaries.  What does the resulting crystal look like?  Can you imagine what this would look like in three dimensions?

Some metal applications require that the metal's grains form long strips across the metal.  To achieve this, only one side of the metal is cooled.  This causes all of the crystals to begin on one side of the metal, and consequently grow across its length.  This is called directional solidification.  In the Procedures window, change the code so one side of the room is much cooler than the rest.


NETLOGO FEATURES
------------------
In NetLogo, a turtle's heading specifies which direction the turtle's shape appears.  However, in this model, turtles must move in a direction unrelated to their shape direction.  To circumvent this, SETXY was used to move the turtles instead of FD.

Note how we can draw a multi-colored histogram.  The HISTOGRAM primitive can only draw in one color at a time, but we work around this by calling it over and over again, plotting only one bar each time, and changing the pen color each time.

With every time step, each atom's temperature changes to the average of everything around it.  To do this, each turtle has an agent set of all of its neighboring turtles that is updated each time the turtles move.  In addition, each turtle has an agent set of all the patches surrounding it that is also updated.  Any white patches in the set are on the outside wall.  Therefore, the new temperature is taken as the average of the temperatures of the neighbor list, plus the room temperature multiplied by the number of white patches in the set.  Therefore, turtles on the edge of the metal will average in the room temperature to their temperature, but other turtles will not.


RELATED MODELS
--------------
Crystallization Basic
Crystallization Directed


CREDITS AND REFERENCES
----------------------
Original implementation: Carrie Hobbs, for the Center for Connected Learning and Computer-Based Modeling.

To refer to this model in academic publications, please use:  Wilensky, U. (2002).  NetLogo Crystallization Moving model.  http://ccl.northwestern.edu/netlogo/models/CrystallizationMoving.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2002 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/CrystallizationMoving for terms of use.
"
Crystallization Basic,/models/Sample Models/Chemistry & Physics/Crystallization,"turtles-own [
  temp                ;; this turtle's temperature
  neighboring-turtles ;; agentset of surrounding turtles
  sides-exposed       ;; how many sides turtle has exposed
]

globals [
  ave-metal-temp   ;; shows average temperature of all metal
  num-frozen       ;; keeps track of how many atoms are frozen
  temp-range       ;; for histogram
  colors           ;; used both to color turtles, and for histogram
  pens             ;; keeps track of all the histogram's pen names
]

to setup
  clear-all
  set colors sentence (white - 1) [cyan sky blue violet magenta red]
  set pens []
  set temp-range (init-metal-temp - melting-temp) / (length colors - 1)
  ;; create turtles everywhere inside the given box range
  ask patches [
    if (not circle? and ((abs pycor) < height / 2) and ((abs pxcor) < width / 2))
       or (circle? and distancexy 0 0 < height / 2)
    [
      sprout 1
      [
        set shape ""T""
        set temp init-metal-temp
        set-color
      ]
    ]
  ]
  ask turtles [
    set neighboring-turtles (turtles at-points [[-1  1] [ 0  1] [1  1]
                                                [-1  0] [ 0  0] [1  0]
                                                [-1 -1] [ 0 -1] [1 -1]])
    set sides-exposed (9 - (count neighboring-turtles))
  ]
  set ave-metal-temp init-metal-temp
  setup-plots
  do-plots
end


to go
  ;; stop if all turtles are below melting temp
  if (max ([temp] of turtles) < melting-temp) [ stop ]
  ;; otherwise...
  set num-frozen 0
  ask turtles [ cool-turtles ]
  ask turtles [ set-color ]
  ask turtles [ rotate ]
  set ave-metal-temp (mean [temp] of turtles)
  tick
  do-plots
end


;; turtle procedure -- if metal is liquid and it is next to a solid,
;; change its heading to that of the solid; otherwise, just rotate
;; randomly
to rotate
  if (temp >= melting-temp) [
    let frozen-neighbors (neighboring-turtles with [temp <= melting-temp])
    ifelse (any? frozen-neighbors)
      [ set heading ([heading] of (one-of frozen-neighbors)) ]
      [ rt random-float 360 ]
  ]
end


;; turtle procedure -- sets turtle's temp to ave temp of all
;; neighboring turtles and patches added turtle's own temp in twice so
;; it changes more slowly
to cool-turtles
  let total-temp ((sum [temp] of neighboring-turtles) + (room-temp * sides-exposed) + temp)
  set temp (total-temp / 10)
end

;; turtle procedure
to set-color
  ;; create index ranging from 1 to 8 for all melting colors
  let index (floor ((temp - melting-temp) / temp-range)) + 1
  ifelse (index < 0 ) [
    set color white - 1
    set num-frozen (num-frozen + 1)
  ]
  [
    if index >= length colors
      [ set index (length colors) - 1 ]
    set color item index colors
  ]
end


to setup-plots
  set-current-plot ""Average Metal Temperature""
  set-plot-y-range room-temp init-metal-temp

  set-current-plot ""Number Solidified""
  set-plot-y-range 0 count turtles

  set-current-plot ""Temperatures""
  set-plot-y-range 0 count turtles
  set-histogram-num-bars 1 + (length colors)
  make-histogram-pens
end

to make-histogram-pens
  let bottom (round room-temp)
  let top (round melting-temp)
  let index 0
  foreach colors [
    create-temporary-plot-pen (word bottom "" - "" top)
    set-plot-pen-mode 1
    set-plot-pen-color ?
    set pens lput (word bottom "" - "" top) pens

    set index index + 1
    set bottom top
    set top (round ((index * temp-range) + melting-temp))
  ]
end

to do-plots
  set-current-plot ""Average Metal Temperature""
  plot ave-metal-temp
  set-current-plot ""Number Solidified""
  plot num-frozen
  if histogram? [ do-histogram ]
end

to do-histogram
  set-current-plot ""Temperatures""
  let index 0
  foreach colors [
    set-current-plot-pen (item index pens)
    plot-pen-reset
    if any? turtles with [color = ?]
      [ plotxy index count turtles with [color = ?] ]
    set index index + 1
  ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2002 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2002).  NetLogo Crystallization Basic model.
; http://ccl.northwestern.edu/netlogo/models/CrystallizationBasic.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2002 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/CrystallizationBasic
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
As a metal cools, it solidifies.  The first atoms to solidify have a random orientation.  But when an atom solidifies next to an already solidified atom, the first atom orients itself with the solid atom, thus creating a crystal ""grain"".  As more atoms solidify, the grains grow.  Within each grain, all the atoms are oriented the same, but different grains have different orientations.

Two grains next to each other form what is called a grain boundary.  When a metal is stressed, such as when it is pulled from both ends, deformations occur in the crystal structure.  As more stress is applied, these deformations pass through the crystal structure, allowing the metal to bend.  Grain boundaries prevent deformations from flowing through the metal.  Therefore, pieces of metal with fewer grain boundaries tend to be ductile, while pieces of metal with more grain boundaries tend to be brittle.

This model shows how grains are formed as a metal crystallizes.  In it, liquid metal is placed in a room with a constant temperature much lower than that of the metal.  As heat leaves the metal, the metal begins to solidify.  Liquid atoms are free to rotate, but solid atoms (gray) are literally frozen.  If a liquid atom is next to a solid atom, it will orient itself with it, otherwise it will rotate randomly.  (Note that the actual number of atoms is small compared to a real metal sample and the metal is only two-dimensional.)


HOW TO USE IT
-------------
Buttons:
SETUP: Resets the simulation, and sets the metal to the correct size.
GO-ONCE: Runs the simulation for one time step.
GO: Runs the simulation continuously until either the GO button is pressed again, or all of the atoms are frozen.

Sliders:
WIDTH: How many atoms wide the metal is.
HEIGHT: How many atoms high the metal is.  (Ignored if CIRCLE? switch is on.)
ROOM-TEMP: Varies the temperature of the room.
INIT-METAL-TEMP: Varies the initial temperature of the metal.
MELTING-TEMP: Varies the temperature at which the metal solidifies.

Monitors:
AVE-METAL-TEMP: Monitors the average temperature of all the atoms.
TIME: Keeps track of the time that has elapsed during each run.

Switches:
CIRCLE?: If on, pressing SETUP produces a circular piece of metal.  Otherwise, you get a square or rectangular piece of metal. (If CIRCLE? is on, the size of the circle is determined by the WIDTH slider, and the HEIGHT slider is ignored.)
HISTOGRAM?: Turns the histogram plotting on and off.  Turning off the histogram speeds up the model.

Graphs:
AVERAGE METAL TEMPERATURE: Plots the average temperature of all the metal over time.
NUMBER SOLIDIFIED: Plots how many metal atoms are below the melting temperature over time.
TEMPERATURES:  Histograms how many atoms are in each temperature range.  (Note that the colors of the histogram match the actual colors of the atoms.)


THINGS TO TRY
---------------
Set HEIGHT to 19.  Try to obtain the largest grains possible by systematically changing the three temperature variables.  Are there multiple settings that achieve this affect?  Now find the settings that result in the smallest grains.  Are there multiple settings that achieve this affect?

Compare the time it takes for the metal to completely crystallize using each of the settings you found in the above paragraph.  To do this, use the TIME monitor.  How does crystallization time relate to grain size?

Keeping the HEIGHT 19, what is the fewest number of grains you can make?  Why can you not make only one grain?  From what part of the metal does crystallization always start from?  Does setting CIRCLE? to OFF make any difference?

Set the ROOM-TEMP to be 20, the INIT-METAL-TEMP to be 1550, and the MELTING-TEMP to be 500.  Set CIRCLE? to OFF.  Now try various settings for HEIGHT and WIDTH.  Which setting achieves the largest size of grains?  Which setting achieves the fewest number of grains?


EXTENDING THE MODEL
-------------------
Some metal applications require that the metal's grains form long strips across the metal.  To achieve this, only one side of the metal is cooled.  This causes all of the crystals to begin on one side of the metal, and consequently grow across its length.  This is called directional solidification.  In the Procedures window, change the code so one side of the room is much cooler than the others.

Other metal applications require that metal consist of a single grain.  One way to do this is to crystallize the metal in a magnetic field.  This induces polarization in the metal atoms, causing them to line up.  Add a procedure to the code that creates a magnetic field in the room.


NETLOGO FEATURES
------------------
In the setup procedure, a turtle is created on every patch within the requested dimensions.  This is achieved by asking every patch satisfying certain conditions to SPROUT 1.

Note how we can draw a multi-colored histogram.  The HISTOGRAM primitive can only draw in one color at a time, but we work around this by calling it over and over again, plotting only one bar each time, changing the pen color each time.

With every time step, each atom's temperature changes to the average of everything around it.  To do this, each turtle has a list of all of its neighboring turtles.  In this model, every patch surrounding a given turtle is either occupied by a turtle or considered to be outside the metal.  Therefore, the new temperature is then taken as the average of the temperatures of the neighbor list, plus the room temperature multiplied by the maximum number of neighbors minus the number of neighbors that particular turtle has.  Therefore, turtles completely surrounded by other turtles don't average in the room temperature to their temperature, but turtles on the edge of the metal will.


RELATED MODELS
--------------
Crystallization Directed
Crystallization Moving


CREDITS AND REFERENCES
----------------------
Original implementation: Carrie Hobbs, for the Center for Connected Learning and Computer-Based Modeling.

To refer to this model in academic publications, please use:  Wilensky, U. (2002).  NetLogo Crystallization Basic model.  http://ccl.northwestern.edu/netlogo/models/CrystallizationBasic.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2002 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/CrystallizationBasic for terms of use.
"
DLA Alternate Linear,/models/Sample Models/Chemistry & Physics/Diffusion Limited Aggregation,"globals [
  next-color  ;; this is the next color we'll use when a new aggregate starts
              ;; (when a particle touches the bottom edge of the world)
]

breed [ movers mover ]     ;; gray particles zooming down from the top
breed [ stayers stayer ]   ;; colored particles that stay where they are


;; throughout, we assume that the turtles are all of size 1.
;; to support different-sized turtles, minor adjustments
;; would be needed.

to setup
  clear-all
  set-default-shape turtles ""circle""  ;; applies to both breeds
  set next-color gray                 ;; first aggregate will be gray
end

to go
  ;; if any aggregates reach the top of the world, we're done
  if any? stayers with [pycor = max-pycor] [
    ask movers [ die ]
    stop
  ]
  ;; make one new falling particle per tick
  make-mover
  ;; we sort the green particles by who number, because we
  ;; need to make sure that closer particles move before farther
  ;; particles, otherwise we could get wrong results when two
  ;; greens are very close together.  SORT reports a list and
  ;; not an agentset (since agentsets are always in random
  ;; order), so we use FOREACH to iterate over the sorted list
  foreach sort movers [ ask ? [ move ] ]
  tick
end

to make-mover
  create-movers 1 [
    ;; start at a random location along the top edge
    setxy random-xcor max-pycor
    ;; head down
    set heading 180
  ]
end

to move  ;; mover procedure
  ;; any greens within a 2 step radius are potential
  ;; candidates for colliding with.  (Remember, in-radius
  ;; measures the distances between turtles' centers; but
  ;; we're checking for how far apart the edges are, hence
  ;; the 2 step radius: 1 is the sum of the two radii, and
  ;; another 1 for the distance from edge to edge.)  The
  ;; closest one we find is the one we actually collide with.
  let blocker min-one-of (stayers in-radius 2)
               [ collision-distance myself ]
  ;; if there's nothing within 2 steps, then we're free
  ;; to take a step forward
  if blocker = nobody
    [ fd 1
      if ycor = min-pycor
       [ set breed stayers
         set color next-color
         ;; the next aggregate that starts will be a new color
         set next-color next-color + 10 ]
      stop ]
  ;; see how far away the one we're about to collide with is.
  let dist [collision-distance myself] of blocker
  ;; if it's more than one step away, we're still free to
  ;; take a step forward.
  if dist > 1
    [ fd 1
      stop ]
  ;; otherwise, go forward until we're just touching the
  ;; ""blocker"", then cease any further motion
  fd dist
  set breed stayers
  ;; turn the same color as the particle we touched
  set color [color] of blocker
end

to fall  ;; mover procedure
  fd min list 1 (ycor + max-pycor)
end

;; essentially what all this math does is compute the intersection
;; point between a line and a circle.  the line is the straight path the
;; center point of the moving particle is following.  the circle is
;; a circle of radius 1 around the center of the stationary particle.
;; see http://mathworld.wolfram.com/Circle-LineIntersection.html
;; The details of the math are hard to follow, but the gist of it
;; is that the system of two equations, one for the circle and one
;; for the line, can be combined into a single quadratic equation,
;; and then that equation can be solved by the quadratic formula.
;; Note the strong resemblance of the formulas on the web page
;; to the quadratic formula.
to-report collision-distance [ incoming ]  ;; stayer procedure
  let x1 [xcor] of incoming - xcor
  let y1 [ycor] of incoming - ycor
  let d-x sin [heading] of incoming
  let d-y cos [heading] of incoming
  let x2 x1 + d-x
  let y2 y1 + d-y
  let big-d x1 * y2 - x2 * y1
  let discriminant 1 - big-d ^ 2
  ;; if the discriminant isn't positive, then there is no collision.
  if discriminant <= 0
    [ report false ]
  ;; the line and the circle will intersect at two points.  we find
  ;; both points, then look to see which one is closer
  let new-x-1 (   big-d *  d-y + sign-star d-y * d-x * sqrt discriminant)
  let new-y-1 ((- big-d) * d-x + abs       d-y       * sqrt discriminant)
  let new-x-2 (   big-d *  d-y - sign-star d-y * d-x * sqrt discriminant)
  let new-y-2 ((- big-d) * d-x - abs       d-y       * sqrt discriminant)
  let distance1 sqrt ((x1 - new-x-1) ^ 2 + (y1 - new-y-1) ^ 2)
  let distance2 sqrt ((x1 - new-x-2) ^ 2 + (y1 - new-y-2) ^ 2)
  ifelse distance1 < distance2
    [ report distance1 ]
    [ report distance2 ]
end

to-report sign-star [ x ]
  report ifelse-value (x < 0) [-1] [1]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2005 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2005).  NetLogo DLA Alternate Linear model.
; http://ccl.northwestern.edu/netlogo/models/DLAAlternateLinear.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2005 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/DLAAlternateLinear
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
Like the main DLA model, this model demonstrates diffusion-limited aggregation.  In this variant, instead of particles forming a circular aggregate that grows from a central point, particles form vertical aggregates that grow along an edge.

In diffusion limited aggregation, particles moving (diffusing) in random trajectories stick together (aggregate) to form beautiful treelike branching fractal structures.  There are many patterns found in nature that resemble the patterns produced by this model: crystals, coral, fungi, lightning, and so on.

This model has ""Alternate"" in its name because, like DLA Alternate, it is based on slightly different rules than the main DLA model.  In the main model, the aggregate forms on a grid.  In this version, there is no grid; the particles are circles and we do the necessary calculations to determine exactly when the circles touch each other.  That makes this version more complicated, but arguably more physically accurate.


HOW IT WORKS
------------
Gray particles fall from the top of the world, straight down.  When a falling particle touches the floor, or a stationary particle, the falling particle stops moving.  Periodically, a new particle is created to keep the process going.

When a particle touches the floor, it changes color.  When a particle touches another particle, it takes that particle's color.  That makes it easy to see the separate aggregates that form.


HOW TO USE IT
-------------
Press SETUP, then press GO.

SETUP - eliminates all existing particles and starts over

GO - runs the simulation


THINGS TO NOTICE
----------------
Stuck particles block the passage of falling particles.  We get black areas that do not have any stuck particles, because the falling particles are moving in straight lines, so they cannot work their way in to fill the black areas.

The simulation runs slower as it goes on.  That's because there are more and more particles in the view that have to be redrawn.  If you freeze the view, the model will always run at the same speed.  You can also use the speed slider to ""fast forward"" the model.

The number of ""live"" aggregates (that can still grow) decreases over time.


THINGS TO TRY
-------------
Try changing the size of the world (by editing the view).  What happens when the world is very tall?  How many live aggregates do you end up with?


EXTENDING THE MODEL
-------------------
Create a plot showing the number of live aggregates over time.  Over several runs, does this graph have a typical shape?

Introduce a ""wiggle"" into the path of falling particles.  That means that just before the particle moves forward, it turns a bit, randomly.  How does the affect the aggregate?  Experiment with different amounts of wiggle.


NETLOGO FEATURES
----------------
The code is mostly the same as in DLA Alternate.

In particular, the COLLISION-DISTANCE procedure, the one with all the hairy math, is the same.  It would actually be possible to use simpler math in this model, because we know that only the y coordinate of the moving particle is changing, while its x coordinate remains the same.


RELATED MODELS
--------------
DLA and DLA Alternate are the same idea, but with particles all falling towards a central point instead of straight down.


CREDITS AND REFERENCES
----------------------
The mathematical procedures used in calculating the collision paths comes from: Eric W. Weisstein, ""Circle-Line Intersection"". From MathWorld--A Wolfram Web Resource.  http://mathworld.wolfram.com/Circle-LineIntersection.html

To refer to this model in academic publications, please use:  Wilensky, U. (2005).  NetLogo DLA Alternate Linear model.  http://ccl.northwestern.edu/netlogo/models/DLAAlternateLinear.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2005 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/DLAAlternateLinear for terms of use.
"
DLA Simple,/models/Sample Models/Chemistry & Physics/Diffusion Limited Aggregation,"to setup
  clear-all
  ask patch 0 0
    [ set pcolor green ]
  create-turtles num-particles
    [ set color red
      set size 1.5  ;; easier to see
      setxy random-xcor random-ycor ]
end

to go
  ask turtles
    [ right random wiggle-angle
      left random wiggle-angle
      forward 1
      if any? neighbors with [pcolor = green]
        [ set pcolor green
          die ] ]
  tick
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2006 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2006).  NetLogo DLA Simple model.
; http://ccl.northwestern.edu/netlogo/models/DLASimple.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2006 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/DLASimple
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
Like the main DLA model, this model demonstrates diffusion-limited aggregation, in which particles moving (diffusing) in random trajectories stick together (aggregate) to form beautiful treelike branching fractal structures. There are many patterns found in nature that resemble the patterns produced by this model: crystals, coral, fungi, lightning, and so on.

This model is called DLA Simple because it is it is a simplified version of the main DLA model. In the main model, new particles are created as existing particles aggregate. In this model, particles are only created at the beginning. The main model is more computationally efficient, but the rules that drive the phenomenon are more digestible in this model.


HOW TO USE IT
-------------
Press SETUP to make the initial seed, then press GO to run the model.


THINGS TO NOTICE
----------------
Note that the resulting structure has a branching structure, like a tree.  Why does this happen?

What other phenomena in the world do the shapes remind you of?  Is this aggregation process a plausible model of how those phenomena occur?


THINGS TO TRY
-------------
Try different settings for how much the turtles turn as they do their random walk (the WIGGLE-ANGLE slider).  What is the effect on the appearance of the resulting aggregate?  Why?

Does it make any difference whether there are more or fewer particles?  Why or why not?


EXTENDING THE MODEL
-------------------
What happens if you start with more than one ""seed"" patch?  What happens if the seed is a line instead of a point?

Can you find a way to modify the code so the resulting pattern spirals out instead of radiating straight out?

The rule used in this model is that a particle ""sticks"" if any of the eight patches surrounding it are green.  What do the resulting structures look like if you use a different rule (for example, only testing the single patch ahead, or using NEIGHBORS4 instead of NEIGHBORS)?

Can you compute the fractal dimension of the aggregate?

If instead of using green, you gradually vary the color of deposited particles over time, you can see more vividly the accretion of ""layers"" over time.  (The effect is also visually pleasing.)

The model will run faster if the turtles are invisible, so you may want to add a switch that hides them (using the HT command).


NETLOGO FEATURES
----------------
Note the use of the NEIGHBORS primitive.


RELATED MODELS
--------------
The DLA model is a more complicated (but more computationally efficient) model than this one.

The various models in the ""Fractals"" subsection of the ""Mathematics"" section of the Models Library demonstrate some other ways of ""growing"" fractal structures.

The ""Percolation"" model in the ""Earth Science"" section produces patterns resembling the patterns in this model.


CREDITS AND REFERENCES
----------------------
The concept of diffusion limited aggregation was invented by T.A. Witten and L.M. Sander in 1981.  Tamas Viczek's book ""Fractal Growth Phenomena"" contains a discussion, as do many other books about fractals.

To refer to this model in academic publications, please use:  Wilensky, U. (2006).  NetLogo DLA Simple model.  http://ccl.northwestern.edu/netlogo/models/DLASimple.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2006 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/DLASimple for terms of use.
"
DLA Alternate,/models/Sample Models/Chemistry & Physics/Diffusion Limited Aggregation,"breed [ movers mover ]     ;; red particles zooming in from the edges
breed [ stayers stayer ]   ;; green particles that stay where they are

;; throughout, we assume that the turtles are all of size 1.
;; to support different-sized turtles, minor adjustments
;; would be needed.

to setup
  clear-all
  set-default-shape turtles ""circle""
  ;; note that the single stayer is created in the center (patch 0 0)
  create-stayers 1
    [ set color green ]
end

to go
  ;; if any part of the aggregate gets close to the edge
  ;; of the view, then we're done
  if any? stayers with [distancexy 0 0 > max-pxcor - 1] [
    ask movers [ die ]
    stop
  ]
  ;; make one new red particle per tick
  make-mover
  ;; we sort the green particles by who number, because we
  ;; need to make sure that closer particles move before farther
  ;; particles, otherwise we could get wrong results when two
  ;; greens are very close together.  SORT reports a list and
  ;; not an agentset (since agentsets are always in random
  ;; order), so we use FOREACH to iterate over the sorted list
  foreach sort movers [ ask ? [ move ] ]
  tick
end

to make-mover
  create-movers 1 [
    ;; move to the perimeter of a circle the same
    ;; size as the world
    set color red
    jump max-pxcor
    ;; and point inward
    rt 180
  ]
end

to move  ;; mover procedure
  ;; any greens within a 2 step radius are potential
  ;; candidates for colliding with.  (Remember, in-radius
  ;; measures the distances between turtles' centers; but
  ;; we're checking for how far apart the edges are, hence
  ;; the 2 step radius: 1 is the sum of the two radii, and
  ;; another 1 for the distance from edge to edge.)  The
  ;; closest one we find is the one we actually collide with.
  let blocker min-one-of (stayers in-radius 2)
               [collision-distance myself]
  ;; if there's nothing within 2 steps, then we're free
  ;; to take a step forward
  if blocker = nobody
    [ fd 1
      stop ]
  ;; see how far away the one we're about to collide with is.
  let dist [collision-distance myself] of blocker
  ;; if it's more than one step away, we're still free to
  ;; take a step forward.
  if dist > 1
    [ fd 1
      stop ]
  ;; otherwise, go forward until we're just touching the
  ;; ""blocker"", then cease any further motion
  fd dist
  set breed stayers
  set color green
end

;; essentially what all this math does is compute the intersection
;; point between a line and a circle.  the line is the straight path the
;; center point of the moving particle is following.  the circle is
;; a circle of radius 1 around the center of the stationary particle.
;; see http://mathworld.wolfram.com/Circle-LineIntersection.html
;; The details of the math are hard to follow, but the gist of it
;; is that the system of two equations, one for the circle and one
;; for the line, can be combined into a single quadratic equation,
;; and then that equation can be solved by the quadratic formula.
;; Note the strong resemblance of the formulas on the web page
;; to the quadratic formula.
to-report collision-distance [incoming]  ;; stayer procedure
  let x1 [xcor] of incoming - xcor
  let y1 [ycor] of incoming - ycor
  let d-x sin [heading] of incoming
  let d-y cos [heading] of incoming
  let x2 x1 + d-x
  let y2 y1 + d-y
  let big-d x1 * y2 - x2 * y1
  let discriminant 1 - big-d ^ 2
  ;; if the discriminant isn't positive, then there is no collision.
  ;; note that there cannot be tangency (discriminant = 0) because the
  ;; turtles' trajectories are all along radii of the same circle
  if discriminant <= 0
    [ report false ]
  ;; the line and the circle will intersect at two points.  we find
  ;; both points, then look to see which one is closer
  let new-x-1 (   big-d *  d-y + sign-star d-y * d-x * sqrt discriminant)
  let new-y-1 ((- big-d) * d-x + abs       d-y       * sqrt discriminant)
  let new-x-2 (   big-d *  d-y - sign-star d-y * d-x * sqrt discriminant)
  let new-y-2 ((- big-d) * d-x - abs       d-y       * sqrt discriminant)
  let distance1 sqrt ((x1 - new-x-1) ^ 2 + (y1 - new-y-1) ^ 2)
  let distance2 sqrt ((x1 - new-x-2) ^ 2 + (y1 - new-y-2) ^ 2)
  ifelse distance1 < distance2
    [ report distance1 ]
    [ report distance2 ]
end

to-report sign-star [x]
  report ifelse-value (x < 0) [-1] [1]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2005 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2005).  NetLogo DLA Alternate model.
; http://ccl.northwestern.edu/netlogo/models/DLAAlternate.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2005 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/DLAAlternate
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
Like the main DLA model, this model demonstrates diffusion-limited aggregation, in which particles moving (diffusing) in random trajectories stick together (aggregate) to form beautiful treelike branching fractal structures.  There are many patterns found in nature that resemble the patterns produced by this model: crystals, coral, fungi, lightning, and so on.

This model is called DLA Alternate because it is based on slightly different rules than the main DLA model.  In the main model, the aggregate forms on a grid.  In this version, there is no grid; the particles are circles and we do the necessary calculations to determine exactly when the circles touch each other.  That makes this version more complicated, but arguably more physically accurate.


HOW IT WORKS
------------
A single green particle is created in the center (patch 0 0).  Red particles move in from the periphery in straight trajectories.  When a moving red particle touches a stationary green particle, the red particle turns green and stops moving.  Periodically, a new red particle is created to keep the process going.


HOW TO USE IT
-------------
Press SETUP, then press GO.

SETUP - eliminates all existing particles, initializes variables, and creates one new green particle in the center.

GO - creates a particle on the periphery that moves in towards the center.  Because GO is a forever button, you will see many particles moving in.


THINGS TO NOTICE
----------------
Green particles block the passage of red particles. We get black areas that do not have any green turtles, because the red particle are moving in straight lines, so they cannot work their way in to fill the black areas.

The red particles first appear on the perimeter of a large circle around the center of the display window.

What does the green shape remind you of?  Can you think of any process in nature that could possibly generate an object of this shape?

Particles move in order, according to their distances from the center -- closer particles move before farther particles, and each particle moves just one step at a time.


THINGS TO TRY
-------------
Run the program slowly (using the speed slider in the top-left corner of the display window).  Watch how the red particles take turns in moving forward.  See that only after each one of the red particles has moved, a new particle is created, which enters from the periphery.

Run the simulation until it stops.  Now, beginning from the center, choose one of the ""branches"" and follow along outwards.  At every node (a ""fork in the road""), add 1, and then choose randomly between the two branches.  How many nodes did you find along the way? Is it this number the same for any route you choose?


EXTENDING THE MODEL
-------------------
What happens if you start with more than one ""seed"" patch?  What happens if the seed is a line instead of a point?

Create a graph showing the number of green particles over time.  Over several runs, does this graph have a typical shape?

Let's use the term ""envelope"" to describe the large ""circle"" created by all the green particles, with the green particle that is farthest from the center defining the radius of this envelope.  Within this envelope, what is the ratio between patches with green particles and patches that have no particles?  Or, what is the ratio between particles and patches?  Create a graph to track this ratio.  Create a histogram that accumulates the end value of this process over multiple runs.

How circular is the envelope at the end of a simulation? Is it ""smooth?"" - ""bumpy?"" How would you define the goodness of this circle?

Introduce a ""wiggle"" into the path of red particles.  That means that just before the particle moves forward, it turns a bit, randomly.  Should this affect the aggregation of green particles?  One way to think of this extension is that you are modeling the DLA in different media, for instance in water or some chemical of different viscosity, or that there are currents in the liquid that jostle the particles about.

Let's use the term ""end particles"" to describe the green particles at the end of an outward reaching branch (so they are connected only to one other particle).  Create a procedure to calculate and report the average number of nodes along all the possible paths from the center to the end particles).  You can also create a histogram of these values.

How many ""end particles"" are there over time?  It seem likely that this number should grow, but how would you expect this number to grow?  Create a graph to track the growth in the number of these ""end particles.""

What is the ratio between ""end particles"" and nodes?  Does this ratio change over time?  Create a graph to track this ratio as the simulation runs.

Create a procedure that allows you to click on any two green particles and have another moving particle sprout at the first green particle you clicked and then track and color the path between these two green particles. What is the longest path between any two green particles?  Is this number bound above?


NETLOGO FEATURES
----------------
Note the use of SORT to make turtles execute in order by who number (meaning, oldest turtles first).  Because SORT reports a list, we must use FOREACH to iterate over the list in order to ASK each agent in it.


RELATED MODELS
--------------
The main DLA model is a simpler implementation of the same idea; it uses grid cells instead of touching circles to form the aggregate.

DLA Alternate Linear has particles that fall straight down from the top of the world, instead of falling towards a central point.


CREDITS AND REFERENCES
----------------------
The mathematical procedures used in calculating the collision paths comes from:
Eric W. Weisstein.  ""Circle-Line Intersection.""
From MathWorld--A Wolfram Web Resource.
http://mathworld. wolfram.com/Circle-LineIntersection.html

To refer to this model in academic publications, please use:  Wilensky, U. (2005).  NetLogo DLA Alternate model.  http://ccl.northwestern.edu/netlogo/models/DLAAlternate.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2005 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/DLAAlternate for terms of use.
"
DLA,/models/Sample Models/Chemistry & Physics/Diffusion Limited Aggregation,"globals [
  radius   ;; distance of the farthest green patch from the center
]

to setup
  clear-all
  set radius 0
  ask patch 0 0
    [ set pcolor green ]
end

to go
  ;; stop when we get near the edge of the world
  if radius >= max-pxcor - 3
    [ stop ]
  ;; make new turtles, up to a maximum controlled by the MAX-PARTICLES
  ;; slider; also check clock so we don't make too many turtles too
  ;; soon, otherwise we get a big green clump at the center
  while [count turtles < max-particles and
         count turtles < ticks]
    [ make-new-turtle ]
  ;; now move the turtles
  ask turtles
    [ wander
      if any? neighbors with [pcolor = green]
        [ set pcolor green
          ;; increase radius if appropriate
          if distancexy 0 0 > radius
            [ set radius distancexy 0 0 ]
          die ]
      ;; kill turtles that wander too far away from the center
      if not use-whole-world? and distancexy 0 0 > radius + 3
        [ die ] ]
  ;; advance clock
  tick
end

to make-new-turtle
  ;; each new turtle starts its random walk from a position
  ;; a bit outside the current radius and facing the center
  crt 1
    [ set color red
      set size 3  ;; easier to see
      setxy 0 0
      ifelse use-whole-world?
        [ jump max-pxcor ]
        [ jump radius + 1.5 ]
      rt 180 ]
end

to wander   ;; turtle procedure
  ;; the WIGGLE-ANGLE slider makes our path straight or wiggly
  rt random-float wiggle-angle - random-float wiggle-angle
  ;; kill off particles that reach the edge
  if not can-move? 1 [ die ]
  ;; move
  fd 1
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2002 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2002).  NetLogo DLA model.
; http://ccl.northwestern.edu/netlogo/models/DLA.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2002 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/DLA
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model demonstrates diffusion-limited aggregation, in which randomly moving (diffusing) particles stick together (aggregate) to form beautiful treelike branching fractal structures.  There are many patterns found in nature that resemble the patterns produced by this model: crystals, coral, fungi, lightning, and so on.


HOW IT WORKS
------------
The model begins with an initial green ""seed"" in the center of the world.  Red particles move around the world randomly.  When a red particle hits a green square, it ""sticks"" and turns green (and a new red particle is created to keep the process going).


HOW TO USE IT
-------------
Press SETUP to make the initial seed, then press GO to run the model.

The WIGGLE-ANGLE slider controls how wiggly the paths the particles follow are.  If WIGGLE-ANGLE is 0, they move in straight lines.  If WIGGLE-ANGLE is 360, they move in a totally random direction at each time step.

The MAX-PARTICLES slider controls how many red particles can exist at the same time.

Both settings may be altered in the middle of a model run.

The USE-WHOLE-WORLD? switch controls whether the red particles start at the edge of the world, or from just outside a circle enclosing the green area.  If the switch is on, it's easier to see what's going on, but the model runs slower, particularly when WIGGLE-ANGLE is high.


THINGS TO NOTICE
----------------
Note that the resulting structure has a branching structure, like a tree.  Why does this happen?

What other phenomena in the world do the shapes remind you of?  Is this aggregation process a plausible model of how those phenomena occur?

When the enclosing circle gets too near to the edge of the world, the model stops, since allowing the particles to wrap around the edges of the world would distort the shape of the aggregate.

New red particles are created not at the edge of the world, but at the edge of a circle enclosing the current size of the green aggregate, instead of traveling from the edge of the world.  Also, if a red particle wanders too far outside the circle, it disappears and a new one is created.  Neither of these behaviors is essential to the model -- it is done this way just to the model runs fast.


THINGS TO TRY
-------------
Try different settings for WIGGLE-ANGLE.  What is the effect on the appearance of the resulting aggregate?  Why?

Does the MAX-PARTICLES slider make any difference?  Why or why not?

Do you think the USE-WHOLE-WORLD? setting has an effect on the appearance of the resulting aggregate?  Why or why not?  Experiment and find out.  If you initially thought differently from what you found, why do you think you thought otherwise?  Can you explain why it does happen the way you found?


EXTENDING THE MODEL
-------------------
What happens if you start with more than one ""seed"" patch?  What happens if the seed is a line instead of a point?

Can you find a way to modify the code so the resulting pattern spirals out instead of radiating straight out?

The rule used in this model is that a particle ""sticks"" if any of the eight patches surrounding it are green.  What do the resulting structures look like if you use a different rule (for example, only testing the single patch ahead, or using NEIGHBORS4 instead of NEIGHBORS)?

Can you compute the fractal dimension of the aggregate?

If instead of using green, you gradually vary the color of deposited particles over time, you can see more vividly the accretion of ""layers"" over time.  (The effect is also visually pleasing.)

The model will run faster if the turtles are invisible, so you may want to add a switch that hides them (using the HT command).

Let's use the term ""envelope"" to describe the large ""circle"" created by all the green particles, with the green particle that is farthest from the center defining the radius of this envelope.  Within this envelope, what is the ratio between patches with green particles and patches that have no particles?  Or, what is the ratio between particles and patches?  Create a graph to track this ratio.  Create a histogram that accumulates the end value of this process over multiple runs.

How circular is the envelope at the end of a simulation? Is it ""smooth?"" - ""bumpy?"" How would you define the goodness of this circle?

Let's use the term ""end particles"" to describe the green particles at the end of an outward reaching branch (so they are connected only to one other particle).  Create a procedure to calculate and report the average number of nodes along all the possible paths from the center to the end particles).  You can also create a histogram of these values.

How many ""end particles"" are there over time?  It seem likely that this number should grow, but how would you expect this number to grow?  Create a graph to track the growth in the number of these ""end particles.""

What is the ratio between ""end particles"" and nodes?  Does this ratio change over time?  Create a graph to track this ratio as the simulation runs.

Create a procedure that allows you to click on any two green particles and have another moving particle sprout at the first green particle you clicked and then track and color the path between these two green particles. What is the longest path between any two green particles?  Is this number bound above?


NETLOGO FEATURES
----------------
Note the use of the NEIGHBORS and DISTANCEXY primitives.


RELATED MODELS
--------------
In this model, the green squares are on a grid.  For a different implementation of the same idea that does not involve a grid, see DLA Alternate.  It uses circular particles that stick to each other.

DLA Alternate Linear has particles that fall straight down from the top of the world, instead of falling towards a central point.

DLA Simple is a simplified (but less computationally efficient) version of this model.

The various models in the ""Fractals"" subsection of the ""Mathematics"" section of the Models Library demonstrate some other ways of ""growing"" fractal structures.

The ""Percolation"" model in the ""Earth Science"" section produces patterns resembling the patterns in this model.

The ""Hex Cell Aggregation"" model in the ""Computer Science"" section uses a grid of hexagons, rather than squares, and uses a cellular automaton with a growth rule instead of moving particles.


CREDITS AND REFERENCES
----------------------
The concept of diffusion limited aggregation was invented by T.A. Witten and L.M. Sander in 1981.  Tamas Viczek's book ""Fractal Growth Phenomena"" contains a discussion, as do many other books about fractals.

To refer to this model in academic publications, please use:  Wilensky, U. (2002).  NetLogo DLA model.  http://ccl.northwestern.edu/netlogo/models/DLA.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2002 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/DLA for terms of use.
"
Boiling,/models/Sample Models/Chemistry & Physics/Heat,"patches-own [heat]

to setup
  clear-all
  ask patches [
    set heat random 212
    set pcolor scale-color red heat 0 212
  ]
  plot average-heat
end

to go
  diffuse heat 1
  ask patches [
    ;; warm up patches till they reach 212
    set heat (heat + 5) mod 212
    set pcolor scale-color red heat 0 212
  ]
  tick
  plot average-heat
end

to-report average-heat
  report mean [heat] of patches
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Boiling model.
; http://ccl.northwestern.edu/netlogo/models/Boiling.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Boiling
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This project depicts a simple cellular automata model that appears to be like a pot of boiling water. Heat is applied evenly to the entire pot, but when the temperature of a patch reaches the boiling temperature, the bubble pops and that patch's temperature drops to zero.

If all of a cell's neighbors are at the maximum value of 212, then that cell's new value will be 213 which gets wrapped down to zero. At the next tick, the presence of this zero-valued cell will lower the values of the cell's nearest neighbors. This process is analogous to the way in which a hot enough region of water gives up some heat by forming a bubble of steam. The water right around the steam bubble cools off for a moment.


HOW TO USE IT
-------------
Click the SETUP button to set up a random field of heat.

Click the BOIL button to start adding heat to the pot and watch it boil. The redder the color, the hotter the patch (Black is very cool and white is very hot).


THINGS TO NOTICE
----------------
Watch how the added heat diffuses through the pot. When bubbles pop, the resulting drop in heat affects nearby patches too by taking away their heat.

What happens to the average heat in the pot?


EXTENDING THE MODEL
-------------------
Try diffusing the heat more slowly through the system.

Change the diffuse parameter from 1 to a smaller fraction.

Add ""ice cubes"".

Add a heat sink, such as edges that constantly cool the liquid.


CREDITS AND REFERENCES
-----------------------
This model is described on page 79 in  ""Artificial Life Lab"",  by Rudy Rucker, published in 1993 by Waite Group Press.

To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Boiling model.  http://ccl.northwestern.edu/netlogo/models/Boiling.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Boiling for terms of use.
"
Thermostat,/models/Sample Models/Chemistry & Physics/Heat/Unverified,"turtles-own [ new? ]

globals
[
  temperature
  temperatures
]

to setup
  clear-all
  set-default-shape turtles ""circle""
  set temperature initial-temp
  set temperatures n-values 10 [initial-temp]
  ask patches
  [
    ;; create the thermometer
    if (((abs pxcor) < 5) and
        (pycor < (max-pxcor - 15)) and
        (pycor > (max-pxcor - 25)))
    [ set pcolor green ]
    ;; create the sides of room
    if (((abs pycor) <= (max-pxcor - 7)) and
        ((abs pxcor) =  (max-pxcor - 7)))
    [ set pcolor yellow ]
    ;; create the front and back of room
    if (((abs pycor) =  (max-pxcor - 7)) and
        ((abs pxcor) <= (max-pxcor - 7)))
    [ set pcolor yellow ]
  ]
  ;; create enough turtles to fill room to init-temp temperature
  crt (round (initial-temp * (((world-width - 16) * (world-width - 16)) / 81)))
  [
    set color red
    fd (random-float (max-pxcor - 8))
  ]
  init-plot
  plotter
end

to go
  ask turtles
  [ circulate-heat ]
  take-temperature
  thermo-control  ;; the control for the thermostat
  tick
  plotter
end

to thermo-control
  ifelse (temperature < goal-temp )
  [
    run-heater
    ask patches  ;; show the heater
    [
      if (((distancexy 0 0) <= 2))
      [ set pcolor  white ]
    ]
  ]
  [
    ask patches
    [
      if (((distancexy 0 0) <= 2))  ;; hide the heater
      [ set pcolor black ]
    ]
  ]
end

to run-heater
  crt heater-strength
  [
    if (new? = 0)
    [ set new? 1 ]
    set color red
  ]
end

to circulate-heat  ;; turtle procedure
  if (pcolor = yellow)
  [
    ;; to be reflected back into the room, turtles choose a random point
    ;; inside and set their heading in that direction. This diffuses the
    ;; heat evenly around the room.
    if ((random-float insulation) > 1)
    [
      facexy ((random-float (world-width - 13)) - (max-pxcor - 6))
                            ((random-float (world-width - 14)) - (max-pxcor - 6))
    ]
  ]
  fd 1
  if not can-move? 1
  [ die ]
end

to take-temperature
  set temperatures but-last fput count turtles with [ pcolor = green ] temperatures
  set temperature mean temperatures
end

to init-plot
  set-current-plot ""Temperature""
  set-plot-y-range 0 (goal-temp * 2)
end

to plotter
  set-current-plot ""Temperature""
  set-current-plot-pen ""temperature""
  plot temperature
  set-current-plot-pen ""goal-temp""
  plot goal-temp
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Thermostat model.
; http://ccl.northwestern.edu/netlogo/models/Thermostat.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Thermostat
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
A thermostat is a device that responds to the temperature of a room in order to maintain the temperature at some desired level.  This is often used as an example of feedback control, where a system adjusts its behavior in response the effects of its prior behavior.

Generally speaking, heating systems have only two settings - on and off - and it is the job of the thermostat to turn the heater on and off at the appropriate times. A simple thermostat does this by switching the heater on when the temperature of the room has fallen below the set desired temperature, and switching the heater off once the desired temperature has been reached or exceeded.


HOW IT WORKS
------------
In this model, the red turtles represent heat, and the yellow border demarcates the room whose temperature is being regulated. The yellow border is semi-permeable, allowing some of the heat that hits it to escape from the room. This heat disappears from the model once it reaches the edge of the world. A thermometer, indicated by the green square, measures the approximate temperature of the room (effectively, the density of red turtles). The heater is located in the center of the room, represented by a white patch.

It should be noted that use of turtles in this model to represent heat is not intended to be physically realistic. Instead, it is an example where a model is simplified in such a way so as to make another feature of the model more salient. In this case, it is the regulating function of the thermostat that we are primarily concerned with.


HOW TO USE IT
-------------
GO: Starts and stops the simulation.
SETUP: Resets the simulation, and sets the initial temperature according to init-temp.
TEMPERATURE: Monitors the temperature in the room, as detected by the green box near the top.
GOAL-TEMP: The thermostat aims to maintain the room at this temperature. It may be adjusted in the middle of a simulation.
HEATER-STRENGTH: The number of red turtles created by the heater in a tick (if the heater is 'on').
INSULATION: The efficiency of the room's insulation, or the rate at which heat escapes from the room. Higher numbers allow less heat to escape; lower number numbers allow more. This may be adjusted during a simulation.
INITIAL-TEMP: The initial temperature of the room. This takes effect only when the SETUP button is pressed.

There is also a plot, which tracks the temperature over time (in red) and the desired temperature (in green).

THINGS TO NOTICE
----------------

With some settings, the room cannot be heated to the desired temperature (for example, the room attains a maximum temperature that is lower than the desired temperature). Under what circumstances does this happen?

Look at the plot: does the thermostat do a good job of keeping the temperature at the desired level? If we hold the variables constant, to what factors can we attribute fluctuations of the temperature (in red) over the desired temperature (in green)?

Try adjusting the insulation of the room and the strength of the heater. Do these factors affect the efficiency of the thermostat (i.e. cause the temperature to stay closer or further from the desired temperature)?

Notice that there is a delay from the time the heater is turned on to the time when this added heat reached the thermometer. What are the consequences of this delay?

EXTENDING THE MODEL
-------------------

The thermostat in this model uses a very simple rule to control the heater based on the temperature. It might be possible to improve the performance of this system by making it 'smarter'. One suggestion is to write a control program that turns the heater on and off before the temperature hits the desired temperature - this would compensate for the delay mentioned above. Try rewriting the function THERMO-CONTROL. Keep in mind that the only inputs your control function should have are GOAL-TEMP and TEMPERATURE, and the only action should be to either call RUN-HEATER or not. Notice this leaves open the possibility of creating variables to store past information.

Much of observed instability in the temperature might simply be attributed to the thermometer that we are using. The current thermometer takes an average of the number of turtles occupying the green patches over the past ten ticks. Why do you suppose we are measuring the temperature in such a way, instead of simply counting the number of turtles inside the room? Can you design a better thermometer?

This model doesn't account for how the outside temperature (outside the yellow box) could effect the inside temperature.  Alter the model so that this now becomes a factor.

The heater in this model puts out heat at a fixed rate, regardless of how long it has been on. Real heaters generally have a warm up period during which time they slowly increase their output, until they reach their maximum rate. Try adjusting the heater in this model to act more like a real heater. How does this affect the behavior or efficiency of the thermostat? How might we alter THERMO-CONTROL to account for this?

Begin a simulation with INITIAL-TEMP set to zero, and notice how long it takes to heat up the room. This means that if we wanted to warm the room up at a certain time it might make sense to turn the heater on beforehand. Introduce time into this model, and try adjusting the thermostat so that it heats the room according to some schedule.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Thermostat model.  http://ccl.northwestern.edu/netlogo/models/Thermostat.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Thermostat for terms of use.
"
Heat Diffusion,/models/Sample Models/Chemistry & Physics/Heat/Unverified,"patches-own
[
  old-temperature  ;; the temperature of the patch the last time thru go
  temperature  ;; the current temperature of the patch
]

globals
[
  plate-size  ;; the size of the plate on which heat is diffusing
  ;; Used for scaling the color of the patches
  min-temp  ;; the minimum temperature at setup time
  max-temp  ;; the maximum temperature at setup time
]


;;;;;;;;;;;;;;;;;;;;;;;;
;;; Setup Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;
to setup
  clear-all
  ;; initialize variables
  set plate-size round (0.6 * max-pxcor)  ;; use 0.6 to make a nice sized plate

  ;; set up the plate
  ask patches
  [
    set pcolor gray
    set-initial-temperatures
    set-edge-temperatures
    set old-temperature temperature
  ]
  set min-temp min [old-temperature] of patches
  set max-temp max [old-temperature] of patches
  draw-legend
  ask patches [ draw-plate ]
end

;; Sets the temperature for inside of the plate
to set-initial-temperatures  ;; Patch Procedure
  if ((abs pycor) < plate-size) and ((abs pxcor) < plate-size)
  [set temperature initial-plate-temp]
end

;; Draws the Color Scale Legend
to draw-legend  ;; Patch Procedure
  let x (1 + min-pxcor)
  repeat 3
  [
    let y 0
    repeat 10
    [
      ask patch (x + 4) (y * 2 - 11) [ set temperature (y * 10) ]
      ask patch (x + 4) (y * 2 - 10) [ set temperature (y * 10) ]
      set y y + 1
    ]
    set x x + 1
  ]

  set x (1 + min-pxcor)
  repeat 3
  [
    let y 0
    repeat 10
    [
      ask patch (x + 4) (y * 2 - 11) [color-patch ]
      ask patch (x + 4) (y * 2 - 10) [color-patch ]
      set y y + 1
    ]
    set x x + 1
  ]


  set x (1 + min-pxcor)
  repeat 3
  [
    let y 0
    repeat 11
    [
      if (x = (3 + min-pxcor)) [ ask patch  x (y * 2 - 12) [ set plabel (y * 10) ] ]
    set y y + 1
    ]
    set x x + 1
  ]

end

;; Sets the temperatures of the plate edges and corners
to set-edge-temperatures  ;; patch procedure
  ;; set the temperatures of the edges
  if (pxcor >= plate-size) and ((abs pycor) < plate-size)
  [set temperature right-temp]
  if (pxcor <= (- plate-size)) and ((abs pycor) < plate-size)
  [set temperature left-temp]
  if (pycor >= plate-size) and ((abs pxcor) < plate-size)
  [set temperature top-temp]
  if (pycor <= (- plate-size)) and ((abs pxcor) < plate-size )
  [set temperature bottom-temp]

  ;; set the temperatures of the corners
  if (pxcor >= plate-size) and (pycor >= plate-size)
  [set temperature 0.5 * (right-temp + top-temp)]
  if (pxcor >= plate-size) and (pycor <= (- plate-size))
  [set temperature 0.5 * (right-temp + bottom-temp)]
  if (pxcor <= (- plate-size)) and (pycor >= plate-size)
  [set temperature 0.5 * (left-temp + top-temp)]
  if (pxcor <= (- plate-size)) and (pycor <= (- plate-size))
  [set temperature 0.5 * (left-temp + bottom-temp)]
end


;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Runtime Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Runs the simulation through a loop
to go
  ask patches
  [
    ;; diffuse the heat of a patch with its neighbors
    set temperature (heat-diffusivity * (sum [old-temperature] of neighbors4)) + ((1 - ( 4 * heat-diffusivity )) * old-temperature)
    ;; set the edges back to their constant heat
    set-edge-temperatures
    set old-temperature temperature
    draw-plate
  ]
  tick
end

;; Draws the patches that are within the plate
to draw-plate  ;; Patch Procedure
  if ((abs pycor) <= plate-size) and ((abs pxcor) <= plate-size)
  [color-patch]
end

;; color the patch based on its temperature
to color-patch  ;; Patch Procedure
  set pcolor scale-color red temperature min-temp max-temp
end

;; report the heat diffusivity constant that we use for the calculations
to-report heat-diffusivity
  ;; a few notes on the constants used here:
  ;; --we use .25 as a time step that causes the heat to diffuse at a reasonable pace
  ;; --we use alpha + .3 instead of just alpha here since alpha would be too
  ;; small to view any changes between some of the preset materials
  ;; --these constants are necessary since this model uses an Euler approximation to
  ;; calculate the temperature.  the approximation is only valid within a certain range
  ;; of time-steps and this range changes depending upon the value of alpha.
  report .25 * e ^ (-1 / (alpha + .3))
end

;; Sets the material
to update-alpha
  ifelse (material-type = ""wood"") ;; wood
  [ set alpha 0.00128 ]
  [
    ifelse (material-type = ""stone"") ;; stone
    [ set alpha 0.012 ]
    [
      ifelse (material-type = ""iron"")  ;; iron
      [ set alpha 0.2034 ]
      [
        ifelse (material-type = ""aluminum"") ;; aluminum
        [ set alpha 0.8418 ]
        [
          ifelse (material-type = ""silver"")  ;; silver
          [ set alpha 1.7004 ]
          [ user-message ""Choose your own value for alpha!"" ]
        ]
      ]
    ]
  ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Heat Diffusion model.
; http://ccl.northwestern.edu/netlogo/models/HeatDiffusion.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/HeatDiffusion
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model simulates transient and steady-state temperature distribution of a thin plate.

The View shows a square thin plate as viewed from above.  The plate is thermally isolated on the two faces parallel to the view such that heat can flow only in and out from the perimeter of the plate and not into or out of the world.  Heat is kept constant at the edges.  As the simulation runs, heat is transmitted from warmer parts of the plate to cooler parts of the plate as shown by the varying color of the plate.  Therefore, the temperature of the plate begins to change immediately and possibly differently at different locations, gradually converging to a stable state.  Overall, the temperature distribution over the plate is a function of time and location.  In addition to this simple use of the model, you are encouraged to control various paramaters, such as the temperature of each edge edge of the plate and of the center of the plate before--and even while--the model is running.

Heat diffuses (""spreads"") at different rates through different media.  These rates can be determined and are called the Thermal Diffusivity of the material.  The Greek letter alpha is often associated with this value.  The diffusivity of a material does not change based on how much of the material there is.  It is always the same.  Below is a table containing several different materials with different diffusivity rates.  See that wood (bottom row) has a lower heat diffusivity than, say, iron.  This means that it takes a longer for heat to spread through a wooden object than an iron one.  That is one reason why the handles of iron saucepans are wooden, and not the other way round.  Also, think of a marble table with iron legs that has just been put out in the sun in a street-side cafe.  Which material part of the table do you expect will warm up faster?  The model allows you to change thermal diffusivity of the plate in two ways.  You can directly change the value of ALPHA to any value you like, or you can indirectly change ALPHA by selecting a material.

|  THERMAL DIFFUSIVITY OF SELECTED MATERIALS
|
|  Material       Thermal diffusivity
|                 (alpha cm*cm/s)
|
|  Wood (Maple)   0.00128
|  Stone (Marble) 0.0120
|  Iron           0.2034
|  Aluminum       0.8418
|  Silver         1.7004


HOW IT WORKS
------------
Initialize the plate and edges to have temperatures that equal their respective slider values.  Each time through the GO procedure, diffuse the heat on each patch in the following way.  Have each patch set its current temperature to the sum of the 4 neighbors' old temperature times a constant based on alpha plus a weighted version of the patch's old temperature.  (For those interested, the updated temperature is calculated by using a Forward Euler Method.)  Then the edges are set back to the specified values and the old temperature is updated to the current temperature.  Then the plate is redrawn.


HOW TO USE IT
-------------
There are five temperature sliders which enable users to set four fixed edge temperatures and one initial plate temperature:
-- TOP-TEMP - Top edge temperature
-- BOTTOM-TEMP - Bottom edge temperature
-- IN-PLATE-TEMP - Initial plate temperature
-- LEFT-TEMP - Left edge temperature
-- RIGHT-TEMP - Right edge temperature

There are two sliders that govern the thermal diffusivity of the plate:
-- MATERIAL-TYPE - The value of the chooser is that of the above chart.  You must press UPDATE ALPHA for this to change the value of ALPHA.
-- ALPHA - The alpha constant of thermal diffusivity

There are four buttons with the following functions:
-- SETUP - Initializes the model
-- GO - Runs the simulation indefinitely
-- GO ONCE - Runs the simulation for 1 time step
-- UPDATE ALPHA - press this if you want to set ALPHA to a preset value based on a material selected by the MATERIAL-TYPE chooser

The TIME monitor shows how many time steps the model has gone through.


THINGS TO TRY
-------------
Set the paramters on the temperature sliders.  Pick a value for ALPHA (or pick MATERIAL-TYPE and press UPDATE ALPHA).  After you have changed all the sliders to values you like, press Setup followed by GO or GO ONCE.


THINGS TO NOTICE
----------------
How does the equilibrium temperature distribution vary for different edge temperature settings?

Notice how an equilibrium (the steady-state condition) is reached.

Keep track of the units:

|  Variables            Units
|  ---------            -----
|  time                 0.1 second
|  temperature          degrees Celsius
|  length               centimeters
|  diffusivity          square centimeters per second


THINGS TO TRY
-------------
Try different materials to observe the heat transfer speed.  How does this compare to physical experiments?

Try the following sample settings...
| - Top:100, Bottom:0,   Left:0,   Right:0.
| - Top:0,   Bottom:100, Left:100, Right:100.
| - Top:0,   Bottom:66,  Left:99,  Right:33.
| - Top:25,  Bottom:25,  Left:100, Right:0.


EXTENDING THE MODEL
-------------------
This model simulates a classic partial differential equation problem (that of heat diffusion). The thin square plate is a typical example, and the simplest model of the behavior.  Try changing the shape or thickness of the plate (e.g. a circular or elliptical plate), or adding a hole in the center (the plate would then be a slice of a torus, a doughnut-shaped geometric object).

Add a slider to alter this thickness.

Try modeling derivative or combined boundary conditions.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Heat Diffusion model.  http://ccl.northwestern.edu/netlogo/models/HeatDiffusion.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/HeatDiffusion for terms of use.
"
Gas Chromatography,/models/Sample Models/Chemistry & Physics,"breed [ reds a-red ]
breed [ greens a-green ]

turtles-own [ stuck ]

;;;
;;; Setup procedures
;;;

to setup
  clear-all
  set-default-shape turtles ""circle""
  setup-patches
  create-molecules 400 reds red
  create-molecules 400 greens green
end

to setup-patches
  draw-absorber
  erode
  draw-walls
end

to draw-absorber
  ask patches
    [ if abs pycor < thickness-of-medium
        [ set pcolor blue ]
      ;; if wall-effect? is on, create two channels near the edges
      if wall-effect? and ( pxcor > (max-pxcor - 15) or pxcor < (min-pxcor + 15) )
        [ set pcolor black ] ]
end

to draw-walls
  ask patches
    [ if patch-at 3 0 = nobody or patch-at -3 0 = nobody
        [ set pcolor (violet - 1) ] ]
end

to erode
  crt number-of-pores
    [ setxy random-xcor thickness-of-medium
      dig-tunnel 180 90 ]
end

; tunnels are dug using random walks
to dig-tunnel [direction wiggle]  ;; turtle procedure
  loop
    [ if ycor < (- thickness-of-medium)
        [ die ]
      set heading direction + wiggle - 2 * random-float wiggle
      set pcolor black
      fd 1
      set pcolor black
      fd 1 ]
end

to create-molecules [number new-breed new-color]
  crt number
    [ set xcor (max-pxcor - 3) - random-float (2 * (max-pxcor - 3))
      set ycor thickness-of-medium + random-float (max-pycor - thickness-of-medium)
      set breed new-breed
      set color new-color
      set stuck 0 ]
end

;;;
;;; Running the model
;;;

to go
  if not any? turtles
    [ stop ]
  ask turtles
    [ if patch-at 0 -1 = nobody
        [ die ]
      wander ]
  tick
  do-plot
end

; The red turtles are inert and don't stick to the blue patches
; Green turtles stick to blue.  When a green turtle encounters
; a blue patch its stuck variable is set to stickiness and then
; decreases with time.  When stuck hits zero the particle is
; no longer stuck.
to wander
  set heading (270 - random-float 180)
  ifelse stuck = 0
    [ if ([pcolor] of patch-ahead 1) = black
        [ fd 1 ]
      let p patch-ahead 1
      if p = nobody [ die ]
      if (breed = greens) and (([pcolor] of p) = blue)
        [ set stuck stickiness ] ]
    [ set stuck stuck - 1 ]
end

;;;
;;; Plotting procedures
;;;

; We need to compute concentrations of reds and greens that made
; it thru the absorbing layer.
to do-plot
  set-current-plot ""Gas Output""

  set-current-plot-pen ""Reds""
  let reds-out (count reds with [ycor < (- thickness-of-medium)])
  plot (100 * reds-out) / 400

  set-current-plot-pen ""Greens""
  let greens-out (count greens with [ycor < (- thickness-of-medium)])
  plot (100 * greens-out) / 400
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Gas Chromatography model.
; http://ccl.northwestern.edu/netlogo/models/GasChromatography.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/GasChromatography
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This is a model of gas chromatography.  Much of modern chemistry depends on chromatography for the separation of chemicals.  (Gas chromatography is one form of chromatography, involving gases.)  Chromatography can even be so sensitive as to separate enantiomers (i.e., molecules that differ only by being mirror images of each other!).

Chromatography separates chemicals using surface interactions. The idea is simple.  Different chemicals have different tendencies to move through small spaces (for example, if they are of different sizes) and different tendencies to stick to surfaces.  This can be observed in everyday life.  For example, if you put a drop of water and a drop of glue on an inclined plane, the water will roll off, but the glue will stick where it was.  Single molecules, too, can stick very differently to surfaces.  For instance, water vapor will condense on a cold glass, but the oxygen in the air will not.  This is because the bonds that oxygen can make with glass are not strong enough to hold the oxygen there.  It takes only a small step to imagine using the different stickiness of molecules to separate them.

Practically, in gas chromatography molecules are forced to pass through a porous medium, which acts as the sticky surface.  A porous medium is a material that has holes in it -- like swiss cheese, but these holes are microscopic in size.  The holes allow molecules to pass from one side of the medium to the other.  One example would be packed silica.  Under a microscope, packed silica looks not unlike a lump of wood shavings, so molecules can go through it like water would through the wood shavings.

The blue area of the world represents the porous medium. The molecules start at the top; they are collected at the bottom.  The red and green particles represent two different kind of molecules.  (In real gas chromatography, these would typically be carried by an inert gas.  The inert gas is forced through the medium by applying pressure.  But gas chromatography can also be used to simply separate gases without a carrier.)  Molecules in this model wander randomly downward through the medium.  Red molecules don't stick to the medium, but green molecules do.  Chemically, this is caused by a number of factors: surface interactions, geometry and size of the molecule, etc.

The amount of stickiness is controlled by a slider.  For example, if the stickiness is set to five, then green molecules sticks to each part of the blue medium for five cycles, essentially slowing its downward motion when compared to the red molecules.  This leads to separation.

This model also attempts to demonstrate the concept of ""wall effect"".  If there is some space near the walls then the molecules can get through these channels.  This will drastically reduce the quality of separation.  The empty space near the walls may result from bad quality of absorber or from inadequate stuffing.


HOW TO USE IT
-------------
First set the porosity of the blue absorber with the NUMBER-OF-PORES slider.  You can change the thickness of the absorbent layer with a slider named THICKNESS-OF-MEDIUM.  The WALL-EFFECT? switch turns the wall effect on and off.

To run the model, press SETUP, then press GO.

The STICKINESS slider changes the stickiness parameter.  The higher the value of stickiness the slower the green turtles move through absorbing layer.


RUNNING the MODEL
-----------------
The program works fastest when STICKINESS is between 3 and 7 and when NUMBER-OF-PORES is over 30.  If STICKINESS is too high, or NUMBER-OF-PORES is too small, it might take a long time for the green turtles to pass through the absorbing layer.


THINGS TO NOTICE
----------------
Separation depends on porosity.  If porosity is too small the absorbent gets contaminated and clogged up and the process stops.  If porosity is too high then there is not enough separation.  Also wall effect reduces the quality of separation in a drastic way.


THINGS TO TRY
-------------
One could try to improve the plotting routine.  In a real chromatograph there is only one output curve showing the rate at which molecules come out and a device called an integrator that tells the amount of matter that has come out.

Try separating more than two gases.


NETLOGO FEATURES
-----------------
Notice the routine that digs tunnels.  It is very easy to implement parallel random walk algorithms with NetLogo.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Gas Chromatography model.  http://ccl.northwestern.edu/netlogo/models/GasChromatography.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/GasChromatography for terms of use.
"
Solid Diffusion,/models/Sample Models/Chemistry & Physics,"to setup
  clear-all
  set-default-shape turtles ""square""
  ;; make green atoms on left
  ask patches with [pxcor < 0]
    [ sprout 1 [ set color green ] ]
  ;; make blue atoms on right
  ask patches with [pxcor > 0]
    [ sprout 1 [ set color blue ] ]
  ;; plot the initial state of the system
  setup-plots
  update-plots
end

to go
  ;; asks vacancies to ask a neighboring atom to
  ;; move into the vacancy
  ask patches with [not any? turtles-here]
    [ move-atom-to-here ]
  tick
  update-plots
end

;; chooses a neighboring atom to move onto a empty patch (vacancy)
to move-atom-to-here  ;; patch procedure
  let atom one-of turtles-on neighbors4
  if atom != nobody [
    ask atom [ move-to myself ]  ;; myself is the calling patch
  ]
end

;;; plotting procedures

to setup-plots
  set-current-plot ""Atoms by Column""
  set-plot-x-range min-pxcor (max-pxcor + 1)
  set-plot-y-range 0 world-height
  set-current-plot ""Max Diffusion Distance""
end

to update-plots
  let greens turtles with [color = green]
  let blues turtles with [color = blue]
  ;; update the top plot
  set-current-plot ""Atoms by Column""
  set-current-plot-pen ""Greens""
  plot-atoms greens
  set-current-plot-pen ""Blues""
  plot-atoms blues
  ;; update the bottom plot
  set-current-plot ""Max Diffusion Distance""
  let rightmost max [pxcor] of greens
  let leftmost  min [pxcor] of blues
  plot (rightmost - leftmost) ^ 2
end

to plot-atoms [atoms]
  plot-pen-reset
  plot-pen-up
  let column min-pxcor
  repeat world-width [
    let y count atoms with [pxcor = column]
    plotxy column y
    plot-pen-down
    set column column + 1
    plotxy column y
  ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2007 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2007).  NetLogo Solid Diffusion model.
; http://ccl.northwestern.edu/netlogo/models/SolidDiffusion.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2007 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/SolidDiffusion
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model describes how diffusion occurs between two adjacent solids.

Diffusion is one of the most important phenomena in fields such as biology, chemistry, geology, chemistry, engineering and physics.  Interestingly, before becoming a famous for the Relativity Laws, Albert Einstein wrote extensively about diffusion, and was one of the first to connect diffusion to the Brownian motion of atoms.

Diffusion can take place in gases, liquids, or solids.  In solids, particularly, diffusion occurs due to thermally-activated random motion of atoms - unless the material is at absolute zero temperature (zero Kelvin), individual atoms keep vibrating and eventually move within the material. One of the possible net effects of diffusion is that atoms move from regions of high concentration of one element to regions with low concentration, until the concentration is equal throughout the sample.

This model demonstrates a solid diffusion couple, such as copper and nickel.  In a real laboratory, such experiment would take place at very high temperatures, for the process to take place in a reasonable amount of time (note that the diffusion coefficient varies exponentially with the inverse of the temperature). There are many mechanisms for diffusion in solids. In this model we demonstrate one of them, which is caused by missing atoms in the metal crystal. The locations, of the missing atoms are often called vacancies.  Therefore, this type of diffusion mechanism is referred to as ""vacancy diffusion"".  The extent to which the diffusion can happen depends on the temperature and the number of vacancies in the crystal.

In addition, there are various other conditions that are needed for solid diffusion to occur.  Some examples of these are similar atomic size, similar crystal structure, and similar electronegativity.  This model assumes all of these conditions are present.


HOW IT WORKS
------------
There are two types of atoms, green and blue.  At the beginning, all green atoms are on the left and the blue atoms are on the right.  All the vacancies start out between the two metals.  As atoms move into vacancies, the vacancies disperse.  In most real-world scenarios, vacancies are scattered in the material to begin with.  In this model, for simplification purposes, we assume that the materials have no vacancies in the beginning, and that all the vacancies start off in between the two materials.

In this model we also assume that the heat is evenly distributed throughout the metals.  Therefore, each atom has an equal chance of breaking bonds with its neighbors and moving to a vacancy.


HOW TO USE IT
-------------
To run the model, first press the SETUP button, then press the GO button.

""Atoms by Column"" is a distribution diagram of the two atom types.  The other graph is a maximum diffusion distance, squared, versus time. If the model runs long enough, this plot will show an approximately linear relationship between the squared distance and time, following the known equation (for one-dimensional diffusion):

| 2
|x  = 2 * D * t

where x is the maximum diffusion distance, D is the diffusion coefficient, and t is elapsed time.

THINGS TO NOTICE
----------------
If you run the model for a few hundred ticks, the distribution graph should look like two interleaving curves.  The far edges remain purely one color, while the middle is about 50-50.

The other graph should be generally linear.  The ""diffusion coefficient"" of the system is proportional to the slope, and can be easily calculated using the above equation.


THINGS TO TRY
-------------
Let the model run for a long time.  (You can use the speed slider to make the model run faster.)  Do you think the metal will ever become completely diffused?

Try increasing the dimensions of the world.  Does the behavior change at all?


EXTENDING THE MODEL
-------------------
The model uses a very simple initial state in which there is always exactly one column of vacancies and they are all located in the middle.  Try adding settings that dictate how many vacancies there are and where they start out.

Give the two metals, or the two sides of the world, different characteristics.  For example, a temperature difference could be simulated by making atomic movements on one side happen less often than on the other.

Try changing the crystal structure of the atoms.  In close-packed atoms in two dimensions, atoms actually have six neighbors (hexagonal) instead of four (square).


NETLOGO FEATURES
----------------
This model uses a non-wrapping world.


RELATED MODELS
--------------
MaterialSim Grain Growth
GasLab Two Gas


CREDITS AND REFERENCES
----------------------
Thanks to James Newell for his work on this model.

For additional information:

Porter, D.A., and Easterling, K.E., Phase Transformations in Metals and Alloys, 2nd ed., Chapman & Hall, 1992

Shewmon, P.G., Diffusion in solids, 2nd ed., TMS, 1989

To refer to this model in academic publications, please use:  Wilensky, U. (2007).  NetLogo Solid Diffusion model.  http://ccl.northwestern.edu/netlogo/models/SolidDiffusion.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2007 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/SolidDiffusion for terms of use.
"
Polymer Dynamics,/models/Sample Models/Chemistry & Physics,"breed [ blues a-blue ]
breed [ oranges an-orange ]

turtles-own [other-breed]

to setup
  clear-all
  set-default-shape turtles ""circle""
  ;; now create the main chain.
  ask patches with [pycor = round (max-pycor / 2) and
                    pxcor < max-pxcor and
                    pxcor > min-pxcor ]
    [ ;; monomers on even x coordinates are blue,
      ;; monomers on odd x coordinates are orange
      ifelse pxcor mod 2 = 0
        [ sprout 1
            [ set breed blues
              set color blue + 1
              set other-breed oranges ] ]
        [ sprout 1
            [ set breed oranges
              set color orange
              set other-breed blues ] ] ]
end

to go
  ask blues [ move ]
  ask oranges [ move ]
  tick
end

to move  ;; turtle procedure
  ;; choose a heading, and before moving the monomer,
  ;; checks if the move would break or cross the chain
  face one-of neighbors4
  if not breaking-chain? and not crossing-chain?
    [ fd 1 ]
end

to-report breaking-chain?  ;; turtle procedure
  ;; checks if moving the turtle would break the chain
  report (heading = 0 and any? other-breed at-points [[-1 -1] [0 -1] [1 -1]])
           or
         (heading = 90 and any? other-breed at-points [[-1 -1] [-1 0] [-1 1]])
           or
         (heading = 180 and any? other-breed at-points [[-1 1] [0 1] [1 1]])
           or
         (heading = 270 and any? other-breed at-points [[1 -1] [1 0] [1 1]])
end

to-report crossing-chain?  ;; turtle procedure
  ;; checks if moving the turtle would cross the chain
  report (heading = 0 and any? other-breed at-points [[-1 2] [0 2] [1 2]])
           or
         (heading = 90 and any? other-breed at-points [[2 -1] [2 0] [2 1]])
           or
         (heading = 180 and any? other-breed at-points [[-1 -2] [0 -2] [1 -2]])
           or
         (heading = 270 and any? other-breed at-points [[-2 -1] [-2 0] [-2 1]])
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2005 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2005).  NetLogo Polymer Dynamics model.
; http://ccl.northwestern.edu/netlogo/models/PolymerDynamics.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2005 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/PolymerDynamics
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model simulates the motion of a simple polymer.  Polymers are simply long chains of identical, smaller molecules called monomers, which often have some mobility, causing many polymers to be flexible.  Many common materials and chemical substances are polymers, for example plastics and proteins.


HOW IT WORKS
------------
The polymer is modeled using a cellular automaton approach involving only local interactions.

Initially the monomers are colored alternating orange and blue.  Blue monomers interact only with their two neighboring orange monomers, and vice versa.

Movement occurs in two alternating phases, one for the orange monomers, one for the blue.  For each monomer (of the appropriate color) a random direction to move in is chosen.  Before making the actual move we check if the move would cause the chain to either break or cross itself.  If not, the monomer moves one step in that direction.

To check if a move will break the chain, we see if the moving monomer will leave a blank patch behind it.  To check if it will cross the chain, we see if the movement will cause the monomer to be next to another piece of the chain in front of it.


HOW TO USE IT
-------------
SETUP: initializes the simulation

GO: starts the simulation

GO ONCE: advances the simulation one step only


THINGS TO NOTICE
----------------
One interesting thing to notice is that, despite all the interactions being local, the polymer has a very realistic macroscopic movement.


THINGS TO TRY
----------------
Try a much longer polymer.  This is done by making the world size bigger.  (You'll probably want to reduce the patch size.)

Slow down the simulation, and observe the local interaction closely.

Activate the 3D view, and try to follow a turtle.


EXTENDING THE MODEL
-------------------
Measure the distance between the two ends of the polymer and plot how it changes over time.

Are other movement rules possible, without causing the chain to break or cross?

Try having different mobility for different kinds of monomers.

Make a preferential direction for movement, determined by a slider.

Allow monomers to break apart from the polymer, in some particular situations.  Why might this happen?


NETLOGO FEATURES
----------------
Note that the model makes use of turtle procedures (with which the monomers move and check their neighborhood), and breeds (to distinguish blue and orange polymers).

In order for the model to operate correctly on a torus, the dimensions of the world must be even, so we put the world origin in the corner.


RELATED MODELS
--------------
CA 1D Elementary - an introduction to cellular automata
Life Turtle-Based - a cellular automaton implemented, like this one, using turtles
Radical Polymerization - another model about polymers


CREDITS AND REFERENCES
----------------------
For a detailed treatment of this model, see Yaneer Bar-Yam, Dynamics of Complex Systems (2003), pages 496-502.  Westview Press, Boulder, CO.  The book is available online at http://necsi.org/publications/dcs/.

See also Y. Bar-Yam, Y. Rabin, M. A. Smith, Macromolecules Rep. 25 (1992) 2985.

To refer to this model in academic publications, please use:  Wilensky, U. (2005).  NetLogo Polymer Dynamics model.  http://ccl.northwestern.edu/netlogo/models/PolymerDynamics.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2005 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/PolymerDynamics for terms of use.
"
GasLab Single Collision,/models/Sample Models/Chemistry & Physics/GasLab,"globals
[
  tick-delta                      ;; how much we advance the tick counter this time through
  max-tick-delta                  ;; the largest tick-delta is allowed to be
  plot-clock                      ;; keeps track of the x-axis for the plot
  avg-speed                       ;; average speed of the two particles
  total-energy                    ;; total energy of the two particles
  x-center y-center               ;; coordinates of center of mass
  done?                           ;; becomes true when one particles is about to 'leave' the world
  after-collision?                ;; for graphing purposes
]

breed [ particles particle ]
breed [ centers-of-mass center-of-mass ]

particles-own
[
  speed mass energy                ;; particle variables
  last-collision
]

to setup
  clear-all
  set-default-shape particles ""circle""
  set-default-shape centers-of-mass ""x""
  set done? false
  set max-tick-delta 0.1073
  set after-collision? false
  make-particles
  create-centers-of-mass 1
    [ set size 3 ]
  update-variables
  clear-drawing  ;; erase the line made by initially moving the center of mass
  do-plotting
end

to update-variables
  let total-mass sum [mass] of particles
  set x-center (sum [ xcor * mass ] of particles) / total-mass
  set y-center (sum [ ycor * mass ] of particles) / total-mass
  set avg-speed  mean [speed] of particles
  set total-energy sum [energy] of particles
  ask centers-of-mass
  [
    ifelse show-center-of-mass?                         ;; marks a gray path along the particles' center of mass
      [ show-turtle
        pen-down ]
      [ hide-turtle
        pen-up ]
    setxy x-center y-center
  ]
end

to go
  ask particles [ move ]

  ask particles                                   ;;  each particle checks if it's on the same patch as the other
  [ check-for-collision ]
  update-variables
  calculate-tick-delta
  tick-advance tick-delta
  display
  do-plotting

end


to go-mode

if run-mode = ""one-collision""  [go-once stop]
if run-mode = ""all-collision-angles"" [all-collision-angles]
if run-mode = ""all-reflection-angles"" [all-reflection-angles]

end


to go-once                                          ;; a single collision
  setup
  while [ not done? ]
  [ go
    ask particles
    [ if not can-move? 1
      [ set done? true ]
    ]
  ]
end

to all-collision-angles                            ;; activated when the reflection angle is constant and the collision angle is varied
  go-once
  ifelse collision-angle >= 345
    [ set collision-angle 15 ]
    [ set collision-angle collision-angle + 15 ]
end

to all-reflection-angles                           ;; activated when the collision angle is constant and the reflection angle is varied
  go-once
  set reflection-angle reflection-angle + 15
  if reflection-angle = 360
  [ set reflection-angle 0 ]
end

to calculate-tick-delta
  ;; tick-delta is calculated in such way that even the fastest
  ;; particle will jump at most 1 patch length in a tick. As
  ;; particles jump (speed * tick-delta) at every tick, making
  ;; tick length the inverse of the speed of the fastest particle
  ;; (1/max speed) assures that. Having each particle advance at most
  ;; one patch-length is necessary for them not to ""jump over"" each
  ;; other without colliding.
  ifelse any? particles with [speed > 0]
    [ set tick-delta min list (1 / (ceiling max [speed] of particles)) max-tick-delta ]
    [ set tick-delta max-tick-delta ]
end


to move  ;; particle procedure
  jump (speed * tick-delta)
end

to check-for-collision  ;; particle procedure
  if count other particles-here = 1
  [
    ;; the following conditions are imposed on collision candidates:
    ;;   1. they must have a lower who number than my own, because collision
    ;;      code is asymmetrical: it must always happen from the point of view
    ;;      of just one particle.
    ;;   2. they must not be the same particle that we last collided with on
    ;;      this patch, so that we have a chance to leave the patch after we've
    ;;      collided with someone.
    let candidate one-of other particles-here with
      [who < [who] of myself and myself != last-collision]
    ;; we also only collide if one of us has non-zero speed. It's useless
    ;; (and incorrect, actually) for two particles with zero speed to collide.
    if (candidate != nobody) and (speed > 0 or [speed] of candidate > 0)
    [
      collide-with candidate
      set last-collision candidate
      ask candidate [ set last-collision myself ]
      set after-collision? true
    ]
  ]
end

;; implements a collision with another particle.
;;
;; THIS IS THE HEART OF THE PARTICLE SIMULATION, AND YOU ARE STRONGLY ADVISED
;; NOT TO CHANGE IT UNLESS YOU REALLY UNDERSTAND WHAT YOU'RE DOING!
;;
;; The two particles colliding are self and other-particle, and while the
;; collision is performed from the point of view of self, both particles are
;; modified to reflect its effects. This is somewhat complicated, so I'll
;; give a general outline here:
;;   1. Do initial setup, and determine the heading between the reflected particles
;;      (call it theta).
;;   2. Convert the representation of the velocity of each particle from
;;      speed/heading to a theta-based vector whose first component is the
;;      particle's speed along theta, and whose second component is the speed
;;      perpendicular to theta.
;;   3. Modify the velocity vectors to reflect the effects of the collision.
;;      This involves:
;;        a. computing the velocity of the center of mass of the whole system
;;           along direction theta
;;        b. updating the along-theta components of the two velocity vectors.
;;   4. Convert from the theta-based vector representation of velocity back to
;;      the usual speed/heading representation for each particle.
;;   5. Perform final cleanup and update derived quantities.
to collide-with [ other-particle ] ;; particle procedure
  ;;; PHASE 1: initial setup

  ;; for convenience, grab some quantities from other-particle
  let mass2 [mass] of other-particle
  let speed2 [speed] of other-particle
  let heading2 [heading] of other-particle

  ;; since particles are modeled as zero-size points, theta isn't meaningfully
  ;; defined. we can assign it randomly without affecting the model's outcome.
  let theta reflection-angle

  ;;; PHASE 2: convert velocities to theta-based vector representation

  ;; now convert my velocity from speed/heading representation to components
  ;; along theta and perpendicular to theta
  let v1t (speed * cos (theta - heading))
  let v1l (speed * sin (theta - heading))

  ;; do the same for other-particle
  let v2t (speed2 * cos (theta - heading2))
  let v2l (speed2 * sin (theta - heading2))



  ;;; PHASE 3: manipulate vectors to implement collision

  ;; compute the velocity of the system's center of mass along theta
  let vcm (((mass * v1t) + (mass2 * v2t)) / (mass + mass2) )

  ;; now compute the new velocity for each particle along direction theta.
  ;; velocity perpendicular to theta is unaffected by a collision along theta,
  ;; so the next two lines actually implement the collision itself, in the
  ;; sense that the effects of the collision are exactly the following changes
  ;; in particle velocity.
  set v1t (2 * vcm - v1t)
  set v2t (2 * vcm - v2t)



  ;;; PHASE 4: convert back to normal speed/heading

  ;; now convert my velocity vector into my new speed and heading
  set speed sqrt ((v1t ^ 2) + (v1l ^ 2))
  set energy (0.5 * mass * speed ^ 2)
  ;; if the magnitude of the velocity vector is 0, atan is undefined. but
  ;; speed will be 0, so heading is irrelevant anyway. therefore, in that
  ;; case we'll just leave it unmodified.
  if v1l != 0 or v1t != 0
    [ set heading (theta - (atan v1l v1t)) ]

  ;; and do the same for other-particle
  ask other-particle [
    set speed sqrt ((v2t ^ 2) + (v2l ^ 2))
    set energy (0.5 * mass * (speed ^ 2))
    if v2l != 0 or v2t != 0
      [ set heading (theta - (atan v2l v2t)) ]
  ]
end

to recolor  ;; particle procedure
  ifelse speed < (0.5 * 10)
  [
    set color blue + 2
  ]
  [
    ifelse speed > (1.5 * 10)
      [ set color red ]
      [ set color green ]
  ]
end

;; creates initial particles
to make-particles
  create-particles 1 [
    set color pink
    set speed init-pink-speed
    set mass pink-mass
    set heading 180
    bk 2 * speed
  ]
  create-particles 1 [
    set color blue
    set speed init-blue-speed
    set mass blue-mass
    set heading 180 + collision-angle
    bk 2 * speed
  ]
  ask particles
  [
    setup-particle
  ]
  calculate-tick-delta
end


to setup-particle  ;; particle procedure
  pen-down
  set size 2
  set energy (0.5 * mass * speed ^ 2 )
  set last-collision nobody
end

;;; plotting procedure
to do-plotting
  set-current-plot ""Speeds""
  ifelse after-collision?
     [set plot-clock (ticks - (tick-delta))]
     [set plot-clock ticks]

  ifelse [speed] of turtle 0 = [speed] of turtle 1
     [set-current-plot-pen ""both""
      plotxy plot-clock ([speed] of turtle 0)]

     [set-current-plot-pen ""pink""
      plotxy plot-clock ([speed] of turtle 0)
      set-current-plot-pen ""blue""
      plotxy plot-clock ([speed] of turtle 1)]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1997 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2002.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1997).  NetLogo GasLab Single Collision model.
; http://ccl.northwestern.edu/netlogo/models/GasLabSingleCollision.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1997 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/GasLabSingleCollision
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This is one in a series of GasLab models that use the same basic rules for what happens when particles run into each other. Each one has different features in order to show different aspects of the behavior of gases.

This model is simplified to show the collision of only two particles, since this event is so hard to watch when there are many particles in the world: given the initial motions of two colliding particles, what can we learn about their final motions from the principles of conservation of momentum and energy?


HOW IT WORKS
------------
The particles are modeled as hard balls with no internal energy except that which is due to their motion.  Collisions between particles are elastic.  Particles are colored according to speed -- blue for slow, green for medium, and red for high speeds.

Coloring of the particles is with respect to one speed (10).  Particles with a speed less than 5 are blue, ones that are more than 15 are red, while all in those in-between are green.

Particles behave according to the following rules:
1. A particle moves in a straight line without changing its speed, unless it collides with another particle or bounces off the wall.  The particles are aimed to hit each other at the origin.
2. Two particles ""collide"" if they find themselves on the same patch (the world is composed of a grid of small squares called patches).
3. A random axis is chosen, as if they are two balls that hit each other and this axis is the line connecting their centers.
4. They exchange momentum and energy along that axis, according to the conservation of momentum and energy.  This calculation is done in the center of mass system.
5. Each turtle is assigned its new velocity, energy, and heading.
6. If a turtle finds itself on or very close to a wall of the container, it ""bounces"" -- that is, reflects its direction and keeps its same speed.


HOW TO USE IT
-------------
Initial settings:
- COLLISION-ANGLE: Sets the angle that separates the pink and blue particles before the collision.
- REFLECTION-ANGLE: Sets the angle of the axis connecting the particles' centers when they collide with respect to the vertical axis. To calculate the outcome of the collision, the speeds of the two particles are projected onto this new axis and the new speeds and headings are computed. Other GasLab models use random values for ""REFLECTION-ANGLE"", but this model allows you to experiment with them one by one. This angle is called THETA in the code of the model.
- INIT-PINK-SPEED (or BLUE): Sets the initial speed of the pink (or blue) particle.
- PINK-MASS (or BLUE): Sets the mass of the pink (or blue) particle.

Other settings:
- SHOW-CENTER-OF-MASS?: If ON, the center of mass of the system will be shown in gray.

Buttons for running the model:
- SETUP
- RUN-MODE: Chooses between ONE COLLISION (just one run), ALL-COLLISION-ANGLES (loops through all the collision angles with 15-degrees steps) and ALL-REFLECTION-ANGLES(loops through all the reflection angles with 15-degrees steps).
- GO

Monitors:
- ENERGY OF PINK (or -BLUE): Shows the current energy of the pink (or blue) particle.
- SPEED OF PINK (or -BLUE): Shows the current speed of the pink (or blue) particle.
- AVERAGE SPEED: Shows the average of the speeds of the two particles.
- TOTAL ENERGY: Shows the sum of the energies of the two particles.

Plots:
- SPEEDS: speed of each of the particles over time.


THINGS TO TRY
-------------
Set the reflection-angle to zero.  Draw a picture representing the two balls as they collide, with their two faces touching.  Make the line connecting their centers be the same as theta.  Draw vectors representing their motion.

While running the following situations note the paths of the two particles.  Can you make sense of what they do?  Is it what you expected?

Choose a COLLISION-ANGLE and a REFLECTION-ANGLE and choose ONE-COLLISION to see one particular collision.

Choose a COLLISION-ANGLE and choose ALL-REFLECTION-ANGLES to cycle through all of the angles of reflection.

Choose a REFLECTION-ANGLE and choose ALL-COLLISION-ANGLES to cycle through all of the angles of collision.


THINGS TO NOTICE
----------------
With COLLISION-ANGLE = 180 (directly across from each other) and REFLECTION-ANGLE = 90, it looks as if the two particles miss each other.  What is happening?

With REFLECTION-ANGLE = 45 degrees, the particles go off at right angles. Why?  Draw a picture of what is happening at the moment of collision.

With REFLECTION-ANGLE = 0 degrees, the two particles reverse direction. Why?

What is the motion of the center of mass?  What would you expect it to be?


THINGS TO TRY
-------------
Have the masses of the two particles be different.

Have the initial speeds of the two particles be different.

Change the initial positions and headings of the two particles.  As a simple case, set one on the y-axis and the other on the x-axis, (COLLISION-ANGLE = 90) each one heading toward the origin.  The center of mass is no longer stationary. Note its path.  Is it what you would expect?

If the center of mass is not stationary, the two particles often have different speeds after they collide, even when they have identical initial speeds and masses!  Why does this happen?  How can this satisfy the conservation of both energy and momentum?

The fact that the velocities are not always the same after every kind of collision is essential to getting a distribution of velocities among identical particles after many collisions, which is what we observe with particles in a gas.

Does this seem like a reasonable model for colliding particles? When is it reasonably valid, and when is it decidedly NOT valid?

When two particles collide, should theta be picked randomly -- each theta has an equal probability -- or in some other way?  Would this change the eventual velocity distribution among many particles?

After you have gotten used to observing and understanding these simple collisions, go to the ""Free Gas"" or ""Gas in a Box"" model.  Especially watch the particle whose path is traced in gray.  Does it make sense?  Can you picture each collision?

Record the velocities of each particle after each collision. After you have several sets of velocities, look at the entire velocity distribution. What do you notice? Is it the Maxwell-Boltzmann distribution?


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1997).  NetLogo GasLab Single Collision model.  http://ccl.northwestern.edu/netlogo/models/GasLabSingleCollision.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1997 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/GasLabSingleCollision for terms of use.
"
GasLab Isothermal Piston,/models/Sample Models/Chemistry & Physics/GasLab,"globals
[
  tick-delta                 ;; how much we advance the tick counter this time through
  max-tick-delta             ;; the largest tick-delta is allowed to be
  raw-width raw-height       ;; box size variables
  pressure
  pressure-history           ;; lists previous pressure values, so that averaging can take place in plotting
  wall-hits-per-particle     ;; average number of wall hits per particle
  length-horizontal-surface  ;; the size of the wall surfaces that run horizontally - the top and bottom of the box
  length-vertical-surface    ;; the size of the wall surfaces that run vertically - the left and right of the box

  init-avg-speed init-avg-energy  ;; initial averages
  avg-speed avg-energy            ;; current averages
  fast medium slow                ;; current counts

  piston-position            ;; xcor of piston wall
  run-go?                    ;; flag of whether or not its safe for go to run
  volume
]

breed [ particles particle ]
breed [ flashes flash ]

flashes-own [birthday]

particles-own
[
  speed mass energy          ;; particle info
  wall-hits                  ;; # of wall hits during this cycle (""big tick"")
  momentum-difference        ;; used to calculate pressure from wall hits
  last-collision             ;; sets identity of particle which is collided with, prevents colliding twice with the same particle if they remain on the same patch after moving away
]


to setup
  ca
  set-default-shape particles ""circle""
  set-default-shape flashes ""plane""
  set run-go? true
  set max-tick-delta 0.1073
  set raw-width  round (0.01 * box-width  * max-pxcor)
  set raw-height round (0.01 * box-height * max-pycor)
  set piston-position 0
  ;;; the length of the horizontal or vertical surface of
  ;;; the inside of the box must exclude the two patches
  ;; that are the where the perpendicular walls join it,
  ;;; but must also add in the axes as an additional patch
  ;;; example:  a box with a edge of 10, is drawn with
  ;;; 19 patches of wall space on the inside of the box
  set length-horizontal-surface  ( 2 * (raw-height - 1) + 1)
  set length-vertical-surface raw-width + piston-position
  set volume (length-horizontal-surface * length-vertical-surface * 1)  ;;depth of 1
  make-box
  draw-piston
  make-particles

  set pressure-history [0 0 0]  ;; plotted pressure will be averaged over the past 3 entries
  update-variables
  set init-avg-speed avg-speed
  set init-avg-energy avg-energy
  setup-plots
  setup-histograms
  do-plotting
end

to update-variables
  set medium count particles with [color = green]
  set slow   count particles with [color = blue]
  set fast   count particles with [color = red]
  set avg-speed  mean [speed] of particles
  set avg-energy mean [energy] of particles
end

to go
  if not run-go? [stop]        ;; when the piston is moved, the model run is stopped
  ask particles [ bounce ]
  ask particles [ move ]
  ask particles
  [ if collide? [check-for-collision] ]
  tick-advance tick-delta
  if floor ticks > floor (ticks - tick-delta)
  [
    ifelse any? particles
      [ set wall-hits-per-particle mean [wall-hits] of particles ]
      [ set wall-hits-per-particle 0 ]
    ask particles
      [ set wall-hits 0 ]
    calculate-pressure
    update-variables
    do-plotting
  ]
  calculate-tick-delta

  ask flashes with [ticks - birthday > 0.4]
    [ die ]
  display
end

to calculate-tick-delta
  ;; tick-delta is calculated in such way that even the fastest
  ;; particle will jump at most 1 patch length in a tick. As
  ;; particles jump (speed * tick-delta) at every tick, making
  ;; tick length the inverse of the speed of the fastest particle
  ;; (1/max speed) assures that. Having each particle advance at most
  ;; one patch-length is necessary for it not to ""jump over"" a wall,
  ;; the piston or another particle.
  ifelse any? particles with [speed > 0]
    [ set tick-delta min list (1 / (ceiling max [speed] of particles)) max-tick-delta ]
    [ set tick-delta max-tick-delta ]
end

;;; Pressure is defined as the force per unit area.  In this context,
;;; that means the total momentum per unit time transferred to the walls
;;; by particle hits, divided by the surface area of the walls.  (Here
;;; we're in a two dimensional world, so the ""surface area"" of the walls
;;; is just their length.)  Each wall contributes a different amount
;;; to the total pressure in the box, based on the number of collisions, the
;;; direction of each collision, and the length of the wall.  Conservation of momentum
;;; in hits ensures that the difference in momentum for the particles is equal to and
;;; opposite to that for the wall.  The force on each wall is the rate of change in
;;; momentum imparted to the wall, or the sum of change in momentum for each particle:
;;; F = SUM  [d(mv)/dt] = SUM [m(dv/dt)] = SUM [ ma ], in a direction perpendicular to
;;; the wall surface.  The pressure (P) on a given wall is the force (F) applied to that
;;; wall over its surface area.  The total pressure in the box is sum of each wall's
;;; pressure contribution.

to calculate-pressure
  ;; by summing the momentum change for each particle,
  ;; the wall's total momentum change is calculated
  set pressure 15 * sum [momentum-difference] of particles
  set pressure-history lput pressure but-first pressure-history
  ask particles
    [ set momentum-difference 0 ]  ;; once the contribution to momentum has been calculated
                                   ;; this value is reset to zero till the next wall hit
end

to bounce  ;; particle procedure
  ;; get the coordinates of the patch we'll be on if we go forward 1
  let new-patch patch-ahead 1
  let new-px [pxcor] of new-patch
  let new-py [pycor] of new-patch
  ;; if we're not about to hit a wall, we don't need to do any further checks
  if ([pcolor] of new-patch != yellow and [pcolor] of new-patch != orange)
    [ stop ]
  ;; if hitting left or right wall, reflect heading around x axis
  if (abs new-px = raw-width or new-px = piston-position)
    [ set heading (- heading)
      set wall-hits wall-hits + 1
  ;;  if the particle is hitting a vertical wall, only the horizontal component of the speed
  ;;  vector can change.  The change in velocity for this component is 2 * the speed of the particle,
  ;;  due to the reversing of direction of travel from the collision with the wall
      set momentum-difference momentum-difference + (abs (sin heading * 2 * mass * speed) / length-vertical-surface) ]
  ;; if hitting top or bottom wall, reflect heading around y axis
  if (abs new-py = raw-height)
    [ set heading (180 - heading)
      set wall-hits wall-hits + 1
  ;;  if the particle is hitting a horizontal wall, only the vertical component of the speed
  ;;  vector can change.  The change in velocity for this component is 2 * the speed of the particle,
  ;;  due to the reversing of direction of travel from the collision with the wall
      set momentum-difference momentum-difference + (abs (cos heading * 2 * mass * speed) / length-horizontal-surface)  ]
  ;;  every time a particle hits the wall, it produces a short-living ""flash"" so assist in visualization
  ask patch new-px new-py
  [ sprout-flashes 1 [
      set color pcolor - 2
      set birthday ticks
      set heading 0
    ]
  ]
end

to move  ;; particle procedure
  if patch-ahead (speed * tick-delta) != patch-here
    [ set last-collision nobody ]
  jump (speed * tick-delta)
end

to check-for-collision  ;; particle procedure
  ;; Here we impose a rule that collisions only take place when there
  ;; are exactly two particles per patch.

  if count other particles-here = 1
  [
    ;; the following conditions are imposed on collision candidates:
    ;;   1. they must have a lower who number than my own, because collision
    ;;      code is asymmetrical: it must always happen from the point of view
    ;;      of just one particle.
    ;;   2. they must not be the same particle that we last collided with on
    ;;      this patch, so that we have a chance to leave the patch after we've
    ;;      collided with someone.
    let candidate one-of other particles-here with
      [who < [who] of myself and myself != last-collision]
    ;; we also only collide if one of us has non-zero speed. It's useless
    ;; (and incorrect, actually) for two particles with zero speed to collide.
    if (candidate != nobody) and (speed > 0 or [speed] of candidate > 0)
    [
      collide-with candidate
      set last-collision candidate
      ask candidate [ set last-collision myself ]
    ]
  ]
end

;; implements a collision with another particle.
;;
;; THIS IS THE HEART OF THE PARTICLE SIMULATION, AND YOU ARE STRONGLY ADVISED
;; NOT TO CHANGE IT UNLESS YOU REALLY UNDERSTAND WHAT YOU'RE DOING!
;;
;; The two particles colliding are self and other-particle, and while the
;; collision is performed from the point of view of self, both particles are
;; modified to reflect its effects. This is somewhat complicated, so I'll
;; give a general outline here:
;;   1. Do initial setup, and determine the heading between particle centers
;;      (call it theta).
;;   2. Convert the representation of the velocity of each particle from
;;      speed/heading to a theta-based vector whose first component is the
;;      particle's speed along theta, and whose second component is the speed
;;      perpendicular to theta.
;;   3. Modify the velocity vectors to reflect the effects of the collision.
;;      This involves:
;;        a. computing the velocity of the center of mass of the whole system
;;           along direction theta
;;        b. updating the along-theta components of the two velocity vectors.
;;   4. Convert from the theta-based vector representation of velocity back to
;;      the usual speed/heading representation for each particle.
;;   5. Perform final cleanup and update derived quantities.
to collide-with [ other-particle ] ;; particle procedure
  ;;; PHASE 1: initial setup

  ;; for convenience, grab some quantities from other-particle
  let mass2 [mass] of other-particle
  let speed2 [speed] of other-particle
  let heading2 [heading] of other-particle

  ;; since particles are modeled as zero-size points, theta isn't meaningfully
  ;; defined. we can assign it randomly without affecting the model's outcome.
  let theta (random-float 360)



  ;;; PHASE 2: convert velocities to theta-based vector representation

  ;; now convert my velocity from speed/heading representation to components
  ;; along theta and perpendicular to theta
  let v1t (speed * cos (theta - heading))
  let v1l (speed * sin (theta - heading))

  ;; do the same for other-particle
  let v2t (speed2 * cos (theta - heading2))
  let v2l (speed2 * sin (theta - heading2))



  ;;; PHASE 3: manipulate vectors to implement collision

  ;; compute the velocity of the system's center of mass along theta
  let vcm (((mass * v1t) + (mass2 * v2t)) / (mass + mass2) )

  ;; now compute the new velocity for each particle along direction theta.
  ;; velocity perpendicular to theta is unaffected by a collision along theta,
  ;; so the next two lines actually implement the collision itself, in the
  ;; sense that the effects of the collision are exactly the following changes
  ;; in particle velocity.
  set v1t (2 * vcm - v1t)
  set v2t (2 * vcm - v2t)



  ;;; PHASE 4: convert back to normal speed/heading

  ;; now convert my velocity vector into my new speed and heading
  set speed sqrt ((v1t ^ 2) + (v1l ^ 2))
  set energy (0.5 * mass * speed ^ 2)
  ;; if the magnitude of the velocity vector is 0, atan is undefined. but
  ;; speed will be 0, so heading is irrelevant anyway. therefore, in that
  ;; case we'll just leave it unmodified.
  if v1l != 0 or v1t != 0
    [ set heading (theta - (atan v1l v1t)) ]

  ;; and do the same for other-particle
  ask other-particle [
    set speed sqrt ((v2t ^ 2) + (v2l ^ 2))
    set energy (0.5 * mass * (speed ^ 2))
    if v2l != 0 or v2t != 0
      [ set heading (theta - (atan v2l v2t)) ]
  ]


  ;; PHASE 5: final updates

  ;; now recolor, since color is based on quantities that may have changed
  recolor
  ask other-particle
    [ recolor ]
end

to recolor  ;; particle procedure
  ifelse speed < (0.5 * 10)
  [
    set color blue
  ]
  [
    ifelse speed > (1.5 * 10)
      [ set color red ]
      [ set color green ]
  ]
end


;;;
;;; drawing procedures
;;;

;; draws the box
to make-box
  ask patches with [ ((abs pxcor = raw-width) and (abs pycor <= raw-height)) or
                     ((abs pycor = raw-height) and (abs pxcor <= raw-width)) ]
    [ set pcolor yellow ]
  ;;color the left side of the wall gray:
  ask patches with [ ((pxcor = ( raw-width)) and (abs pycor <= raw-height))]
    [set pcolor gray]
end

;; creates initial particles
to make-particles
  create-particles number-of-particles
  [
    setup-particle
    random-position
    recolor
  ]
  calculate-tick-delta
end


to setup-particle  ;; particle procedure
  set speed init-particle-speed
  set mass particle-mass
  set energy (0.5 * mass * speed ^ 2)
  set last-collision nobody
  set wall-hits 0
  set momentum-difference 0
end

;; place particle at random location inside the box
;; to the left of the piston
to random-position ;; particle procedure
  setxy ((1 - raw-width)  + random-float (raw-width + piston-position - 3))
        ((1 - raw-height) + random-float (2 * raw-height - 2))
end




;; ------ Piston ----------
to move-piston
  set run-go? false
  ;;note: if user clicks too far to the left or right, nothing will happen
  if (mouse-down? and abs mouse-xcor < raw-width - 3 )
  [
    ifelse mouse-xcor >= piston-position
      [ piston-out ceiling (mouse-xcor - piston-position) ]
      [ piston-in (piston-position - mouse-xcor) ]
    set length-horizontal-surface  ( 2 * (raw-width - 1) + 1) - (abs (piston-position - raw-width) - 1)
    set volume (length-horizontal-surface * length-vertical-surface * 1)  ;;depth of 1
    set run-go? true
    stop
  ]
end

;; piston procedure
to piston-out [dist]
  undraw-piston
  set piston-position round (piston-position + dist)
  draw-piston
end

;; piston procedure
to piston-in [dist]
  undraw-piston
  set piston-position round (piston-position - dist)
  ask particles with [xcor >= piston-position - 1]
    [ bounce-off-piston ]
  ask flashes with [xcor >= piston-position - 1]
    [ die ]
  draw-piston
end

;; particle procedure
to bounce-off-piston
  ifelse ((((2 * piston-position) - (xcor + 2)) < (1 - raw-width)) or
          (((2 * piston-position) - (xcor + 2)) > (piston-position - 2)))
   [ set xcor ((random (raw-width + piston-position - 2)) - (raw-width - 1)) ]
   [ set xcor ((2 * piston-position) - (xcor + 2)) ]
end

;; piston procedure
to draw-piston
  ask patches with [ ((pxcor = (round piston-position)) and ((abs pycor) < raw-height)) ]
    [ set pcolor orange ]
  ;; make sides of box that are to right right of the piston gray
  ask patches with [(pxcor > (round piston-position)) and (abs (pxcor) < raw-width)
                    and ((abs pycor) = raw-height)]
    [set pcolor gray]
end

;; piston procedure
to undraw-piston
  ask patches with [ (pxcor = round piston-position) and ((abs pycor) < raw-height) ]
    [ set pcolor black ]
  ask patches with [(pxcor > (round piston-position)) and (abs (pxcor) < raw-width)
                    and ((abs pycor) = raw-height)]
    [set pcolor yellow]
  ask flashes with [ (xcor = round piston-position) and ((abs ycor) < raw-height) ]
    [ die ]
end


;;; plotting procedures

to setup-plots
  set-current-plot ""Volume""
  set-plot-y-range 0 (2 * volume)
end

to setup-histograms
  set-current-plot ""Speed Histogram""
  set-plot-x-range 0 (init-particle-speed * 2)
  set-plot-y-range 0 ceiling (number-of-particles / 6)
  set-current-plot-pen ""medium""
  set-histogram-num-bars 40
  set-current-plot-pen ""slow""
  set-histogram-num-bars 40
  set-current-plot-pen ""fast""
  set-histogram-num-bars 40
  set-current-plot-pen ""init-avg-speed""
  draw-vert-line init-avg-speed

  set-current-plot ""Energy Histogram""
  set-plot-x-range 0 (0.5 * (init-particle-speed * 2) ^ 2 * particle-mass)
  set-plot-y-range 0 ceiling (number-of-particles / 6)
  set-current-plot-pen ""medium""
  set-histogram-num-bars 40
  set-current-plot-pen ""slow""
  set-histogram-num-bars 40
  set-current-plot-pen ""fast""
  set-histogram-num-bars 40
  set-current-plot-pen ""init-avg-energy""
  draw-vert-line init-avg-energy
end


to do-plotting
  set-current-plot ""Pressure""
  plotxy ticks (mean pressure-history)

  set-current-plot ""Volume""
  set-current-plot-pen ""volume""
  plotxy ticks volume

  if ticks > 1
  [
     set-current-plot ""Wall Hits per Particle""
     plotxy ticks wall-hits-per-particle
  ]

  plot-histograms
end


to plot-histograms
  set-current-plot ""Energy histogram""
  set-current-plot-pen ""fast""
  histogram [ energy ] of particles with [color = red]
  set-current-plot-pen ""medium""
  histogram [ energy ] of particles with [color = green]
  set-current-plot-pen ""slow""
  histogram [ energy ] of particles with [color = blue]
  set-current-plot-pen ""avg-energy""
  plot-pen-reset
  draw-vert-line avg-energy

  set-current-plot ""Speed histogram""
  set-current-plot-pen ""fast""
  histogram [ speed ] of particles with [color = red]
  set-current-plot-pen ""medium""
  histogram [ speed ] of particles with [color = green]
  set-current-plot-pen ""slow""
  histogram [ speed ] of particles with [color = blue]
  set-current-plot-pen ""avg-speed""
  plot-pen-reset
  draw-vert-line avg-speed
end

;; histogram procedure
to draw-vert-line [ xval ]
  plotxy xval plot-y-min
  plot-pen-down
  plotxy xval plot-y-max
  plot-pen-up
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1997 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2002.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1997).  NetLogo GasLab Isothermal Piston model.
; http://ccl.northwestern.edu/netlogo/models/GasLabIsothermalPiston.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1997 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/GasLabIsothermalPiston
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model is one in a series of GasLab models. They use the same basic rules for simulating the behavior of gases.  Each model integrates different features in order to highlight different aspects of gas behavior.

The basic principle of the models is that gas particles are assumed to have two elementary actions: they move and they collide - either with other particles or with any other objects such as walls.

This model simulates the behavior of gas particles in a piston, or a container with a changing volume.  The volume in which the gas is contained can be changed by moving the piston in and out.  ""Isothermal"" means that the temperature of the gas is not changed by moving the piston.

This model is part of the Connected Mathematics ""Making Sense of Complex Phenomena"" Modeling Project.


HOW IT WORKS
------------
The particles are modeled as hard balls with no internal energy except that which is due to their motion.  Collisions between particles are elastic.  Particles are colored according to speed -- blue for slow, green for medium, and red for high speeds.

Coloring of the particles is with respect to one speed (10).  Particles with a speed less than 5 are blue, ones that are more than 15 are red, while all in those in-between are green.

Particles behave according to the following rules:
1. A particle moves in a straight line without changing its speed, unless it collides with another particle or bounces off the wall.
2. Two particles ""collide"" if they find themselves on the same patch (NetLogo's View is composed of a grid of small squares called patches).
3. A random axis is chosen, as if they are two balls that hit each other and this axis is the line connecting their centers.
4. They exchange momentum and energy along that axis, according to the conservation of momentum and energy.  This calculation is done in the center of mass system.
5. Each turtle is assigned its new velocity, energy, and heading.
6. If a turtle finds itself on or very close to a wall of the container, it ""bounces"" -- that is, reflects its direction and keeps its same speed.

Pressure is calculated as the force per unit area (or length in this two-dimensional model).  Pressure is calculated by adding up the momentum transferred to the walls of the box by the particles when they bounce off and divided by the length of the wall, which they hit.


HOW TO USE IT
-------------
Initial settings:
- NUMBER-OF-PARTICLES: number of particles
- INIT-PARTICLE-SPEED: initial speed of the particles
- PARTICLE-MASS: initial mass of the molecules
- BOX-WIDTH: width of the container
- BOX-HEIGHT: height of the container

Other settings:
- COLLIDE?: Turns collisions between particles on and off.  It can be changed in the middle of the run.

The SETUP button will set the initial conditions.
The GO button will run the simulation.

Pushing the MOVE-PISTON button allows you to reposition the piston by clicking on the view with the mouse, hence changing the volume. When this button is pressed, the model stops.  Once the reposition is done, push the GO button to continue.

The intention in this model is for the user to quickly pull the piston back thus simulating quickly removing a plate. This means no particles collide with the piston as it is removed. However, we have left in code that allows the user to push the piston in and compress the gas. In this model, though, the collisions of the piston with the particles are ignored. Note that there's a physical impossibility in the model here:  in real life if you moved the piston in you would do work on the gas by compressing it, and its temperature would increase.  In this model the energy and temperature are constant no matter how you manipulate the piston, hence the name ""isothermal"".  Nonetheless, the basic relationship between volume and pressure is correctly demonstrated here.

The physically accurate version of piston compression is shown in the ""Adiabatic Piston"" model.

Monitors:
- PISTON POSITION: position of the piston with respect to the x-axis
- VOLUME: volume (or area) of the piston
- PRESSURE
- AVERAGE SPEED: average speed of the particles
- AVERAGE ENERGY: average energy of the particles, calculated as m*(v^2)/2.

Plots:
- PRESSURE: pressure in the piston over time.
- VOLUME: volume of the piston vs time.
- WALL HITS PER PARTICLE: the number of wall hits averaged for the particles during each time unit
- SPEED HISTOGRAM: particles' speed distribution
- ENERGY HISTOGRAM: distribution of energies of all the particles, calculated as m*(v^2)/2.


THINGS TO NOTICE
----------------
How does the pressure change as you change the volume of the box by moving the piston?  Compare the two plots of volume and pressure.

Measure changes in pressure and volume. Is there a clear quantitative relationship? Boyle's Law describes the relationship between pressure and volume, when all else is kept constant.

How can the relationship between volume and pressure be explained in terms of the wall hits?  How does it relate to collisions among molecules?

What shapes do the energy and velocity histograms reach after a while?  Why aren't they the same?  Do the pressure and volume affect these shapes?  How does changing the particles' mass or speed affect them?

Change different kinds of settings and observe the number of wall hits per particle.  What causes this number to change?  What changes do not affect this number?  Can you connect these relationships with those between the number of particles and pressure?  Volume and pressure?


THINGS TO TRY
-------------
How would you calculate pressure?  How does this code do it?

Change the number, mass, and initial velocity of the molecules.  Does this affect the pressure?   Why? Do the results make intuitive sense?  Look at the extremes:  very few or very many molecules, high or low volumes.

Figure out how many molecules there REALLY are in a box this size -- say a 10-cm cube.  Look up or calculate the REAL mass and speed of a typical molecule.  When you compare those numbers to the ones in the model, are you surprised this model works as well as it does?

Observe the number of wall hits per particle with and without collisions.  Does this number change?  Why?

If you change the number of particles in the piston: will the pressure change?  will the number of wall hits change?  Why?


EXTENDING THE MODEL
-------------------
Are there other ways one might calculate pressure?

When the piston is moved out, the gas is not evenly distributed for a while.  What's the pressure during this time?  Does this ever happen in the real world?   What does pressure mean when it's not the same throughout a gas?


NETLOGO FEATURES
----------------
Notice how collisions are detected by the turtles and how the code guarantees that the same two particles do not collide twice.  What happens if we let the patches detect them?


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1997).  NetLogo GasLab Isothermal Piston model.  http://ccl.northwestern.edu/netlogo/models/GasLabIsothermalPiston.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1997 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/GasLabIsothermalPiston for terms of use.
"
GasLab Second Law,/models/Sample Models/Chemistry & Physics/GasLab/Unverified,"globals [
  fast average slow               ;; current counts
  avg-speed avg-energy            ;; current averages
  avg-speed-init avg-energy-init  ;; initial averages
  vsplit vclock                   ;; clock variables
  left-count right-count          ;; # of particles on each side
  propeller-velocity              ;; current velocity of the propeller
  left-pressure right-pressure    ;; pressure in each chamber
  left-walls right-walls          ;; agentsets of the walls on each side (used when calculating pressure)
  propeller-angle                 ;; current angular position of the propeller
]

turtles-own [
  speed mass energy new-speed           ;; turtle info
  v1t v1l tmp-turtle                    ;; collision info (turtle 1)
  heading2 mass2 speed2 v2t v2l turtle2 ;; collision info (turtle 2)
  theta                                 ;; collision info (both particles)
]

patches-own [
  wall?       ;; is this patch part of the wall?
  pressure    ;; sum of momentums of particles that have bounced here during this time slice
]

to setup [mode]
  ca
  make-box
  set vclock  0
  crt number
  [ set new-speed 10.0
    set shape ""circle""
    set mass 1.0
    setup-position mode
    recolor ]
  update-variables
  set avg-speed-init avg-speed
  set avg-energy-init avg-energy
  rotate-propeller
  setup-plots
  do-plotting
end

to setup-position [mode]  ;; turtle procedure
  if mode = ""corner""
    [ setxy (- (max-pxcor - 1)) (- (max-pycor - 1))
      set heading random-float 90
      fd random-float 8 ]
  if mode = ""one side""
    [ setxy (- (1 + random-float (max-pxcor - 2)))
            (random-float (world-height - 3) + min-pycor + 1) ]
  if mode = ""both sides""
    [ setxy (random-float (world-width - 3) + min-pxcor + 1)
            (random-float (world-height - 3) + min-pycor + 1) ]
end

to update-variables
  ask turtles
    [ set speed new-speed
      set energy (0.5 * speed * speed * mass) ]
  set average count turtles with [color = green]
  set slow    count turtles with [color = blue]
  set fast    count turtles with [color = red]
  set avg-speed  mean [speed] of turtles
  set avg-energy mean [energy] of turtles
  set vsplit (round ((max [speed] of turtles) * 1.2))
  set left-count count turtles with [xcor < 0]
  set right-count count turtles with [xcor >= 0]
  set left-pressure sum [pressure] of left-walls
  ask left-walls [ set pressure 0 ]
  set right-pressure sum [pressure] of right-walls
  ask right-walls [ set pressure 0 ]
end

to go
  ask turtles [ bounce ]
  ask turtles [ move ]
  ask turtles [ check-for-collision ]
  set vclock (vclock + 1)
  rotate-propeller
  ifelse (vclock = vsplit)
  [
    tick
    set vclock 0
    update-variables
    do-plotting
  ]
  [ display ]
end

to rotate-propeller
  set-current-plot ""Propeller""
  plot-pen-reset
  set propeller-angle propeller-angle - propeller-velocity / 2
  plot-pen-up
  plotxy cos propeller-angle sin propeller-angle
  plot-pen-down
  plotxy 0 - cos propeller-angle 0 - sin propeller-angle
  plot-pen-up
  plotxy cos (propeller-angle + 90) sin (propeller-angle + 90)
  plot-pen-down
  plotxy 0 - cos (propeller-angle + 90) 0 - sin (propeller-angle + 90)
  ;; slow down the propeller due to friction
  set propeller-velocity propeller-velocity * 0.999
end

to bounce ;; turtle procedure
  ; if we're not about to hit a wall (yellow patch),
  ; we don't need to do any further checks
  if [pcolor] of patch-ahead 1 != yellow [ stop ]
  ; get the coordinates of the patch we'll be on if we go forward 1
  let new-px [pxcor] of patch-ahead 1
  let new-py [pycor] of patch-ahead 1
  let pressure-increment mass * speed
  ask patch new-px new-py [ set pressure pressure + pressure-increment ]
  ; check: hitting left, right, or middle wall?
  if (abs new-px = max-pxcor) or (pxcor != 0 and new-px = 0)
    ; if so, reflect heading around x axis
    [ set heading (- heading) ]
  ; check: hitting top or bottom wall?
  if (abs new-py = max-pycor) or (pxcor = 0)
    ; if so, reflect heading around y axis
    [ set heading (180 - heading) ]
end

to move  ;; turtle procedure
  let old-xcor xcor
  jump (speed / vsplit)
  if (old-xcor < 0) and (xcor >= 0)
    [ set propeller-velocity propeller-velocity + 0.03 * speed ]
  if (old-xcor > 0) and (xcor <= 0)
    [ set propeller-velocity propeller-velocity - 0.03 * speed ]
end

to check-for-collision  ;; turtle procedure
  if count other turtles-here = 1
    [ set tmp-turtle one-of other turtles-here
      if ((who > [who] of tmp-turtle) and (turtle2 != tmp-turtle))
        [ collide ] ]
end

to collide  ;; turtle procedure
  get-turtle2-info
  calculate-velocity-components
  set-new-speed-and-headings
end

to get-turtle2-info  ;; turtle procedure
  set turtle2 tmp-turtle
  set mass2 [mass] of turtle2
  set speed2 [new-speed] of turtle2
  set heading2 [heading] of turtle2
end

to calculate-velocity-components  ;; turtle procedure
  set theta (random-float 360)
  set v1l (new-speed * sin (theta - heading))
  set v1t (new-speed * cos (theta - heading))
  set v2l (speed2 * sin (theta - heading2))
  set v2t (speed2 * cos (theta - heading2))
  ;; CM vel. along dir. theta
  let vcm (((mass * v1t) + (mass2 * v2t)) / (mass + mass2))
  set v1t (vcm + vcm - v1t)
  set v2t (vcm + vcm - v2t)
end

;; set new speed and headings of each turtles that has had a collision
to set-new-speed-and-headings
  set new-speed sqrt ((v1t * v1t) + (v1l * v1l))
  set heading (theta - (atan v1l v1t))

  let new-speed2 sqrt ((v2t * v2t) + (v2l * v2l))
  let new-heading (theta - (atan v2l v2t))
  ask turtle2 [
    set new-speed new-speed2
    set heading new-heading
  ]

  recolor
  ask turtle2 [ recolor ]
end

to recolor  ;; turtle procedure
  ifelse new-speed < 5.0
    [ set color blue ]
    [ ifelse new-speed > 15.0
        [ set color red ]
        [ set color green ] ]
end

to make-box
  ask patches
    [ set pressure 0
      set wall? false
      if count neighbors != 8 or
         ((pxcor = 0) and (abs pycor > propeller-radius))
        [ set pcolor yellow
          set wall? true ]
      if (pxcor = 0) and (abs pycor <= propeller-radius)
        [ set pcolor gray ] ]
  set left-walls patches with [wall? and (pxcor < 0)]
  set right-walls patches with [wall? and (pxcor > 0)]
end

;;; plotting procedures

to setup-plots
  ;; work
  set-current-plot ""Propeller Velocity""
  set-plot-y-range ceiling (number / -25) ceiling (number / 25)
  auto-plot-off
  set-current-plot-pen ""x-axis""
  plotxy 0 0
  plotxy 1000 0
  auto-plot-on
  set-current-plot-pen ""velocity""

  ;; pressure
  set-current-plot ""Pressures""
  set-plot-y-range 0 ceiling (number / 25)
end

to do-plotting
  ;; counts
  set-current-plot ""Particle Counts""
  set-current-plot-pen ""left""
  plot left-count
  set-current-plot-pen ""right""
  plot right-count

  ;; work
  set-current-plot ""Propeller Velocity""
  plot propeller-velocity

  ;; pressure
  set-current-plot ""Pressures""
  set-current-plot-pen ""left""
  plot left-pressure
  set-current-plot-pen ""right""
  plot right-pressure

  ;; entropy
  set-current-plot ""entropy""
  plot 100 * (1 / calculate-order)
end

to-report calculate-order
  let x-patches-per-grid-cell (world-width / 5)
  let y-patches-per-grid-cell (world-height / 5)
  let counts-list []
  let gridx -2
  repeat 5
    [ let gridy -2
      repeat 5
        [ let gridcount count turtles with [int (pxcor / x-patches-per-grid-cell) = gridx
                                            and int (pycor / y-patches-per-grid-cell) = gridy]
          set counts-list lput gridcount counts-list
          set gridy gridy + 1 ]
      set gridx gridx + 1 ]
   ;; show counts-list
  report variance counts-list
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2002 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2002).  NetLogo GasLab Second Law model.
; http://ccl.northwestern.edu/netlogo/models/GasLabSecondLaw.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2002 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/GasLabSecondLaw
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model is one in a series of GasLab models. They use the same basic rules for simulating the behavior of gases.  Each model integrates different features in order to highlight different aspects of gas behavior.

The basic principle of the models is that gas particles are assumed to have two elementary actions: they move and they collide - either with other particles or with any other objects such as walls.

This model simulates the Second Law of Thermodynamics via the behavior of gas particles in a box. The Second Law of Thermodynamics states that systems tend towards increased entropy.  Essentially what this means is that over time ordered systems become less ordered unless work is done on the system to keep it ordered.

HOW IT WORKS
------------
Particles are modeled as perfectly elastic particles with no energy except their kinetic energy -- that which is due to their motion.  Collisions between particles are elastic.  Particles are colored according to speed -- blue for slow, green for medium, and red for high speeds.

The exact way two particles collide is as follows:
1. Two turtles ""collide"" if they find themselves on the same patch.
2. A random axis is chosen, as if they are two balls that hit each other and this axis is the line connecting their centers.
3. They exchange momentum and energy along that axis, according to the conservation of momentum and energy.  This calculation is done in the center of mass system.
4. Each turtle is assigned its new velocity, energy, and heading.
5. If a turtle finds itself on or very close to a wall of the container, it ""bounces"" -- that is, reflects its direction and keeps its same speed.

The propeller is modeled such that it shows the effect of the flux of the particles between the two sides of the box, but does not effect or interact with the particles as they pass through.  When particles move from the left side to the right side they accelerate the propeller clockwise, and likewise, when particles move from the right side to the left side they accelerate the propeller counter-clockwise.


HOW TO USE IT
-------------
SETUP: sets up the initial conditions and distributes the particles in one of three different modes.  Be sure to wait till the Setup button stops before pushing go.
CORNER: all the particles are created in the lower left corner of the box and diffuse outwards from there.
ONE SIDE: all the particles are created in the left side of the box evenly distributed.
BOTH SIDES: all the particles are created evenly distributed throughout the entire box.
GO: runs the code again and again.  This is a ""forever"" button.
NUMBER: the number of gas particles
PROPELLER-RADIUS: the radius of the propeller in the opening between the sides of the box.  The size of the opening is based on the size of the propeller.

About the plots:
PARTICLE COUNTS: plots the number of particles on each side of the box.
PROPELLER VELOCITY: plots the velocity of the propeller: positive is clockwise, negative is counter-clockwise.
PRESSURES: plots the pressure of the gas on each side of the box.
ENTROPY: plots a measure of the entropy of the system.  As the particles become more evenly and randomly distributed the entropy will increase.


THINGS TO NOTICE
----------------
When the particles are evenly distributed throughout the box, what do you notice about the behavior of the propeller?

In what ways is this model a correct or incorrect idealization of the real world?

In what ways can you quantify entropy?  What is the best way to quantify entropy in this model?  Does this model use this method?  If not, what is wrong with the method being used?


THINGS TO TRY
-------------
Set all the particles in part of the world, or with the same heading -- what happens?  Does this correspond to a physical possibility?

Are there other interesting quantities to keep track of?


EXTENDING THE MODEL
-------------------
Could you find a way to measure or express the ""temperature"" of this imaginary gas?  Try to construct a thermometer.

What happens if there are particles of different masses?  (See GasLab Two Gas model.)

How does this 2-D model differ from the 3-D model?

If MORE than two particles arrive on the same patch, the current code says they don't collide.  Is this a mistake?  How does it affect the results?

Is this model valid for fluids in any aspect?  How could it be made to be fluid-like?


RELATED MODELS
--------------
The GasLab suite of models, especially GasLab Maxwell's Demon, which models a theoretical system that seems to violate the Second Law of Thermodynamics.


CREDITS AND REFERENCES
----------------------
Based on GasLab -- thanks to Brent Collins and Seth Tisue for their help on this model.

To refer to this model in academic publications, please use:  Wilensky, U. (2002).  NetLogo GasLab Second Law model.  http://ccl.northwestern.edu/netlogo/models/GasLabSecondLaw.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2002 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/GasLabSecondLaw for terms of use.
"
GasLab Heat Box,/models/Sample Models/Chemistry & Physics/GasLab/Unverified,"globals
[
  tick-delta                      ;; how much we advance the tick counter this time through
  max-tick-delta                  ;; the largest tick-delta is allowed to be
  box-edge                        ;; distance of box edge from axes
  pressure                        ;; pressure in the box
  pressure-history
  zero-pressure-count             ;; how many zero entries are in pressure-history
  wall-hits-per-particle          ;; average number of wall hits per particle
  length-horizontal-surface       ;; the size of the wall surfaces that run horizontally - the top and bottom of the box
  length-vertical-surface         ;; the size of the wall surfaces that run vertically - the left and right of the box
  walls                           ;; agentset containing patches that are the walls of the box
  init-avg-speed init-avg-energy  ;; initial averages
  avg-speed avg-energy            ;; current averages
  fast medium slow                ;; current counts
  percent-slow percent-medium percent-fast   ;;  percentage of current counts
  outside-energy
]

breed [ particles particle ]
breed [ flashes flash ]

flashes-own [birthday]

particles-own
[
  speed mass energy          ;; particle info
  wall-hits                  ;; number of wall hits during this cycle (""big tick"")
  momentum-difference        ;; used to calculate pressure from wall hits
  last-collision             ;; used to prevent particles from colliding multiple times
]

to setup
  ca
  set-default-shape particles ""circle""
  set-default-shape flashes ""plane""
  set max-tick-delta 0.1073
  ;; box has constant size...
  set box-edge (max-pxcor - 1)
  ;;; the length of the horizontal or vertical surface of
  ;;; the inside of the box must exclude the two patches
  ;; that are the where the perpendicular walls join it,
  ;;; but must also add in the axes as an additional patch
  ;;; example:  a box with an box-edge of 10, is drawn with
  ;;; 19 patches of wall space on the inside of the box
  set length-horizontal-surface  ( 2 * (box-edge - 1) + 1)
  set length-vertical-surface  ( 2 * (box-edge - 1) + 1)
  make-box
  make-particles
  set pressure-history [0 0 0]  ;; plotted pressure will be averaged over the past 3 entries
  set zero-pressure-count 0
  update-variables
  set init-avg-speed avg-speed
  set init-avg-energy avg-energy
  setup-plots
  setup-histograms
  do-plotting
end

to update-variables
  set medium count particles with [color = green]
  set slow   count particles with [color = blue]
  set fast   count particles with [color = red]
  set percent-medium (medium / (count particles)) * 100
  set percent-slow (slow / (count particles)) * 100
  set percent-fast (fast / (count particles)) * 100
  set avg-speed  mean [speed] of particles
  set avg-energy mean [energy] of particles
end

to go
  ask walls
    [set pcolor box-color]
  ask particles [ bounce ]
  ask particles [ move ]
  if collide? [
    ask particles
      [ check-for-collision ]
  ]
  tick-advance tick-delta
  if floor ticks > floor (ticks - tick-delta)
  [
    ifelse any? particles
      [ set wall-hits-per-particle mean [wall-hits] of particles ]
      [ set wall-hits-per-particle 0 ]
    ask particles
      [ set wall-hits 0 ]
    calculate-pressure
    update-variables
    do-plotting
  ]
  calculate-tick-delta
  ask flashes with [ticks - birthday > 0.4]
    [ die ]
  set outside-energy outside-temperature
  display
end

to calculate-tick-delta
  ;; tick-delta is calculated in such way that even the fastest
  ;; particle will jump at most 1 patch length in a tick. As
  ;; particles jump (speed * tick-delta) at every tick, making
  ;; tick length the inverse of the speed of the fastest particle
  ;; (1/max speed) assures that. Having each particle advance at most
  ;; one patch-length is necessary for it not to ""jump over"" a wall
  ;; or another particle.
  ifelse any? particles with [speed > 0]
    [ set tick-delta min list (1 / (ceiling max [speed] of particles)) max-tick-delta ]
    [ set tick-delta max-tick-delta ]
end

;;; Pressure is defined as the force per unit area.  In this context,
;;; that means the total momentum per unit time transferred to the walls
;;; by particle hits, divided by the surface area of the walls.  (Here
;;; we're in a two dimensional world, so the ""surface area"" of the walls
;;; is just their length.)  Each wall contributes a different amount
;;; to the total pressure in the box, based on the number of collisions, the
;;; direction of each collision, and the length of the wall.  Conservation of momentum
;;; in hits ensures that the difference in momentum for the particles is equal to and
;;; opposite to that for the wall.  The force on each wall is the rate of change in
;;; momentum imparted to the wall, or the sum of change in momentum for each particle:
;;; F = SUM  [d(mv)/dt] = SUM [m(dv/dt)] = SUM [ ma ], in a direction perpendicular to
;;; the wall surface.  The pressure (P) on a given wall is the force (F) applied to that
;;; wall over its surface area.  The total pressure in the box is sum of each wall's
;;; pressure contribution.

to calculate-pressure
  ;; by summing the momentum change for each particle,
  ;; the wall's total momentum change is calculated
  set pressure 15 * sum [momentum-difference] of particles
  set pressure-history lput pressure but-first pressure-history
  ask particles
    [ set momentum-difference 0 ]  ;; once the contribution to momentum has been calculated
                                   ;; this value is reset to zero till the next wall hit
end

to bounce  ;; particle procedure
  ;; get the coordinates of the patch we'll be on if we go forward 1
  let new-patch patch-ahead 1
  let new-px [pxcor] of new-patch
  let new-py [pycor] of new-patch
  ;; if we're not about to hit a wall, we don't need to do any further checks
  if (abs new-px != box-edge and abs new-py != box-edge)
    [stop]
  ;; if hitting left or right wall, reflect heading around x axis
  if (abs new-px = box-edge)
    [ set heading (- heading)
      set wall-hits wall-hits + 1
  ;;  if the particle is hitting a vertical wall, only the horizontal component of the speed
  ;;  vector can change.  The change in velocity for this component is 2 * the speed of the particle,
  ;; due to the reversing of direction of travel from the collision with the wall
      set momentum-difference momentum-difference + (abs (sin heading * 2 * mass * speed) / length-vertical-surface) ]
  ;; if hitting top or bottom wall, reflect heading around y axis
  if (abs new-py = box-edge)
    [ set heading (180 - heading)
      set wall-hits wall-hits + 1
  ;;  if the particle is hitting a horizontal wall, only the vertical component of the speed
  ;;  vector can change.  The change in velocity for this component is 2 * the speed of the particle,
  ;; due to the reversing of direction of travel from the collision with the wall
      set momentum-difference momentum-difference + (abs (cos heading * 2 * mass * speed) / length-horizontal-surface)  ]

  if [heated-wall?] of patch new-px new-py  ;; check if the patch ahead of us is heated
  [

    set energy ((energy +  outside-energy ) / 2)
    set speed sqrt (2 * energy / mass )
    recolor
  ]

  ask patch new-px new-py
  [ sprout-flashes 1 [
      set color pcolor - 2
      set birthday ticks
      set heading 0
    ]
  ]
end

to move  ;; particle procedure
  if patch-ahead (speed * tick-delta) != patch-here
    [ set last-collision nobody ]
  jump (speed * tick-delta)
end

to check-for-collision  ;; particle procedure
  ;; Here we impose a rule that collisions only take place when there
  ;; are exactly two particles per patch.  We do this because when the
  ;; student introduces new particles from the side, we want them to
  ;; form a uniform wavefront.
  ;;
  ;; Why do we want a uniform wavefront?  Because it is actually more
  ;; realistic.  (And also because the curriculum uses the uniform
  ;; wavefront to help teach the relationship between particle collisions,
  ;; wall hits, and pressure.)
  ;;
  ;; Why is it realistic to assume a uniform wavefront?  Because in reality,
  ;; whether a collision takes place would depend on the actual headings
  ;; of the particles, not merely on their proximity.  Since the particles
  ;; in the wavefront have identical speeds and near-identical headings,
  ;; in reality they would not collide.  So even though the two-particles
  ;; rule is not itself realistic, it produces a realistic result.  Also,
  ;; unless the number of particles is extremely large, it is very rare
  ;; for three or more particles to land on the same patch (for example,
  ;; with 400 particles it happens less than 1% of the time).  So imposing
  ;; this additional rule should have only a negligible effect on the
  ;; aggregate behavior of the system.
  ;;
  ;; Why does this rule produce a uniform wavefront?  The particles all
  ;; start out on the same patch, which means that without the only-two
  ;; rule, they would all start colliding with each other immediately,
  ;; resulting in much random variation of speeds and headings.  With
  ;; the only-two rule, they are prevented from colliding with each other
  ;; until they have spread out a lot.  (And in fact, if you observe
  ;; the wavefront closely, you will see that it is not completely smooth,
  ;; because some collisions eventually do start occurring when it thins out while fanning.)

  if count other particles-here = 1
  [
    ;; the following conditions are imposed on collision candidates:
    ;;   1. they must have a lower who number than my own, because collision
    ;;      code is asymmetrical: it must always happen from the point of view
    ;;      of just one particle.
    ;;   2. they must not be the same particle that we last collided with on
    ;;      this patch, so that we have a chance to leave the patch after we've
    ;;      collided with someone.
    let candidate one-of other particles-here with
      [who < [who] of myself and myself != last-collision]
    ;; we also only collide if one of us has non-zero speed. It's useless
    ;; (and incorrect, actually) for two particles with zero speed to collide.
    if (candidate != nobody) and (speed > 0 or [speed] of candidate > 0)
    [
      collide-with candidate
      set last-collision candidate
      ask candidate [ set last-collision myself ]
    ]
  ]
end

;; implements a collision with another particle.
;;
;; THIS IS THE HEART OF THE PARTICLE SIMULATION, AND YOU ARE STRONGLY ADVISED
;; NOT TO CHANGE IT UNLESS YOU REALLY UNDERSTAND WHAT YOU'RE DOING!
;;
;; The two particles colliding are self and other-particle, and while the
;; collision is performed from the point of view of self, both particles are
;; modified to reflect its effects. This is somewhat complicated, so I'll
;; give a general outline here:
;;   1. Do initial setup, and determine the heading between particle centers
;;      (call it theta).
;;   2. Convert the representation of the velocity of each particle from
;;      speed/heading to a theta-based vector whose first component is the
;;      particle's speed along theta, and whose second component is the speed
;;      perpendicular to theta.
;;   3. Modify the velocity vectors to reflect the effects of the collision.
;;      This involves:
;;        a. computing the velocity of the center of mass of the whole system
;;           along direction theta
;;        b. updating the along-theta components of the two velocity vectors.
;;   4. Convert from the theta-based vector representation of velocity back to
;;      the usual speed/heading representation for each particle.
;;   5. Perform final cleanup and update derived quantities.
to collide-with [ other-particle ] ;; particle procedure
  ;;; PHASE 1: initial setup

  ;; for convenience, grab some quantities from other-particle
  let mass2 [mass] of other-particle
  let speed2 [speed] of other-particle
  let heading2 [heading] of other-particle

  ;; since particles are modeled as zero-size points, theta isn't meaningfully
  ;; defined. we can assign it randomly without affecting the model's outcome.
  let theta (random-float 360)



  ;;; PHASE 2: convert velocities to theta-based vector representation

  ;; now convert my velocity from speed/heading representation to components
  ;; along theta and perpendicular to theta
  let v1t (speed * cos (theta - heading))
  let v1l (speed * sin (theta - heading))

  ;; do the same for other-particle
  let v2t (speed2 * cos (theta - heading2))
  let v2l (speed2 * sin (theta - heading2))



  ;;; PHASE 3: manipulate vectors to implement collision

  ;; compute the velocity of the system's center of mass along theta
  let vcm (((mass * v1t) + (mass2 * v2t)) / (mass + mass2) )

  ;; now compute the new velocity for each particle along direction theta.
  ;; velocity perpendicular to theta is unaffected by a collision along theta,
  ;; so the next two lines actually implement the collision itself, in the
  ;; sense that the effects of the collision are exactly the following changes
  ;; in particle velocity.
  set v1t (2 * vcm - v1t)
  set v2t (2 * vcm - v2t)



  ;;; PHASE 4: convert back to normal speed/heading

  ;; now convert my velocity vector into my new speed and heading
  set speed sqrt ((v1t ^ 2) + (v1l ^ 2))
  set energy (0.5 * mass * (speed ^ 2))
  ;; if the magnitude of the velocity vector is 0, atan is undefined. but
  ;; speed will be 0, so heading is irrelevant anyway. therefore, in that
  ;; case we'll just leave it unmodified.
  if v1l != 0 or v1t != 0
    [ set heading (theta - (atan v1l v1t)) ]

  ;; and do the same for other-particle
  ask other-particle [
    set speed sqrt ((v2t ^ 2) + (v2l ^ 2))
    set energy (0.5 * mass * (speed ^ 2))
    if v2l != 0 or v2t != 0
      [ set heading (theta - (atan v2l v2t)) ]
  ]


  ;; PHASE 5: final updates

  ;; now recolor, since color is based on quantities that may have changed
  recolor
  ask other-particle
    [ recolor ]
end

to recolor  ;; particle procedure
  ifelse speed < (0.5 * 10)
  [
    set color blue
  ]
  [
    ifelse speed > (1.5 * 10)
      [ set color red ]
      [ set color green ]
  ]
end

;; reports color of box according to temperature and position
;; if only one side is heated, the other walls will be yellow
to-report box-color
     ifelse heated-wall?
       [report scale-color red outside-temperature -200 600]
       [report yellow]

end

;; reports true if there is a heated wall at the given location
to-report heated-wall?
     ifelse one-side?
     [
       ifelse ((pxcor = (- box-edge)) and (abs pycor < box-edge))
        [report true]
        [report false]
     ]
     [
      if (( abs pxcor = box-edge) and (abs pycor <= box-edge)) or
                     ((abs pycor = box-edge) and (abs pxcor <= box-edge))
        [report true]
     ]
     report false
end

;;;
;;; drawing procedures
;;;

;; draws the box
to make-box
  set walls patches with [ ((abs pxcor = box-edge) and (abs pycor <= box-edge)) or
                     ((abs pycor = box-edge) and (abs pxcor <= box-edge)) ]
  ask walls
    [ set pcolor box-color ]
end

;; creates initial particles
to make-particles
  create-particles number-of-particles
  [
    setup-particle
    set speed random-float 20
    set energy (0.5 * mass * speed * speed)
    random-position
    recolor
  ]
  calculate-tick-delta
end


to setup-particle  ;; particle procedure
  set speed 10
  set mass 1.0
  set energy (0.5 * mass * speed * speed)
  set last-collision nobody
  set wall-hits 0
  set momentum-difference 0
end

;; place particle at random location inside the box.
to random-position ;; particle procedure
  setxy ((1 - box-edge) + random-float ((2 * box-edge) - 2))
        ((1 - box-edge) + random-float ((2 * box-edge) - 2))
end


;;; plotting procedures

to setup-plots
  set-current-plot ""Speed Counts""
  set-plot-y-range 0 100
end

to setup-histograms
  let init-particle-speed 20  ;;the initial speeds in this model cannot be faster than 20 at setup
  let particle-mass 1    ;; each particle has a mass of 1

  set-current-plot ""Speed Histogram""
  set-plot-x-range 0 (init-particle-speed * 2)
  set-plot-y-range 0 ceiling (number-of-particles / 6)
  set-current-plot-pen ""medium""
  set-histogram-num-bars 40
  set-current-plot-pen ""slow""
  set-histogram-num-bars 40
  set-current-plot-pen ""fast""
  set-histogram-num-bars 40
  set-current-plot-pen ""init-avg-speed""
  draw-vert-line init-avg-speed

  set-current-plot ""Energy Histogram""
  set-plot-x-range 0 (0.5 * (init-particle-speed * 2) * (init-particle-speed * 2) * particle-mass)
  set-plot-y-range 0 ceiling (number-of-particles / 4)
  set-current-plot-pen ""medium""
  set-histogram-num-bars 40
  set-current-plot-pen ""slow""
  set-histogram-num-bars 40
  set-current-plot-pen ""fast""
  set-histogram-num-bars 40
  set-current-plot-pen ""init-avg-energy""
  draw-vert-line init-avg-energy
end


to do-plotting
  set-current-plot ""Pressure vs. Time""
  plotxy ticks (mean pressure-history)

  set-current-plot ""Speed Counts""
  set-current-plot-pen ""fast""
  plotxy ticks percent-fast
  set-current-plot-pen ""medium""
  plotxy ticks percent-medium
  set-current-plot-pen ""slow""
  plotxy ticks percent-slow

  set-current-plot ""Temperature vs. Time""
  set-current-plot-pen ""outside""
  plotxy ticks outside-temperature
  set-current-plot-pen ""inside""
  plotxy ticks avg-energy

  if ticks > 1
  [
     set-current-plot ""Wall Hits per Particle""
     plotxy ticks wall-hits-per-particle
  ]

  plot-histograms
end


to plot-histograms
  set-current-plot ""Energy histogram""
  set-current-plot-pen ""fast""
  histogram [ energy ] of particles with [color = red]
  set-current-plot-pen ""medium""
  histogram [ energy ] of particles with [color = green]
  set-current-plot-pen ""slow""
  histogram [ energy ] of particles with [color = blue]
  set-current-plot-pen ""avg-energy""
  plot-pen-reset
  draw-vert-line avg-energy

  set-current-plot ""Speed histogram""
  set-current-plot-pen ""fast""
  histogram [ speed ] of particles with [color = red]
  set-current-plot-pen ""medium""
  histogram [ speed ] of particles with [color = green]
  set-current-plot-pen ""slow""
  histogram [ speed ] of particles with [color = blue]
  set-current-plot-pen ""avg-speed""
  plot-pen-reset
  draw-vert-line avg-speed
end

;; histogram procedure
to draw-vert-line [ xval ]
  plotxy xval plot-y-min
  plot-pen-down
  plotxy xval plot-y-max
  plot-pen-up
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model and associated activities and materials were created as
; part of the project: MODELING ACROSS THE CURRICULUM.  The project
; gratefully acknowledges the support of the National Science Foundation,
; the National Institute of Health, and the Department of Education
; (IERI program) -- grant number REC # 0115699.Additional support
; was provided through the projects: PARTICIPATORY SIMULATIONS:
; NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN CLASSROOMS and/or
; INTEGRATED SIMULATION AND MODELING ENVIRONMENT -- NSF (REPP & ROLE
; programs) grant numbers REC #9814682 and REC-0126227.

; Copyright 2002 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2002).  NetLogo GasLab Heat Box model.
; http://ccl.northwestern.edu/netlogo/models/GasLabHeatBox.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2002 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/GasLabHeatBox
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model is one in a series of GasLab models. They use the same basic rules for simulating the behavior of gases.  Each model integrates different features in order to highlight different aspects of gas behavior.

The basic principle of the models is that gas particles are assumed to have two elementary actions: they move and they collide - either with other particles or with any other objects such as walls.

This model is illustrates the relationship between temperature and pressure in
a fixed volume gas container.

This model is part of the Connected Mathematics ""Making Sense of Complex Phenomena"" Modeling Project.

HOW IT WORKS
------------
The particles are modeled as hard balls with no internal energy except that which is due to their motion.  Collisions between particles are elastic.

1. A particle moves in a straight line without changing its speed, unless it collides with another particle or bounces off the wall.
2. Two particles ""collide"" if they find themselves on the same patch. In this model, two turtles are aimed so that they will collide at the origin.
3. An angle of collision for the particles is chosen, as if they were two solid balls that hit, and this angle describes the direction of the line connecting their centers.
4. The particles exchange momentum and energy only along this line, conforming to the conservation of momentum and energy for elastic collisions.
5. Each particle is assigned its new speed, heading and energy.
6. If a particle finds itself on or very close to a wall of the container, it ""bounces"" -- that is, reflects its direction and keeps its same speed.

As the walls of the box are heated, the sides of the walls will change color from a deep red (cool) to a bright red, to pink to a pale pink white (hot).  The walls contain a constant heat value throughout the simulation.  If ONE-SIDE? is set to ON, only the left wall will be heated, while the other three walls remain yellow.

The exact way particles gain energy from the walls of the box is as follows:
1. Particles check their state of energy.
2. They hit or bounce off the wall.
3. They find wall energy and recalculate their new energy.
4. They change their speed and direction after the wall hit.


HOW TO USE IT
-------------
Initial settings:
- NUMBER-OF-PARTICLES: number of particles within in the box

Buttons:
The SETUP button will set these initial conditions.
The GO button will begin the simulation.

Other Settings:
-  OUTSIDE TEMPERATURE: temperature of the outside of the box and the wall of the box.
-  ONE SIDE?: heats only the left wall if enabled.  the other walls are colored yellow, and do not affect the energy of the particles that bounce into it.
- COLLIDE?: Turns collisions between particles on and off.

Monitors:
- PRESSURE: the pressure of the gas particles in the box
- WALL HITS PER PARTICLE: number of times that each particle hit the walls
- AVERAGE SPEED: average speed of the particles.
- AVERAGE ENERGY: average kinetic energy of the particles.

Plots:
- SPEED COUNTS: plots the number of particles in each range of speed.
- SPEED HISTOGRAM: speed distribution of all the particles.  The gray line is the average value, and the black line is the initial average.
- ENERGY HISTOGRAM: distribution of energies of all the particles, calculated as m*(v^2)/2.
- PRESSURE VS. TIME: plots average pressure of the inside of the box over time.
- TEMPERATURE VS. TIME: plots particle temperature inside the box over time and wall temperature over time.
- WALL HITS PER PARTICLE: plots average wall hits per particle over time.

THINGS TO NOTICE
----------------

How does adding heat to the box walls affect the pressure?

How does adding heat to the wall affect the particle behavior?

How does the particle behavior or system response change with only one wall heated instead of all walls heated?

Does the system reach an equilibrium temperature faster when the wall is heated or cooled the same amount in comparison to the temperature of the particles?


THINGS TO TRY
-------------
Try to get the inside temperature to reach the outside temperature.  Is this possible?

Try to increase the wall hits per particle.


EXTENDING THE MODEL
-------------------
Give the wall a mass and see how that affects the behavior of the model.

Close off the right side of the box.  Create two valves on either side to the wall that allow the user to ""spurt"" particles into the chambers to see how number of particles affects pressure.

Vary the width and length of the box, does this effect how fast the particle temperature changes?


NETLOGO FEATURES
----------------
Notice how the collisions are detected by the turtles and how the code guarantees the same two particles do not collide twice.  What happens if we let the patches detect them?


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (2002).  NetLogo GasLab Heat Box model.  http://ccl.northwestern.edu/netlogo/models/GasLabHeatBox.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2002 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/GasLabHeatBox for terms of use.
"
GasLab Moving Piston,/models/Sample Models/Chemistry & Physics/GasLab/Unverified,"globals [
  fast average slow     ;; current counts
  avg-speed avg-energy  ;; current averages
  vsplit vclock         ;; clock variables
  raw-width raw-height  ;; box size variables
  piston-position       ;; position of the piston at any given time
  volume area           ;; because this is 2D, area is the perimeter and volume is the area
  total-pressure        ;; pressure per unit area
  pressure-history      ;; list of 'scale' previous total-pressures
  avg-pressure          ;; mean of the pressure-history
  initspeed initmass    ;; initial speed and initial mass of the all the particles-particle mass always stays the same, but the speed changes.
  going-down?           ;; flag for whether or not the piston is moving up or down
]

turtles-own [
  speed mass energy new-speed            ;; Turtle Info
  v1t v1l tmp-turtle                     ;; Turtle 1 -- Collide
  heading2 mass2 speed2 v2t v2l turtle2  ;; Turtle 2 -- Collide
  theta                                  ;; Turtles 1 + 2 -- Collide
  pressure                               ;; pressure variable
]

;; procedure that setup up initial variables
to setup
  ca
  set going-down? true
  set pressure-history []
  set initspeed 10.0
  set initmass 1.0
  set raw-width  round (0.01 * box-width  * max-pxcor)
  set raw-height round (0.01 * box-height * max-pycor)
  set piston-position 0.75 * raw-height
  set area ((4 * raw-width) + (2 * (piston-position + raw-height)))
  set volume ((2 * raw-width) * (piston-position + raw-height))
  make-box
  draw-piston
  ;;set vclock 0
  ;; create the gas molecules
  crt number [
     set new-speed initspeed
     set mass initmass
     random-position
     set shape ""circle""
     recolor
     set pressure 0
  ]
  update-variables
  setup-histograms
end

;; updates variables after every time tick
to update-variables
  ;; Gas Variables
  ask turtles
    [ set speed new-speed
      set energy (0.5 * mass * speed * speed) ]
  set average count turtles with [ color = green ]
  set slow    count turtles with [ color = blue  ]
  set fast    count turtles with [ color = red   ]
  set avg-speed  mean [ speed  ] of turtles
  set avg-energy mean [ energy ] of turtles

  ;; System Variables
  calculate-pressure
  set vsplit (round (max [speed] of turtles * 1.2))
end

;; procedure that runs the model
to go
  ask turtles [bounce]
  ask turtles [move]
  ask turtles [check-for-collision]
  ;; control the piston's motion
  if piston-position < (-0.75 * raw-height)
  [ set going-down? false ]
  if piston-position > (0.75 * raw-height)
  [ set going-down? true ]
  ifelse going-down?
  [ piston-down piston-speed / vsplit ]
  [ piston-up piston-speed / vsplit ]

  set vclock vclock + 1
  ifelse (vclock = vsplit)
  [
    tick
    set vclock 0
    update-variables
    do-plotting
    do-histograms
  ]
  [ display ]
end


;; turtle procedure for bouncing off of the walls
to bounce
  ; if we're not about to hit a wall (yellow patch)
  ; or the piston (gray+2 patch),
  ; we don't need to do any further checks
  if ([pcolor] of patch-ahead 1 != yellow) and
     ([pcolor] of patch-ahead 1 != gray + 2) [ stop ]
  ; get the coordinates of the patch we'll be on if we go forward 1
  let new-px [pxcor] of patch-ahead 1
  let new-py [pycor] of patch-ahead 1
  ; check: hitting left or right wall?
  if (abs new-px = raw-width)
    ; if so, reflect heading around x axis
    [ set heading (- heading)
      set pressure pressure + abs (sin heading * mass * speed)
    ]
  ; check: hitting piston or bottom wall?
  if (abs new-py = raw-height) or (new-py = round piston-position)
    ; if so, reflect heading around y axis
    [ set heading (180 - heading)
      set pressure pressure + abs (cos heading * mass * speed)
    ]
end

;; turtle procedure that moves all the particles
to move
  jump (speed / vsplit)
end

;; turtle procedure to check to see if two particles collide
to check-for-collision
  if count other turtles-here = 1
    [ set tmp-turtle one-of other turtles-here
      if ((who > [who] of tmp-turtle) and (turtle2 != tmp-turtle))
        [ collide ]
    ]
end

;; turtle procedure for when two particles collide
to collide
  get-turtle2-info
  calculate-velocity-components
  set-new-speed-and-headings
end

;; turtle gets mass and speed info from turtle it is colliding with
to get-turtle2-info
  set turtle2 tmp-turtle
  set mass2 [mass] of turtle2
  set speed2 [new-speed] of turtle2
  set heading2 [heading] of turtle2
end

;; calculates new turtle velocity after the collision
to calculate-velocity-components
  set theta (random-float 360)
  set v1l (new-speed * sin (theta - heading))
  set v1t (new-speed * cos (theta - heading))
  set v2l (speed2 * sin (theta - heading2))
  set v2t (speed2 * cos (theta - heading2))
  let vcm (((mass * v1t) + (mass2 * v2t)) / (mass + mass2))
  set v1t (vcm + vcm - v1t)
  set v2t (vcm + vcm - v2t)
end

;; set new speed and headings of each turtles that has had a collision
to set-new-speed-and-headings
  set new-speed sqrt ((v1t * v1t) + (v1l * v1l))
  set heading (theta - (atan v1l v1t))

  let new-speed2 sqrt ((v2t * v2t) + (v2l * v2l))
  let new-heading (theta - (atan v2l v2t))
  ask turtle2 [
    set new-speed new-speed2
    set heading new-heading
  ]

  recolor
  ask turtle2 [ recolor ]
end

to recolor  ;; turtle procedure
  ifelse new-speed < (0.5 * initspeed)
    [ set color blue ]
    [ ifelse new-speed > (1.5 * initspeed)
        [ set color red ]
        [ set color green ] ]
end

;; patch procedure to make a box
to make-box
  ask patches with [ ((abs pxcor = raw-width) and (abs pycor <= raw-height)) or
                     ((abs pycor = raw-height) and (abs pxcor <= raw-width)) ]
    [ set pcolor yellow ]
end

;; turtle procedure to give turtles a random position within the confined area
to random-position
  setxy ((1 - raw-width)  + random-float (2 * raw-width - 2))
        ((1 - raw-height) + random-float (raw-height + piston-position - 2))
end


;; ------ Piston ----------
to piston-up [dist]
  if (dist > 0)
  [ ifelse ((piston-position + dist) < raw-height - 1)
    [ undraw-piston
      set piston-position (piston-position + dist)
      draw-piston ]
    [ undraw-piston
      set piston-position (raw-height - 1)
      draw-piston ]
    set volume ((2 * raw-width) * (piston-position + raw-height))
    set area ((4 * raw-width) + (2 * (piston-position + raw-height)))
  ]
end

to piston-down [dist]
  if (dist > 0)
  [ ifelse (piston-position - dist) > (2 - raw-height)
    [ undraw-piston
      set piston-position (piston-position - dist)
      ask turtles
      [ if (ycor >= (piston-position - 1))
        [ bounce-off-piston ] ]
      draw-piston ]
    [ undraw-piston
      set piston-position (3 - raw-height)
      ask turtles
      [ if (pycor >= 3 - raw-height)
        [ bounce-off-piston ] ]
      draw-piston ]
    set area ((4 * raw-width) + (2 * (piston-position + raw-height)))
    set volume ((2 * raw-width) * (piston-position + raw-height))
  ]
end

to draw-piston
  ask patches with [ ((pycor = (round piston-position)) and ((abs pxcor) < raw-width)) ]
    [ set pcolor gray + 2 ]
end

to undraw-piston
  ask patches with [ (pycor = round piston-position) and ((abs pxcor) < raw-width) ]
    [ set pcolor black ]
end

to bounce-off-piston  ;; Turtles procedure particle bounces off piston
  ifelse ((((2 * piston-position) - (ycor + 2)) < (1 - raw-height)) or
          (((2 * piston-position) - (ycor + 2)) > (piston-position - 2)))
   [ set ycor ((random (raw-height + piston-position - 2)) - (raw-height - 1)) ]
   [ set ycor ((2 * piston-position) - (ycor + 2)) ]
end

to calculate-pressure  ;; Observer procedure
  set total-pressure 100 * (sum [pressure] of turtles) / area
  ifelse (length pressure-history < scale)
  [ set pressure-history fput total-pressure pressure-history ]
  [ set pressure-history fput total-pressure but-last pressure-history ]
  set avg-pressure mean pressure-history
  ;; rezero pressures in preparation for the next cycle
  ask turtles [ set pressure 0 ]
end

;;; plotting procedures
to setup-histograms
  ;; Speed Histogram
  set-current-plot ""Speed histogram""
  set-plot-x-range 0 (initspeed * 2)
  set-plot-y-range 0 ceiling (number / 6)
  set-current-plot-pen ""average""
  set-histogram-num-bars 45
  set-current-plot-pen ""fast""
  set-histogram-num-bars 45
  set-current-plot-pen ""slow""
  set-histogram-num-bars 45

  ;; Energy histogram
  set-current-plot ""Energy histogram""
  set-plot-x-range 0 (0.5 * (initspeed * 2) * (initspeed * 2) * initmass)
  set-plot-y-range 0 ceiling (number / 6)
  set-current-plot-pen ""average""
  set-histogram-num-bars 45
  set-current-plot-pen ""fast""
  set-histogram-num-bars 45
  set-current-plot-pen ""slow""
  set-histogram-num-bars 45
end

;; does actual plotting (called in Go)
to do-plotting
  set-current-plot ""Volume""
  plot volume
  set-current-plot ""Pressure""
  plot avg-pressure
  set-current-plot ""Temperature""
  plot avg-energy
  set-current-plot ""Pressure vs. Volume""
  plotxy volume avg-pressure
  set-current-plot ""Pressure * Volume""
  plot avg-pressure * volume / 1000
end

;; does actual histograms plotting (called in Go)
to do-histograms
  if (histogram?)
    [ histo-energy
      histo-speed ]
end

;; draw energy histogram
to histo-energy
  set-current-plot ""Energy histogram""
  set-current-plot-pen ""average""
  histogram [ energy ] of turtles with [ color = green ]
  set-current-plot-pen ""slow""
  histogram [ energy ] of turtles with [ color = blue ]
  set-current-plot-pen ""fast""
  histogram [ energy ] of turtles with [ color = red ]
  set-current-plot-pen ""avg-energy""
  plot-pen-reset
  draw-vert-line avg-energy
end

;; draw speed histogram
to histo-speed
  set-current-plot ""Speed histogram""
  set-current-plot-pen ""average""
  histogram [ speed ] of turtles with [ color = green ]
  set-current-plot-pen ""slow""
  histogram [ speed ] of turtles with [ color = blue ]
  set-current-plot-pen ""fast""
  histogram [ speed ] of turtles with [ color = red ]
  set-current-plot-pen ""avg-speed""
  plot-pen-reset
  draw-vert-line avg-speed
end

; draws a vertical line at xval on the current-plot with the current plot-pen
to draw-vert-line [xval]
  plotxy xval plot-y-min
  plot-pen-down
  plotxy xval plot-y-max
  plot-pen-up
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model and associated activities and materials were created as
; part of the project: MODELING ACROSS THE CURRICULUM.  The project
; gratefully acknowledges the support of the National Science Foundation,
; the National Institute of Health, and the Department of Education
; (IERI program) -- grant number REC # 0115699.Additional support
; was provided through the projects: PARTICIPATORY SIMULATIONS:
; NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN CLASSROOMS and/or
; INTEGRATED SIMULATION AND MODELING ENVIRONMENT -- NSF (REPP & ROLE
; programs) grant numbers REC #9814682 and REC-0126227.

; Copyright 2002 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2002).  NetLogo GasLab Moving Piston model.
; http://ccl.northwestern.edu/netlogo/models/GasLabMovingPiston.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2002 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/GasLabMovingPiston
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model simulates the behavior of gas particles as the volume changes. In this model, the volume is slowly changing over time by a piston that is rising and falling.  As the piston lowers, the volume of the box decreases and as the piston rises, the volume of the box increases.  This systematic motion of the piston does no work on the particles inside the box.  The piston only serves a mechanism to change the volume of the box.

The particles start with the same mass and speed upon the start of the simulation. The mass of the particles stays constant throughout the simulation, whereas, the speeds will change once particles start to collide.  Particles are in constant motion colliding with other particles and the walls. All collisions are modeled as elastic collisions, in that the total kinetic energy before and after the collision is conserved.  For example, when a fast moving particle collides with a slow moving particle, the fast moving particle will give some of its speed to the slow moving particle.  Therefore, the fast moving particle will leave the collision moving slower then when it entered the collision.  And the slow moving particle will speed up a bit.  The speed in a particle to particle collision is still conserved.  The collisions between a particle and a wall is modeled the same way.  When the particles hit the wall they transfer momentum to the wall.  After this transfer occurs, the particles then bounce off the wall with a different direction and speed. The system's pressure is calculated by averaging the number of collisions the particles have with the walls at each time step.

The Moving Piston model is one of a collection of GasLab models that use the same basic rules for expressing what happens when gas particles collide.  Each model in this collection has different features to show the different aspects of the Gas Laws.

Multiple adaptations of this model can be found in the Chemistry folder of the Curricular Models section under the names Chem Volume 1 and 2.  It is part of a suite of models used to teach students about the chemistry of the Gas Laws.


HOW IT WORKS
------------
The particles are modeled as single particles, all with the same mass and initial velocity.  Molecules are modeled as perfectly elastic particles with no internal energy except that which is due to their motion.  Collisions with the box and between molecules are elastic.  Particles are colored according to speed -- blue for slow, green for medium, and red for high speeds.

The exact way two particles collide is as follows:
1. Two turtles ""collide"" if they find themselves on the same patch.
2. A random axis is chosen, as if they were two billiard balls that hit and this axis was the line connecting their centers.
3. They exchange momentum and energy along that axis, according to the conservation of momentum and energy.  This calculation is done in the center mass system.
4. Each turtle is assigned its new speed, energy and heading.
5. If a turtle finds itself on or very close to a wall of the container, it ""bounces"" -- that is, reflects its direction and keeps its same speed.


HOW TO USE IT
-------------
Buttons:
SETUP - puts in the initial conditions you have set with the sliders.  Be sure to wait till the SETUP button stops before pushing GO.
GO - runs the code again and again.  This is a ""forever"" button.

Sliders:
BOX-HEIGHT - height of the container
BOX-WIDTH - width of the container
NUMBER - number of particles
PISTON-SPEED - rate of the piston
SCALE - number of clock cycles over which to average the pressure

Switch:
HISTOGRAM? - turns histograms on or off

Plots:
VOLUME - plots the volume over time
PRESSURE - plots the pressure over time
PRESSURE VS. VOLUME - plots pressure over volume
PRESSURE * VOLUME - plots the value of pressure * volume over time
TEMPERATURE - plots the average temperature
SPEED HISTOGRAM - illustrates the number of particles at their various speeds
ENERGY HISTOGRAM - illustrates the number of particles at their various energy levels

Adjust the BOX-HEIGHT, BOX-WIDTH, NUMBER, and PISTON-SPEED variable before pressing SETUP.  The SETUP button will set the initial conditions.  The GO button will run the simulation.

In this model, though, the collisions of the piston with the particles are ignored. Note that there's a physical impossibility in the model here: in real life if you moved the piston down you would do work on the gas by compressing it, and its temperature would increase.  In this model, the energy and temperature are constant no matter how you manipulate the piston.  Nonetheless, the basic relationship between volume and pressure is correctly demonstrated here.


THINGS TO NOTICE
----------------
How does the pressure change as the volume of the box changes?  Compare the two plots of volume and pressure.

How does the pressure change as the shape of the box changes?

Measure changes in pressure and volume. Is there a clear quantitative relationship?

How can the relationship between pressure and volume be explained in terms of the collisions of molecules?

How does more particles change the relationship between pressure and volume?

What shapes do the energy and speed histograms reach after a while?  Why aren't they the same?  Do the pressure and volume affect these shapes?


THINGS TO TRY
-------------
How would you calculate pressure?  How does this code do it?

Change the number, mass, and initial velocity of the particles.  Does this affect the pressure?   Why? Do the results make intuitive sense?  Look at the extremes:  very few or very many molecules,  high or low volumes.

Figure out how many molecules there REALLY are in a box this size -- say a 10-cm cube.  Look up or calculate the REAL mass and speed of a typical molecule.  When you compare those numbers to the ones in the model, are you surprised this model works as well as it does?


EXTENDING THE MODEL
-------------------
Are there other ways one might calculate pressure?

Create an isothermal piston example where the user can manually move the piston to any level in the box.

Add in a temperature variable that allows for the particles to move the piston to the appropriate volume.


NETLOGO FEATURES
----------------
Notice how collisions are detected by the turtles and how the code guarantees that the same two particles do not collide twice.  What happens if we let the patches detect them?


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (2002).  NetLogo GasLab Moving Piston model.  http://ccl.northwestern.edu/netlogo/models/GasLabMovingPiston.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2002 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/GasLabMovingPiston for terms of use.
"
GasLab Pressure Box,/models/Sample Models/Chemistry & Physics/GasLab/Unverified,"globals
[
  tick-delta                         ;; how much we advance the tick counter this time through
  max-tick-delta                     ;; the largest tick-delta is allowed to be
  init-particle-speed particle-mass  ;; default particle settings
  box-edge                           ;; distance of box edge from axes
  pressure
  pressure-history
  wall-hits-per-particle     ;; average number of wall hits per particle
  length-horizontal-surface  ;; the size of the wall surfaces that run horizontally - the top and bottom of the box
  length-vertical-surface    ;; the size of the wall surfaces that run vertically - the left and right of the box

  init-avg-speed init-avg-energy  ;; initial averages
  avg-speed avg-energy            ;; current averages
  fast medium slow                ;; current counts

]

breed [ particles particle ]
breed [ flashes flash ]

flashes-own [birthday]

particles-own
[
  speed mass energy          ;; particle info
  wall-hits                  ;; # of wall hits during this cycle (""big tick"")
  momentum-difference        ;; used to calculate pressure from wall hits
  last-collision
]


to setup
  ca
  set-default-shape particles ""circle""
  set-default-shape flashes ""plane""
  set init-particle-speed 10.0
  set particle-mass 1.0
  set max-tick-delta 0.1073
  ;; box size is determined by the slider
  set box-edge (round (max-pxcor * box-size / 100))
  ;;; the length of the horizontal or vertical surface of
  ;;; the inside of the box must exclude the two patches
  ;; that are the where the perpendicular walls join it,
  ;;; but must also add in the axes as an additional patch
  ;;; example:  a box with an box-edge of 10, is drawn with
  ;;; 19 patches of wall space on the inside of the box
  set length-horizontal-surface  ( 2 * (box-edge - 1) + 1)
  set length-vertical-surface  ( 2 * (box-edge - 1) + 1)
  make-box
  make-particles
  set pressure-history [0 0 0]  ;; plotted pressure will be averaged over the past 3 entries
  update-variables
  set init-avg-speed avg-speed
  set init-avg-energy avg-energy
  setup-plots
  do-plotting
end

to update-variables
  set medium count particles with [color = green]
  set slow   count particles with [color = blue]
  set fast   count particles with [color = red]
  set avg-speed  mean [speed] of particles
  set avg-energy mean [energy] of particles
end

to go
  ask particles [ bounce ]
  ask particles [ move ]
  ask particles
  [ if collide? [check-for-collision] ]
  tick-advance tick-delta
  if floor ticks > floor (ticks - tick-delta)
  [
    ifelse any? particles
      [ set wall-hits-per-particle mean [wall-hits] of particles ]
      [ set wall-hits-per-particle 0 ]
    ask particles
      [ set wall-hits 0 ]
    calculate-pressure
    update-variables
    do-plotting
  ]
  calculate-tick-delta
  ask flashes with [ticks - birthday > 0.4]
    [ die ]
  display
end

to calculate-tick-delta
  ;; tick-delta is calculated in such way that even the fastest
  ;; particle will jump at most 1 patch length in a tick. As
  ;; particles jump (speed * tick-delta) at every tick, making
  ;; tick length the inverse of the speed of the fastest particle
  ;; (1/max speed) assures that. Having each particle advance at most
  ;; one patch-length is necessary for it not to ""jump over"" a wall
  ;; or another particle.
  ifelse any? particles with [speed > 0]
    [ set tick-delta min list (1 / (ceiling max [speed] of particles)) max-tick-delta ]
    [ set tick-delta max-tick-delta ]
end

;;; Pressure is defined as the force per unit area.  In this context,
;;; that means the total momentum per unit time transferred to the walls
;;; by particle hits, divided by the surface area of the walls.  (Here
;;; we're in a two dimensional world, so the ""surface area"" of the walls
;;; is just their length.)  Each wall contributes a different amount
;;; to the total pressure in the box, based on the number of collisions, the
;;; direction of each collision, and the length of the wall.  Conservation of momentum
;;; in hits ensures that the difference in momentum for the particles is equal to and
;;; opposite to that for the wall.  The force on each wall is the rate of change in
;;; momentum imparted to the wall, or the sum of change in momentum for each particle:
;;; F = SUM  [d(mv)/dt] = SUM [m(dv/dt)] = SUM [ ma ], in a direction perpendicular to
;;; the wall surface.  The pressure (P) on a given wall is the force (F) applied to that
;;; wall over its surface area.  The total pressure in the box is sum of each wall's
;;; pressure contribution.

to calculate-pressure
  ;; by summing the momentum change for each particle,
  ;; the wall's total momentum change is calculated
  set pressure 15 * sum [momentum-difference] of particles
  set pressure-history lput pressure but-first pressure-history
  ask particles
    [ set momentum-difference 0 ]  ;; once the contribution to momentum has been calculated
                                   ;; this value is reset to zero till the next wall hit
end

to bounce  ;; particle procedure
  ;; get the coordinates of the patch we'll be on if we go forward 1
  let new-patch patch-ahead 1
  let new-px [pxcor] of new-patch
  let new-py [pycor] of new-patch

  ;; if we're not about to hit the edge of the wall, we don't need to do any further checks
  ;; note: we check the new coordinates, and not the color, to make sure particles
  ;; do not go into the nozzle
  if (abs new-px != box-edge and abs new-py != box-edge)
    [ stop ]
  ;; if hitting left or right wall, reflect heading around x axis
  if (abs new-px = box-edge)
    [ set heading (- heading)
      set wall-hits wall-hits + 1
  ;;  if the particle is hitting a vertical wall, only the horizontal component of the speed
  ;;  vector can change.  The change in velocity for this component is 2 * the speed of the particle,
  ;;  due to the reversing of direction of travel from the collision with the wall
      set momentum-difference momentum-difference + (abs (sin heading * 2 * mass * speed) / length-vertical-surface) ]
  ;; if hitting top or bottom wall, reflect heading around y axis
  if (abs new-py = box-edge)
    [ set heading (180 - heading)
      set wall-hits wall-hits + 1
  ;;  if the particle is hitting a horizontal wall, only the vertical component of the speed
  ;;  vector can change.  The change in velocity for this component is 2 * the speed of the particle,
  ;;  due to the reversing of direction of travel from the collision with the wall
      set momentum-difference momentum-difference + (abs (cos heading * 2 * mass * speed) / length-horizontal-surface)  ]

  ;; if we are at the entrance of the nozzle, do not make a flash
  if (new-py = 0 and new-px = (- box-edge))
    [stop]

  ask patch new-px new-py
  [ sprout-flashes 1 [
      set color pcolor - 2
      set birthday ticks
      set heading 0
    ]
  ]
end

to move  ;; particle procedure
  if patch-ahead (speed * tick-delta) != patch-here
    [ set last-collision nobody ]
  jump (speed * tick-delta)
end

to check-for-collision  ;; particle procedure
  ;; Here we impose a rule that collisions only take place when there
  ;; are exactly two particles per patch.  We do this because when the
  ;; student introduces new particles from the side, we want them to
  ;; form a uniform wavefront.
  ;;
  ;; Why do we want a uniform wavefront?  Because it is actually more
  ;; realistic.  (And also because the curriculum uses the uniform
  ;; wavefront to help teach the relationship between particle collisions,
  ;; wall hits, and pressure.)
  ;;
  ;; Why is it realistic to assume a uniform wavefront?  Because in reality,
  ;; whether a collision takes place would depend on the actual headings
  ;; of the particles, not merely on their proximity.  Since the particles
  ;; in the wavefront have identical speeds and near-identical headings,
  ;; in reality they would not collide.  So even though the two-particles
  ;; rule is not itself realistic, it produces a realistic result.  Also,
  ;; unless the number of particles is extremely large, it is very rare
  ;; for three or more particles to land on the same patch (for example,
  ;; with 400 particles it happens less than 1% of the time).  So imposing
  ;; this additional rule should have only a negligible effect on the
  ;; aggregate behavior of the system.
  ;;
  ;; Why does this rule produce a uniform wavefront?  The particles all
  ;; start out on the same patch, which means that without the only-two
  ;; rule, they would all start colliding with each other immediately,
  ;; resulting in much random variation of speeds and headings.  With
  ;; the only-two rule, they are prevented from colliding with each other
  ;; until they have spread out a lot.  (And in fact, if you observe
  ;; the wavefront closely, you will see that it is not completely smooth,
  ;; because some collisions eventually do start occurring when it thins out while fanning.)

  if count other particles-here = 1
  [
    ;; the following conditions are imposed on collision candidates:
    ;;   1. they must have a lower who number than my own, because collision
    ;;      code is asymmetrical: it must always happen from the point of view
    ;;      of just one particle.
    ;;   2. they must not be the same particle that we last collided with on
    ;;      this patch, so that we have a chance to leave the patch after we've
    ;;      collided with someone.
    let candidate one-of other particles-here with
      [who < [who] of myself and myself != last-collision]
    ;; we also only collide if one of us has non-zero speed. It's useless
    ;; (and incorrect, actually) for two particles with zero speed to collide.
    if (candidate != nobody) and (speed > 0 or [speed] of candidate > 0)
    [
      collide-with candidate
      set last-collision candidate
      ask candidate [ set last-collision myself ]
    ]
  ]
end

;; implements a collision with another particle.
;;
;; THIS IS THE HEART OF THE PARTICLE SIMULATION, AND YOU ARE STRONGLY ADVISED
;; NOT TO CHANGE IT UNLESS YOU REALLY UNDERSTAND WHAT YOU'RE DOING!
;;
;; The two particles colliding are self and other-particle, and while the
;; collision is performed from the point of view of self, both particles are
;; modified to reflect its effects. This is somewhat complicated, so I'll
;; give a general outline here:
;;   1. Do initial setup, and determine the heading between particle centers
;;      (call it theta).
;;   2. Convert the representation of the velocity of each particle from
;;      speed/heading to a theta-based vector whose first component is the
;;      particle's speed along theta, and whose second component is the speed
;;      perpendicular to theta.
;;   3. Modify the velocity vectors to reflect the effects of the collision.
;;      This involves:
;;        a. computing the velocity of the center of mass of the whole system
;;           along direction theta
;;        b. updating the along-theta components of the two velocity vectors.
;;   4. Convert from the theta-based vector representation of velocity back to
;;      the usual speed/heading representation for each particle.
;;   5. Perform final cleanup and update derived quantities.
to collide-with [ other-particle ] ;; particle procedure
  ;;; PHASE 1: initial setup

  ;; for convenience, grab some quantities from other-particle
  let mass2 [mass] of other-particle
  let speed2 [speed] of other-particle
  let heading2 [heading] of other-particle

  ;; since particles are modeled as zero-size points, theta isn't meaningfully
  ;; defined. we can assign it randomly without affecting the model's outcome.
  let theta (random-float 360)



  ;;; PHASE 2: convert velocities to theta-based vector representation

  ;; now convert my velocity from speed/heading representation to components
  ;; along theta and perpendicular to theta
  let v1t (speed * cos (theta - heading))
  let v1l (speed * sin (theta - heading))

  ;; do the same for other-particle
  let v2t (speed2 * cos (theta - heading2))
  let v2l (speed2 * sin (theta - heading2))



  ;;; PHASE 3: manipulate vectors to implement collision

  ;; compute the velocity of the system's center of mass along theta
  let vcm (((mass * v1t) + (mass2 * v2t)) / (mass + mass2) )

  ;; now compute the new velocity for each particle along direction theta.
  ;; velocity perpendicular to theta is unaffected by a collision along theta,
  ;; so the next two lines actually implement the collision itself, in the
  ;; sense that the effects of the collision are exactly the following changes
  ;; in particle velocity.
  set v1t (2 * vcm - v1t)
  set v2t (2 * vcm - v2t)



  ;;; PHASE 4: convert back to normal speed/heading

  ;; now convert my velocity vector into my new speed and heading
  set speed sqrt ((v1t ^ 2) + (v1l ^ 2))
  set energy (0.5 * mass * speed ^ 2)
  ;; if the magnitude of the velocity vector is 0, atan is undefined. but
  ;; speed will be 0, so heading is irrelevant anyway. therefore, in that
  ;; case we'll just leave it unmodified.
  if v1l != 0 or v1t != 0
    [ set heading (theta - (atan v1l v1t)) ]

  ;; and do the same for other-particle
  ask other-particle [
    set speed sqrt ((v2t ^ 2) + (v2l ^ 2))
    set energy (0.5 * mass * (speed ^ 2))
    if v2l != 0 or v2t != 0
      [ set heading (theta - (atan v2l v2t)) ]
  ]



  ;; PHASE 5: final updates

  ;; now recolor, since color is based on quantities that may have changed
  recolor
  ask other-particle
    [ recolor ]
end

to recolor  ;; particle procedure
  ifelse speed < (0.5 * 10)
  [
    set color blue
  ]
  [
    ifelse speed > (1.5 * 10)
      [ set color red ]
      [ set color green ]
  ]
end


;;;
;;; drawing procedures
;;;

;; draws the box
to make-box
  ask patches with [ ((abs pxcor = box-edge) and (abs pycor <= box-edge)) or
                     ((abs pycor = box-edge) and (abs pxcor <= box-edge)) ]
    [ set pcolor yellow ]
  ;; make nozzle
  ask patches with [ pycor = 0 and pxcor < (1 - box-edge) ]
  [
    set pcolor yellow - 5  ;; trick the bounce code so particles don't go into the inlet.
    ask patch-at 0  1 [ set pcolor yellow ]
    ask patch-at 0 -1 [ set pcolor yellow ]
  ]
end

;; creates initial particles
to make-particles
  create-particles initial-number-of-particles
  [
    setup-particle
    random-position
    recolor
  ]
  calculate-tick-delta
end

;; adds new particles into the box from the left nozzle
to add-particles [n]
  if n > 0
    [ create-particles n
        [ setup-particle
          setxy (- box-edge) 0
          set heading 90 ;; east
          rt 45 - random-float 90
          recolor
        ]
      calculate-tick-delta
    ]
end


to setup-particle  ;; particle procedure
  set speed init-particle-speed
  set mass particle-mass
  set energy (0.5 * mass * speed ^ 2)
  set last-collision nobody
  set wall-hits 0
  set momentum-difference 0
end

;; place particle at random location inside the box.
to random-position ;; particle procedure
  setxy ((1 - box-edge) + random-float ((2 * box-edge) - 2))
        ((1 - box-edge) + random-float ((2 * box-edge) - 2))
  set heading random-float 360
end

;;; plotting procedures

to setup-plots
  set-current-plot ""Particle Count""
  set-plot-y-range 0 initial-number-of-particles
end

to do-plotting
  set-current-plot ""Pressure""
  plotxy ticks (mean pressure-history)

  set-current-plot ""Particle Count""
  plotxy ticks (count particles)

  if ticks > 1
  [
     set-current-plot ""Wall Hits per Particle""
     plotxy ticks wall-hits-per-particle
  ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model and associated activities and materials were created as
; part of the project: MODELING ACROSS THE CURRICULUM.  The project
; gratefully acknowledges the support of the National Science Foundation,
; the National Institute of Health, and the Department of Education
; (IERI program) -- grant number REC # 0115699.Additional support
; was provided through the projects: PARTICIPATORY SIMULATIONS:
; NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN CLASSROOMS and/or
; INTEGRATED SIMULATION AND MODELING ENVIRONMENT -- NSF (REPP & ROLE
; programs) grant numbers REC #9814682 and REC-0126227.

; Copyright 2002 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2002).  NetLogo GasLab Pressure Box model.
; http://ccl.northwestern.edu/netlogo/models/GasLabPressureBox.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2002 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/GasLabPressureBox
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model is one in a series of GasLab models. They use the same basic rules for simulating the behavior of gases.  Each model integrates different features in order to highlight different aspects of gas behavior.

The basic principle of the models is that gas particles are assumed to have two elementary actions: they move and they collide - either with other particles or with any other objects such as walls.

This model simulates the behavior of gas particles trapped in a container with a fixed volume, such as inflating a bike tire.  The number of particles in the box can be changed by adding particles through a valve on the side.

This model is part of the Connected Chemistry curriculum, which is part of the Modeling Across the Curriculum (MAC) Project.


HOW IT WORKS
------------
The particles are modeled as hard balls with no internal energy except that which is due to their motion.  Collisions between particles are elastic.  Particles are colored according to speed -- blue for slow, green for medium, and red for high speeds.

Coloring of the particles is with respect to one speed (10).  Particles with a speed less than 5 are blue, ones that are more than 15 are red, while all in those in-between are green.

Particles behave according to the following rules:
1. A particle moves in a straight line without changing its speed, unless it collides with another particle or bounces off the wall.
2. Two particles ""collide"" if they find themselves on the same patch (the world is composed of a grid of small squares called patches).
3. A random axis is chosen, as if they are two balls that hit each other and this axis is the line connecting their centers.
4. They exchange momentum and energy along that axis, according to the conservation of momentum and energy.  This calculation is done in the center of mass system.
5. Each turtle is assigned its new velocity, energy, and heading.
6. If a turtle finds itself on or very close to a wall of the container, it ""bounces"" -- that is, reflects its direction and keeps its same speed.

Pressure is calculated as the force per unit area (or length in this two-dimensional model).  Pressure is calculated by adding up the momentum transferred to the walls of the box by the particles when they bounce off and divided by the length of the wall, which they hit.


HOW TO USE IT
-------------
Initial settings:
- BOX-SIZE: The size of the box as a percentage of the world-width
- INITIAL-NUMBER-PARTICLES: the number of gas particles in the box when the simulation starts

The SETUP button puts in the initial conditions you have set with the sliders.  Be sure to wait until the SETUP button stops before pushing GO.
The GO button runs the code again and again.  This is a ""forever"" button.

Additional settings:
COLLIDE?: determines whether or not the particles collide among themselves
ADD PARTICLES: pressing this button adds particles to the container through a valve, before and while the model is running
NUMBER-TO-ADD: number of particles that are added to the box with each press of the ""ADD PARTICLES"" button

Monitors:
- NUMBER OF PARTICLES: the number of particles in the box
- PRESSURE: the pressure of the gas particles in the box
- WALL HITS PER PARTICLE:
- AVERAGE SPEED: average speed of the particles.
- AVERAGE ENERGY: average kinetic energy of the particles.

Plots:
- PRESSURE: plots the pressure in the box
- PARTICLE COUNT: plots the number of particles in the box
- WALL HITS PER PARTICLE: plots the number of times a particle hits a wall every big tick

Pressure is defined as the force per unit area (or length in this two-dimensional model).  Pressure is calculated by adding up the momentum transferred to the walls of the box by the particles when they bounce off and divided by the length of the wall, which they hit.

Initially, the particles are not moving, and cannot hit the wall. Therefore the initial pressure is zero.  As the particles start moving, they all first have the same speed in random directions.  As the particles repeatedly collide, they exchange energy and head off in new directions, and the speeds are dispersed -- some particles get faster, some get slower.


THINGS TO NOTICE
----------------
What is happening to the particles in the box as a new group of particles is injected?  How is this related to the way pressure changes over time?

Can you observe collisions with the walls as they happen (you can pendown a particle or slow down the model)?  For example, do the particles change their color?  Direction?

Can you relate what you can see happening to the particles in the box with changes in pressure?  The average speed?  The average energy?

Why does the pressure fluctuate, even though the number of particles is the same?  How long does it take for the pressure to stabilize?  Does the number of particles in the box affect this time?

In what ways is this model an incorrect idealization of the real world?


THINGS TO TRY
-------------
Try different settings, especially the extremes.   Are the particles behaving in a similar way?  How does this effect the pressure?  The energy?

How are the number of particles and the pressure in the box related to each other?  Can you quantify this relationship? Does it change if collisions among particles are removed?

Does the same relationship hold for the number of wall hits per particle and the number of particles?  Why?  How are the two relationships connected?

Can you make the pressure graph smooth?  Can you do it in more than one way?

The ideal gas equation shows that when keeping a constant temperature and volume, increasing the number of particles increases the pressure as well.   Keeping a constant temperature means that the average kinetic energy of the particles, does not change, nor does their average speed.  How is this related to the behavior of particles that you have seen so far?  Are there any other observations that could be made to test this relationship between the number of particles and the pressure?

Notice that the pressure does not go up immediately after particles are added.  What is the reason for this delay?  Try adding particles into the box in different ways to increase or decrease this delay.  Can you think of real-life situations, with a similar delay?

Sometimes, when going up in an elevator, airplane or up a mountain we feel a 'popping' sensation in our ears.  This is associated with changes in pressure.  Can you relate between this model and these changes in pressure?  Are the temperature and volume constant in this situation?


EXTENDING THE MODEL
-------------------
What would happen if particles were added continuously rather than instantly?  Add a switch that allows for particles to continuously be added to the box.

Can you ""puncture"" the box, so that particles will escape?

What would happen if the box were heated?  How would the particles behave?  How would this affect the pressure?  Add a slider and code that increases the temperature inside the box.

If you could change the shape of the box, so that the volume remains the same: Does the shape of the box make a difference in the way the particles behave, or the values of pressure?


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (2002).  NetLogo GasLab Pressure Box model.  http://ccl.northwestern.edu/netlogo/models/GasLabPressureBox.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2002 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/GasLabPressureBox for terms of use.
"
GasLab Circular Particles,/models/Sample Models/Chemistry & Physics/GasLab/Unverified,"globals [
  tick-delta        ;; how much simulation time will pass in this step
  box-edge          ;; distance of box edge from origin
  collisions        ;; list used to keep track of future collisions
  particle1         ;; first particle currently colliding
  particle2         ;; second particle currently colliding
]

breed [particles particle]
particles-own [
  speed
  mass
]

;;;
;;; SETUP PROCEDURES
;;;

to setup
  clear-all
  set-default-shape particles ""circle""
  set box-edge max-pxcor - 1
  ask patches with [(abs pxcor = box-edge or abs pycor = box-edge) and
                    abs pxcor <= box-edge and abs pycor <= box-edge]
    [ set pcolor yellow ]
  make-particles
  set particle1 nobody
  set particle2 nobody
  set collisions []
  ask particles [ check-for-wall-collision ]
  ask particles [ check-for-particle-collision ]
end

to make-particles
  create-particles number [
    set speed 1
    set size smallest-particle-size
             + random-float (largest-particle-size - smallest-particle-size)
    ;; set the mass proportional to the area of the particle
    set mass (size * size)
    recolor
  ]
  ;; When space is tight, placing the big particles first improves
  ;; our chances of eventually finding places for all of them.
  foreach sort-by [[size] of ?1 > [size] of ?2] particles [
    ask ? [
      position-randomly
      while [overlapping?] [ position-randomly ]
    ]
  ]
end

to position-randomly  ;; particle procedure
  ;; place particle at random location inside the box
  setxy one-of [1 -1] * random-float (box-edge - 0.5 - size / 2)
        one-of [1 -1] * random-float (box-edge - 0.5 - size / 2)
end

to-report overlapping?  ;; particle procedure
  ;; here, we use IN-RADIUS just for improved speed; the real testing
  ;; is done by DISTANCE
  report any? other particles in-radius ((size + largest-particle-size) / 2)
                              with [distance myself < (size + [size] of myself) / 2]
end

;;;
;;; GO PROCEDURES
;;;

to go
  choose-next-collision
  ask particles [ jump speed * tick-delta ]
  perform-next-collision
  tick-advance tick-delta
  recalculate-particles-that-just-collided
end

to recalculate-particles-that-just-collided
  ;; Since only collisions involving the particles that collided most recently could be affected,
  ;; we filter those out of collisions.  Then we recalculate all possible collisions for
  ;; the particles that collided last.  The ifelse statement is necessary because
  ;; particle2 can be either a particle or a string representing a wall.  If it is a
  ;; wall, we don't want to invalidate all collisions involving that wall (because the wall's
  ;; position wasn't affected, those collisions are still valid.
  ifelse is-turtle? particle2
    [
      set collisions filter [item 1 ? != particle1 and
                             item 2 ? != particle1 and
                             item 1 ? != particle2 and
                             item 2 ? != particle2]
                            collisions
      ask particle2 [ check-for-wall-collision ]
      ask particle2 [ check-for-particle-collision ]
    ]
    [
      set collisions filter [item 1 ? != particle1 and
                             item 2 ? != particle1]
                            collisions
    ]
  if particle1 != nobody [ ask particle1 [ check-for-wall-collision ] ]
  if particle1 != nobody [ ask particle1 [ check-for-particle-collision ] ]
  ;; Slight errors in floating point math can cause a collision that just
  ;; happened to be calculated as happening again a very tiny amount of
  ;; time into the future, so we remove any collisions that involves
  ;; the same two particles (or particle and wall) as last time.
  set collisions filter [item 1 ? != particle1 or
                         item 2 ? != particle2]
                        collisions
  ;; All done.
  set particle1 nobody
  set particle2 nobody
end

;; check-for-particle-collision is a particle procedure that determines the time it takes
;; to the collision between two particles (if one exists).  It solves for the time by representing
;; the equations of motion for distance, velocity, and time in a quadratic equation of the vector
;; components of the relative velocities and changes in position between the two particles and
;; solves for the time until the next collision
to check-for-particle-collision
  let my-x xcor
  let my-y ycor
  let my-particle-size size
  let my-x-speed speed * sin heading
  let my-y-speed speed * cos heading
  ask other particles
  [
    let dpx (xcor - my-x)   ;; relative distance between particles in the x direction
    let dpy (ycor - my-y)    ;; relative distance between particles in the y direction
    let x-speed (speed * sin heading) ;; speed of other particle in the x direction
    let y-speed (speed * cos heading) ;; speed of other particle in the x direction
    let dvx (x-speed - my-x-speed) ;; relative speed difference between particles in x direction
    let dvy (y-speed - my-y-speed) ;; relative speed difference between particles in y direction
    let sum-r (((my-particle-size) / 2 ) + (([size] of self) / 2 )) ;; sum of both particle radii

    ;; To figure out what the difference in position (P1) between two particles at a future
    ;; time (t) will be, one would need to know the current difference in position (P0) between the
    ;; two particles and the current difference in the velocity (V0) between the two particles.
    ;;
    ;; The equation that represents the relationship is:
    ;;   P1 = P0 + t * V0
    ;; we want find when in time (t), P1 would be equal to the sum of both the particle's radii
    ;; (sum-r).  When P1 is equal to is equal to sum-r, the particles will just be touching each
    ;; other at their edges (a single point of contact).
    ;;
    ;; Therefore we are looking for when:   sum-r =  P0 + t * V0
    ;;
    ;; This equation is not a simple linear equation, since P0 and V0 should both have x and y
    ;; components in their two dimensional vector representation (calculated as dpx, dpy, and
    ;; dvx, dvy).
    ;;
    ;; By squaring both sides of the equation, we get:
    ;;   (sum-r) * (sum-r) =  (P0 + t * V0) * (P0 + t * V0)
    ;; When expanded gives:
    ;;   (sum-r ^ 2) = (P0 ^ 2) + (t * PO * V0) + (t * PO * V0) + (t ^ 2 * VO ^ 2)
    ;; Which can be simplified to:
    ;;   0 = (P0 ^ 2) - (sum-r ^ 2) + (2 * PO * V0) * t + (VO ^ 2) * t ^ 2
    ;; Below, we will let p-squared represent:   (P0 ^ 2) - (sum-r ^ 2)
    ;; and pv represent: (2 * PO * V0)
    ;; and v-squared represent: (VO ^ 2)
    ;;
    ;;  then the equation will simplify to:     0 = p-squared + pv * t + v-squared * t^2

    let p-squared   ((dpx * dpx) + (dpy * dpy)) - (sum-r ^ 2)   ;; p-squared represents difference
    ;; of the square of the radii and the square of the initial positions

    let pv  (2 * ((dpx * dvx) + (dpy * dvy)))  ;; vector product of the position times the velocity
    let v-squared  ((dvx * dvx) + (dvy * dvy)) ;; the square of the difference in speeds
    ;; represented as the sum of the squares of the x-component
    ;; and y-component of relative speeds between the two particles

    ;; p-squared, pv, and v-squared are coefficients in the quadratic equation shown above that
    ;; represents how distance between the particles and relative velocity are related to the time,
    ;; t, at which they will next collide (or when their edges will just be touching)

    ;; Any quadratic equation that is a function of time (t) can be represented as:
    ;;   a*t*t + b*t + c = 0,
    ;; where a, b, and c are the coefficients of the three different terms, and has solutions for t
    ;; that can be found by using the quadratic formula.  The quadratic formula states that if a is
    ;; not 0, then there are two solutions for t, either real or complex.
    ;; t is equal to (b +/- sqrt (b^2 - 4*a*c)) / 2*a
    ;; the portion of this equation that is under a square root is referred to here
    ;; as the determinant, D1.   D1 is equal to (b^2 - 4*a*c)
    ;; and:   a = v-squared, b = pv, and c = p-squared.
    let D1 pv ^ 2 -  (4 * v-squared * p-squared)

    ;; the next test tells us that a collision will happen in the future if
    ;; the determinant, D1 is > 0,  since a positive determinant tells us that there is a
    ;; real solution for the quadratic equation.  Quadratic equations can have solutions
    ;; that are not real (they are square roots of negative numbers).  These are referred
    ;; to as imaginary numbers and for many real world systems that the equations represent
    ;; are not real world states the system can actually end up in.

    ;; Once we determine that a real solution exists, we want to take only one of the two
    ;; possible solutions to the quadratic equation, namely the smaller of the two the solutions:
    ;;  (b - sqrt (b^2 - 4*a*c)) / 2*a
    ;;  which is a solution that represents when the particles first touching on their edges.
    ;;  instead of (b + sqrt (b^2 - 4*a*c)) / 2*a
    ;;  which is a solution that represents a time after the particles have penetrated
    ;;  and are coming back out of each other and when they are just touching on their edges.

    let time-to-collision  -1

    if D1 > 0
      [ set time-to-collision (- pv - sqrt D1) / (2 * v-squared) ]        ;; solution for time step

    ;; if time-to-collision is still -1 there is no collision in the future - no valid solution
    ;; note:  negative values for time-to-collision represent where particles would collide
    ;; if allowed to move backward in time.
    ;; if time-to-collision is greater than 1, then we continue to advance the motion
    ;; of the particles along their current trajectories.  They do not collide yet.

    if time-to-collision > 0
    [
      ;; time-to-collision is relative (ie, a collision will occur one second from now)
      ;; We need to store the absolute time (ie, a collision will occur at time 48.5 seconds.
      ;; So, we add clock to time-to-collision when we store it.
      ;; The entry we add is a three element list of the time to collision and the colliding pair.
      set collisions fput (list (time-to-collision + ticks) self myself)
                          collisions
    ]
  ]
end


;; determines when a particle will hit any of the four walls
to check-for-wall-collision  ;; particle procedure 
  ;; right & left walls
  let x-speed (speed * sin heading)
  if x-speed != 0
    [ ;; solve for how long it will take particle to reach right wall
      let right-interval (box-edge - 0.5 - xcor - size / 2) / x-speed
      if right-interval > 0
        [ assign-colliding-wall right-interval ""right wall"" ]
      ;; solve for time it will take particle to reach left wall
      let left-interval ((- box-edge) + 0.5 - xcor + size / 2) / x-speed
      if left-interval > 0
        [ assign-colliding-wall left-interval ""left wall"" ] ]
  ;; top & bottom walls
  let y-speed (speed * cos heading)
  if y-speed != 0
    [ ;; solve for time it will take particle to reach top wall
      let top-interval (box-edge - 0.5 - ycor - size / 2) / y-speed
      if top-interval > 0
        [ assign-colliding-wall top-interval ""top wall"" ]
      ;; solve for time it will take particle to reach bottom wall
      let bottom-interval ((- box-edge) + 0.5 - ycor + size / 2) / y-speed
      if bottom-interval > 0
        [ assign-colliding-wall bottom-interval ""bottom wall"" ] ]
end


to assign-colliding-wall [time-to-collision wall]  ;; particle procedure
  ;; this procedure is used by the check-for-wall-collision procedure
  ;; to assemble the correct particle-wall pair
  ;; time-to-collision is relative (ie, a collision will occur one second from now)
  ;; We need to store the absolute time (ie, a collision will occur at time 48.5 seconds.
  ;; So, we add clock to time-to-collision when we store it.
  let colliding-pair (list (time-to-collision + ticks) self wall)
  set collisions fput colliding-pair collisions
end

to choose-next-collision
  if collisions = [] [ stop ]
  ;; Sort the list of projected collisions between all the particles into an ordered list.
  ;; Take the smallest time-step from the list (which represents the next collision that will
  ;; happen in time).  Use this time step as the tick-delta for all the particles to move through
  let winner first collisions
  foreach collisions [ if first ? < first winner [ set winner ? ] ]
  ;; winner is now the collision that will occur next
  let dt item 0 winner
  ;; If the next collision is more than 1 in the future,
  ;; only advance the simulation one tick, for smoother animation.
  set tick-delta dt - ticks
  if tick-delta > 1
    [ set tick-delta 1
      set particle1 nobody
      set particle2 nobody
      stop ]
  set particle1 item 1 winner
  set particle2 item 2 winner
end


to perform-next-collision
  ;; deal with 3 possible cases:
  ;; 1) no collision at all
  if particle1 = nobody [ stop ]
  ;; 2) particle meets wall
  if is-string? particle2
    [ if particle2 = ""left wall"" or particle2 = ""right wall""
        [ ask particle1 [ set heading (- heading) ]
          stop ]
      if particle2 = ""top wall"" or particle2 = ""bottom wall""
        [ ask particle1 [ set heading 180 - heading ]
          stop ] ]
  ;; 3) particle meets particle
  ask particle1 [ collide-with particle2 ]
end


to collide-with [other-particle]  ;; particle procedure
  ;;; PHASE 1: initial setup
  ;; for convenience, grab some quantities from other-particle
  let mass2 [mass] of other-particle
  let speed2 [speed] of other-particle
  let heading2 [heading] of other-particle
  ;; modified so that theta is heading toward other particle
  let theta towards other-particle

  ;;; PHASE 2: convert velocities to theta-based vector representation
  ;; now convert my velocity from speed/heading representation to components
  ;; along theta and perpendicular to theta
  let v1t (speed * cos (theta - heading))
  let v1l (speed * sin (theta - heading))
  ;; do the same for other-particle
  let v2t (speed2 * cos (theta - heading2))
  let v2l (speed2 * sin (theta - heading2))

  ;;; PHASE 3: manipulate vectors to implement collision
  ;; compute the velocity of the system's center of mass along theta
  let vcm (((mass * v1t) + (mass2 * v2t)) / (mass + mass2) )
  ;; now compute the new velocity for each particle along direction theta.
  ;; velocity perpendicular to theta is unaffected by a collision along theta,
  ;; so the next two lines actually implement the collision itself, in the
  ;; sense that the effects of the collision are exactly the following changes
  ;; in particle velocity.
  set v1t (2 * vcm - v1t)
  set v2t (2 * vcm - v2t)

  ;;; PHASE 4: convert back to normal speed/heading
  ;; now convert my velocity vector into my new speed and heading
  set speed sqrt ((v1t * v1t) + (v1l * v1l))
  ;; if the magnitude of the velocity vector is 0, atan is undefined. but
  ;; speed will be 0, so heading is irrelevant anyway. therefore, in that
  ;; case we'll just leave it unmodified.
  if v1l != 0 or v1t != 0
    [ set heading (theta - (atan v1l v1t)) ]
  ;; and do the same for other-particle
  ask other-particle [
    set speed sqrt ((v2t ^ 2) + (v2l ^ 2))
    if v2l != 0 or v2t != 0
      [ set heading (theta - (atan v2l v2t)) ]
  ]
  
  ;; PHASE 5: recolor
  ;; since color is based on quantities that may have changed
  recolor
  ask other-particle [ recolor ]
end

;;;
;;; COLOR PROCEDURES
;;;

to recolor  ;; particle procedure
  if color-scheme = ""red-green-blue"" [ recolor-banded ]
  if color-scheme = ""blue shades""    [ recolor-shaded ]
  if color-scheme = ""one color""      [ recolor-none   ]
end

to recolor-banded  ;; particle procedure
  let avg-speed 1
  ;; avg-speed is assumed to be 0.5, since particles are assigned a random speed between 0 and 1
  ;; particle coloring procedures for visualizing speed with a color palette,
  ;; red are fast particles, blue slow, and green in between.
  ifelse speed < (0.5 * avg-speed) ;; at lower than 50% the average speed
    [ set color blue ]      ;; slow particles colored blue
    [ ifelse speed > (1.5 * avg-speed) ;; above 50% higher the average speed
        [ set color red ]        ;; fast particles colored red
        [ set color green ] ]    ;; medium speed particles colored green
end

to recolor-shaded
  let avg-speed 1
  ;; avg-speed is assumed to be 0.5, since particles are assigned a random speed between 0 and 1
  ;; a particle shading gradient is applied to all particles less than speed 1.5,
  ;; the uppermost threshold speed to apply the shading gradient to.
  ifelse speed < (3 * avg-speed)
    [ set color (sky - 3) + (8 * speed / (3 * avg-speed)) ]
    [ set color (sky + 4.999) ]
end

to recolor-none
  set color green - 1
end

;;;
;;; AN EXPERIMENT IN TIME REVERSAL
;;;

;; Here's a procedure that demonstrates time-reversing the model.
;; You can run it from the command center.  When it finishes,
;; the final particle positions may be slightly different because
;; the amount of time that passes after the reversal might not
;; be exactly the same as the amount that passed before; this
;; doesn't indicate a bug in the model.
;; For larger values of n, you will start to notice larger
;; discrepancies, eventually causing the behavior of the system
;; to diverge totally. Unless the model has some bug we don't know
;; about, this is due to accumulating tiny inaccuracies in the
;; floating point calculations.  Once these inaccuracies accumulate
;; to the point that a collision is missed or an extra collision
;; happens, after that the reversed model will diverge rapidly.
to test-time-reversal [n]
  setup
  ask particles [ stamp ]
  while [ticks < n] [ go ]
  let old-ticks ticks
  reverse-time
  while [ticks < 2 * old-ticks] [ go ]
  ask particles [ set color white ]
end

to reverse-time
  ask particles [ rt 180 ]
  set collisions []
  ask particles [ check-for-wall-collision ]
  ask particles [ check-for-particle-collision ]
  ;; the last collision that happened before the model was paused
  ;; (if the model was paused immediately after a collision)
  ;; won't happen again after time is reversed because of the
  ;; ""don't do the same collision twice in a row"" rule.  We could
  ;; try to fool that rule by setting particle1 and
  ;; particle2 to nobody, but that might not always work,
  ;; because the vagaries of floating point math means that the
  ;; collision might be calculated to be slightly in the past
  ;; (the past that used to be the future!) and be skipped.
  ;; So to be sure, we force the collision to happen:
  perform-next-collision
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model and associated activities and materials were created as
; part of the project: MODELING ACROSS THE CURRICULUM.  The project
; gratefully acknowledges the support of the National Science Foundation,
; the National Institute of Health, and the Department of Education
; (IERI program) -- grant number REC # 0115699.

; Copyright 2005 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2005).  NetLogo GasLab Circular Particles model.
; http://ccl.northwestern.edu/netlogo/models/GasLabCircularParticles.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2005 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/GasLabCircularParticles
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model is one in a series of GasLab models. They use the same basic rules for simulating the behavior of gases.  Each model integrates different features in order to highlight different aspects of gas behavior.  This model is different from the other GasLab models in that the collision calculations take the circular shape and size of the particles into account, instead of modeling the particles as dimensionless points.


HOW IT WORKS
------------
The model determines the resulting motion of particles that collide, with no loss in their total momentum or total kinetic energy (an elastic collision).

To calculate the outcome of collision, it is necessary to calculate the exact time at which the edge of one particle (represented as a circle), would touch the edge of another particle (or the walls of a container) if the particles were allowed to continue with their current headings and speeds.

By performing such a calculation, one can determine when the next collision anywhere in the system would occur in time.  From this determination, the model then advances the motion of all the particles using their current headings and speeds that far in time until this next collision point is reached.  Exchange of kinetic energy and momentum between the two particles, according to conservation of kinetic energy and conservation of momentum along the collision axis (a line drawn between the centers of the two particles), is then calculated, and the particles are given new headings and speeds based on this outcome.


HOW TO USE IT
-------------
NUMBER determines the number of gas particles used with SETUP.  If the world is too small or the particles are too large, the SETUP procedure of the particles will stop so as to prevent overlapping particles.

SMALLEST-PARTICLE-SIZE and LARGEST-PARTICLE-SIZE determines the range of particle sizes that will be created when SETUP is pressed.  (Particles are also assigned a mass proportional to the area of the particle that is created.)

SHOW-SPEED-AS-COLOR? allows you to visualize particle speed using a color palette.
The ""blue-green-red"" setting shows the lower half of the speeds of the starting population as blue, and the upper half as red.
The ""blue shades"" setting shows a gradient of dark blue to light blue for slow to fast particle speed.
The ""all green"" setting does not show a different color for each particle based on its speed.



THINGS TO NOTICE
----------------
Particles never overlap or penetrate into each other or the wall as they move about.

SET the SPEED-AS-COLOR? chooser to red-green-blue and run the model with RANDOMIZE-MASS-SIZES? set turned on.  With many different mass particles colliding over time, different sized particles start to move at different speed ranges (in general).  The smallest mass particles will be usually moving faster (red) than the average particle speed and the largest mass particles will be usually slower (blue) than the average particle speed.  This emergent result is what happens in a gas that is a mixture of particles of different masses.  At any given temperature, the higher mass particles are moving slower (such as Nitrogen gas: N2) then the lower mass particles (such as water vapor: H2O).


THINGS TO TRY
-------------
Setting all the particles to have a very slow speed (e.g. 0.001) and one particle to have a very fast speed helps show how kinetic energy is eventually transferred to all the particles through a series of collisions and would serve as a good model for energy exchange through conduction between hot and cold gases.

To see what the approximate mass of each particle is, type this in the command center:
|    ask particles [set label precision mass 0]


EXTENDING THE MODEL
-------------------
Collisions between boxes and circles could also be explored.  Variations in size between particles could investigated or variations in the mass of some of the particle could be made to explore other factors that affect the outcome of collisions.


NETLOGO FEATURES
----------------
Instead of advancing one tick at a time as in most models, the tick counter takes on fractional values, using the TICK-ADVANCE primitive.  (In the Interface tab, it is displayed as an integer, but if you make a monitor for TICKS you'll see the exact value.)


RELATED MODELS
---------------
Look at the other GasLab models to see collisions of ""point"" particles, that is, the particles are assumed to have an area or volume of zero.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (2005).  NetLogo GasLab Circular Particles model.  http://ccl.northwestern.edu/netlogo/models/GasLabCircularParticles.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2005 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/GasLabCircularParticles for terms of use.
"
GasLab Adiabatic Piston,/models/Sample Models/Chemistry & Physics/GasLab,"globals
[
  tick-delta                      ;; how much we advance the tick counter this time through
  max-tick-delta                  ;; the largest tick-delta is allowed to be
  raw-width raw-height            ;; box size variables
  gravity                         ;; acceleration of the piston
  piston-energy total-energy      ;; current energies
  piston-height                   ;; piston variables
  piston-vel                      ;; piston speed
  pressure
  pressure-history
  length-horizontal-surface       ;; the size of the wall surfaces that run horizontally - the top and bottom of the box
  length-vertical-surface         ;; the size of the wall surfaces that run vertically - the left and right of the box
  init-avg-speed init-avg-energy  ;; initial averages
  avg-speed avg-energy            ;; current averages
  tot-particle-energy             ;; sum of the energy of all particles taken together
  piston-kinetic-energy           ;; piston's kinetic energy
  piston-potential-energy         ;; piston's potential energy
  fast medium slow                ;; current counts
]

breed [ particles particle ]
breed [ flashes flash ]
breed [ pistons piston]


flashes-own [birthday]

particles-own
[
  speed mass energy          ;; particle info
  momentum-difference        ;; used to calculate pressure from wall hits
  last-collision             ;; used to prevent particles from colliding multiple times

]

pistons-own
[
  speed mass energy
]

to setup
  ca
  set-default-shape particles ""circle""
  set-default-shape flashes ""plane""
  set max-tick-delta 0.1073
  ;; box has constant size.
  set raw-width  round (0.01 * box-width  * max-pxcor)
  set raw-height round (0.01 * box-height * max-pycor)
  set piston-height raw-height
  make-box
  make-piston
  set piston-vel 0
  set gravity 0.125
  ;;; the length of the horizontal or vertical surface of
  ;;; the inside of the box must exclude the two patches
  ;;; that are the where the perpendicular walls join it,
  ;;; but must also add in the axes as an additional patch
  ;;; example:  a box with an box-edge of 10, is drawn with
  ;;; 19 patches of wall space on the inside of the box
  set length-horizontal-surface  ( 2 * (raw-height - 1) + 1)
  set length-vertical-surface  (piston-height)
  make-box
  make-particles
  set pressure-history [0 0 0]  ;; plotted pressure will be averaged over the past 3 entries
  update-variables
  set init-avg-speed avg-speed
  set init-avg-energy avg-energy
  setup-plots
  do-plotting
end

to go
  if piston-height < 3
  [ user-message ""The piston reached the bottom of the chamber. The simulation will stop.""
    stop
  ]
  if piston-height >= 2 * raw-height - 1
  [ user-message ""The piston reached the top of the chamber. The simulation will stop.""
    stop
  ]
  ask particles [ bounce ]
  ask particles [ move ]
  ask particles [ check-for-collision ]
  move-piston
  tick-advance tick-delta
  if floor ticks > floor (ticks - tick-delta)
  [
    calculate-pressure
    update-variables
    do-plotting
  ]
  calculate-tick-delta
  ;; we check for pcolor = black to make sure flashes that are left behind by the piston die
  ask flashes with [ticks - birthday > 0.4 or pcolor = black]
    [ die ]
  display
end

to update-variables
  ;; particle variables
  set medium count particles with [color = green]
  set slow   count particles with [color = blue]
  set fast   count particles with [color = red]
  set avg-speed  mean [speed] of particles
  set avg-energy mean [energy] of particles
  set tot-particle-energy sum [energy] of particles

  ;; piston Variables
  set piston-kinetic-energy (0.5 * piston-mass * (piston-vel ^ 2))
  set piston-potential-energy (piston-mass * gravity * piston-height)
  set piston-energy (piston-kinetic-energy + piston-potential-energy)

  ;; system Variables
  set total-energy (tot-particle-energy + piston-energy)
  set length-vertical-surface (piston-height)
  calculate-pressure
end

to calculate-tick-delta
  ;; tick-delta is calculated in such way that even the fastest
  ;; particle (or the piston) will jump at most 1 patch length in a
  ;; tick. As particles jump (speed * tick-delta) at every
  ;; tick, making tick length the inverse of the speed of the
  ;; fastest particle (1/max speed) assures that. Having each particle
  ;; advance at most one patch-length is necessary for them not to
  ;; ""jump over"" a wall or the piston.
  ifelse any? particles with [speed > 0]
    [ set tick-delta min list
                            (1 / (ceiling max (sentence ([speed] of particles) ([speed] of one-of pistons))))
                            max-tick-delta ]
    [ set tick-delta max-tick-delta ]
end

;;; Pressure is defined as the force per unit area.  In this context,
;;; that means the total momentum per unit time transferred to the walls
;;; by particle hits, divided by the surface area of the walls.  (Here
;;; we're in a two dimensional world, so the ""surface area"" of the walls
;;; is just their length.)  Each wall contributes a different amount
;;; to the total pressure in the box, based on the number of collisions, the
;;; direction of each collision, and the length of the wall.  Conservation of momentum
;;; in hits ensures that the difference in momentum for the particles is equal to and
;;; opposite to that for the wall.  The force on each wall is the rate of change in
;;; momentum imparted to the wall, or the sum of change in momentum for each particle:
;;; F = SUM  [d(mv)/dt] = SUM [m(dv/dt)] = SUM [ ma ], in a direction perpendicular to
;;; the wall surface.  The pressure (P) on a given wall is the force (F) applied to that
;;; wall over its surface area.  The total pressure in the box is sum of each wall's
;;; pressure contribution.

to calculate-pressure
  ;; by summing the momentum change for each particle,
  ;; the wall's total momentum change is calculated
  set pressure 15 * sum [momentum-difference] of particles
  set pressure-history lput pressure but-first pressure-history
  ask particles
    [ set momentum-difference 0 ]  ;; once the contribution to momentum has been calculated
                                   ;; this value is reset to zero till the next wall hit
end

to bounce  ;; particles procedure
  ;; get the coordinates of the patch we'll be on if we go forward 1
  let new-patch patch-ahead 1
  let new-px [pxcor] of new-patch
  let new-py [pycor] of new-patch
  ; if we're not about to hit a wall (yellow patch) or piston (orange patch)
  ; we don't need to do any further checks
  if ([pcolor] of new-patch != yellow and [pcolor] of new-patch != orange)
    [ stop ]

  ; check: hitting left or right wall?
  if (abs new-px = raw-width)
    ; if so, reflect heading around x axis
    [
      ;;  if the particle is hitting a vertical wall, only the horizontal component of the speed
      ;;  vector can change.  The change in velocity for this component is 2 * the speed of the particle,
      ;; due to the reversing of direction of travel from the collision with the wall
      set momentum-difference momentum-difference + (abs (sin heading * 2 * mass * speed) / length-vertical-surface)
      set heading (- heading) ]

  ; check: hitting top or bottom wall? (Should never hit top, but this would handle it.)
  if (abs new-py = raw-height)
  [
    ;;  if the particle is hitting a horizontal wall, only the vertical component of the speed
    ;;  vector can change.  The change in velocity for this component is 2 * the speed of the particle,
    ;; due to the reversing of direction of travel from the collision with the wall
    set momentum-difference momentum-difference + (abs (cos heading * 2 * mass * speed) / length-horizontal-surface)
    set heading (180 - heading)
  ]

  ; check: hitting piston?
  if (new-py = [pycor] of one-of pistons and (speed * cos heading) > piston-vel)
  [
    ;;  if the particle is hitting the piston, only the vertical component of the speed
    ;;  vector can change.  The change in velocity for this component is 2 * the speed of the particle,
    ;; due to the reversing of direction of travel from the collision with the wall
    ;; make sure that each particle finishes exchanging energy before any others can
    set momentum-difference momentum-difference + (abs (cos heading * 2 * mass * speed) / length-horizontal-surface)
    exchange-energy-with-piston
  ]

  ask patch new-px new-py
    [ sprout-flashes 1 [
      set color pcolor - 2
      set birthday ticks
      set heading 0
    ]
  ]
end

to move  ;; particle procedure
  if patch-ahead (speed * tick-delta) != patch-here
    [ set last-collision nobody ]
  jump (speed * tick-delta)
end

to check-for-collision  ;; particle procedure
  ;; Here we impose a rule that collisions only take place when there
  ;; are exactly two particles per patch.

  if count other particles-here = 1
  [
    ;; the following conditions are imposed on collision candidates:
    ;;   1. they must have a lower who number than my own, because collision
    ;;      code is asymmetrical: it must always happen from the point of view
    ;;      of just one particle.
    ;;   2. they must not be the same particle that we last collided with on
    ;;      this patch, so that we have a chance to leave the patch after we've
    ;;      collided with someone.
    let candidate one-of other particles-here with
      [who < [who] of myself and myself != last-collision]
    ;; we also only collide if one of us has non-zero speed. It's useless
    ;; (and incorrect, actually) for two particles with zero speed to collide.
    if (candidate != nobody) and (speed > 0 or [speed] of candidate > 0)
    [
      collide-with candidate
      set last-collision candidate
      ask candidate [ set last-collision myself ]
    ]
  ]
end

;; implements a collision with another particle.
;;
;; THIS IS THE HEART OF THE PARTICLE SIMULATION, AND YOU ARE STRONGLY ADVISED
;; NOT TO CHANGE IT UNLESS YOU REALLY UNDERSTAND WHAT YOU'RE DOING!
;;
;; The two particles colliding are self and other-particle, and while the
;; collision is performed from the point of view of self, both particles are
;; modified to reflect its effects. This is somewhat complicated, so I'll
;; give a general outline here:
;;   1. Do initial setup, and determine the heading between particle centers
;;      (call it theta).
;;   2. Convert the representation of the velocity of each particle from
;;      speed/heading to a theta-based vector whose first component is the
;;      particle's speed along theta, and whose second component is the speed
;;      perpendicular to theta.
;;   3. Modify the velocity vectors to reflect the effects of the collision.
;;      This involves:
;;        a. computing the velocity of the center of mass of the whole system
;;           along direction theta
;;        b. updating the along-theta components of the two velocity vectors.
;;   4. Convert from the theta-based vector representation of velocity back to
;;      the usual speed/heading representation for each particle.
;;   5. Perform final cleanup and update derived quantities.
to collide-with [ other-particle ] ;; particle procedure
  ;;; PHASE 1: initial setup

  ;; for convenience, grab some quantities from other-particle
  let mass2 [mass] of other-particle
  let speed2 [speed] of other-particle
  let heading2 [heading] of other-particle

  ;; since particles are modeled as zero-size points, theta isn't meaningfully
  ;; defined. we can assign it randomly without affecting the model's outcome.
  let theta (random-float 360)


  ;;; PHASE 2: convert velocities to theta-based vector representation

  ;; now convert my velocity from speed/heading representation to components
  ;; along theta and perpendicular to theta
  let v1t (speed * cos (theta - heading))
  let v1l (speed * sin (theta - heading))

  ;; do the same for other-particle
  let v2t (speed2 * cos (theta - heading2))
  let v2l (speed2 * sin (theta - heading2))



  ;;; PHASE 3: manipulate vectors to implement collision

  ;; compute the velocity of the system's center of mass along theta
  let vcm (((mass * v1t) + (mass2 * v2t)) / (mass + mass2) )

  ;; now compute the new velocity for each particle along direction theta.
  ;; velocity perpendicular to theta is unaffected by a collision along theta,
  ;; so the next two lines actually implement the collision itself, in the
  ;; sense that the effects of the collision are exactly the following changes
  ;; in particle velocity.
  set v1t (2 * vcm - v1t)
  set v2t (2 * vcm - v2t)



  ;;; PHASE 4: convert back to normal speed/heading

  ;; now convert my velocity vector into my new speed and heading
  set speed sqrt ((v1t ^ 2) + (v1l ^ 2))
  set energy (0.5 * mass * (speed ^ 2))
  ;; if the magnitude of the velocity vector is 0, atan is undefined. but
  ;; speed will be 0, so heading is irrelevant anyway. therefore, in that
  ;; case we'll just leave it unmodified.
  if v1l != 0 or v1t != 0
    [ set heading (theta - (atan v1l v1t)) ]

  ;; and do the same for other-particle
  ask other-particle [
    set speed sqrt ((v2t ^ 2) + (v2l ^ 2))
    set energy (0.5 * mass * (speed ^ 2))
    if v2l != 0 or v2t != 0
      [ set heading (theta - (atan v2l v2t)) ]
  ]

  ;; PHASE 5: final updates

  ;; now recolor, since color is based on quantities that may have changed
  recolor
  ask other-particle
    [ recolor ]
end

to recolor  ;; particle procedure
  ifelse speed < (0.5 * 10)
  [
    set color blue
  ]
  [
    ifelse speed > (1.5 * 10)
      [ set color red ]
      [ set color green ]
  ]
end

;;;
;;; drawing procedures
;;;

to make-box
  ask patches with [((abs pxcor = raw-width) and (abs pycor <= raw-height)) or
                    ((abs pycor = raw-height) and (abs pxcor <= raw-width))]
    [ set pcolor yellow ]
end

;; creates initial particles
to make-particles
  create-particles number-of-particles
  [
    setup-particle
    random-position
    recolor
  ]
  calculate-tick-delta
end


to setup-particle  ;; particle procedure
  set speed init-particle-speed
  set mass particle-mass
  set energy (0.5 * mass * (speed  ^ 2))
  set last-collision nobody
  set momentum-difference 0
end

;; place particle at random location inside the box.
to random-position  ;; particle procedure
  setxy ((1 - raw-width)  + random-float (2 * raw-width - 2))
        ((1 - raw-height) + random-float (raw-height - 2))
end


;; ------ Piston ----------
to make-piston
  ask patches with [pycor = 0 and (abs pxcor < raw-width)]
  [ sprout-pistons 1
    [ set color orange
      set heading 0
      set pcolor color
      ht
    ]
  ]
end

to move-piston
  let old-piston-vel piston-vel
  set piston-vel (old-piston-vel - gravity * tick-delta)    ;;apply gravity
  let movement-amount ((old-piston-vel * tick-delta) - (gravity * (0.5 * (tick-delta  ^ 2))))
  ;; Setting the pcolor makes the piston look like a wall to the particles.
  ask pistons
  [ set pcolor black
    while [(piston-vel * tick-delta) >= 1.0]
      [ calculate-tick-delta ]
    ifelse piston-height + movement-amount <= 2 * raw-height - 1
    [
      fd movement-amount
      set piston-height (raw-height + [ycor] of one-of pistons)
    ]
    [
      set ycor raw-height - 1
      set piston-height 2 * raw-height - 1
      if piston-vel > 0
        [ set piston-vel 0 ]
    ]
    set speed piston-vel ;; just used for tick-delta calculations
    set pcolor color
    if (piston-vel < 0) ;; piston can't hit particles when moving upwards
    [ if (any? particles-here with [(speed * (cos heading)) > piston-vel])
      [ ;; only bounce particles that are moving down slower than the piston
        ;; faster ones should outrun it
        ask particles-here with [(speed * (cos heading)) > piston-vel]
        [
          ;;  if the particle is hitting the piston, only the vertical component of the speed
          ;;  vector can change.  The change in velocity for this component is 2 * the speed of the particle,
          ;; due to the reversing of direction of travel from the collision with the wall
          ;; make sure that each particle finishes exchanging energy before any others can
          set momentum-difference momentum-difference + (abs (cos heading * 2 * mass * speed) / length-horizontal-surface)
          exchange-energy-with-piston
        ]
      ]
    ]
  ]
end


to exchange-energy-with-piston  ;; particle procedure -- piston and particle exchange energy
  let vx (speed * (sin heading))
  let vy (speed * (cos heading))         ;;only along y-axis
  let old-vy vy
  let old-piston-vel piston-vel
  set piston-vel ((((piston-mass - mass) / (piston-mass + mass)) * old-piston-vel) +
                  (((2 * mass) / (piston-mass + mass)) * old-vy))
  set vy ((((2 * piston-mass) / (piston-mass + mass)) * old-piston-vel) -
         (((piston-mass - mass) / (piston-mass + mass)) * old-vy))
  set speed (sqrt ((vx ^ 2) + (vy ^ 2)))
  set energy (0.5 * mass * (speed  ^ 2))
  set heading atan vx vy
end

;;; plotting procedures

to setup-plots
  ;; Piston height plot
  set-current-plot ""Piston Height vs. Time""
  set-plot-y-range 0 (2 * raw-height)

  ;; Energy plot
  set-current-plot ""Energy vs. Time""
  set-plot-y-range 0 max list 1 (tot-particle-energy * 2)
end


to do-plotting
  set-current-plot ""Piston Height vs. Time""
  set-current-plot-pen ""height""
  plotxy ticks piston-height

  set-current-plot ""Pressure vs. Time""
  plotxy ticks (mean pressure-history)

  set-current-plot ""Energy vs. Time""
  set-current-plot-pen ""gas""
  plotxy ticks tot-particle-energy
  set-current-plot-pen ""piston""
  plotxy ticks piston-energy
  set-current-plot-pen ""total""
  plotxy ticks total-energy
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1997 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2002.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1997).  NetLogo GasLab Adiabatic Piston model.
; http://ccl.northwestern.edu/netlogo/models/GasLabAdiabaticPiston.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1997 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/GasLabAdiabaticPiston
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model is one in a series of GasLab models. They use the same basic rules for simulating the behavior of gases.  Each model integrates different features in order to highlight different aspects of gas behavior.

The basic principle of the models is that gas particles are assumed to have two elementary actions: they move and they collide - either with other particles or with any other objects such as walls (see the model ""GasLab Gas in a Box"" for an introduction to the GasLab collection).

This particular model simulates the behavior of gas particles in a box with a movable piston. The piston has weight which pushes it down, and the gas particles push upward against the piston when they collide with it.

""Adiabatic"" means ""without loss or gain of heat"".  In this model, no heat energy (such as heat loss through the walls of the box) is added to or removed from the system.


HOW IT WORKS
------------
The basic principle of all GasLab models is the following algorithm (for more details, see the model ""GasLab Gas in a Box"":

1) A particle moves in a straight line without changing its speed, unless it collides with another particle or bounces off the wall.
2) Two particles ""collide"" if they find themselves on the same patch (NetLogo's View is composed of a grid of small squares called patches). In this model, two particles are aimed so that they will collide at the origin.
3) An angle of collision for the particles is chosen, as if they were two solid balls that hit, and this angle describes the direction of the line connecting their centers.
4) The particles exchange momentum and energy only along this line, conforming to the conservation of momentum and energy for elastic collisions.
5) Each particle is assigned its new speed, heading and energy.
6) If a particle finds itself on or very close to a wall of the container or the piston, it ""bounces"" -- that is, reflects its direction and keeps its same speed.

The piston has both potential energy (due to gravity) and kinetic energy (from its motion).

Each particle bounces off the sides and the bottom of the box without changing speed.  When it hits the piston, however, its speed does change.  If the piston is moving upward at that moment, the particle bounces off at a slightly smaller speed.  If the piston is moving downward, it gives the particle a kick and the particle speeds up.  This is the process by which the energy of the gas is changed by the motion of the piston.

The piston also changes speed with each collision.  The change is not large, because the piston is much heavier than each particle; but the accumulated effect of many particle collisions is enough to hold the piston up.

Gravity is incorporated in this model as a constant downwards acceleration on the piston.  In order to make the model simpler, this model doesn't include the effect of gravity on the particles.  See the ""GasLab Atmosphere"" and ""GasLab Gravity Box"" models if you are interested in the effect of gravity on the particles.

Pressure is calculated by adding up the momentum transferred to the walls of the box and the piston by the particles when they bounce off.  This is averaged over the surface area of the box to give the pressure.


HOW TO USE IT
-------------
Initial settings:
- NUMBER-OF-PARTICLES: number of gas particles.
- INIT-PARTICLE-SPEED: initial speed of the particles.
- PARTICLE-MASS: mass of each particle.
- BOX-HEIGHT: height of the container (percentage of the world-height).
- BOX-WIDTH: width of the container  (percentage of the world-width).
- PISTON-MASS: mass of the piston, in the same ""units"" as the particle's mass.

The SETUP button will set the initial conditions.
The GO button will run the simulation.

Other settings:
- COLLIDE?: Turns collisions between particles on and off.

Monitors:
- AVERAGE SPEED: average speed of the particles.
- AVERAGE ENERGY: average kinetic energy per particle of the gas.
- TOTAL ENERGY: total energy of the particles.
- PISTON HEIGHT: piston's height above the bottom of the box.
- PISTON VELOCITY: speed of the piston (up is positive).
- PISTON POTENTIAL ENERGY: potential energy of the piston, due to gravity.
- PISTON KINETIC ENERGY: kinetic energy of the piston, due to its motion.
- PISTON TOTAL ENERGY: sum of potential and kinetic energy of the piston.
- SYSTEM ENERGY: sum of particles' and the piston's total energy.

Plots:
- PISTON HEIGHT VS. TIME: measured up from the bottom of the box.
- PRESSURE VS. TIME: average pressure of the particles.
- ENERGY OF PARTICLES, PISTON, AND TOTAL ENERGY: in terms of energy per particle.  The piston's energy is both kinetic (motion) and potential (height).


THINGS TO NOTICE
----------------
Watch all the plots and notice how they change in relation to each other.

Does the piston reach an equilibrium position (as this might take a long time, so you could turn the display off to speed the process up)?  What is the pattern of its motion before that?  Why doesn't it keep oscillating, like a bouncing ball, if all of the collisions are elastic?

Would you expect that the pressure would settle at a stable value?  What would determine it?

The energy of the gas changes as the piston moves up and down.  How are the two related?   Where does the energy come from and where does it go?

Can you infer what is happening to the temperature of the gas as the piston moves?

Explain in physical terms and in terms of the model's rules how the piston heats up the gas by pushing downward and cools it down when moving upward.

Gravity only affects the piston in this model.  Does this make sense?  If gravity were made to affect the particles as well would that significantly change the behavior of the model?  What if you were to think of the downwards acceleration of the piston as the atmospheric pressure pushing down from above the piston.  Would this make more sense?  Would you need to make any changes to the behavior of the model to have the force be atmospheric pressure instead of gravity?  Why or why not?

You can change the coloring of the particles while the model is running by moving the INIT-PARTICLE-SPEED slider.  This will change the meaning of the colors, but not the relative meanings of the colors or the behavior of the model.


THINGS TO TRY
-------------
Change the initial particle mass and particle speed.  How do these variables affect the piston's motion and its equilibrium position?  Adjust the piston's mass to keep it inside the box.

Change the piston mass, leaving the gas alone.  What happens to all of the volume, pressure, and energy?  Note: if you do this while the model is running, the piston energy changes suddenly.  Why is this?

In this simulation, the piston and the particles exchange energy on every collision.  The model treats the wall collisions differently. Is this legitimate?  How is a piston different from a wall?

In this adiabatic system, neither pressure, volume, nor temperature are constant, so pressure and volume are not simply inversely proportional.  In fact it turns out that for two different states,

|   (P'/P) = (V/V')^gamma,

where gamma depends on the number of degrees of freedom of the particles.   In this two-dimensional case, gamma = 2.  Confirm that this is roughly true by changing piston-mass (hence pressure) and noticing its effect on piston height (hence volume).


EXTENDING THE MODEL
-------------------
Add a heater in the box that changes the temperature of the gas.  What would happen if the gas were heated and nothing else were changed?

Combine this with the ""Two Gas"" model such that there are gases pushing on both sides of a piston, instead of gravity against a single gas.

Give the piston the ability to store thermal energy, so that it heats up instead of moving when the particles hit it.


RELATED MODELS
--------------
Look at the other GasLab models, especially ""GasLab Isothermal Piston"" and ""GasLab Moving Piston"".


CREDITS AND REFERENCES
----------------------
Wilensky, U. (1999). GasLab--an Extensible Modeling Toolkit for Exploring Micro- and Macro- Views of Gases. In Roberts, N. , Feurzeig, W. & Hunter, B. (Eds.) Computer Modeling and Simulation in Science Education. Berlin: Springer Verlag.  (this is the best and most detailed source)

Wilensky, U. & Resnick, M. (1999). Thinking in Levels: A Dynamic Systems Perspective to Making Sense of the World. Journal of Science Education and Technology. Vol. 8 No. 1

Wilensky, U., Hazzard, E. & Froemke, R. (1999). An Extensible Modeling Toolkit for Exploring Statistical Mechanics Proceedings of the Seventh European Logo Conference - EUROLOGO'99, Sofia, Bulgaria.

To refer to this model in academic publications, please use:  Wilensky, U. (1997).  NetLogo GasLab Adiabatic Piston model.  http://ccl.northwestern.edu/netlogo/models/GasLabAdiabaticPiston.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1997 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/GasLabAdiabaticPiston for terms of use.
"
GasLab Two Gas,/models/Sample Models/Chemistry & Physics/GasLab,"globals
[
  tick-delta                           ;; how much we advance the tick counter this time through
  max-tick-delta                       ;; the largest tick-delta is allowed to be
  box-edge                             ;; distance of box edge from axes
  left-particles right-particles       ;; particles in the left and right chambers
  avg-speed-cyan avg-energy-cyan       ;; left chamber averages
  avg-speed-magenta avg-energy-magenta ;; right chamber averages
  fast medium slow                     ;; current counts
  cyans magentas
]

breed [ particles particle ]
breed [ flashes flash ]

flashes-own [birthday]

particles-own
[
  speed mass energy          ;; particle info
  last-collision
  step-size
]


to setup
  ca
  set-default-shape particles ""circle""
  set-default-shape flashes ""square""
  set max-tick-delta 0.1073
  set box-edge (round (max-pxcor * box-size / 100) - 1)
  make-box
  make-particles
  update-variables
  setup-plots
  do-plotting
end

to update-variables
  set avg-speed-cyan      mean [speed] of cyans
  set avg-speed-magenta    mean [speed] of magentas
  set avg-energy-cyan     mean [energy] of cyans
  set avg-energy-magenta   mean [energy] of magentas
end

to go
  ask particles [set step-size speed * tick-delta]
  ask particles [bounce]
  ask particles [ move ]
  ask particles
  [ if collide? [check-for-collision] ]
  tick-advance tick-delta
  if floor ticks > floor (ticks - tick-delta)
  [
     update-variables
     do-plotting
  ]
  calculate-tick-delta

  ask flashes with [ticks - birthday > 0.4]
    [ die ]
  display
end

to calculate-tick-delta
  ;; tick-delta is calculated in such way that even the fastest
  ;; particle will jump at most 1 patch length in a tick. As
  ;; particles jump (speed * tick-delta) at every tick, making
  ;; tick length the inverse of the speed of the fastest particle
  ;; (1/max speed) assures that. Having each particle advance at most
  ;; one patch-length is necessary for it not to ""jump over"" a wall.
  ifelse any? particles with [speed > 0]
    [ set tick-delta min list (1 / (ceiling max [speed] of particles)) max-tick-delta ]
    [ set tick-delta max-tick-delta ]
end

to bounce  ;; particle procedure
  ;; if we are already on a wall, no need for further checks
  if pcolor = yellow [stop]
  ;; get the coordinates of the patch we'll be on if we go forward 1
  let new-patch patch-ahead step-size
  let new-px [pxcor] of new-patch
  let new-py [pycor] of new-patch
  if [pcolor] of new-patch != yellow
    [ stop ]
  ;; if hitting left or right wall, reflect heading around x axis
  if abs new-px = box-edge [ set heading (- heading)]
  ;; if hitting top or bottom wall, reflect heading around y axis
  if abs new-py = box-edge  [ set heading (180 - heading) ]
  ;; if hitting partition, reflect heading around x axis unless near an opening
  if new-px = 0 [set heading ( - heading)
                if [pcolor] of patch-ahead step-size = yellow [set heading  (180 - heading)]]
 ;; create some flash turtles to show the bouncing particles
  ask patch new-px new-py
  [ sprout-flashes 1 [
      set color pcolor - 2
      set birthday ticks
    ]
  ]
end

to move  ;; particle procedure
  if patch-ahead (speed * tick-delta) != patch-here
    [ set last-collision nobody ]
  jump (speed * tick-delta)
end

to check-for-collision  ;; particle procedure
  ;; Here we impose a rule that collisions only take place when there
  ;; are exactly two particles per patch.  We do this because when the
  ;; student introduces new particles from the side, we want them to
  ;; form a uniform wavefront.
  ;;
  ;; Why do we want a uniform wavefront?  Because it is actually more
  ;; realistic.  (And also because the curriculum uses the uniform
  ;; wavefront to help teach the relationship between particle collisions,
  ;; wall hits, and pressure.)
  ;;
  ;; Why is it realistic to assume a uniform wavefront?  Because in reality,
  ;; whether a collision takes place would depend on the actual headings
  ;; of the particles, not merely on their proximity.  Since the particles
  ;; in the wavefront have identical speeds and near-identical headings,
  ;; in reality they would not collide.  So even though the two-particles
  ;; rule is not itself realistic, it produces a realistic result.  Also,
  ;; unless the number of particles is extremely large, it is very rare
  ;; for three or more particles to land on the same patch (for example,
  ;; with 400 particles it happens less than 1% of the time).  So imposing
  ;; this additional rule should have only a negligible effect on the
  ;; aggregate behavior of the system.
  ;;
  ;; Why does this rule produce a uniform wavefront?  The particles all
  ;; start out on the same patch, which means that without the only-two
  ;; rule, they would all start colliding with each other immediately,
  ;; resulting in much random variation of speeds and headings.  With
  ;; the only-two rule, they are prevented from colliding with each other
  ;; until they have spread out a lot.  (And in fact, if you observe
  ;; the wavefront closely, you will see that it is not completely smooth,
  ;; because some collisions eventually do start occurring when it thins out while fanning.)

  if count other particles-here = 1
  [
    ;; the following conditions are imposed on collision candidates:
    ;;   1. they must have a lower who number than my own, because collision
    ;;      code is asymmetrical: it must always happen from the point of view
    ;;      of just one particle.
    ;;   2. they must not be the same particle that we last collided with on
    ;;      this patch, so that we have a chance to leave the patch after we've
    ;;      collided with someone.
    let candidate one-of other particles-here with
      [who < [who] of myself and myself != last-collision]
    ;; we also only collide if one of us has non-zero speed. It's useless
    ;; (and incorrect, actually) for two particles with zero speed to collide.
    if (candidate != nobody) and (speed > 0 or [speed] of candidate > 0)
    [
      collide-with candidate
      set last-collision candidate
      ask candidate [ set last-collision myself ]
    ]
  ]
end

;; implements a collision with another particle.
;;
;; THIS IS THE HEART OF THE PARTICLE SIMULATION, AND YOU ARE STRONGLY ADVISED
;; NOT TO CHANGE IT UNLESS YOU REALLY UNDERSTAND WHAT YOU'RE DOING!
;;
;; The two particles colliding are self and other-particle, and while the
;; collision is performed from the point of view of self, both particles are
;; modified to reflect its effects. This is somewhat complicated, so I'll
;; give a general outline here:
;;   1. Do initial setup, and determine the heading between particle centers
;;      (call it theta).
;;   2. Convert the representation of the velocity of each particle from
;;      speed/heading to a theta-based vector whose first component is the
;;      particle's speed along theta, and whose second component is the speed
;;      perpendicular to theta.
;;   3. Modify the velocity vectors to reflect the effects of the collision.
;;      This involves:
;;        a. computing the velocity of the center of mass of the whole system
;;           along direction theta
;;        b. updating the along-theta components of the two velocity vectors.
;;   4. Convert from the theta-based vector representation of velocity back to
;;      the usual speed/heading representation for each particle.
;;   5. Perform final cleanup and update derived quantities.
to collide-with [ other-particle ] ;; particle procedure
  ;;; PHASE 1: initial setup

  ;; for convenience, grab some quantities from other-particle
  let mass2 [mass] of other-particle
  let speed2 [speed] of other-particle
  let heading2 [heading] of other-particle

  ;; since particles are modeled as zero-size points, theta isn't meaningfully
  ;; defined. we can assign it randomly without affecting the model's outcome.
  let theta (random-float 360)



  ;;; PHASE 2: convert velocities to theta-based vector representation

  ;; now convert my velocity from speed/heading representation to components
  ;; along theta and perpendicular to theta
  let v1t (speed * cos (theta - heading))
  let v1l (speed * sin (theta - heading))

  ;; do the same for other-particle
  let v2t (speed2 * cos (theta - heading2))
  let v2l (speed2 * sin (theta - heading2))



  ;;; PHASE 3: manipulate vectors to implement collision

  ;; compute the velocity of the system's center of mass along theta
  let vcm (((mass * v1t) + (mass2 * v2t)) / (mass + mass2) )

  ;; now compute the new velocity for each particle along direction theta.
  ;; velocity perpendicular to theta is unaffected by a collision along theta,
  ;; so the next two lines actually implement the collision itself, in the
  ;; sense that the effects of the collision are exactly the following changes
  ;; in particle velocity.
  set v1t (2 * vcm - v1t)
  set v2t (2 * vcm - v2t)



  ;;; PHASE 4: convert back to normal speed/heading

  ;; now convert my velocity vector into my new speed and heading
  set speed sqrt ((v1t ^ 2) + (v1l ^ 2))
  set energy (0.5 * mass * speed * speed)
  ;; if the magnitude of the velocity vector is 0, atan is undefined. but
  ;; speed will be 0, so heading is irrelevant anyway. therefore, in that
  ;; case we'll just leave it unmodified.
  if v1l != 0 or v1t != 0
    [ set heading (theta - (atan v1l v1t)) ]

  ;; and do the same for other-particle
  ask other-particle [
    set speed sqrt ((v2t ^ 2) + (v2l ^ 2))
    set energy (0.5 * mass * (speed ^ 2))
    if v2l != 0 or v2t != 0
      [ set heading (theta - (atan v2l v2t)) ]
  ]

  ;; PHASE 5: final updates

  ;; now recolor, since color is based on quantities that may have changed
  recolor
  ask other-particle
    [ recolor ]
end

to recolor  ;; particle procedure
  let values [ speed ] of breed
  let lower-limit mean values - 3 * standard-deviation values
  let upper-limit mean values + 3 * standard-deviation values
  set color scale-color color speed (lower-limit - 1) (upper-limit + 1)
end

;;;
;;; drawing procedures
;;;

;; draws the box
to make-box
  ask patches with [ ((abs pxcor = box-edge) and (abs pycor <= box-edge)) or
                     ((abs pycor = box-edge) and (abs pxcor <= box-edge)) or
                     ((abs pycor <= box-edge) and (pxcor = 0))]
    [ set pcolor yellow ]
end

to open-middle
  ask patches with [ pxcor = 0 and (abs pycor <= floor (box-edge * (opening-size / 100)))
                     and (abs pycor <= (box-edge - 1))] ;; in case opening reaches box edge
  [set pcolor black ask flashes-here [die]]
end


to close-middle
  ask patches with [ pxcor = 0 and (abs pycor <= box-edge) ]
    [ set pcolor yellow ]
end

;; creates initial particles
to make-particles
  create-particles num-cyans [
    set speed cyan-init-speed
    set mass cyan-mass
    random-position-left
    set color cyan
  ]
  create-particles num-magentas [
    set speed magenta-init-speed
    set mass magenta-mass
    random-position-right
    set shape ""circle""
    set color magenta
  ]
  set cyans particles with [color = cyan]
  set magentas particles with [color = magenta]
  ask particles
  [
    set energy (0.5 * mass * speed * speed)
    ;; make their graphical size equal to the cube root of their mass
    set size  mass ^ .33
    set last-collision nobody
    recolor
  ]
  calculate-tick-delta
end


to random-position-left ;; particle procedure
  setxy ( 1 + random-float (box-edge - 2))
        ((1 - box-edge) + random-float (2 * box-edge - 2))
end

to random-position-right ;; particle procedure
  setxy ((1 - box-edge) + random-float (box-edge - 2))
        ((1 - box-edge) + random-float (2 * box-edge - 2))
end


;;; plotting procedures

to setup-plots
  let max-init-speed (max (list cyan-init-speed magenta-init-speed))
  let max-particle-mass (max (list cyan-mass magenta-mass))
  set-current-plot ""Average Speeds""
  set-plot-y-range 0 (1.5 * max-init-speed)
  set-current-plot ""Average Energies""
  set-plot-y-range 0 (1.5 * max-init-speed * max-init-speed * max-particle-mass)
end


to do-plotting
  set-current-plot ""Average Speeds""
  set-current-plot-pen ""cyan""
  plotxy ticks avg-speed-cyan
  set-current-plot-pen ""magenta""
  plotxy ticks avg-speed-magenta

  set-current-plot ""Average Energies""
  set-current-plot-pen ""cyan""
  plotxy ticks avg-energy-cyan
  set-current-plot-pen ""magenta""
  plotxy ticks avg-energy-magenta
end



; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1997 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2002.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1997).  NetLogo GasLab Two Gas model.
; http://ccl.northwestern.edu/netlogo/models/GasLabTwoGas.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1997 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/GasLabTwoGas
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------

This model is one in a series of GasLab models. They use the same basic rules for simulating the behavior of gases.  Each model integrates different features in order to highlight different aspects of gas behavior.

The basic principle of the models is that gas particles are assumed to have two elementary actions: they move and they collide - either with other particles or with any other objects such as walls.

This model simulates the behavior of two different types of gas particles in a box with a partitioning wall. Part or all of the wall can be removed, allowing the particles to mix together. It was one of the original CM StarLogo applications (under the name GPCEE) and is now ported to NetLogo as part of the Connected Mathematics ""Making Sense of Complex Phenomena"" Modeling Project.

This model is part of the Connected Mathematics ""Making Sense of Complex Phenomena"" Modeling Project.



HOW IT WORKS
------------

The particles are modeled as hard balls with no internal energy except that which is due to their motion.  Collisions between particles are elastic.  Particles are colored according to speed -- blue for slow, green for medium, and red for high speeds.

Coloring of the particles is with respect to one speed (10).
Particles with a speed less than 5 are blue, ones that are more than
15 are red, while all in those in-between are green.

The exact way two particles collide is as follows:
1. A particle moves in a straight line without changing its speed, unless it collides with another particle or bounces off the wall.
2. Two particles ""collide"" if they find themselves on the same patch.
3. A random axis is chosen, as if they are two balls that hit each other and this axis is the line connecting their centers.
4. They exchange momentum and energy along that axis, according to the conservation of momentum and energy.  This calculation is done in the center of mass system.
5. Each particle is assigned its new velocity, energy, and heading.
6. If a particle finds itself on or very close to a wall of the container, it ""bounces"" -- that is, reflects its direction and keeps its same speed.



HOW TO USE IT
-------------
Initial settings:
- BOX-SIZE: the percent of the width and height of the world that the box will occupy.
- NUM-MAGENTAS and NUM-CYAN: the number of gas particles of each color.
- MAGENTA-INIT-SPEED and CYAN-INIT-SPEED: the initial speed the the respective particle.
- MAGENTA-MASS and CYAN-MASS: the mass of the respective particles.

The SETUP button will set these initial conditions.
The GO button will begin the simulation.

Controls:
The OPEN button opens the wall between the chambers of the box.
The CLOSE button closes the wall between the chambers of the box.

Other settings:
- COLLIDE?: Turns collisions between particles on and off.
- OPENING-SIZE: the size of the opening made as a percentage of the BOX-SIZE when the OPEN button is pressed.

Monitors:
- MAGENTAS IN RIGHT CHAMBER: number of magenta particles in the right chamber.
- CYANS IN LEFT CHAMBER: number of cyan particles in the left chamber
- AVERAGE ENERGY MAGENTA or CYAN: average energy of magenta or cyan particles.
- AVERAGE SPEED MAGENTA or CYAN: average speed of magenta or cyan particles.

Plots:
- AVERAGE ENERGY: average energy of the different particles over time.
- AVERAGE SPEED: average speed of the different particles over time.


THINGS TO NOTICE
----------------
What variables affect how quickly the model reaches a new equilibrium when the wall is removed?

Why does the average speed for each color decrease as the model runs with the wall in place, even though the average energy remains constant?

What happens to the relative energies and speeds of each kind of particle as they intermingle?   What effect do the initial speeds and masses have on this relationship?

Does the system reach an equilibrium state?

Do heavier particles tend to have higher or lower speeds when the distribution of energy has reached equilibrium?

Is it reasonable that this box can be considered to be ""insulated""?


THINGS TO TRY
-------------
Calculate how long the model takes to reach equilibrium with different sizes of windows (holding other parameters constant).

Calculate how long the model takes to reach equilibrium with different particle speeds.

Set the number of cyan particles to zero.  This is a model of a gas expanding into a vacuum.  This experiment was first done by Joule, using two insulated chambers separated by a valve.  He found that the temperature of the gas remained the same when the valve was opened.  Why would this be true? Is this model consistent with that observation?

Try some extreme situations, to test your intuitive understanding:
-- masses the same, speeds of the two particles very different.
-- speeds the same, masses very different.
-- a very small number of one kind of particle -- almost, but not quite a vacuum.  What happens to those few particles, and how do they affect the other kind?

Try relating quantitatively the ratio of the equilibrium speeds of both gases after the wall is opened to the ratio of the masses of both gases.  How are they related?


EXTENDING THE MODEL
-------------------
Monitor pressure in the right and left chambers.

Monitor temperature in the right and left chambers.

Replace the partition wall with a moveable piston, so that the two kinds of particles can push against each other without intermingling.  Do they arrive at a different equilibrium then?

Replace the partition wall with a surface that can transmit energy.

Add the histograms of energy and speed distribution (such as found in the ""Free Gas"" model).


NETLOGO FEATURES
-----------------
Notice how collisions are detected by the turtles and how the code guarantees that the same two particles do not collide twice.  What happens if we let the patches detect them?


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1997).  NetLogo GasLab Two Gas model.  http://ccl.northwestern.edu/netlogo/models/GasLabTwoGas.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1997 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/GasLabTwoGas for terms of use.
"
GasLab Free Gas,/models/Sample Models/Chemistry & Physics/GasLab,"globals
[
  tick-delta                      ;; how much we advance the tick counter this time through
  max-tick-delta                  ;; the largest tick-delta is allowed to be
  init-avg-speed init-avg-energy  ;; initial averages
  avg-speed avg-energy            ;; current averages
  fast medium slow                ;; current counts
  percent-fast percent-medium     ;; percentage of the counts
  percent-slow                    ;; percentage of the counts

]

breed [ particles particle ]

particles-own
[
  speed mass energy          ;; particle info
  last-collision
]


to setup
  ca
  set-default-shape particles ""circle""
  set max-tick-delta 0.1073
  make-particles
  update-variables
  set init-avg-speed avg-speed
  set init-avg-energy avg-energy
  setup-plots
  setup-histograms
  do-plotting
end

to go
  ask particles [ move ]
  ask particles
  [ if collide? [check-for-collision] ]
  ifelse (trace?)
    [ ask particle 0 [ pen-down ] ]
    [ ask particle 0 [ pen-up ] ]
  tick-advance tick-delta
  if floor ticks > floor (ticks - tick-delta)
  [
    update-variables
    do-plotting
  ]
  calculate-tick-delta

  display
end

to update-variables
  set medium count particles with [color = green]
  set slow count particles with [color = blue]
  set fast count particles with [color = red]
  set percent-medium (medium / count particles) * 100
  set percent-slow (slow / count particles) * 100
  set percent-fast (fast / count particles) * 100
  set avg-speed  mean [speed] of particles
  set avg-energy  mean [energy] of particles
end



to calculate-tick-delta
  ;; tick-delta is calculated in such way that even the fastest
  ;; particle will jump at most 1 patch length in a tick. As
  ;; particles jump (speed * tick-delta) at every tick, making
  ;; tick length the inverse of the speed of the fastest particle
  ;; (1/max speed) assures that. Having each particle advance at most
  ;; one patch-length is necessary for them not to jump over each other
  ;; without colliding.
  ifelse any? particles with [speed > 0]
    [ set tick-delta min list (1 / (ceiling max [speed] of particles)) max-tick-delta ]
    [ set tick-delta max-tick-delta ]
end



to move  ;; particle procedure
  if patch-ahead (speed * tick-delta) != patch-here
    [ set last-collision nobody ]
  jump (speed * tick-delta)
end

to check-for-collision  ;; particle procedure
  ;; Here we impose a rule that collisions only take place when there
  ;; are exactly two particles per patch.

  if count other particles-here = 1
  [
    ;; the following conditions are imposed on collision candidates:
    ;;   1. they must have a lower who number than my own, because collision
    ;;      code is asymmetrical: it must always happen from the point of view
    ;;      of just one particle.
    ;;   2. they must not be the same particle that we last collided with on
    ;;      this patch, so that we have a chance to leave the patch after we've
    ;;      collided with someone.
    let candidate one-of other particles-here with
      [who < [who] of myself and myself != last-collision]
    ;; we also only collide if one of us has non-zero speed. It's useless
    ;; (and incorrect, actually) for two particles with zero speed to collide.
    if (candidate != nobody) and (speed > 0 or [speed] of candidate > 0)
    [
      collide-with candidate
      set last-collision candidate
      ask candidate [ set last-collision myself ]
    ]
  ]
end

;; implements a collision with another particle.
;;
;; THIS IS THE HEART OF THE PARTICLE SIMULATION, AND YOU ARE STRONGLY ADVISED
;; NOT TO CHANGE IT UNLESS YOU REALLY UNDERSTAND WHAT YOU'RE DOING!
;;
;; The two particles colliding are self and other-particle, and while the
;; collision is performed from the point of view of self, both particles are
;; modified to reflect its effects. This is somewhat complicated, so I'll
;; give a general outline here:
;;   1. Do initial setup, and determine the heading between particle centers
;;      (call it theta).
;;   2. Convert the representation of the velocity of each particle from
;;      speed/heading to a theta-based vector whose first component is the
;;      particle's speed along theta, and whose second component is the speed
;;      perpendicular to theta.
;;   3. Modify the velocity vectors to reflect the effects of the collision.
;;      This involves:
;;        a. computing the velocity of the center of mass of the whole system
;;           along direction theta
;;        b. updating the along-theta components of the two velocity vectors.
;;   4. Convert from the theta-based vector representation of velocity back to
;;      the usual speed/heading representation for each particle.
;;   5. Perform final cleanup and update derived quantities.
to collide-with [ other-particle ] ;; particle procedure
  ;;; PHASE 1: initial setup

  ;; for convenience, grab some quantities from other-particle
  let mass2 [mass] of other-particle
  let speed2 [speed] of other-particle
  let heading2 [heading] of other-particle

  ;; since particles are modeled as zero-size points, theta isn't meaningfully
  ;; defined. we can assign it randomly without affecting the model's outcome.
  let theta (random-float 360)



  ;;; PHASE 2: convert velocities to theta-based vector representation

  ;; now convert my velocity from speed/heading representation to components
  ;; along theta and perpendicular to theta
  let v1t (speed * cos (theta - heading))
  let v1l (speed * sin (theta - heading))

  ;; do the same for other-particle
  let v2t (speed2 * cos (theta - heading2))
  let v2l (speed2 * sin (theta - heading2))



  ;;; PHASE 3: manipulate vectors to implement collision

  ;; compute the velocity of the system's center of mass along theta
  let vcm (((mass * v1t) + (mass2 * v2t)) / (mass + mass2) )

  ;; now compute the new velocity for each particle along direction theta.
  ;; velocity perpendicular to theta is unaffected by a collision along theta,
  ;; so the next two lines actually implement the collision itself, in the
  ;; sense that the effects of the collision are exactly the following changes
  ;; in particle velocity.
  set v1t (2 * vcm - v1t)
  set v2t (2 * vcm - v2t)



  ;;; PHASE 4: convert back to normal speed/heading

  ;; now convert my velocity vector into my new speed and heading
  set speed sqrt ((v1t ^ 2) + (v1l ^ 2))
  set energy (0.5 * mass * (speed ^ 2))
  ;; if the magnitude of the velocity vector is 0, atan is undefined. but
  ;; speed will be 0, so heading is irrelevant anyway. therefore, in that
  ;; case we'll just leave it unmodified.
  if v1l != 0 or v1t != 0
    [ set heading (theta - (atan v1l v1t)) ]

  ;; and do the same for other-particle
  ask other-particle [
    set speed sqrt ((v2t ^ 2) + (v2l ^ 2))
    set energy (0.5 * mass * (speed ^ 2))
    if v2l != 0 or v2t != 0
      [ set heading (theta - (atan v2l v2t)) ]
  ]

  ;; PHASE 5: final updates

  ;; now recolor, since color is based on quantities that may have changed
  recolor
  ask other-particle
    [ recolor ]
end

to recolor  ;; particle procedure
  ifelse speed < (0.5 * 10)
  [
    set color blue
  ]
  [
    ifelse speed > (1.5 * 10)
      [ set color red ]
      [ set color green ]
  ]
end

;;;
;;; drawing procedures
;;;


;; creates initial particles
to make-particles
  create-particles number-of-particles
  [
    setup-particle
    random-position
    recolor
  ]
  calculate-tick-delta
end


to setup-particle  ;; particle procedure
  set speed init-particle-speed
  set mass particle-mass
  set energy (0.5 * mass * (speed ^ 2))
  set last-collision nobody
end


;; place particle at random location inside the box.
to random-position ;; particle procedure
  setxy ((1 + min-pxcor) + random-float ((2 * max-pxcor) - 2))
        ((1 + min-pycor) + random-float ((2 * max-pycor) - 2))
end

to-report last-n [n the-list]
  ifelse n >= length the-list
    [ report the-list ]
    [ report last-n n butfirst the-list ]
end


;;; plotting procedures

to setup-plots
  set-current-plot ""Speed Counts""
  set-plot-y-range 0 100
end

to setup-histograms
  set-current-plot ""Speed Histogram""
  set-plot-x-range 0 (init-particle-speed * 2)
  set-plot-y-range 0 ceiling (number-of-particles / 6)
  set-current-plot-pen ""medium""
  set-histogram-num-bars 40
  set-current-plot-pen ""slow""
  set-histogram-num-bars 40
  set-current-plot-pen ""fast""
  set-histogram-num-bars 40
  set-current-plot-pen ""init-avg-speed""
  draw-vert-line init-avg-speed

  set-current-plot ""Energy Histogram""
  set-plot-x-range 0 (0.5 * (init-particle-speed * 2) * (init-particle-speed * 2) * particle-mass)
  set-plot-y-range 0 ceiling (number-of-particles / 6)
  set-current-plot-pen ""medium""
  set-histogram-num-bars 40
  set-current-plot-pen ""slow""
  set-histogram-num-bars 40
  set-current-plot-pen ""fast""
  set-histogram-num-bars 40
  set-current-plot-pen ""init-avg-energy""
  draw-vert-line init-avg-energy
end


to do-plotting
  set-current-plot ""Speed Counts""
  set-current-plot-pen ""fast""
  plotxy ticks percent-fast
  set-current-plot-pen ""medium""
  plotxy ticks percent-medium
  set-current-plot-pen ""slow""
  plotxy ticks percent-slow

  plot-histograms
end


to plot-histograms
  set-current-plot ""Energy histogram""
  set-current-plot-pen ""fast""
  histogram [ energy ] of particles with [color = red]
  set-current-plot-pen ""medium""
  histogram [ energy ] of particles with [color = green]
  set-current-plot-pen ""slow""
  histogram [ energy ] of particles with [color = blue]
  set-current-plot-pen ""avg-energy""
  plot-pen-reset
  draw-vert-line avg-energy

  set-current-plot ""Speed histogram""
  set-current-plot-pen ""fast""
  histogram [ speed ] of particles with [color = red]
  set-current-plot-pen ""medium""
  histogram [ speed ] of particles with [color = green]
  set-current-plot-pen ""slow""
  histogram [ speed ] of particles with [color = blue]
  set-current-plot-pen ""avg-speed""
  plot-pen-reset
  draw-vert-line avg-speed
end

;; histogram procedure
to draw-vert-line [ xval ]
  plotxy xval plot-y-min
  plot-pen-down
  plotxy xval plot-y-max
  plot-pen-up
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1997 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2002.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1997).  NetLogo GasLab Free Gas model.
; http://ccl.northwestern.edu/netlogo/models/GasLabFreeGas.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1997 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/GasLabFreeGas
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model is one in a series of GasLab models. They use the same basic rules for simulating the behavior of gases.  Each model integrates different features in order to highlight different aspects of gas behavior.

The basic principle of the models is that gas particles are assumed to have two elementary actions: they move and they collide - either with other particles or with any other objects such as walls.

This model is the simplest gas model in the suite of GasLab models.  The particles are moving and colliding with each other with no external constraints, such as gravity or containers. In this model, particles are modeled as perfectly elastic ones with no energy except their kinetic energy -- which is due to their motion.  Collisions between particles are elastic.  Particles are colored according to their speed -- blue for slow, green for medium, and red for high.


HOW IT WORKS
------------
The basic principle of all GasLab models is the following algorithm (for more details, see the model ""GasLab Gas in a Box""):

1) A particle moves in a straight line without changing its speed, unless it collides with another particle or bounces off the wall.
2) Two particles ""collide"" if they find themselves on the same patch (NetLogo's View is composed of a grid of small squares called patches). In this model, two particles are aimed so that they will collide at the origin.
3) An angle of collision for the particles is chosen, as if they were two solid balls that hit, and this angle describes the direction of the line connecting their centers.
4) The particles exchange momentum and energy only along this line, conforming to the conservation of momentum and energy for elastic collisions.
5) Each particle is assigned its new speed, heading and energy.


HOW TO USE IT
-------------
Initial settings:
- NUMBER-OF-PARTICLES: the number of gas particles.
- TRACE?: Draws the path of one individual particle.
- COLLIDE?: Turns collisions between particles on and off.
- INIT-PARTICLE-SPEED: the initial speed of each particle -- they all start with the same speed.
- PARTICLE-MASS: the mass of each particle -- they all have the same mass.


As in most NetLogo models, the first step is to press SETUP. It puts in the initial conditions you have set with the sliders.  Be sure to wait till the SETUP button stops before pushing GO.
The GO button runs the models again and again.  This is a ""forever"" button.

Monitors:
- PERCENT FAST, PERCENT MEDIUM, PERCENT SLOW monitors: percent of particles with different speeds: fast (red), medium (green), and slow (blue).
- AVERAGE SPEED: average speed of the particles.
- AVERAGE ENERGY: average kinetic energy of the particles.

Plots:
- SPEED COUNTS: plots the number of particles in each range of speed (fast, medium or slow).
- SPEED HISTOGRAM: speed distribution of all the particles.  The gray line is the average value, and the black line is the initial average.  The displayed values for speed are ten times the actual values.
- ENERGY HISTOGRAM: the distribution of energies of all the particles, calculated as (m*v^2)/2.  The gray line is the average value, and the black line is the initial average.

Initially, all the particles have the same speed but random directions. Therefore the first histogram plots of speed and energy should show only one column each.  As the particles repeatedly collide, they exchange energy and head off in new directions, and the speeds are dispersed -- some particles get faster, some get slower, and the plot will show that change.


THINGS TO NOTICE
----------------

What is happening to the numbers of particles of different colors?  Why are there more blue particles than red ones?

Can you observe collisions and color changes as they happen?  For instance, when a red particle hits a green particle, what color do they each become?

Why does the average speed (avg-speed) drop?  Does this violate conservation of energy?

This gas is in ""endless space"" -- no boundaries, no obstructions, but still a finite size!  Is there a physical situation like this?

Watch the particle whose path is traced in the drawing. Notice how the path ""wraps"" around the world. Does the trace resemble Brownian motion? Can you recognize when a collision happens?  What factors affect the frequency of collisions?   What about the ""angularity"" of the path?  Could you get it to stay ""local"" or travel all over the world?

In what ways is this model an ""idealization"" of the real world?


THINGS TO TRY
-------------
Set all the particles in part of the world, or with the same heading -- what happens?  Does this correspond to a physical possibility?

Try different settings, especially the extremes.   Are the histograms different?  Does the trace pattern change?

Are there other interesting quantities to keep track of?

Look up or calculate the REAL number, size, mass and speed of particles in a typical gas.  When you compare those numbers to the ones in the model, are you surprised this model works as well as it does?  What physical phenomena might be observed if there really were a small number of big particles in the space around us?

We often say outer space is a vacuum.  Is that really true?  How many particles would there be in a space the size of this computer?


EXTENDING THE MODEL
-------------------
Could you find a way to measure or express the ""temperature"" of this imaginary gas?  Try to construct a thermometer.

What happens if there are particles of different masses?  (See ""GasLab Two Gas"" model.)

How would you define and calculate pressure in this ""boundless"" space?

What happens if the gas is inside a container instead of a boundless space?  (See ""Gas in a Box"" model.)

What happens if the collisions are non-elastic?

How does this 2-D model differ from the 3-D model?

Set up only two particles to collide head-on.  This may help to show how the collision rule works.  Remember that the axis of collision is being randomly chosen each time.

What if some of the particles had a ""drift"" tendency -- a force pulling them in one direction?  Could you develop a model of a centrifuge, or charged particles in an electric field?

Find a way to monitor how often particles collide, and how far they go, on average, between collisions.  The latter is called the ""mean free path"".  What factors affect its value?

In what ways is this idealization different from the one  used to derive the Maxwell-Boltzmann distribution?   Specifically, what other code could be used to represent the two-body collisions of particles?

If MORE than two particles arrive on the same patch, the current code says they don't collide.  Is this a mistake?  How does it affect the results?

Is this model valid for fluids in any aspect?  How could it be made to be fluid-like?


NETLOGO FEATURES
-----------------
Notice the use of the histogram primitive.

Notice how collisions are detected by the turtles and how the code guarantees that the same two particles do not collide twice.  What happens if we let the patches detect them?


CREDITS AND REFERENCES
----------------------
This was one of the original Connection Machine StarLogo applications (under the name GPCEE) and is now ported to NetLogo as part of the Participatory Simulations project.

To refer to this model in academic publications, please use:  Wilensky, U. (1997).  NetLogo GasLab Free Gas model.  http://ccl.northwestern.edu/netlogo/models/GasLabFreeGas.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1997 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/GasLabFreeGas for terms of use.
"
GasLab Atmosphere,/models/Sample Models/Chemistry & Physics/GasLab,"globals
[
  tick-delta                          ;; how much we advance the tick counter this time through
  max-tick-delta                      ;; the largest tick-delta is allowed to be
  avg-speed-init avg-energy-init      ;; initial averages
  avg-speed avg-energy                ;; current averages
  fast medium slow lost-particles     ;; current counts
  percent-medium percent-slow         ;; percentage of current counts
  percent-fast percent-lost-particles ;; percentage of current counts
]

breed [ particles particle ]
breed [ flashes flash ]

flashes-own [birthday]

particles-own
[
  speed mass energy          ;; particle info
  last-collision
]


to setup
  ca
  set-default-shape particles ""circle""
  set-default-shape flashes ""plane""
  set max-tick-delta 0.1073
  ;; make floor
  ask patches with [ pycor = min-pycor ]
    [ set pcolor yellow ]
  make-particles
  update-variables
  set avg-speed-init avg-speed
  set avg-energy-init avg-energy
  setup-plots
  setup-histograms
  do-plotting
end

to go
  ask particles [ bounce ]
  ask particles [ move ]
  if not any? particles [stop]  ;; particles can die when they float too high
  ask particles
  [ if collide? [check-for-collision] ]
  ifelse (trace?)
    [ ask particle 0 [ pen-down ] ]
    [ ask particle 0 [ pen-up ] ]
  tick-advance tick-delta
  if floor ticks > floor (ticks - tick-delta)
  [
    update-variables
    do-plotting
  ]
  calculate-tick-delta

  ask flashes with [ticks - birthday > 0.4]
    [ die ]
  display
end

to update-variables
  set lost-particles (number-of-particles - count particles)
  set percent-lost-particles (lost-particles / number-of-particles) * 100
  set medium count particles with [color = green]
  set slow count particles with [color = blue]
  set fast count particles with [color = red]
  set percent-medium (medium / (number-of-particles - lost-particles)) * 100
  set percent-slow (slow / (number-of-particles - lost-particles)) * 100
  set percent-fast (fast / (number-of-particles - lost-particles)) * 100
  set avg-speed  mean [speed] of particles
  set avg-energy  mean [energy] of particles
end

to calculate-tick-delta
  ;; tick-delta is calculated in such way that even the fastest
  ;; particle will jump at most 1 patch length in a tick. As
  ;; particles jump (speed * tick-delta) at every tick, making
  ;; tick length the inverse of the speed of the fastest particle
  ;; (1/max speed) assures that. Having each particle advance at most
  ;; one patch-length is necessary for it not to ""jump over"" a wall
  ;; or another particle.
  ifelse any? particles with [speed > 0]
    [ set tick-delta min list (1 / (ceiling max [speed] of particles)) max-tick-delta ]
    [ set tick-delta max-tick-delta ]
end


to bounce  ;; particle procedure
  ;; get the coordinates of the patch we'll be on if we go forward 1
  let new-patch patch-ahead 1
  ;; if we're not about to hit a wall, we don't need to do any further checks
  if new-patch = nobody or [pcolor] of new-patch != yellow
    [ stop ]

  let new-px [pxcor] of new-patch
  let new-py [pycor] of new-patch
  ;; if hitting the bottom, reflect heading around y axis
  if (new-py = min-pycor )
    [ set heading (180 - heading)]

  ask patch new-px new-py
  [ sprout-flashes 1 [
      set color pcolor - 2
      set birthday ticks
      set heading 0
    ]
  ]
end

to move  ;; particle procedure
  ;; In other GasLab models, we use ""jump speed * tick-delta"" to move the
  ;; turtle the right distance along its current heading.  In this
  ;; model, though, the particles are affected by gravity as well, so we
  ;; need to offset the turtle vertically by an additional amount.  The
  ;; easiest way to do this is to use ""setxy"" instead of ""jump"".
  ;; Trigonometry tells us that ""jump speed * tick-delta"" is equivalent to:
  ;;   setxy (xcor + sin heading * speed * tick-delta)
  ;;         (ycor + cos heading * speed * tick-delta)
  ;; so to take gravity into account we just need to alter ycor
  ;; by an additional amount given by the classical physics equation:
  ;;   y(t) = 0.5*a*t^2 + v*t + y(t-1)
  ;; but taking tick-delta into account, since tick-delta is a multiplier of t.
  let xdiff sin heading * speed * tick-delta
  let ydiff cos heading * speed * tick-delta - gravity-acceleration * (0.5 * (tick-delta ^ 2))
  if patch-at xdiff ydiff = nobody [ die ]
  setxy (xcor + xdiff) (ycor + ydiff)
  factor-gravity
end


to factor-gravity  ;; turtle procedure
  let vx (sin heading * speed)
  let vy (cos heading * speed) - (gravity-acceleration * tick-delta)
  set speed sqrt ((vy ^ 2) + (vx ^ 2))
  recolor
  set heading atan vx vy
end


to check-for-collision  ;; particle procedure
  ;; Here we impose a rule that collisions only take place when there
  ;; are exactly two particles per patch.

  if count other particles-here = 1
  [
    ;; the following conditions are imposed on collision candidates:
    ;;   1. they must have a lower who number than my own, because collision
    ;;      code is asymmetrical: it must always happen from the point of view
    ;;      of just one particle.
    ;;   2. they must not be the same particle that we last collided with on
    ;;      this patch, so that we have a chance to leave the patch after we've
    ;;      collided with someone.
    let candidate one-of other particles-here with
      [who < [who] of myself and myself != last-collision]
    ;; we also only collide if one of us has non-zero speed. It's useless
    ;; (and incorrect, actually) for two particles with zero speed to collide.
    if (candidate != nobody) and (speed > 0 or [speed] of candidate > 0)
    [
      collide-with candidate
      set last-collision candidate
      ask candidate [ set last-collision myself ]
    ]
  ]
end

;; implements a collision with another particle.
;;
;; THIS IS THE HEART OF THE PARTICLE SIMULATION, AND YOU ARE STRONGLY ADVISED
;; NOT TO CHANGE IT UNLESS YOU REALLY UNDERSTAND WHAT YOU'RE DOING!
;;
;; The two particles colliding are self and other-particle, and while the
;; collision is performed from the point of view of self, both particles are
;; modified to reflect its effects. This is somewhat complicated, so I'll
;; give a general outline here:
;;   1. Do initial setup, and determine the heading between particle centers
;;      (call it theta).
;;   2. Convert the representation of the velocity of each particle from
;;      speed/heading to a theta-based vector whose first component is the
;;      particle's speed along theta, and whose second component is the speed
;;      perpendicular to theta.
;;   3. Modify the velocity vectors to reflect the effects of the collision.
;;      This involves:
;;        a. computing the velocity of the center of mass of the whole system
;;           along direction theta
;;        b. updating the along-theta components of the two velocity vectors.
;;   4. Convert from the theta-based vector representation of velocity back to
;;      the usual speed/heading representation for each particle.
;;   5. Perform final cleanup and update derived quantities.
to collide-with [ other-particle ] ;; particle procedure
  ;; local copies of other-particle's relevant quantities:
  ;; mass2 speed2 heading2
  ;;
  ;; quantities used in the collision itself
  ;; theta   ;; heading of vector from my center to the center of other-particle.
  ;; v1t     ;; velocity of self along direction theta
  ;; v1l     ;; velocity of self perpendicular to theta
  ;; v2t v2l ;; velocity of other-particle, represented in the same way
  ;; vcm     ;; velocity of the center of mass of the colliding particles,
             ;;   along direction theta

  ;;; PHASE 1: initial setup

  ;; for convenience, grab some quantities from other-particle
  let mass2 [mass] of other-particle
  let speed2 [speed] of other-particle
  let heading2 [heading] of other-particle

  ;; since particles are modeled as zero-size points, theta isn't meaningfully
  ;; defined. we can assign it randomly without affecting the model's outcome.
  let theta (random-float 360)



  ;;; PHASE 2: convert velocities to theta-based vector representation

  ;; now convert my velocity from speed/heading representation to components
  ;; along theta and perpendicular to theta
  let v1t (speed * cos (theta - heading))
  let v1l (speed * sin (theta - heading))

  ;; do the same for other-particle
  let v2t (speed2 * cos (theta - heading2))
  let v2l (speed2 * sin (theta - heading2))



  ;;; PHASE 3: manipulate vectors to implement collision

  ;; compute the velocity of the system's center of mass along theta
  let vcm (((mass * v1t) + (mass2 * v2t)) / (mass + mass2) )

  ;; now compute the new velocity for each particle along direction theta.
  ;; velocity perpendicular to theta is unaffected by a collision along theta,
  ;; so the next two lines actually implement the collision itself, in the
  ;; sense that the effects of the collision are exactly the following changes
  ;; in particle velocity.
  set v1t (2 * vcm - v1t)
  set v2t (2 * vcm - v2t)



  ;;; PHASE 4: convert back to normal speed/heading

  ;; now convert my velocity vector into my new speed and heading
  set speed sqrt ((v1t ^ 2) + (v1l ^ 2))
  set energy (0.5 * mass * (speed ^ 2))
  ;; if the magnitude of the velocity vector is 0, atan is undefined. but
  ;; speed will be 0, so heading is irrelevant anyway. therefore, in that
  ;; case we'll just leave it unmodified.
  if v1l != 0 or v1t != 0
    [ set heading (theta - (atan v1l v1t)) ]

  ;; and do the same for other-particle
  ask other-particle [
    set speed sqrt ((v2t ^ 2) + (v2l ^ 2))
    set energy (0.5 * mass * (speed ^ 2))
    if v2l != 0 or v2t != 0
      [ set heading (theta - (atan v2l v2t)) ]
  ]

  ;; PHASE 5: final updates

  ;; now recolor, since color is based on quantities that may have changed
  recolor
  ask other-particle
    [ recolor ]
end

to recolor  ;; particle procedure
  ifelse speed < (0.5 * init-particle-speed)
  [
    set color blue
  ]
  [
    ifelse speed > (1.5 * init-particle-speed)
      [ set color red ]
      [ set color green ]
  ]
end

;;;
;;; drawing procedures
;;;


;; creates initial particles
to make-particles
  create-particles number-of-particles
  [
    setup-particle
    random-position
    recolor
  ]
  calculate-tick-delta
end


to setup-particle  ;; particle procedure
  set speed init-particle-speed
  set mass particle-mass
  set energy (0.5 * mass * (speed ^ 2))
  set last-collision nobody
end




to-report last-n [n the-list]
  ifelse n >= length the-list
    [ report the-list ]
    [ report last-n n butfirst the-list ]
end


;; place particle at random location inside the box.
to random-position ;; particle procedure
  setxy random-xcor random-float ( ( world-height  - 1 ) / 2 ) + 1
end


;;; plotting procedures

to setup-plots
  set-current-plot ""Speed Counts""
  set-plot-y-range 0 100
  set-current-plot ""Energy vs. Height""
  set-plot-x-range 0 (max-pycor * 2)
end

to setup-histograms
  set-current-plot ""Speed Histogram""
  set-plot-x-range 0 (init-particle-speed * 3)
  set-plot-y-range 0 ceiling (number-of-particles / 10)
  set-current-plot-pen ""medium""
  set-histogram-num-bars 45
  set-current-plot-pen ""slow""
  set-histogram-num-bars 45
  set-current-plot-pen ""fast""
  set-histogram-num-bars 45
  set-current-plot-pen ""init-avg-speed""
  draw-vert-line avg-speed-init

  set-current-plot ""Energy Histogram""
  set-plot-x-range 0 (0.5 * ((init-particle-speed * 3) ^ 2 ) * particle-mass)
  set-plot-y-range 0 ceiling (number-of-particles / 10)
  set-current-plot-pen ""medium""
  set-histogram-num-bars 45
  set-current-plot-pen ""slow""
  set-histogram-num-bars 45
  set-current-plot-pen ""fast""
  set-histogram-num-bars 45
  set-current-plot-pen ""init-avg-energy""
  draw-vert-line avg-energy-init

  set-current-plot ""Density Histogram""
  set-plot-x-range 0 (max-pycor * 2)
  set-plot-y-range 0 (max-pxcor * 2)
  set-histogram-num-bars round (max-pxcor / 2)
end

to do-plotting
  set-current-plot ""Energy vs. Height""
  plot-pen-reset
  draw-graph

  set-current-plot ""Speed Counts""
  set-current-plot-pen ""fast""
  plotxy ticks percent-fast
  set-current-plot-pen ""medium""
  plotxy ticks percent-medium
  set-current-plot-pen ""slow""
  plotxy ticks percent-slow

  plot-histograms
end


to plot-histograms
  set-current-plot ""Energy histogram""
  set-current-plot-pen ""fast""
  histogram [ energy ] of particles with [color = red]
  set-current-plot-pen ""medium""
  histogram [ energy ] of particles with [color = green]
  set-current-plot-pen ""slow""
  histogram [ energy ] of particles with [color = blue]
  set-current-plot-pen ""avg-energy""
  plot-pen-reset
  draw-vert-line avg-energy

  set-current-plot ""Speed histogram""
  set-current-plot-pen ""fast""
  histogram [ speed ] of particles with [color = red]
  set-current-plot-pen ""medium""
  histogram [ speed ] of particles with [color = green]
  set-current-plot-pen ""slow""
  histogram [ speed ] of particles with [color = blue]
  set-current-plot-pen ""avg-speed""
  plot-pen-reset
  draw-vert-line avg-speed

  set-current-plot ""Density Histogram""
  histogram [ycor + max-pycor] of particles
end


to draw-graph
  let n min-pycor
  repeat (max-pycor / 2)
  [ let x particles with [ (pycor >= n) and (pycor < (n + 4)) ]
    ifelse count x = 0
     [ plot 0 ]
     [ plot mean [energy] of x ]
    set n n + 4
  ]
end


;; histogram procedure
to draw-vert-line [ xval ]
  plotxy xval plot-y-min
  plot-pen-down
  plotxy xval plot-y-max
  plot-pen-up
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1997 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2002.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1997).  NetLogo GasLab Atmosphere model.
; http://ccl.northwestern.edu/netlogo/models/GasLabAtmosphere.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1997 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/GasLabAtmosphere
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model is one in a series of GasLab models. They use the same basic rules for simulating the behavior of gases.  Each model integrates different features in order to highlight different aspects of gas behavior.

The basic principle of the models is that gas particles are assumed to have two elementary actions: they move and they collide - either with other particles or with any other objects such as walls.

In this model, a gaseous atmosphere is placed above the surface of a ""planet"", represented by a yellow line at the bottom of the world.


HOW IT WORKS
------------
The basic principle of all GasLab models is the following algorithm (for more details, see the model ""GasLab Gas in a Box""):

1) A particle moves in a straight line without changing its speed, unless it collides with another particle or bounces off the wall.
2) Two particles ""collide"" if they find themselves on the same patch (NetLogo's View is composed of a grid of small squares called patches). In this model, two particles are aimed so that they will collide at the origin.
3) An angle of collision for the particles is chosen, as if they were two solid balls that hit, and this angle describes the direction of the line connecting their centers.
4) The particles exchange momentum and energy only along this line, conforming to the conservation of momentum and energy for elastic collisions.
5) Each particle is assigned its new speed, heading and energy.
6) If a particle finds itself on or very close to the surface of the planet, it ""bounces"" -- that is, reflects its direction and keeps its same speed.

In this model, the effect of gravity is calculated as follows: every particle is given additional velocity downward during each clock tick, as it would get in a gravitational field. The particles bounce off the ""ground"". They disappear if they reach the top of the world, as if they had escaped the planet's gravitational field. The percentage of lost particles is shown in the PERCENT LOST PARTICLES monitor.


HOW TO USE IT
-------------
Initial settings:
- NUMBER-OF-PARTICLES: number of gas particles
- INIT-PARTICLE-SPEED: initial speed of each particle
- PARTICLE-MASS: mass of each particle
- GRAVITY-ACCELERATION: value of the gravitational acceleration

The SETUP button will set the initial conditions.  The GO button will run the simulation.

Other settings:
- COLLIDE?: Turns collisions between particles on and off.
- TRACE?: Traces the path of one of the particles.

Monitors:
- AVERAGE SPEED: average speed of the particles.
- PERCENT FAST, PERCENT MEDIUM, PERCENT SLOW: percentage of particles with different speeds - fast (red), medium (green), and slow (blue).
- PERCENT LOST PARTICLES: percentage of particles that have disappeared at the top edge of the world.
- CLOCK (inside the View): number of ticks that have run.

Plots:
- SPEED COUNTS: plots the number of particles in each range of speed.
- SPEED HISTOGRAM: speed distribution of all the particles.  The gray line is the average value, and the black line is the initial average.
- ENERGY HISTOGRAM: distribution of energies of all the particles, using m*(v^2)/2.
- DENSITY HISTOGRAM: shows the number of particles at each 'layer' of the atmosphere, i.e. its local density.
- ENERGY VS. HEIGHT: shows the mean energy of the particles at each ""layer"" of the atmosphere.


THINGS TO NOTICE
----------------
Try to predict what the view will look like after a while, and why.

Watch the gray path of one particle. What can you say about its motion? Turn COLLIDE? off and see if there are any differences.

Watch the change in density distribution as the model runs.

As the model runs, what happens to the average speed and kinetic energy of the particles?  If they gain energy, where does it come from?   What happens to the speed and energy distributions?


THINGS TO TRY
-------------
What happens when gravity is increased or decreased?

Change the initial number, speed and mass.  What happens to the density distribution?

What factors affect how many particles escape this planet?

Does this model come to some sort of equilibrium?  How can you tell when it has been reached?

Try and find out if the distribution of the particles in this model is the same as what is predicted by conventional physical laws. Is this consistent, for instance, with the fact that high-altitude places have lower pressure ( and thus lower density of air)? Why are they colder?

Try making gravity negative.


EXTENDING THE MODEL
-------------------
Find a way to plot the relative ""temperature"" of the gas as a function of distance from the planet.

Try this model with particles of different masses.  You could color each mass differently to be able to see where they go.  Are their distributions different?  Which ones escape most easily?  What does this suggest about the composition of an atmosphere?

The fact that particles escape when they reach a certain height isn't completely realistic, especially in the case when the particle was about to turn back towards the planet.  Improve the model by allowing particles that have ""escaped"" to re-enter the atmosphere once gravity pulls them back down.  How does this change the behavior of the model?  Keeping track of actual losses (particles which reached the escape velocity of the planet) would be interesting.  Under what conditions will particles reach escape velocity at all?

Make the ""planet"" into a central point instead of a flat plane.

This basic model could be used to explore other situations where freely moving particles have forces on them -- e.g. a centrifuge or charged particles (ions) in an electrical field.


NETLOGO FEATURES
----------------
Because of the influence of gravity, the particles follow curved paths.  Since NetLogo models time in discrete steps, these curved paths must be approximated with a series of short straight lines.  This is the source of a slight inaccuracy where the particles gradually lose energy if the model runs for a long time.  The effect is as though the collisions with the ground were slightly inelastic.  The inaccuracy can be reduced by increasing ""vsplit"", but the model will run slower.


RELATED MODELS
---------------
This model is part of the GasLab suite and curriculum.
See, in particular, the models ""Gas in a Box"" and ""Gravity Box"", which is a modified version of the ""Atmosphere"" model, with a ceiling on the atmosphere.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1997).  NetLogo GasLab Atmosphere model.  http://ccl.northwestern.edu/netlogo/models/GasLabAtmosphere.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1997 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/GasLabAtmosphere for terms of use.
"
GasLab Gravity Box,/models/Sample Models/Chemistry & Physics/GasLab,"globals
[
  tick-delta                                  ;; how much we advance the tick counter this time through
  max-tick-delta                              ;; the largest tick-delta is allowed to be
  box-edge                                    ;; distance of box edge from axes
  init-avg-speed init-avg-energy              ;; initial averages
  avg-speed avg-energy                        ;; current averages
  fast medium slow                            ;; current counts
  percent-slow percent-medium percent-fast    ;;  percentage of current counts
  aggregate-list                              ;; list of the sums of the temperature at each height
]

breed [ particles particle ]
breed [ flashes flash ]

flashes-own [birthday]

particles-own
[
  speed mass energy          ;; particle info
  last-collision
]


to setup
  ca
  set-default-shape particles ""circle""
  set-default-shape flashes ""plane""
  set max-tick-delta 0.1073
  ;; box has constant size...
  set box-edge (max-pxcor)
  ;; make floor
  ask patches with [ pycor = min-pycor ]
    [ set pcolor yellow ]
  make-particles
  make-box
  update-variables
  set init-avg-speed avg-speed
  set init-avg-energy avg-energy
  setup-plots
  setup-histograms
  do-plotting
end


to update-variables
  set medium count particles with [color = green]
  set slow   count particles with [color = blue]
  set fast   count particles with [color = red]
  set percent-medium (medium / (count particles)) * 100
  set percent-slow (slow / (count particles)) * 100
  set percent-fast (fast / (count particles)) * 100
  set avg-speed  mean [speed] of particles
  set avg-energy  mean [energy] of particles
end


to go
  ask particles [ bounce ]
  ask particles [ move ]
  ask particles
  [ if collide? [check-for-collision] ]
  ifelse (trace?)
    [ ask particle 0 [ pen-down ] ]
    [ ask particle 0 [ pen-up ] ]
  tick-advance tick-delta
  if floor ticks > floor (ticks - tick-delta)
  [
    update-variables
    do-plotting
  ]
  calculate-tick-delta

  ask flashes with [ticks - birthday > 0.4]
    [ die ]
  display
end

to calculate-tick-delta
  ;; tick-delta is calculated in such way that even the fastest
  ;; particle will jump at most 1 patch length in a tick. As
  ;; particles jump (speed * tick-delta) at every tick, making
  ;; tick length the inverse of the speed of the fastest particle
  ;; (1/max speed) assures that. Having each particle advance at most
  ;; one patch-length is necessary for it not to ""jump over"" a wall
  ;; or another particle.
  ifelse any? particles with [speed > 0]
    [ set tick-delta min list (1 / (ceiling max [speed] of particles)) max-tick-delta ]
    [ set tick-delta max-tick-delta ]
end

to bounce  ;; particle procedure  ;; get the coordinates of the patch we will be on if we go forward 1
  let new-patch patch-ahead 1
  let new-px [pxcor] of new-patch
  let new-py [pycor] of new-patch

  ;; if we're not about to hit a wall, we don't need to do any further checks
  if [pcolor] of new-patch != yellow
    [ stop ]

  ;; if hitting the top or bottom, reflect heading around y axis
  if (new-py = max-pycor or new-py = min-pycor )
    [ set heading (180 - heading)]

  ask patch new-px new-py
  [ sprout-flashes 1 [
      set color pcolor - 2
      set birthday ticks
      set heading 0
    ]
  ]
end

to move  ;; particle procedure
  ;; In other GasLab models, we use ""jump speed * tick-delta"" to move the
  ;; turtle the right distance along its current heading.  In this
  ;; model, though, the particles are affected by gravity as well, so we
  ;; need to offset the turtle vertically by an additional amount.  The
  ;; easiest way to do this is to use ""setxy"" instead of ""jump"".
  ;; Trigonometry tells us that ""jump speed * tick-delta"" is equivalent to:
  ;;   setxy (xcor + sin heading * speed * tick-delta)
  ;;         (ycor + cos heading * speed * tick-delta)
  ;; so to take gravity into account we just need to alter ycor
  ;; by an additional amount given by the classical physics equation:
  ;;   y(t) = 0.5*a*t^2 + v*t + y(t-1)
  ;; but taking tick-delta into account, since tick-delta is a multiplier of t.
  setxy (xcor + sin heading * speed * tick-delta)
        (ycor + cos heading * speed * tick-delta - gravity-acceleration * (0.5 * tick-delta * tick-delta))
  factor-gravity
end


to factor-gravity  ;; turtle procedure
  let vx (sin heading * speed)
  let vy (cos heading * speed) - (gravity-acceleration * tick-delta)
  set speed sqrt ((vy ^ 2) + (vx ^ 2))
  recolor
  set heading atan vx vy
end


to check-for-collision  ;; particle procedure
  ;; Here we impose a rule that collisions only take place when there
  ;; are exactly two particles per patch.  We do this because when the
  ;; student introduces new particles from the side, we want them to
  ;; form a uniform wavefront.
  ;;
  ;; Why do we want a uniform wavefront?  Because it is actually more
  ;; realistic.  (And also because the curriculum uses the uniform
  ;; wavefront to help teach the relationship between particle collisions,
  ;; wall hits, and pressure.)
  ;;
  ;; Why is it realistic to assume a uniform wavefront?  Because in reality,
  ;; whether a collision takes place would depend on the actual headings
  ;; of the particles, not merely on their proximity.  Since the particles
  ;; in the wavefront have identical speeds and near-identical headings,
  ;; in reality they would not collide.  So even though the two-particles
  ;; rule is not itself realistic, it produces a realistic result.  Also,
  ;; unless the number of particles is extremely large, it is very rare
  ;; for three or more particles to land on the same patch (for example,
  ;; with 400 particles it happens less than 1% of the time).  So imposing
  ;; this additional rule should have only a negligible effect on the
  ;; aggregate behavior of the system.
  ;;
  ;; Why does this rule produce a uniform wavefront?  The particles all
  ;; start out on the same patch, which means that without the only-two
  ;; rule, they would all start colliding with each other immediately,
  ;; resulting in much random variation of speeds and headings.  With
  ;; the only-two rule, they are prevented from colliding with each other
  ;; until they have spread out a lot.  (And in fact, if you observe
  ;; the wavefront closely, you will see that it is not completely smooth,
  ;; because some collisions eventually do start occurring when it thins out while fanning.)

  if count other particles-here = 1
  [
    ;; the following conditions are imposed on collision candidates:
    ;;   1. they must have a lower who number than my own, because collision
    ;;      code is asymmetrical: it must always happen from the point of view
    ;;      of just one particle.
    ;;   2. they must not be the same particle that we last collided with on
    ;;      this patch, so that we have a chance to leave the patch after we've
    ;;      collided with someone.
    let candidate one-of other particles-here with
      [who < [who] of myself and myself != last-collision]
    ;; we also only collide if one of us has non-zero speed. It's useless
    ;; (and incorrect, actually) for two particles with zero speed to collide.
    if (candidate != nobody) and (speed > 0 or [speed] of candidate > 0)
    [
      collide-with candidate
      set last-collision candidate
      ask candidate [ set last-collision myself ]
    ]
  ]
end

;; implements a collision with another particle.
;;
;; THIS IS THE HEART OF THE PARTICLE SIMULATION, AND YOU ARE STRONGLY ADVISED
;; NOT TO CHANGE IT UNLESS YOU REALLY UNDERSTAND WHAT YOU'RE DOING!
;;
;; The two particles colliding are self and other-particle, and while the
;; collision is performed from the point of view of self, both particles are
;; modified to reflect its effects. This is somewhat complicated, so I'll
;; give a general outline here:
;;   1. Do initial setup, and determine the heading between particle centers
;;      (call it theta).
;;   2. Convert the representation of the velocity of each particle from
;;      speed/heading to a theta-based vector whose first component is the
;;      particle's speed along theta, and whose second component is the speed
;;      perpendicular to theta.
;;   3. Modify the velocity vectors to reflect the effects of the collision.
;;      This involves:
;;        a. computing the velocity of the center of mass of the whole system
;;           along direction theta
;;        b. updating the along-theta components of the two velocity vectors.
;;   4. Convert from the theta-based vector representation of velocity back to
;;      the usual speed/heading representation for each particle.
;;   5. Perform final cleanup and update derived quantities.
to collide-with [ other-particle ] ;; particle procedure
  ;;; PHASE 1: initial setup

  ;; for convenience, grab some quantities from other-particle
  let mass2 [mass] of other-particle
  let speed2 [speed] of other-particle
  let heading2 [heading] of other-particle

  ;; since particles are modeled as zero-size points, theta isn't meaningfully
  ;; defined. we can assign it randomly without affecting the model's outcome.
  let theta (random-float 360)



  ;;; PHASE 2: convert velocities to theta-based vector representation

  ;; now convert my velocity from speed/heading representation to components
  ;; along theta and perpendicular to theta
  let v1t (speed * cos (theta - heading))
  let v1l (speed * sin (theta - heading))

  ;; do the same for other-particle
  let v2t (speed2 * cos (theta - heading2))
  let v2l (speed2 * sin (theta - heading2))



  ;;; PHASE 3: manipulate vectors to implement collision

  ;; compute the velocity of the system's center of mass along theta
  let vcm (((mass * v1t) + (mass2 * v2t)) / (mass + mass2) )

  ;; now compute the new velocity for each particle along direction theta.
  ;; velocity perpendicular to theta is unaffected by a collision along theta,
  ;; so the next two lines actually implement the collision itself, in the
  ;; sense that the effects of the collision are exactly the following changes
  ;; in particle velocity.
  set v1t (2 * vcm - v1t)
  set v2t (2 * vcm - v2t)



  ;;; PHASE 4: convert back to normal speed/heading

  ;; now convert my velocity vector into my new speed and heading
  set speed sqrt ((v1t ^ 2) + (v1l ^ 2))
  set energy (0.5 * mass * speed * speed)
  ;; if the magnitude of the velocity vector is 0, atan is undefined. but
  ;; speed will be 0, so heading is irrelevant anyway. therefore, in that
  ;; case we'll just leave it unmodified.
  if v1l != 0 or v1t != 0
    [ set heading (theta - (atan v1l v1t)) ]

  ;; and do the same for other-particle
  ask other-particle [
    set speed sqrt ((v2t ^ 2) + (v2l ^ 2))
    set energy (0.5 * mass * (speed ^ 2))
    if v2l != 0 or v2t != 0
      [ set heading (theta - (atan v2l v2t)) ]
  ]


  ;; PHASE 5: final updates

  ;; now recolor, since color is based on quantities that may have changed
  recolor
  ask other-particle
    [ recolor ]
end

to recolor  ;; particle procedure
  ifelse speed < (0.5 * init-particle-speed)
  [
    set color blue
  ]
  [
    ifelse speed > (1.5 * init-particle-speed)
      [ set color red ]
      [ set color green ]
  ]
end

;;;
;;; drawing procedures
;;;

;; draws the box
to make-box
  ask patches with [ count neighbors != 8 ]
    [ set pcolor yellow ]
end

;; creates initial particles
to make-particles
  create-particles number-of-particles
  [
    setup-particle
    random-position
    recolor
  ]
  calculate-tick-delta
end


to setup-particle  ;; particle procedure
  set speed init-particle-speed
  set mass particle-mass
  set energy (0.5 * mass * speed * speed)
  set last-collision nobody
end

;; place particle at random location inside the box.
to random-position ;; particle procedure
  setxy random-xcor random-float (world-height - 3) + 1
  set heading random-float 360
end

;;; plotting procedures

to setup-plots
  set-current-plot ""Speed Counts""
  set-plot-y-range 0 100

  set-current-plot ""Temperature vs. Height""
  set-plot-x-range 0 (max-pycor * 2)

  set-current-plot ""Aggregate Temperature""
  set-plot-x-range 0 (max-pycor * 2)
  set aggregate-list n-values (max-pycor / 2) [0]
end

to setup-histograms
  set-current-plot ""Speed Histogram""
  set-plot-x-range 0 (init-particle-speed * 3)
  set-plot-y-range 0 ceiling (number-of-particles / 10)
  set-current-plot-pen ""medium""
  set-histogram-num-bars 45
  set-current-plot-pen ""slow""
  set-histogram-num-bars 45
  set-current-plot-pen ""fast""
  set-histogram-num-bars 45
  set-current-plot-pen ""init-avg-speed""
  draw-vert-line init-avg-speed

  set-current-plot ""Energy Histogram""
  set-plot-x-range 0 (0.5 * (init-particle-speed * 3) * (init-particle-speed * 3) * particle-mass)
  set-plot-y-range 0 ceiling (number-of-particles / 10)
  set-current-plot-pen ""medium""
  set-histogram-num-bars 45
  set-current-plot-pen ""slow""
  set-histogram-num-bars 45
  set-current-plot-pen ""fast""
  set-histogram-num-bars 45
  set-current-plot-pen ""init-avg-energy""
  draw-vert-line init-avg-energy

  set-current-plot ""Density Histogram""
  set-plot-x-range 0 (max-pycor * 2)
  set-plot-y-range 0 (max-pxcor * 2)
  set-histogram-num-bars round (max-pxcor / 2)
end

to do-plotting
  set-current-plot ""Speed Counts""
  set-current-plot-pen ""fast""
  plotxy ticks percent-fast
  set-current-plot-pen ""medium""
  plotxy ticks percent-medium
  set-current-plot-pen ""slow""
  plotxy ticks percent-slow
  set-current-plot ""Temperature vs. Height""
  plot-pen-reset
  draw-energy-graph

  set-current-plot ""Aggregate Temperature""
  plot-pen-reset
  draw-aggregate-graph aggregate-list

  plot-histograms
end


to plot-histograms
  set-current-plot ""Energy histogram""
  set-current-plot-pen ""fast""
  histogram [ energy ] of particles with [color = red]
  set-current-plot-pen ""medium""
  histogram [ energy ] of particles with [color = green]
  set-current-plot-pen ""slow""
  histogram [ energy ] of particles with [color = blue]
  set-current-plot-pen ""avg-energy""
  plot-pen-reset
  draw-vert-line avg-energy


  set-current-plot ""Speed histogram""
  set-current-plot-pen ""fast""
  histogram [ speed ] of particles with [color = red]
  set-current-plot-pen ""medium""
  histogram [ speed ] of particles with [color = green]
  set-current-plot-pen ""slow""
  histogram [ speed ] of particles with [color = blue]
  set-current-plot-pen ""avg-speed""
  plot-pen-reset
  draw-vert-line avg-speed

  set-current-plot ""Density Histogram""
  histogram [ycor + max-pycor] of particles
end


to draw-energy-graph
  let n min-pycor
  repeat (max-pycor / 2)
  [ let x particles with [ (pycor >= n) and (pycor < (n + 4)) ]
    ifelse count x = 0
     [ plot 0 ]
     [ let temperature mean [ energy ] of x
       plot temperature
       let list-pos (n + max-pycor) / 4
       set aggregate-list (replace-item list-pos aggregate-list ((item list-pos aggregate-list) + temperature))
     ]
    set n n + 4
  ]
end

to draw-aggregate-graph [lst]
  foreach lst
    [ plot ? ]
end


;; histogram procedure
to draw-vert-line [ xval ]
  plotxy xval plot-y-min
  plot-pen-down
  plotxy xval plot-y-max
  plot-pen-up
end

to-report last-n [n the-list]
  ifelse n >= length the-list
    [ report the-list ]
    [ report last-n n butfirst the-list ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2002 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2002).  NetLogo GasLab Gravity Box model.
; http://ccl.northwestern.edu/netlogo/models/GasLabGravityBox.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2002 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/GasLabGravityBox
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------

This model is one in a series of GasLab models. They use the same basic rules for simulating the behavior of gases.  Each model integrates different features in order to highlight different aspects of gas behavior.

The basic principle of the models is that gas particles are assumed to have two elementary actions: they move and they collide - either with other particles or with any other objects such as walls.

This model simulates the effect of gravity on gas particles.  It is very similar to GasLab Atmosphere, but with a ""ceiling"" over the gas, so particles can never escape.

This model is part of the Connected Mathematics ""Making Sense of Complex Phenomena"" Modeling Project.

HOW IT WORKS
------------
The particles are modeled as hard balls with no internal energy except that which is due to their motion.  Collisions between particles are elastic.  Particles are colored according to speed -- blue for slow, green for medium, and red for high speeds.

Coloring of the particles is with respect to one speed (10).
Particles with a speed less than 5 are blue, ones that are more than
15 are red, while all in those in-between are green.

The exact way two particles collide is as follows:
1. A particle moves in a straight line without changing its speed, unless it collides with another particle or bounces off the wall.
2. Two particles ""collide"" if they find themselves on the same patch.
3. A random axis is chosen, as if they are two balls that hit each other and this axis is the line connecting their centers.
4. They exchange momentum and energy along that axis, according to the conservation of momentum and energy.  This calculation is done in the center of mass system.
5. Each particle is assigned its new velocity, energy, and heading.
6. If a particle finds itself on or very close to a wall of the container, it ""bounces"" -- that is, reflects its direction and keeps its same speed.


In this model the particles behave exactly as in the basic Gas in a Box model except for now gravity acts on the particles.  Every particle is given additional velocity downward during each tick, as it would get in a gravitational field.  The particles bounce off the ""ground"" as well as the ceiling.


HOW TO USE IT
-------------
Initial settings:
- GRAVITY: strength of the gravitational acceleration
- NUMBER-OF-PARTICLES: number of gas particles
- INIT-PARTICLE-SPEED: initial speed of each particle
- PARTICLE-MASS: mass of each particle

Other settings:
- TRACE?: Traces the path of one of the particles.
- COLLIDE?: Turns collisions between particles on and off.

The SETUP button will set the initial conditions.
The GO button will run the simulation.


Monitors:
- FAST, MEDIUM, SLOW: numbers of particles with different speeds: fast (red), medium (green), and slow (blue).
- AVERAGE SPEED: average speed of the particles.
- AVERAGE ENERGY: average energy of the particles.

Plots:
- SPEED COUNTS: plots the number of particles in each range of speed.
- SPEED HISTOGRAM: speed distribution of all the particles.  The gray line is the average value, and the black line is the initial average.
- ENERGY HISTOGRAM: distribution of energies of all the particles, calculated as m*(v^2)/2.
- HEIGHT VS. TEMPERATURE: shows the temperature of the particles at each 'layer' of the box.
- DENSITY HISTOGRAM: shows the number of particles at each 'layer' of the box, i.e. its local density.
- AGGREGATE TEMPERATURE: shows the aggregate sum of the HEIGHT VS. TEMPERATURE plot for the entire model run.


THINGS TO NOTICE
----------------
Try to predict what the view will look like after a while, and why.

Watch the gray path of one particle. What can you say about its motion?

Watch the change in density distribution as the model runs.

As the model runs, what happens to the average speed and kinetic energy of the particles?  If they gain energy, where does it come from?   What happens to the speed and energy distributions?

What is the shape of the path of individual particles?

What happens to the aggregate temperature plot over time? Is the temperature uniform over the box?


THINGS TO TRY
-------------
What happens when gravity is increased or decreased?

Change the initial number, speed and mass.  What happens to the density distribution?

Does this model come to some sort of equilibrium?  How can you tell when it has been reached?

Try and find out if the distribution of the particles in this model is the same as what is predicted by conventional physical laws.

Try making gravity negative.

Varying model parameters such as NUMBER and GRAVITY, what do you observe about the aggregate temperature graph?  Can you explain these results?  How would you square these results with a) the fact that ""hot air rises"" in a room and b) that it is colder as you go higher in elevation?


EXTENDING THE MODEL
-------------------
Try this model with particles of different masses.  You could color each mass differently to be able to see where they go.  Are their distributions different?  Do the different masses tend to have different average heights?  What does this suggest about the composition of an atmosphere?


This basic model could be used to explore other situations where freely moving particles have forces on them -- e.g. a centrifuge or charged particles (ions) in an electrical field.


NETLOGO FEATURES
----------------
Because of the influence of gravity, the particles follow curved paths.  Since NetLogo models time in discrete steps, these curved paths must be approximated with a series of short straight lines.  This is the source of a slight inaccuracy where the particles gradually lose energy if the model runs for a long time.  (The effect is as though the collisions with the ground were slightly inelastic.)  The inaccuracy can be reduced by increasing vsplit, but the model will run slower.


RELATED MODELS
---------------
This model is part of the GasLab suite and curriculum.  See, in particular, Gas in a Box and GasLab Atmosphere.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (2002).  NetLogo GasLab Gravity Box model.  http://ccl.northwestern.edu/netlogo/models/GasLabGravityBox.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2002 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/GasLabGravityBox for terms of use.
"
GasLab Maxwells Demon,/models/Sample Models/Chemistry & Physics/GasLab,"globals
[
  tick-delta                                 ;; how much we advance the tick counter this time through
  max-tick-delta                             ;; the largest tick-delta is allowed to be
  box-edge                   ;; distance of box edge from axes
  left-particles right-particles   ;; particles in the left and right chambers
  avg-speed-left avg-energy-left   ;; left chamber averages
  avg-speed-right avg-energy-right ;; right chamber averages
  avg-speed                        ;; average speed of all particles
  fast medium slow                 ;; current counts
]

breed [ particles particle ]
breed [ flashes flash ]

flashes-own [birthday]

particles-own
[
  speed mass energy          ;; particle info
  last-collision
  changed-size-ticks
]


to setup
  ca
  set-default-shape particles ""circle""
  set-default-shape flashes ""plane""
  set max-tick-delta 0.1073
  ;; box has constant size...
  set box-edge (max-pxcor - 1)
  make-box
  make-particles
  update-variables
  setup-plots
  do-plotting
end

to update-variables
  set left-particles particles with [xcor <= 0]
  set right-particles particles with [xcor > 0]
  if (not any? left-particles) or (not any? right-particles) [ stop ]
  set avg-speed-left     sum [speed] of left-particles   / count left-particles
  set avg-speed-right    sum [speed] of right-particles  / count right-particles
  set avg-energy-left    sum [energy] of left-particles  / count left-particles
  set avg-energy-right   sum [energy] of right-particles / count right-particles

  set avg-speed mean [speed] of particles

  set medium count particles with [color = green]
  set slow   count particles with [color = blue]
  set fast   count particles with [color = red]
end

to go
  ask particles [ bounce ]
  ask particles [ move ]
  if demon?
    [ ask particles [ maxwells-demon
                      ifelse (changed-size-ticks > 0)
                      [ set changed-size-ticks changed-size-ticks - 1 ]
                      [ set size 1 set label """" ]
                    ]
    ]
  ask particles
  [ if collide? [check-for-collision] ]
  tick-advance tick-delta
  if floor ticks > floor (ticks - tick-delta)
  [
    update-variables
    do-plotting
  ]
  calculate-tick-delta

  ask flashes with [ticks - birthday > 0.4]
    [ die ]
  display
end

to calculate-tick-delta
  ;; tick-delta is calculated in such way that even the fastest
  ;; particle will jump at most 1 patch length in a ticks tick. As
  ;; particles jump (speed * tick-delta) at every ticks tick, making
  ;; tick length the inverse of the speed of the fastest particle
  ;; (1/max speed) assures that. Having each particle advance at most
  ;; one patch-length is necessary for it not to ""jump over"" a wall
  ;; or another particle.
  ifelse any? particles with [speed > 0]
    [ set tick-delta min list (1 / (ceiling max [speed] of particles)) max-tick-delta ]
    [ set tick-delta max-tick-delta ]
end

to bounce  ;; particle procedure
  ;; get the coordinates of the patch we'll be on if we go forward 1
  let new-patch patch-ahead 1
  let new-px [pxcor] of new-patch
  let new-py [pycor] of new-patch
  ;; if we're not about to hit a wall, we don't need to do any further checks
  if ( [pcolor] of new-patch != yellow )
    [stop]
  ;; if hitting left or right wall, reflect heading around x axis
  if (abs new-px = box-edge or new-px = 0)
    [ set heading (- heading)]
  ;; if hitting top or bottom wall, reflect heading around y axis
  if (abs new-py = box-edge)
    [ set heading (180 - heading) ]

  ask patch new-px new-py
  [ sprout-flashes 1 [
      set color pcolor - 2
      set birthday ticks
      set heading 0
    ]
  ]
end

to move  ;; particle procedure
  if patch-ahead (speed * tick-delta) != patch-here
    [ set last-collision nobody ]
  jump (speed * tick-delta)
end

;;this is the piece that's different from other GasLab models.  It
;;creates a ""valve"" that moves molecules from one chamber to the other,
;; depending on their speed.  It also makes the particles larger for a time determined by the ""time-
;; display-particles"" slider
to maxwells-demon ;;particle procedure
  if ((pcolor = turquoise) and ((speed / threshold) > avg-speed))
   [
     set size 3
     set label round speed
     set label-color yellow
     set xcor 2
     set changed-size-ticks time-display-particles

   ]
  if ((pcolor = violet) and ((speed * threshold) < avg-speed))
   [

     set size 3
     set label round speed
     set label-color yellow
     set xcor -2
     set changed-size-ticks time-display-particles
    ]
end

to check-for-collision  ;; particle procedure
  ;; Here we impose a rule that collisions only take place when there
  ;; are exactly two particles per patch.

  if count other particles-here = 1
  [
    ;; the following conditions are imposed on collision candidates:
    ;;   1. they must have a lower who number than my own, because collision
    ;;      code is asymmetrical: it must always happen from the point of view
    ;;      of just one particle.
    ;;   2. they must not be the same particle that we last collided with on
    ;;      this patch, so that we have a chance to leave the patch after we've
    ;;      collided with someone.
    let candidate one-of other particles-here with
      [who < [who] of myself and myself != last-collision]
    ;; we also only collide if one of us has non-zero speed. It's useless
    ;; (and incorrect, actually) for two particles with zero speed to collide.
    if (candidate != nobody) and (speed > 0 or [speed] of candidate > 0)
    [
      collide-with candidate
      set last-collision candidate
      ask candidate [ set last-collision myself ]
    ]
  ]
end

;; implements a collision with another particle.
;;
;; THIS IS THE HEART OF THE PARTICLE SIMULATION, AND YOU ARE STRONGLY ADVISED
;; NOT TO CHANGE IT UNLESS YOU REALLY UNDERSTAND WHAT YOU'RE DOING!
;;
;; The two particles colliding are self and other-particle, and while the
;; collision is performed from the point of view of self, both particles are
;; modified to reflect its effects. This is somewhat complicated, so I'll
;; give a general outline here:
;;   1. Do initial setup, and determine the heading between particle centers
;;      (call it theta).
;;   2. Convert the representation of the velocity of each particle from
;;      speed/heading to a theta-based vector whose first component is the
;;      particle's speed along theta, and whose second component is the speed
;;      perpendicular to theta.
;;   3. Modify the velocity vectors to reflect the effects of the collision.
;;      This involves:
;;        a. computing the velocity of the center of mass of the whole system
;;           along direction theta
;;        b. updating the along-theta components of the two velocity vectors.
;;   4. Convert from the theta-based vector representation of velocity back to
;;      the usual speed/heading representation for each particle.
;;   5. Perform final cleanup and update derived quantities.
to collide-with [ other-particle ] ;; particle procedure
  ;;; PHASE 1: initial setup

  ;; for convenience, grab some quantities from other-particle
  let mass2 [mass] of other-particle
  let speed2 [speed] of other-particle
  let heading2 [heading] of other-particle

  ;; since particles are modeled as zero-size points, theta isn't meaningfully
  ;; defined. we can assign it randomly without affecting the model's outcome.
  let theta (random-float 360)



  ;;; PHASE 2: convert velocities to theta-based vector representation

  ;; now convert my velocity from speed/heading representation to components
  ;; along theta and perpendicular to theta
  let v1t (speed * cos (theta - heading))
  let v1l (speed * sin (theta - heading))

  ;; do the same for other-particle
  let v2t (speed2 * cos (theta - heading2))
  let v2l (speed2 * sin (theta - heading2))



  ;;; PHASE 3: manipulate vectors to implement collision

  ;; compute the velocity of the system's center of mass along theta
  let vcm (((mass * v1t) + (mass2 * v2t)) / (mass + mass2) )

  ;; now compute the new velocity for each particle along direction theta.
  ;; velocity perpendicular to theta is unaffected by a collision along theta,
  ;; so the next two lines actually implement the collision itself, in the
  ;; sense that the effects of the collision are exactly the following changes
  ;; in particle velocity.
  set v1t (2 * vcm - v1t)
  set v2t (2 * vcm - v2t)



  ;;; PHASE 4: convert back to normal speed/heading

  ;; now convert my velocity vector into my new speed and heading
  set speed sqrt ((v1t * v1t) + (v1l * v1l))
  set energy (0.5 * mass * speed * speed)
  ;; if the magnitude of the velocity vector is 0, atan is undefined. but
  ;; speed will be 0, so heading is irrelevant anyway. therefore, in that
  ;; case we'll just leave it unmodified.
  if v1l != 0 or v1t != 0
    [ set heading (theta - (atan v1l v1t)) ]

  ;; and do the same for other-particle
  ask other-particle [
    set speed sqrt ((v2t ^ 2) + (v2l ^ 2))
    set energy (0.5 * mass * (speed ^ 2))
    if v2l != 0 or v2t != 0
      [ set heading (theta - (atan v2l v2t)) ]
  ]


  ;; PHASE 5: final updates

  ;; now recolor, since color is based on quantities that may have changed
  recolor
  ask other-particle
    [ recolor ]
end

to recolor  ;; particle procedure
  ifelse speed < (0.5 * 10)
  [
    set color blue
  ]
  [
    ifelse speed > (1.5 * 10)
      [ set color red ]
      [ set color green ]
  ]
end

;;;
;;; drawing procedures
;;;

;; draws the box
to make-box
  ask patches with [ ((abs pxcor = box-edge) and (abs pycor <= box-edge)) or
                     ((abs pycor = box-edge) and (abs pxcor <= box-edge)) or
                     ((abs pycor <= box-edge) and (pxcor = 0))]
    [ set pcolor yellow ]
  ;; Maxwell's Demon
  ask patches with [((pycor > -5) and (pycor < 5) and (pxcor = 1))]
    [ set pcolor violet ]
  ask patches with [((pycor > -5) and (pycor < 5) and (pxcor = -1))]
    [ set pcolor turquoise ]
end

;; creates initial particles
to make-particles
  create-particles number-of-particles
  [
    setup-particle
    random-position
    recolor
  ]
  calculate-tick-delta
end


to setup-particle  ;; particle procedure
  set speed init-particle-speed
  set mass particle-mass
  set energy (0.5 * mass * speed * speed)
  set last-collision nobody
  set changed-size-ticks 0
end

;; place particle at random location inside the box.
to random-position ;; particle procedure
  setxy ((1 - box-edge) + random-float ((2 * box-edge) - 2))
        ((1 - box-edge) + random-float ((2 * box-edge) - 2))
  if round pxcor = 0
    [random-position]
end

;; create the ticks representation


;;; plotting procedures

to setup-plots
  set-current-plot ""Average Speeds""
  set-plot-y-range 0 (1.5 * init-particle-speed)
  set-current-plot ""Average Energies""
  set-plot-y-range 0 (1.5 * init-particle-speed * init-particle-speed * particle-mass)
  set-current-plot ""Particles Count""
  set-plot-y-range (number-of-particles / 2 - 100) (number-of-particles / 2 + 100)
end


to do-plotting
  set-current-plot ""Average Speeds""
  set-current-plot-pen ""left""
  plotxy ticks avg-speed-left
  set-current-plot-pen ""right""
  plotxy ticks avg-speed-right

  set-current-plot ""Average Energies""
  set-current-plot-pen ""left""
  plotxy ticks avg-energy-left
  set-current-plot-pen ""right""
  plotxy ticks avg-energy-right

  set-current-plot ""Particles Count""
  set-current-plot-pen ""left""
  plotxy ticks (count left-particles)
  set-current-plot-pen ""right""
  plotxy ticks (count right-particles)
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1997 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2002.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1997).  NetLogo GasLab Maxwells Demon model.
; http://ccl.northwestern.edu/netlogo/models/GasLabMaxwellsDemon.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1997 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/GasLabMaxwellsDemon
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model is one in a series of GasLab models. They use the same basic rules for simulating the behavior of gases.  Each model integrates different features in order to highlight different aspects of gas behavior.

The basic principle of the models is that gas particles are assumed to have two elementary actions: they move and they collide - either with other particles or with any other objects such as walls.

This model illustrates a famous thought experiment, which raised important issues about the nature of entropy.  In 1871, James Clerk Maxwell imagined a situation where a very small and nimble being could, by opening and closing a valve between two gas-filled chambers, allow only faster particles to go through one way and only slower particles to go through the other.  By doing this, the being (later called a demon) could raise the temperature of one chamber (faster particles) and lower the temperature of the other (slower particles), without the expenditure of work.  This was a violation of the Second Law of Thermodynamics, and he asserted that this could not actually occur.  The implications of this puzzle have continued to be central to thermodynamics, entropy, and information theory up to the present time.


HOW IT WORKS
------------
The particles are modeled as hard balls with no internal energy except that which is due to their motion.  Collisions between particles are elastic.  Particles are colored according to speed -- blue for slow, green for medium, and red for high speeds.

Coloring of the particles is with respect to one speed (10).  Particles with a speed less than 5 are blue, ones that are more than 15 are red, while all in those in-between are green.

Particles behave according to the following rules:
1. A particle moves in a straight line without changing its speed, unless it collides with another particle or bounces off the wall.
2. Two particles ""collide"" if they find themselves on the same patch (NetLogo's View is composed of a grid of small squares called patches).
3. A random axis is chosen, as if they are two balls that hit each other and this axis is the line connecting their centers.
4. They exchange momentum and energy along that axis, according to the conservation of momentum and energy.  This calculation is done in the center of mass system.
5. Each turtle is assigned its new velocity, energy, and heading.
6. If a turtle finds itself on or very close to a wall of the container, it ""bounces"" -- that is, reflects its direction and keeps its same speed.

The setup is the same as that for the ""Two-Gas"" model.  What is added is a ""valve"".  It transports fast particles from the left to the right chamber when they arrive at the turquoise strip, and slow particles from the right to the left chamber when they arrive at the violet strip.  When a particle passes through, it becomes larger for a short time and displays its speed.


HOW TO USE IT
-------------
Settings:
NUMBER-OF-PARTICLES: total number of particles in the two chambers
INIT-PARTICLE-SPEED: initial speed of all the particles
PARTICLE-MASS: particles' mass

Other settings:
COLLIDE? If this is On, the particles collide.  If it is Off, they do not collide.
THRESHOLD: The threshold is how much faster or slower than the average speed a particle must be going to be transferred to the other chamber by the ""valve"".
DEMON?: If this is On, the valve is operating.  If it is Off, the valve does nothing.
TIME-DISPLAY-PARTICLES: determines for how long the particles are visually enlarged and their speeds are labeled, before the go back to their original size.

Initialize the model by pressing SETUP, and press GO to run it.

Monitors:
AVERAGE SPEED:  average speed of all the particles.
AVERAGE SPEED LEFT: average particle speed in the left chamber.
AVERAGE SPEED RIGHT: average particle speed in the right chamber.

Plots:
PARTICLES COUNT: the number of particles in the left (turquoise) and right (violet) chambers.
AVERAGE ENERGIES: the average energy of the particles in the left and right chambers.  This is calculated as the average of 1/2 mv^2 for the particles.
AVERAGE SPEEDS:  the average speeds of the particles in both the left and the right chambers.


THINGS TO NOTICE
----------------
Watch the ""valve"" carefully. Can you see fast (red) particles jump right and slow (blue) particles jump left when they run into the valve?  They are enlarged and their speeds are labeled for a short time.

What happens to the average energies and speeds in the left and right chambers?  Do the values settle down after a long time?

Notice the particles count in the two chambers.  While the model starts out with more particles going into the right chamber than the left, this changes after a while.  Why does that happen?  Given the Maxwell-Boltzmann distribution, which chamber should have more particles?


THINGS TO TRY
-------------
Change the valve threshold.  Does it change the rate of evolution of the model?  Does it change its eventual result?


EXTENDING THE MODEL
-------------------
What happens if there are particles of different masses?  (See Two Gas model.)

How would you calculate the pressure in each box?  (See Piston models.)  Do they remain equal?

If such a valve were possible, could ""free energy"" be gotten from the two chambers at different temperatures?

Another way of increasing order and later extracting energy might be to allow the valve to let through particles in only one direction, so that eventually one chamber is filled with gas, while the other one ends up empty.  Can you create such a system?



RELATED MODELS
---------------
Look at the other GasLab models.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1997).  NetLogo GasLab Maxwells Demon model.  http://ccl.northwestern.edu/netlogo/models/GasLabMaxwellsDemon.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1997 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/GasLabMaxwellsDemon for terms of use.
"
GasLab Gas in a Box,/models/Sample Models/Chemistry & Physics/GasLab,"globals
[
  tick-delta                                 ;; how much we advance the tick counter this time through
  max-tick-delta                             ;; the largest tick-delta is allowed to be
  box-edge                                   ;; distance of box edge from axes
  init-avg-speed init-avg-energy             ;; initial averages
  avg-speed avg-energy                       ;; current averages
  fast medium slow                           ;; current counts
  percent-slow percent-medium percent-fast   ;; percentage of current counts
]

breed [ particles particle ]
breed [ flashes flash ]
flashes-own [birthday]

particles-own
[
  speed mass energy          ;; particle info
  last-collision
]


to setup
  ca
  set-default-shape particles ""circle""
  set-default-shape flashes ""plane""
  set max-tick-delta 0.1073
  ;; the box size is determined by the slider
  set box-edge (round (max-pxcor * box-size / 100))
  make-box
  make-particles
  update-variables
  set init-avg-speed avg-speed
  set init-avg-energy avg-energy
  setup-plots
  setup-histograms
  do-plotting
end

to update-variables
  set medium count particles with [color = green]
  set slow   count particles with [color = blue]
  set fast   count particles with [color = red]
  set percent-medium (medium / ( count particles )) * 100
  set percent-slow (slow / (count particles)) * 100
  set percent-fast (fast / (count particles)) * 100
  set avg-speed  mean [speed] of particles
  set avg-energy mean [energy] of particles
end

to go
  ask particles [ bounce ]
  ask particles [ move ]
  ask particles
  [ if collide? [check-for-collision] ]
  ifelse (trace?)
    [ ask particle 0 [ pen-down ] ]
    [ ask particle 0 [ pen-up ] ]
  tick-advance tick-delta
  if floor ticks > floor (ticks - tick-delta)
  [
    update-variables
    do-plotting
  ]
  calculate-tick-delta

  ask flashes with [ticks - birthday > 0.4]
    [ die ]
  display
end

to calculate-tick-delta
  ;; tick-delta is calculated in such way that even the fastest
  ;; particle will jump at most 1 patch length when we advance the
  ;; tick counter. As particles jump (speed * tick-delta) each time, making
  ;; tick-delta the inverse of the speed of the fastest particle
  ;; (1/max speed) assures that. Having each particle advance at most
  ;; one patch-length is necessary for it not to ""jump over"" a wall
  ;; or another particle.
  ifelse any? particles with [speed > 0]
    [ set tick-delta min list (1 / (ceiling max [speed] of particles)) max-tick-delta ]
    [ set tick-delta max-tick-delta ]
end

to bounce  ;; particle procedure
  ;; get the coordinates of the patch we'll be on if we go forward 1
  let new-patch patch-ahead 1
  let new-px [pxcor] of new-patch
  let new-py [pycor] of new-patch
  ;; if we're not about to hit a wall, we don't need to do any further checks
  if not shade-of? yellow [pcolor] of new-patch
    [ stop ]
  ;; if hitting left or right wall, reflect heading around x axis
  if (abs new-px = box-edge)
    [ set heading (- heading) ]
  ;; if hitting top or bottom wall, reflect heading around y axis
  if (abs new-py = box-edge)
    [ set heading (180 - heading)]

  ask patch new-px new-py
  [ sprout-flashes 1 [
      set color pcolor - 2
      set birthday ticks
      set heading 0
    ]
  ]
end

to move  ;; particle procedure
  if patch-ahead (speed * tick-delta) != patch-here
    [ set last-collision nobody ]
  jump (speed * tick-delta)
end

to check-for-collision  ;; particle procedure
  ;; Here we impose a rule that collisions only take place when there
  ;; are exactly two particles per patch.  We do this because when the
  ;; student introduces new particles from the side, we want them to
  ;; form a uniform wavefront.
  ;;
  ;; Why do we want a uniform wavefront?  Because it is actually more
  ;; realistic.  (And also because the curriculum uses the uniform
  ;; wavefront to help teach the relationship between particle collisions,
  ;; wall hits, and pressure.)
  ;;
  ;; Why is it realistic to assume a uniform wavefront?  Because in reality,
  ;; whether a collision takes place would depend on the actual headings
  ;; of the particles, not merely on their proximity.  Since the particles
  ;; in the wavefront have identical speeds and near-identical headings,
  ;; in reality they would not collide.  So even though the two-particles
  ;; rule is not itself realistic, it produces a realistic result.  Also,
  ;; unless the number of particles is extremely large, it is very rare
  ;; for three or more particles to land on the same patch (for example,
  ;; with 400 particles it happens less than 1% of the time).  So imposing
  ;; this additional rule should have only a negligible effect on the
  ;; aggregate behavior of the system.
  ;;
  ;; Why does this rule produce a uniform wavefront?  The particles all
  ;; start out on the same patch, which means that without the only-two
  ;; rule, they would all start colliding with each other immediately,
  ;; resulting in much random variation of speeds and headings.  With
  ;; the only-two rule, they are prevented from colliding with each other
  ;; until they have spread out a lot.  (And in fact, if you observe
  ;; the wavefront closely, you will see that it is not completely smooth,
  ;; because some collisions eventually do start occurring when it thins out while fanning.)

  if count other particles-here = 1
  [
    ;; the following conditions are imposed on collision candidates:
    ;;   1. they must have a lower who number than my own, because collision
    ;;      code is asymmetrical: it must always happen from the point of view
    ;;      of just one particle.
    ;;   2. they must not be the same particle that we last collided with on
    ;;      this patch, so that we have a chance to leave the patch after we've
    ;;      collided with someone.
    let candidate one-of other particles-here with
      [who < [who] of myself and myself != last-collision]
    ;; we also only collide if one of us has non-zero speed. It's useless
    ;; (and incorrect, actually) for two particles with zero speed to collide.
    if (candidate != nobody) and (speed > 0 or [speed] of candidate > 0)
    [
      collide-with candidate
      set last-collision candidate
      ask candidate [ set last-collision myself ]
    ]
  ]
end

;; implements a collision with another particle.
;;
;; THIS IS THE HEART OF THE PARTICLE SIMULATION, AND YOU ARE STRONGLY ADVISED
;; NOT TO CHANGE IT UNLESS YOU REALLY UNDERSTAND WHAT YOU'RE DOING!
;;
;; The two particles colliding are self and other-particle, and while the
;; collision is performed from the point of view of self, both particles are
;; modified to reflect its effects. This is somewhat complicated, so I'll
;; give a general outline here:
;;   1. Do initial setup, and determine the heading between particle centers
;;      (call it theta).
;;   2. Convert the representation of the velocity of each particle from
;;      speed/heading to a theta-based vector whose first component is the
;;      particle's speed along theta, and whose second component is the speed
;;      perpendicular to theta.
;;   3. Modify the velocity vectors to reflect the effects of the collision.
;;      This involves:
;;        a. computing the velocity of the center of mass of the whole system
;;           along direction theta
;;        b. updating the along-theta components of the two velocity vectors.
;;   4. Convert from the theta-based vector representation of velocity back to
;;      the usual speed/heading representation for each particle.
;;   5. Perform final cleanup and update derived quantities.
to collide-with [ other-particle ] ;; particle procedure
  ;;; PHASE 1: initial setup

  ;; for convenience, grab some quantities from other-particle
  let mass2 [mass] of other-particle
  let speed2 [speed] of other-particle
  let heading2 [heading] of other-particle

  ;; since particles are modeled as zero-size points, theta isn't meaningfully
  ;; defined. we can assign it randomly without affecting the model's outcome.
  let theta (random-float 360)



  ;;; PHASE 2: convert velocities to theta-based vector representation

  ;; now convert my velocity from speed/heading representation to components
  ;; along theta and perpendicular to theta
  let v1t (speed * cos (theta - heading))
  let v1l (speed * sin (theta - heading))

  ;; do the same for other-particle
  let v2t (speed2 * cos (theta - heading2))
  let v2l (speed2 * sin (theta - heading2))



  ;;; PHASE 3: manipulate vectors to implement collision

  ;; compute the velocity of the system's center of mass along theta
  let vcm (((mass * v1t) + (mass2 * v2t)) / (mass + mass2) )

  ;; now compute the new velocity for each particle along direction theta.
  ;; velocity perpendicular to theta is unaffected by a collision along theta,
  ;; so the next two lines actually implement the collision itself, in the
  ;; sense that the effects of the collision are exactly the following changes
  ;; in particle velocity.
  set v1t (2 * vcm - v1t)
  set v2t (2 * vcm - v2t)



  ;;; PHASE 4: convert back to normal speed/heading

  ;; now convert my velocity vector into my new speed and heading
  set speed sqrt ((v1t ^ 2) + (v1l ^ 2))
  set energy (0.5 * mass * speed ^ 2)
  ;; if the magnitude of the velocity vector is 0, atan is undefined. but
  ;; speed will be 0, so heading is irrelevant anyway. therefore, in that
  ;; case we'll just leave it unmodified.
  if v1l != 0 or v1t != 0
    [ set heading (theta - (atan v1l v1t)) ]

  ;; and do the same for other-particle
  ask other-particle [
    set speed sqrt ((v2t ^ 2) + (v2l ^ 2))
    set energy (0.5 * mass * (speed ^ 2))
    if v2l != 0 or v2t != 0
      [ set heading (theta - (atan v2l v2t)) ]
  ]


  ;; PHASE 5: final updates

  ;; now recolor, since color is based on quantities that may have changed
  recolor
  ask other-particle
    [ recolor ]
end

to recolor  ;; particle procedure
  ifelse speed < (0.5 * 10)
  [
    set color blue
  ]
  [
    ifelse speed > (1.5 * 10)
      [ set color red ]
      [ set color green ]
  ]
end


;;;
;;; drawing procedures
;;;

;; draws the box
to make-box
  ask patches with [ ((abs pxcor = box-edge) and (abs pycor <= box-edge)) or
                     ((abs pycor = box-edge) and (abs pxcor <= box-edge)) ]
    [ set pcolor yellow ]
end

;; creates initial particles
to make-particles
  create-particles number-of-particles
  [
    setup-particle
    random-position
    recolor
  ]
  calculate-tick-delta
end



to setup-particle  ;; particle procedure
  set speed init-particle-speed
  set mass particle-mass
  set energy (0.5 * mass * speed * speed)
  set last-collision nobody
end

;; place particle at random location inside the box.
to random-position ;; particle procedure
  setxy ((1 - box-edge) + random-float ((2 * box-edge) - 2))
        ((1 - box-edge) + random-float ((2 * box-edge) - 2))
end


;;; plotting procedures

to setup-plots
  set-current-plot ""Speed Counts""
  set-plot-y-range 0 100
end

to setup-histograms
  set-current-plot ""Speed Histogram""
  set-plot-x-range 0 (init-particle-speed * 2)
  set-plot-y-range 0 ceiling (number-of-particles / 6)
  set-current-plot-pen ""medium""
  set-histogram-num-bars 40
  set-current-plot-pen ""slow""
  set-histogram-num-bars 40
  set-current-plot-pen ""fast""
  set-histogram-num-bars 40
  set-current-plot-pen ""init-avg-speed""
  draw-vert-line init-avg-speed

  set-current-plot ""Energy Histogram""
  set-plot-x-range 0 (0.5 * (init-particle-speed * 2) * (init-particle-speed * 2) * particle-mass)
  set-plot-y-range 0 ceiling (number-of-particles / 6)
  set-current-plot-pen ""medium""
  set-histogram-num-bars 40
  set-current-plot-pen ""slow""
  set-histogram-num-bars 40
  set-current-plot-pen ""fast""
  set-histogram-num-bars 40
  set-current-plot-pen ""init-avg-energy""
  draw-vert-line init-avg-energy
end


to do-plotting
  set-current-plot ""Speed Counts""
  set-current-plot-pen ""fast""
  plotxy ticks percent-fast
  set-current-plot-pen ""medium""
  plotxy ticks percent-medium
  set-current-plot-pen ""slow""
  plotxy ticks percent-slow

  plot-histograms
end


to plot-histograms
  set-current-plot ""Energy histogram""
  set-current-plot-pen ""fast""
  histogram [energy] of particles with [color = red]
  set-current-plot-pen ""medium""
  histogram [energy] of particles with [color = green]
  set-current-plot-pen ""slow""
  histogram [energy] of particles with [color = blue]
  set-current-plot-pen ""avg-energy""
  plot-pen-reset
  draw-vert-line avg-energy

  set-current-plot ""Speed histogram""
  set-current-plot-pen ""fast""
  histogram [speed] of particles with [color = red]
  set-current-plot-pen ""medium""
  histogram [speed] of particles with [color = green]
  set-current-plot-pen ""slow""
  histogram [speed] of particles with [color = blue]
  set-current-plot-pen ""avg-speed""
  plot-pen-reset
  draw-vert-line avg-speed
end

;; histogram procedure
to draw-vert-line [ xval ]
  plotxy xval plot-y-min
  plot-pen-down
  plotxy xval plot-y-max
  plot-pen-up
end

to-report last-n [n the-list]
  ifelse n >= length the-list
    [ report the-list ]
    [ report last-n n butfirst the-list ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1997 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2002.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1997).  NetLogo GasLab Gas in a Box model.
; http://ccl.northwestern.edu/netlogo/models/GasLabGasinaBox.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1997 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/GasLabGasinaBox
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model is one in a series of GasLab models. They use the same basic rules for simulating the behavior of gases.  Each model integrates different features in order to highlight different aspects of gas behavior.

The basic principle of the models is that gas particles are assumed to have two elementary actions: they move and they collide - either with other particles or with any other objects such as walls.

This model simulates the behavior of gas particles in a closed box, or a container with a fixed volume.  The path of single particle is visualized by a gray colored trace of the particle's most recent positions.

This model is part of the Connected Mathematics ""Making Sense of Complex Phenomena"" Modeling Project.


HOW IT WORKS
------------
The particles are modeled as hard balls with no internal energy except that which is due to their motion.  Collisions between particles are elastic.  Particles are colored according to speed -- blue for slow (speed less than 5), green for medium (above 5 and below 15), and red for high speeds (above 15).

The basic principle of all GasLab models, including this one, is the following algorithm:

1. A particle moves in a straight line without changing its speed, unless it collides with another particle or bounces off the wall.
2. Two particles ""collide"" if they find themselves on the same patch.
3. A random axis is chosen, as if they are two balls that hit each other and this axis is the line connecting their centers.
4. They exchange momentum and energy along that axis, according to the conservation of momentum and energy.  This calculation is done in the center of mass system.
5. Each particle is assigned its new velocity, energy, and heading.
6. If a particle finds itself on or very close to a wall of the container, it ""bounces"" -- that is, reflects its direction and keeps its same speed.


HOW TO USE IT
-------------
Initial settings:
- NUMBER-OF-PARTICLES: number of gas particles
- INIT-PARTICLE-SPEED: initial speed of the particles
- PARTICLE-MASS: mass of the particles
- BOX-SIZE: size of the box. (percentage of the world-width)

The SETUP button will set the initial conditions.
The GO button will run the simulation.

Other settings:
- TRACE?: Traces the path of one of the particles.
- COLLIDE?: Turns collisions between particles on and off.

Monitors:
- FAST, MEDIUM, SLOW: numbers of particles with different speeds: fast (red), medium (green), and slow (blue).
- AVERAGE SPEED: average speed of the particles.
- AVERAGE ENERGY: average kinetic energy of the particles.

Plots:
- SPEED COUNTS: plots the number of particles in each range of speed.
- SPEED HISTOGRAM: speed distribution of all the particles.  The gray line is the average value, and the black line is the initial average.
- ENERGY HISTOGRAM: distribution of energies of all the particles, calculated as  m*(v^2)/2.  The gray line is the average value, and the black line is the initial average.

Initially, all the particles have the same speed but random directions. Therefore the first histogram plots of speed and energy should show only one column each.  As the particles repeatedly collide, they exchange energy and head off in new directions, and the speeds are dispersed -- some particles get faster, some get slower.  The histogram distribution changes accordingly.


THINGS TO NOTICE
----------------
What is happening to the numbers of particles of different colors?  Does this match what's happening in the histograms?  Why are there more blue particles than red ones?

Can you observe collisions and color changes as they happen?  For instance, when a red particle hits a green particle, what color do they each become?

Why does the average speed (avg-speed) drop?  Does this violate conservation of energy?

The particle histograms quickly converge on the classic Maxwell-Boltzmann distribution.  What's special about these curves?  Why is the shape of the energy curve not the same as the speed curve?

Watch the particle whose path is traced in gray.  Does the trace resemble Brownian motion?  Can you recognize when a collision happens?  What factors affect the frequency of collisions?   What about the how much the angles in the path vary?  Can you get a particle to remain in a relatively small area as it moves, instead of traveling across the entire box?



THINGS TO TRY
-------------
Set all the particles in a region of the box to have the the same heading -- what happens?  Does this correspond to a physical possibility?

Try different settings, especially the extremes.  Are the histograms different?  Does the trace pattern change?

Are there other interesting quantities to keep track of?

Look up or calculate the REAL number, size, mass and speed of particles in a typical gas.  When you compare those numbers to the ones in the model, are you surprised this model works as well as it does?  Try adjusting these variables in the model to better match the numbers you look up.  Does this affect the outcome of the model?  What physical phenomena might be observed if there really were a small number of big particles in the space around us?



EXTENDING THE MODEL
-------------------
Could you find a way to measure or express the ""temperature"" of this imaginary gas?  Try to construct a thermometer.

What happens if there are particles of different masses?  (See GasLab Two Gas model.)

What happens if the collisions are non-elastic?

How does this 2-D model differ from a 3-D model?

Set up only two particles to collide head-on.  This may help to show how the collision rule works.  Remember that the axis of collision is being randomly chosen each time.

What if some of the particles had a ""drift"" tendency -- a force pulling them in one direction?  Could you develop a model of a centrifuge, or charged particles in an electric field?

Find a way to monitor how often particles collide, and how far they go between collisions, on the average.  The latter is called the ""mean free path"".  What factors affect its value?

In what ways is this idealization different from the idealization that is used to derive the Maxwell-Boltzmann distribution?  Specifically, what other code could be used to represent the two-body collisions of particles?

If MORE than two particles arrive on the same patch, the current code says they don't collide.  Is this a mistake?  How does it affect the results?

Is this model valid for fluids in any aspect?  How could it be made to be fluid-like?


NETLOGO FEATURES
-----------------
Notice the use of the histogram primitive.

Notice how collisions are detected by the particles and how the code guarantees that the same two particles do not collide twice.  What happens if we let the patches detect them?


CREDITS AND REFERENCES
----------------------
Wilensky, U. (2003). Statistical mechanics for secondary school: The GasLab modeling toolkit. International Journal of Computers for Mathematical Learning, 8(1), 1-41 (special issue on agent-based modeling).

Wilensky, U., Hazzard, E & Froemke, R. (1999). GasLab: An Extensible Modeling Toolkit for Exploring Statistical Mechanics. Paper presented at the Seventh European Logo Conference - EUROLOGO '99, Sofia, Bulgaria

To refer to this model in academic publications, please use:  Wilensky, U. (1997).  NetLogo GasLab Gas in a Box model.  http://ccl.northwestern.edu/netlogo/models/GasLabGasinaBox.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1997 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/GasLabGasinaBox for terms of use.
"
B-Z Reaction,/models/Sample Models/Chemistry & Physics/Chemical Reactions,"patches-own [state new-state]

to setup
  ca
  ask patches
    [ set state random (max-state + 1)   ;; pick a state from 0 to max-state
      set pcolor scale-color red state 0 max-state ]
end

to go
  ;; first all the patches compute their new state
  ask patches [ find-new-state ]
  ;; only once all the patches have computed their new state
  ;; do they actually change state
  ask patches
  [ set state new-state
    set pcolor scale-color red state 0 max-state ]
  tick
end

to find-new-state  ;; patch procedure
  ifelse state = max-state  ;; ill?
    [ set new-state 0 ] ;; get well
    [ let a count neighbors with [state > 0 and state < max-state]  ;; count infected
      let b count neighbors with [state = max-state] ;; count ill
      ifelse state = 0  ;; healthy?
      [ set new-state int (a / k1) + int (b / k2) ]
        [ let s state + sum [state] of neighbors
          set new-state int (s / (a + b + 1)) + g ]
      if new-state > max-state   ;; don't exceed the maximum state
        [ set new-state max-state ] ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2003 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2003).  NetLogo B-Z Reaction model.
; http://ccl.northwestern.edu/netlogo/models/B-ZReaction.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2003 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/B-ZReaction
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
The Belousov-Zhabotinsky reaction (or B-Z reaction for short) is an unusual chemical reaction.  Instead of steadily moving towards a single equilibrium state, it oscillates back and forth between two such states.  Before this ""chemical oscillator"" was discovered, it was thought that such a reaction could not exist.

If you do the reaction in a beaker, the whole beaker regularly changes color from yellow to clear and back again, over and over.  In this case, we say that the reaction is oscillating in time.  However, if you do the reaction in a thin layer of fluid trapped between two glass plates, then a beautiful pattern emerges of concentric or spiral waves of color change passing through the fluid.  Here, the reaction is oscillating in both time and space.

This model is a cellular automaton (or CA) that produces spiral waves that resemble those produced by the B-Z reaction.  Similar spiral waves have also been observed in biological systems, such as slime molds.

The B-Z reaction is a redox reaction that periodically moves between an oxidized and a reduced state, and has been demonstrated for various chemicals.  This model does not attempt to replicate the actual mechanism of the chemical reaction, which is quite complex (including 18 reactions and 21 species, according to the Fields-Koros-Noyes model).  The abstract features shared by the real reaction and this model include:

1. Two end states.
2. A positive feedback mechanism.
3. A negative feedback mechanism.

The positive feedback mechanism acts to push the system further in the direction that it is already going, reinforcing and amplifying the initial change.  (In the chemical reaction, positive feedback comes from auto-catalysis.)  The negative feedback mechanism pushes the system back in the opposite direction once a threshold is reached, suppressing or counteracting the effected change.


HOW IT WORKS
------------
Each cell has a state which is an integer from 0 to max-state.  We choose to show state 0 as black, max-state as white, and intermediate states as shades of red.

Suppose we call state 0 ""healthy"", max-state ""sick"", and anything in between ""infected"".  Then the rules for how each cell changes at each step can be described as follows:

a) A cell that is sick becomes healthy.

b) A cell that is healthy may become infected, if enough of its eight neighbors are infected or sick.  Whether this happens is affected by the k1 and k2 sliders.  (Lower k1 means higher tendency to be infected by infected neighbors; lower k2 means higher tendency to be infected by sick neighbors.)

c) A cell that is infected computes its new state by averaging the states of itself and its eight neighbors, then adding the value of the g slider.  (Higher g means infected cells get sicker more rapidly.)

a is the negative feedback; b and c are the positive feedback.

These are only qualitative descriptions.  To see the actual math used, look at the FIND-NEW-STATE procedure in the Procedures tab.


HOW TO USE IT
-------------
Press SETUP to initialize each cell in the grid to a random state.

Press GO to run the model.


THINGS TO NOTICE
----------------
Run the model with the default slider settings.

What happens near the beginning of run?

After about 100 ticks, you should start to see spirals emerging.

After about 200 ticks, the spirals should fill the world.

Can you work out why the specific rules used produce patterns like the ones you see?


THINGS TO TRY
-------------
What if you do a really long run -- what happens?

What is the effect of varying the different sliders?  You can think of k1 and k2 as affecting the tendency for healthy cells to become infected, and g as affecting the speed with which the infection gets worse.


EXTENDING THE MODEL
-------------------
This automaton is an example of a ""reaction-diffusion"" system.  By altering the CA rules, you may be able to simulate other reaction-diffusion systems.


NETLOGO FEATURES
----------------
FIND-NEW-STATE is a long and rather complicated procedure.  It could be clearer if it were split into subprocedures, but then the model wouldn't run quite as fast.  Since this particular CA takes so many iterations to settle into its characteristic pattern, we decided that speed was important.


RELATED MODELS
--------------
Boiling, in the Physics/Heat section, is another cellular automaton that uses similar, though simpler, rules.  The early stages of the Boiling model resemble the early stages of this model.

Fireflies, in the Biology section, is analogous to the B-Z reaction in a stirred beaker (the whole beaker ""synchronizes"" so it's switching back and forth all at once, like the fireflies).

Many models in the NetLogo models library can be thought as systems composed of positive and/or negative feedback mechanisms.


CREDITS AND REFERENCES
----------------------
The B-Z reaction is named after Boris Belousov and Anatol Zhabotinsky, the Russian scientists who discovered it in the 1950's.

A discussion of the chemistry behind the reaction, plus a movie and some pictures, are available at http://online.redwoods.cc.ca.us/instruct/darnold/DEProj/Sp98/Gabe/intro.htm .

The cellular automaton was presented by A.K. Dewdney in his ""Computer Recreations"" column in the August 1988 of Scientific American.

See http://www.hermetic.ch/pca/bz.htm for a pretty screen shot of the cellular automaton running on a very large grid (using custom software for Windows, not NetLogo).

To refer to this model in academic publications, please use:  Wilensky, U. (2003).  NetLogo B-Z Reaction model.  http://ccl.northwestern.edu/netlogo/models/B-ZReaction.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2003 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/B-ZReaction for terms of use.
"
Simple Kinetics 3,/models/Sample Models/Chemistry & Physics/Chemical Reactions,"breed [waters water]       ;; blue molecules
breed [anions anion]       ;; red molecules

globals [
  shrink      ;; how many steps right side has been shrunk
]

;; set up model with molecules randomly distributed across world
to setup [both-sides?]
  clear-all
  set-default-shape turtles ""circle""
  set shrink 0
  draw-walls
  create-waters 100         ;; makes 100 blue water molecules
    [ set color blue
      randomize ]                 ;; and puts them on both sides
  create-anions 50         ;; makes 50 red anions
    [ set color red
      ifelse both-sides?          ;; and puts them on one or both sides depending
        [ randomize ]             ;; on which setup button was pressed
        [ randomize-right ] ]
  setup-plot
end

;;turtle procedure that randomizes heading and position
to randomize
  setxy random-xcor random-ycor
  if any? patches in-radius 1 with [pcolor = green]
    [ randomize ] ;; keep trying until we don't land on or near green
end

;; turtle procedure that randomizes heading and position on the
;; right side of the membrane
to randomize-right
  setxy abs random-xcor
        random-ycor
  if any? patches in-radius 1 with [pcolor = green]
    [ randomize-right ] ;; try again until we don't land on or near green
end

;; observer procedure that makes the walls of the box
to draw-walls
  ;; don't let the window be bigger than the right chamber
  if (window-edge > (max-pycor - shrink))
    [ set window-edge (max-pycor - shrink) ]
  ask patches with [(pxcor = min-pxcor) or
                    ((pxcor < 0) and (abs pycor = max-pycor)) or
                    (pxcor >= max-pxcor - shrink) or
                    ((pxcor > 0) and (abs pycor >= max-pycor - shrink))]
    [ set pcolor green ]
  ask patches with [pxcor = 0]
    [ ifelse abs pycor < window-edge
        [ set pcolor black ]
        [ set pcolor green ] ]
  ;; make sure no turtles are embedded in the middle wall
  ;; if the window size changed
  ask turtles with [(pxcor = 0) and (pcolor = green)]
    [ randomize ]
end

to go
  ask turtles
    [ bounce
      fd 1 ]
  tick
  do-plot
end

;;observer procedure used to place 25 more red anions on the right
to add-anions-right
  create-anions 25
    [ set color red
      randomize-right ]
end

to bounce ;; turtle procedure
  ;; Note: The minimum on the window-edge slider is 2, not 0 or 1, because
  ;; this code does not correctly handle the case where window-edge is 1
  ;; (sometimes molecules get stuck in the window).
  ; if we're not about to land on green, we don't need to do any
  ; further checks
  if [pcolor] of patch-ahead 1 != green [ stop ]
  ; figure out where the walls are on this side of the box
  let box-edge-x max-pxcor
  let box-edge-y max-pycor
  if xcor >= 0
    [ set box-edge-x max-pxcor - shrink
      set box-edge-y max-pycor - shrink ]
  ; check: hitting left, right, or middle wall?
  if (abs [pxcor] of patch-ahead 1 = box-edge-x) or
     (([pxcor] of patch-ahead 1 = 0) and (pxcor != 0))
    ; if so, reflect heading around x axis
    [ set heading (- heading) ]
  ; check: hitting top or bottom wall, or edge of middle wall?
  if (abs [pycor] of patch-ahead 1 = box-edge-y) or
     (([pycor] of patch-ahead 1 = 0) and (pxcor = 0))
    ; if so, reflect heading around y axis
    [ set heading (180 - heading) ]
end

;; observer procedure that causes right side of divider to shrink (if amount is
;; positive) or expand (if amount is negative)
to shrink-or-expand [amount]
  set shrink (shrink + amount)
  ;; keep it within bounds
  if (shrink < 0)
    [ set shrink 0 ]
  if (shrink >= max-pxcor - 2)
    [ set shrink max-pxcor - 2 ]
  if (shrink >= max-pycor - 2)
    [ set shrink max-pycor - 2 ]
  clear-patches
  draw-walls
  ;; make sure no turtles are embedded in the walls
  ask turtles with [(xcor > 0) and (pcolor = green)]
    [ randomize-right ]
end

;;; plotting procedures

to setup-plot
  ;; draw the x axis in black
  set-current-plot ""Equilibration Plot""
  auto-plot-off
  set-current-plot-pen ""midline""
  plot 0
  plotxy 10000 0
  auto-plot-on
end

to do-plot
  let anions-left count anions with [xcor < 0]
  let anions-right count anions with [xcor >= 0]
  let water-left count waters with [xcor < 0]
  let water-right count waters with [xcor >= 0]
  set-current-plot ""Equilibration Plot""
  set-current-plot-pen ""anions""
  plot (anions-right - anions-left)
  set-current-plot-pen ""water""
  plot (water-right - water-left)
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2001 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2001).  NetLogo Simple Kinetics 3 model.
; http://ccl.northwestern.edu/netlogo/models/SimpleKinetics3.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2001 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/SimpleKinetics3
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model follows on the Simple Kinetics 2 model.  In Simple Kinetics 2, we saw how changes to variables such as temperature, volume, and concentration affected the rate at which a chemical reaction reached an equilibrium state.  Here we model the same phenomenon based upon a physical separation.

This model investigates some laboratory methods that chemists use to purify chemicals.  Most of these methods are based upon physical properties of molecular separation. The same principles that affect chemical equilibrium affect physical equilibrium as well. By changing the variables of temperature, volume, and concentration, we can affect not only the speed at which a system reaches equilibrium, but also the nature of the distribution ratio. In this model, we watch how these factors affect the physical distribution of red molecules that are considered ""dissolved"" in a blue solvent.


HOW TO USE IT
-------------
Setup the model by pressing either the SETUP-RANDOM or the SETUP-SIDE buttons at the top of the Interface tab.  SETUP-RANDOM distributes all the molecules randomly around the world. SETUP-SIDE distributes the blue molecules evenly, while placing the red molecules on the right side of the world.

Press GO to watch the molecules move about the world as they achieve equilibrium. The plot tracks the relative concentrations of each color molecule on each side of the central divider. If the red line dips below 0, there are more red molecules on the left side of the divider than on the right. If it rises above 0, there are more red molecules on the right side of the divider than on the left. The blue line plots the same relationship for blue molecules.

You can add more red molecules to the right side of the world by pressing ADD RED.

Similarly, you can shrink or expand the right side of the box with the buttons SHRINK RIGHT and EXPAND RIGHT, respectively.

Finally, to change the size of the connection window, move the WINDOW slider to your desired size and then press the CHANGE WINDOW button.


THINGS TO NOTICE
----------------
Pay attention to the plot and compare it what you see in the world. Is there an equal number of blue and red molecules on each side of the divider according to the plot and according to what you see in the view?


THINGS TO TRY
-------------
Run the model with several different states for each variable. Do you observe similar equilibrium effects to those seen in Simple Kinetics 2?  Are there significant differences?

Does the temperature affect the system in the same way it affected the chemical reaction in Simple Kinetics 2?  Why or why not?

How does changing the concentration affect the rate at which the molecules achieve equilibrium? Does this make sense?


EXTENDING THE MODEL
-------------------
The system we have established here always comes to an approximately identical equilibrium state, no matter how you change the variables. In the lab, this is not useful to chemists, who want to separate one type of molecule from another. Can you extend the model to separate all of the red molecules from the blue molecules?

Try adding another color of molecule to the system and randomly distributing all the molecules around the world. Can you devise a way to separate the new molecules from the red molecules?

Add a slider that allows you to alter the temperature of the system. Think about what effect cooling and heating the system would have on the molecules. Be sure to include a command in the procedures window that will execute your proposed effect.


RELATED MODELS
--------------
Simple Kinetics 1, Simple Kinetics 2.  Note that the original StarLogoT version of this model was named ""Le Chatelier 2"".


CREDITS AND REFERENCES
----------------------
Thanks to Mike Stieff for his work on this model.

To refer to this model in academic publications, please use:  Wilensky, U. (2001).  NetLogo Simple Kinetics 3 model.  http://ccl.northwestern.edu/netlogo/models/SimpleKinetics3.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2001 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/SimpleKinetics3 for terms of use.
"
Radical Polymerization,/models/Sample Models/Chemistry & Physics/Chemical Reactions,"breed [ initiators initiator ]  ;; yellow
breed [ monomers monomer ]    ;; green
breed [ polymers polymer ]    ;; blue
breed [ radicals radical ]    ;; red


turtles-own [
  chain-length
]

to setup
  ca
  set-default-shape turtles ""circle""
  ;; make molecules
  create-monomers 200
   [ set color green
     set chain-length 1 ]
  create-initiators Io
   [ set color yellow
     set chain-length 0 ]
  ;; scatter them around the world
  ask turtles
   [ setxy random-xcor random-ycor ]
  ;; start plots
  setup-plots
  do-plot
end

to go
  ask monomers [ grow-chain ]
  ask initiators [ initiate ]
  ask turtles [ move ]
  ask radicals [ terminate ]
  ask radicals [ set label chain-length ]
  ask polymers [ set label chain-length ]
  tick
  do-plot
end

to move
  rt random 50 - random 50
  fd 1
end

;; monomer procedure -- monomer turtle finds a radical on the same patch,
;; increases the chain-length of the radical by 1, then dies
to grow-chain
  let partner one-of radicals-here
  if (partner != nobody) and (random-float 1000 < Km)
    [ ask partner [ set chain-length chain-length + 1 ]
      die ]
end

;; initiator procedure -- unimolecular initiation: yellow turtles
;; spontaneously break up into two red radicals
to initiate
  if (random-float 1000 < Ki)
    [ set color red
      set breed radicals
      hatch 1 [ move ] ]
end

;; radical procedure -- radicals react pairwise
to terminate
  let partner one-of other radicals-here
  if (partner != nobody) and (random-float 500 < Km)
    [ if self < partner
        [ ask partner
            [ set color blue
              set breed polymers
              set chain-length chain-length + [chain-length] of myself ] ]
          die ]
end

;; plotting procedures

to setup-plots
  set-current-plot ""Counts""
  set-plot-y-range 0 count turtles
end

to do-plot
  set-current-plot ""Counts""
  set-current-plot-pen ""initiator""
  plot count initiators
  set-current-plot-pen ""monomer""
  plot count monomers
  set-current-plot-pen ""radical""
  plot count radicals
  set-current-plot-pen ""polymer""
  plot count polymers
  every 0.5 [ do-histogram ]
end

to do-histogram
  set-current-plot ""Chain Lengths""
  let histogram-max max fput 10 [chain-length] of polymers
  set-plot-x-range 0 histogram-max
  set-histogram-num-bars (histogram-max + 1)
  histogram [chain-length] of polymers
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Radical Polymerization model.
; http://ccl.northwestern.edu/netlogo/models/RadicalPolymerization.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/RadicalPolymerization
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model explains kinetics of radical polymerization.  Radical polymerization can be thought of as the process of agglomeration of small molecules (monomers) into chains (polymer chains) initiated by active particles (radicals).

An example of radical polymerization would be industrial polymerization of ethylene into polyethylene (PET):

|        n C H  --------> ~C  H~
|          2 4           2n 4n

A gaseous mixture of ethylene and oxygen (used as a catalyst), is pumped through a mile-long heated pipe.  As the mixture moves along the pipe, the molecules of ethylene polymerize into chains.  At the end of the pipe, the polymer is collected and co-products with low molecular mass are recycled.


Molecules of oxygen turn into bi-radicals under the influence of high temperature:

|        O --------> *O-O*
|         2

here the asterisk denotes a free electron.  These bi-radicals react with pi-bonds in ethylene and start the process of chain growth according to the scheme:


|        *O-O* + C H --------> *O-O-CH-CH*
|                 2 4                 2  2


|        *O-O-CH-CH* + CH-CH --------> *O-O-CH-CH-CH-CH*
|               2  2     2  2                 2  2  2  2


We can thus think of radical polymerization as interaction between (bi-) radicals and monomers.

Notice that if two radicals react with each other, they will form an inert compound and end the process of forming loner chains.

Let us assume that we run polymerization using AIBN as an initiator which we denote by I.  We thus have the following kinetically distinct particles in the system:

(i) Initiator molecules;
(ii) Radicals;
(iii) Monomers;
(iv) ""Dead"" chains;

A radical can react with a monomer, in which case it absorbs the monomer and increases its chain-length by 1.  Alternatively, a radical can react with another radical forming a ""dead"" molecule which does not react with other particles.  Let us denote by R(n) radicals which have reacted n times with monomers.  Let M stand for monomers and C(k) for ""dead"" chains of length k.  Then schematically we can describe the reactions by the following system of equations:

|        I --------> 2 R(1)              (initiation)
|
|        R(n) + M --------> R(n+1)       (growth)
|
|     R(n) + R(m) --------> C(n+m)       (termination)

In this model, there are four breeds of turtles:
- initiators (yellow turtles);
- monomers (green turtles);
- radicals (red turtles);
- polymers (blue turtles).

Each turtle carries a variable, chain-length.  Initially there are 200 turtles of monomer breed with chain-length set to 1.  There is also a user-defined number (Io) of initiator breed with chain-length set to 0.

The rules are quite simple:

(i) All turtles move around randomly.
(ii) Yellow turtles (initiators) spontaneously break up into two red turtles (radicals) with probability Ki;
(iii) Green turtles (monomers) react with red turtles (radicals) with probability Km.  If there is at least one radical on the same patch as the given monomer, the monomer dies and the chain-length of the radical which ""killed"" it is incremented by 1;
(iv) Red turtles (radicals) react with each other pairwise.  If there is a pair of radicals on the same patch, they annihilate each other with probability Kr forming a polymer chain (a blue turtle);


HOW TO USE IT
-------------
With sliders one can control the initial number of initiators (Io) and reaction probabilities
- Ki (initiator): probability of an initiator (yellow) creating two radicals (red);
- Km (monomer): probability of reaction between monomers (green) and radicals (red), forming a radical with a longer chain length;
- Kr (radical): probability of two radicals (red)  reacting to form a polymer chain (blue).

Select the initial number of initiators Io and press the ""setup"" button.  To start the simulation press the GO button.  You can set the probabilities Ki, Km and Kr before or after you do setup.  You can also modify this constants on the fly during the execution of the GO procedure.

One plot shows the number of initiators, monomers, radicals, and polymers.  The distribution of chain-lengths of polymers (blue) is shown in the second plot in the form of a histogram.  Each chain is labeled with its length.


THINGS TO NOTICE
----------------
Distribution of chain-length drastically depends on the mode of initiation.  If you select low values of Io and Ki, then the life expectancy of radicals will rise leading to longer chains.  However in this case the simulation will have to run too long in order to produce a sizable amount of long-length chains.   If you start the simulation with a lot of initiator which decomposes rapidly, radicals will tend to react with themselves and form low molecular oligomers.


THINGS TO TRY
-------------
Try to find the optimum values for which the distribution is tight and the simulation runs at a reasonable pace.


EXTENDING THE MODEL
-------------
Try to implement the model of industrial production of polyethylene (PET) described above.  Are you going to have ""dead"" chains in this model?

Can you modify the model so that visible ""chains"" of turtles actually form, like in the Follower model?


ADDITIONAL INFORMATION
----------------------
Note that in real polymerization reactions, the outcomes are affected by the position and shapes of the chains in three-dimensional space.  This aspect of the reactions is not presented in this model.

Although oxygen is widely used in industry as initiator of radical polymerization, scientists prefer to use other initiators in the lab, especially when the reaction has to be performed under conditions of atmospheric pressure and room temperature.  Two of the most frequently used lab initiators are benzoyl peroxide and 2-2'-azo-bis-isobutyrylnitrile (AIBN):

|        C H-C(O)O-O(O)C-H C
|     6 5             5 6
|
|            CH     CH
|        | 3    | 3
|        CH -C--N=N-C- CH
|      3 |      |    3
|        CN     CN


Peroxydes and azo-compounds are extremely unstable and tend to break up into radicals very easily if exposed to moderate heat or light.  Here is the reaction of decomposition of AIBN:

|            CH     CH                     CH
|        | 3    | 3                    | 3     ^
|        CH -C--N=N-C- CH  --------> 2 CH -C* + N  |
|      3 |      |    3               3 |     2
|        CN     CN                     CN


This reaction is irreversible because of the escape of nitrogen.


RELATED MODELS
--------------
See also the series of ""Simple Kinetics"" models.  Also see ""Polymer Dynamics"".


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Radical Polymerization model.  http://ccl.northwestern.edu/netlogo/models/RadicalPolymerization.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/RadicalPolymerization for terms of use.
"
Enzyme Kinetics,/models/Sample Models/Chemistry & Physics/Chemical Reactions,"breed [ enzymes enzyme]      ;; red turtles that bind with and catalyze substrate
breed [ substrates substrate ]   ;; green turtles that bind with enzyme
breed [ inhibitors inhibitor ]   ;; yellow turtle that binds to enzyme, but does not react
breed [ products product ]     ;; blue turtle generated from enzyme catalysis


turtles-own [
  partner      ;; holds the turtle this turtle is complexed with,
               ;; or nobody if not complexed
]

globals [
  substrate-added ;; keeps track of how much substrate has been added
  v               ;; rate of complex formation at each time step
]

to startup
  setup-mm-plot
end

;; observer procedure to set up model
to setup
  reset-ticks
  clear-turtles                    ;; clears view -- don't use ca so MM plot doesn't clear
  set-current-plot ""Concentrations""
  clear-plot
  set substrate-added 0
  set v 0
  add enzymes 150                   ;; starts with constant number of enzymes
  add substrates volume             ;; add substrate based on slider
end

;; observer procedure to add molecules to reaction
to add [kind amount]
  crt amount
    [ set breed kind
      setxy random-xcor random-ycor
      set partner nobody
      setshape ]
  if kind = substrates
    [ set substrate-added substrate-added + amount ]
end

;; procedure that assigns a specific shape to a turtle, and shows
;; or hides it, depending on its state
to setshape
  ifelse breed = enzymes
    [ set color red
      ifelse partner = nobody
        [ set shape ""enzyme"" ]
        [ ifelse ([breed] of (partner) = substrates)
            [ set shape ""complex"" ]
            [ set shape ""inhib complex"" ] ] ]
    [ ifelse breed = substrates
        [ set color green
          set shape ""substrate""
          set hidden? (partner != nobody) ]
        [ ifelse breed = inhibitors
            [ set color yellow
              set shape ""inhibitor""
              set hidden? (partner != nobody) ]
            [ if breed = products
                [ set color blue
                  set shape ""substrate""
                  set hidden? false ] ] ] ]
end

;; main procedure
to go
  tick
  ask turtles [ move ]                ;; only non-complexed turtles will move
  ask enzymes [ form-complex ]         ;; enzyme may form complexes with substrate or inhibitor
  ask substrates [ react-forward ]     ;; complexed substrate may turn into product
  ask enzymes [ dissociate ]           ;; or complexes may just split apart
  calculate-velocity                  ;; calculate V for use in the Michaelis-Menten curve
  plot-concentrations                 ;; plots variables
  if pause? and (ticks >= 30)
    [ stop ]
end

to move  ;; turtle procedure
  if partner = nobody
    [ fd 1
      rt random-float 360 ]
end

;; An enzyme forms a complex by colliding on a patch with a substrate
;; or inhibitor.  If it collides with an inhibitor, it always forms
;; a complex.  If it collides with a substrate, Kc is its percent chance
;; of forming a complex.
to form-complex  ;; enzyme procedure
  if partner != nobody [ stop ]
  set partner one-of (other turtles-here with [partner = nobody])
  if partner = nobody [ stop ]
  if [partner] of partner != nobody [ set partner nobody stop ]  ;; just in case two enzymes grab the same partner
  ifelse ((([breed] of partner) = substrates) and ((random-float 100) < Kc))
     or (([breed] of partner) = inhibitors)
    [ ask partner [ set partner myself ]
      setshape
      ask partner [ setshape ] ]
    [ set partner nobody ]
end

;; substrate procedure that controls the rate at which complexed substrates
;; are converted into products and released from the complex
to react-forward
  if (partner != nobody) and (random-float 1000 < Kr)
    [ set breed products
      ask partner [ set partner nobody ]
      let old-partner partner
      set partner nobody
      setshape
      ask old-partner [ setshape ] ]
end

;; enzyme procedure that controls the rate at which complexed turtles break apart
to dissociate
  if partner != nobody
    [ if ([breed] of partner = substrates) and (random-float 1000 < Kd)
      [ ask partner [ set partner nobody ]
        let old-partner partner
        set partner nobody
        setshape
        ask old-partner [ setshape ] ] ]
end

to calculate-velocity
  let initial-conc substrate-added
  let current-conc count substrates with [partner = nobody]
  set v (initial-conc - current-conc) / ticks
end

;;; plotting procedures

to plot-concentrations
  set-current-plot ""Concentrations""
  set-current-plot-pen ""Substrate""
  plot count substrates with [partner = nobody]
  set-current-plot-pen ""Complex""
  plot count enzymes with [partner != nobody]
  set-current-plot-pen ""Product""
  plot count products
end

to setup-mm-plot
  set-current-plot ""Michaelis-Menten Curve""
  clear-plot
end

;; allows user to plot the concentration versus the velocity on the Michaelis-Menten Curve
to do-mm-plot
  set-current-plot ""Michaelis-Menten Curve""
  plotxy substrate-added v
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2001 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2001).  NetLogo Enzyme Kinetics model.
; http://ccl.northwestern.edu/netlogo/models/EnzymeKinetics.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2001 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/EnzymeKinetics
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model demonstrates the kinetics of single-substrate enzyme-catalysis. The interactions between enzymes and substrates are often difficult to understand and the model allows users to visualize the complex reaction.

The standard equation for this reaction is shown below.

|                  Kc          Kr
|        E + S <=======> E-S ------> E + P
|                  Kd

Here E represents Enzyme, S Substrate, E-S Enzyme-Substrate complex, and P product.  The rate constants are Kc for complex formation, Kd for complex dissociation, Kr for catalysis.  The first step in catalysis is the formation of the E-S complex.  This can consist of either covalent or non-covalent bonding.  The rates of complex formation and dissociation are very fast because they are determined by collision and separation of the molecules.  The next step is for the enzyme to catalyze the conversion of substrate to product.  This rate is much slower because the energy required for catalysis is much higher than that required for collision or separation.

The model demonstrates several important properties of enzyme kinetics.  Enzyme catalysis is often assumed to be controlled by the rate of complex formation and dissociation, because it occurs much faster than the rate of catalysis. Thus, the reaction becomes dependent on the ratio of Kc / Kd.  The efficiency of catalysis can be studied by observing catalytic behavior at different substrate concentrations.

By measuring the rate of complex formation at different substrate concentrations, a Michaelis-Menten Curve can be plotted.  Analysis of the plot provides biochemists with the maximum rate (Vmax) at which the reaction can proceed. As can be seen from the model, this plot is linear at low levels of substrate, and non-linear at higher levels of substrate.  By examining the model, the reasons for this relationship can be seen easily.

Enzyme catalysis can also be controlled using inhibitors. Inhibitors are molecules that are structurally similar to substrate molecules that can complex with the enzyme and interfere with the E-S complex formation.  Subsequently, the shape of the Michaelis-Menten Curve will be altered. The model demonstrates the effects of inhibitors on catalysis.


HOW TO USE IT
--------------
Choose the values of Kc, Kd, and Kr with appropriate sliders:
- Kc controls the rate at which substrates (green) and enzymes (red) stick together so that catalysis can occur
- Kd controls the rate at which they come unstuck
- Kr controls the rate of the forward reaction by which an enzyme (red) converts a substrate (green) to a product (blue)

Having chosen appropriate values of the constants, press SETUP to clear the world and create a constant initial number of enzyme (red) molecules. Play with several different values to observe variable effects on complex formation and catalysis.

Press GO to start the simulation.  A constant amount of enzyme (red) will be generated.  The concentrations of substrate, complex, and product are plotted in the CONCENTRATIONS window.

Experiment with using the ADD-SUBSTRATE and ADD-INHIBITOR buttons to observe the effects of adding more molecules to the system manually as it runs.  The default setting for Kr is 0, which means that no product (blue) will be generated unless you change Kr to a non-zero value.

Note that when complexes form they stop moving.  This isn't intended to be physically realistic; it just makes the formation of complexes easier to see.  (This shouldn't affect the overall behavior of the model.)

To plot the Michaelis-Menten Curve for your reaction conditions, you will have to perform several runs at different concentrations in order to measure the velocity for each run. To do this, set the PAUSE? switch ON.  When this switch is on, the model automatically stops after 30 time ticks.  Begin your assay by setting the substrate volume to zero and running the simulation.  When it stops, press RECORD V and a point will be plotted on the Michaelis-Menten Curve. Run another simulation with a higher concentration of substrate by changing the VOLUME slider, then hitting SETUP followed by GO, followed by RECORD V once the model stops.  Continue for several values of substrate concentrations until a curve is generated. If you wish to start over hit CLEAR MM to reset the plot.


THINGS TO NOTICE
----------------
Watch the rate at which the enzyme and substrate stick together. How does this affect the conversion of substrate into product? What would happen if Kd is very high and Kc is very low? If Kr were the same order of magnitude as Kd and Kc?

Watch the Michaelis-Menten Curve. Does it match up with the discussion of enzyme kinetics discussed above? Why does the plot initially slope upward, then flatten out?

Which variables can alter the magnitude of v?

How does the magnitude of Kd and Kr affect the smoothness of the Michaelis-Menten Curve?


THINGS TO TRY
-------------
Run the simulation with VOLUME set to various amounts. How does this affect the curve?

If Kr is MUCH greater than Kd, what affect does this have on the reaction?  How important does complex formation become in this situation?

If Kc is MUCH less than Kd, what does this mean in the real-world? How are the enzyme and substrate related under these conditions?

What effect does adding inhibitor to the model have on the plot? Is Vmax affected?


EXTENDING THE MODEL
------------------
What would happen if yellow inhibitor molecules could react to form a product? How would this affect the plot?

Inhibitors can be irreversible or reversible. That is, they can bind to an enzyme and never let go, or they can stick and fall off. Currently, the model simulates irreversible inhibitors. Modify the code so that the yellow molecules reversibly bind to the enzyme. How does this affect catalysis?

Often, the product of catalysis is an inhibitor of the enzyme. This is called a feedback mechanism. In this model, product cannot complex with enzyme. Modify the procedures so that the product is a reversible inhibitor. How does this affect catalysis with and without yellow inhibitor?

Include a slider that allows you to change the concentration of enzyme.  What affect does this have on the plot?  Vmax?  Look closely!


NETLOGO FEATURES
------------------
It is a little difficult to ensure that a reactant never participates in two reactions simultaneously.  In the future, a primitive called GRAB may be added to NetLogo; then the code in the FORM-COMPLEX procedure wouldn't need to be quite so tricky.


CREDITS AND REFERENCES
----------------------
Thanks to Mike Stieff for his work on this model.

To refer to this model in academic publications, please use:  Wilensky, U. (2001).  NetLogo Enzyme Kinetics model.  http://ccl.northwestern.edu/netlogo/models/EnzymeKinetics.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2001 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/EnzymeKinetics for terms of use.
"
Chemical Equilibrium,/models/Sample Models/Chemistry & Physics/Chemical Reactions/Unverified,";; Setup Procedures
to setup
  clear-all
  crt bluemols
  [ set color blue
    randomize
  ]
  crt yellowmols
  [ set color yellow
    randomize
  ]
  ;; adjust the y-range of the plot to fit the number of molecules
  set-plot-y-range 0 max (list yellowmols bluemols)
  update-plot
end

to randomize
  set shape ""circle""
  setxy random-xcor random-ycor
end


;; Runtime Procedures

;; In GO, turtles move according to a number of different checks and
;;  procedures.  Note that all turtles must have executed the procedure
;;  CHECK-FOR-SPACE before any turtle can continue with CHECK-FOR-REACTION
;;  because they are broken up into two separate ask blocks.  This ensures
;;  that every turtle will be on its own patch before any turtles checks for
;;  a reaction.
to go
  ask turtles
  [ fd 1
    wiggle
    check-for-space
  ]
  ask turtles
  [ check-for-reaction ]
  tick
  update-plot
end

;; In WIGGLE, turtles are given a slight random twist to their heading.
to wiggle
  rt random-float 2
  lt random-float 2
end

;; In CHECK-FOR-SPACE, each turtle moves forward until it is alone in its
;;  own patch.  Note that the procedure calls itself if the check is true.
;;  This technique is called recursion.  CHECK-FOR-SPACE is called in GO.
to check-for-space
  if (count turtles-here > 1)
  [ fd 1 check-for-space ]
end

;; In CHECK-FOR-REACTION, every turtle checks for a turtle it can react with within
;;  a radius which approximates the eight patches surrounding it.  Blue turtles can
;;  react with yellow turtles, and brown turtles can react with green turtles.
to check-for-reaction
  if color = blue and any? turtles in-radius 1 with [color = yellow]
  [ react-forward one-of turtles in-radius 1 with [color = yellow] ]
  if color = brown and any? turtles in-radius 1 with [color = green]
  [ react-reverse one-of turtles in-radius 1 with [color = green] ]
end

;; In REACT-FORWARD and REACT-REVERSE, the turtle changes the its color and the color
;;  of the turtle they are reacting with, sets a random heading, and jumps away to
;;  avoid further interaction.  They are the same except for their colors.
to react-forward [t]
  ask t [ set color brown ]
  set color green
  rt random-float 360
  jump 2
end

to react-reverse [t]
  ask t [ set color blue ]
  set color yellow
  rt random-float 360
  jump 2
end

;; In UPDATE-PLOT, each pen plots its corresponding turtle count.
to update-plot
  set-current-plot-pen ""Yellows""
    plot count turtles with [color = yellow]
  set-current-plot-pen ""Blues""
    plot count turtles with [color = blue]
  set-current-plot-pen ""Browns""
    plot count turtles with [color =  brown]
  set-current-plot-pen ""Greens""
    plot count turtles with [color = green]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Chemical Equilibrium model.
; http://ccl.northwestern.edu/netlogo/models/ChemicalEquilibrium.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/ChemicalEquilibrium
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This project shows how a simple chemical system comes to different equilibrium states depending on the concentrations of the initial reactants.

Equilibrium is the term we use to describe a system in which there are no macroscopic changes.  This means that the system ""looks"" like nothing is happening.  In fact, in all chemical systems microscopic processes continue but in a balance that yields no changes at the macroscopic level.

This model simulates two simple reactions of four molecules.  The reactions can be written A + B yields C + D.  And at the same time, of course, C + D yields A + B.

A classic real-life example that would illustrate such reactions is the reactions of carbon monoxide with nitrogen dioxide to produce carbon dioxide and nitrogen monoxide (or, nitric oxide).  The reverse is also possible.  All the reactants are gases.  We could watch such an equilibrium system because NO2 is a reddish colored gas which is visible. However, the combining of nitrogen dioxide (NO2) with carbon monoxide (CO) results in the colorless products nitrogen monoxide (NO) and carbon dioxide (CO2), and so the system loses its reddish color.  And yet, not all the color is lost. Ultimately the system comes to equilibrium with some of the ""reactants"" and some of the ""products"" present.

How much ""reactant"" and ""product"" a system ends up with depends on a number of factors.  The inherent kinetics of the reaction are of vital concern: For instance, some reactions tend to go in a particular direction because energy is released in that direction.  A system's equilibrium is also affected by the concentrations of the reactants -- this is modeled here -- and by the system's temperature.


HOW TO USE IT
-------------
As stated above, this model simulates a chemical system of four different molecules.  They are represented in the view as turtles of four different colors.  In this simulation, yellow molecules react with blue molecules to produce brown molecules and green molecules.

The model is setup by first adjusting the YELLOWMOLS and BLUEMOLS sliders and pushing the SETUP button.  YELLOWMOLS sets how many yellow molecules the simulation starts with, while BLUEMOLS sets how many blue molecules the simulation starts with.


The GO button sets the simulation in motion.  Molecules move randomly and react with each other, changing color to represent rearrangement of atoms into different molecular structures.  The system soon comes into equilibrium.

Four monitors show how many of each kind of molecule are present in the system.  There is also a plot which plots the number of each kind of molecule present versus time.



THINGS TO NOTICE
----------------
Notice that the number of product molecules is limited by the smallest amount of reactant product.  Notice that there are always the same number of reactant products since they are formed in a one-to-one correspondence with each other.


THINGS TO TRY
-------------
How do different amounts of the two reactants affect the final equilibrium.  Are absolute amounts important, is it the difference between the amounts, or is it a ratio of the two reactants that matters?

Try setting the YELLOWMOLS slider to 400 and the BLUEMOLS slider to 20, 40, 100, 200, and 400 in five successive simulations.  What sort of equilibrium state do you predict in each case?  Are certain ratios predictable?


EXTENDING THE MODEL
-------------------
What if the forward and reverse reaction rates were the variables controlled instead of initial concentrations.  You could compare such a simulation with the one in this model and see if concentration and reaction rates act independently of each other, as measured by the final equilibrium state.

You could also extend the program by allowing the user to introduce new molecules into the simulation while it is running.  How would the addition of fifty blue molecules affect a system that was already at equilibrium?


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Chemical Equilibrium model.  http://ccl.northwestern.edu/netlogo/models/ChemicalEquilibrium.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/ChemicalEquilibrium for terms of use.
"
Simple Kinetics 1,/models/Sample Models/Chemistry & Physics/Chemical Reactions,"breed [reactants reactant]    ;; reactants are green, products are red
breed [products product]

to setup
  clear-all
  set-default-shape reactants ""molecule1""
  set-default-shape products ""molecule2""
  create-reactants number
    [ set color green
      setxy random-xcor random-ycor ]
  setup-plot
  do-plotting
end

to go
  ask turtles
    [ rt random-float 10 - random-float 10  ;; wander around randomly
      fd 1 ]
  ask reactants
    [ react-forward ]
  ask products
    [ react-backward ]
  tick
  do-plotting
end

to react-forward
  if (any? other reactants-here) and
     ;; multiply Kb by 2 because 2 molecules are involved
     random-float 1000 < (Kb * 2)
    [ ask one-of other reactants-here
        [ set breed products
          set color red ]
      die ]
end

to react-backward
  if (random-float 1000) < Ku
    [ set breed reactants    ;; change back to reactant
      set color green
      hatch 1 ]         ;; then split into two reactants
end

;;; plotting procedures

to setup-plot      ;; the code below sets up the plot
  set-current-plot ""Concentration""
  set-plot-y-range 0 number
end

to do-plotting      ;; plot concentrations
  set-current-plot ""Concentration""
  set-current-plot-pen ""reactants""
  plot count reactants
  set-current-plot-pen ""products""
  plot count products
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the project: CONNECTED MATHEMATICS:
; MAKING SENSE OF COMPLEX PHENOMENA THROUGH BUILDING OBJECT-BASED PARALLEL
; MODELS (OBPML).  The project gratefully acknowledges the support of the
; National Science Foundation (Applications of Advanced Technologies
; Program) -- grant numbers RED #9552950 and REC #9632612.
;
; Copyright 1998 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; This model was converted to NetLogo as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING
; IN CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
; Converted from StarLogoT to NetLogo, 2001.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (1998).  NetLogo Simple Kinetics 1 model.
; http://ccl.northwestern.edu/netlogo/models/SimpleKinetics1.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 1998 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/SimpleKinetics1
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model demonstrates the kinetics of a simple reversible reaction.  It demonstrates numerically that the application of the Principle of Stationary Concentrations is valid in this case.

In this model there are two kinds of molecules, green and red.  Green turtles turn into red turtles bimolecularly whereas red turtles turn back into pairs of green turtles monomolecularly.  You can control the rate at which this changes occur with sliders Kb and Ku.

The reaction here is a reversible reaction of the type:

|                         Kb
|        A + A <=======> B
|                         Ku

An example of such a reaction would be dimerization of acetic acid:

|                                  Kb
|        2 H C-COOH <=======> H C-COOH~...~HOOC-C H
|       3           Ku     3                 3


This reaction is an example of a complex reaction which consists of two elementary reactions.  The forward bimolecular reaction

|                        Kb
|        A + A --------> B


is characterized by the constant Kb and the reverse unimolecular reaction

|             Ku
|        B ---------> A + A


is characterized by the constant Ku.

The system of ordinary differential equations (ODE) that describes the concentrations of A and B is given below:


|        dA           2
|        -- = -2Kb * A  + 2Ku * B        (1)
|        dt

|        dB         2
|        -- = Kb * A  - Ku * B           (2)
|        dt


The usual initial conditions are A(0) = Ao and B(0) = 0.  While it is possible to solve this system of ODE analytically, chemists usually apply the Principle of Stationary Concentrations when they investigate the kinetics of reactions of this type.  The Principle says that one can assume that the concentrations of the species stop changing from some point on after the system reaches equilibrium.  If concentrations are stationary, the derivatives

|        dA               dB
|        --  and  --
|        dt               dt

are zero.  Hence one can replace the system of ODE above with the system of algebraic equations below:
|                    2
|        0 = -2Kb * A*   + 2Ku * B*              (1')
|
|                  2
|        0 = Kb * A*  - Ku * B*                  (2')

where concentrations marked with * are stationary concentrations.  The second equation (2') is linearly dependent on the first equation (1').  Luckily we also have another equation coming from the law of the conservation of mass:

|        A* + 2 * B* = Ao                        (3)

From equation (2') we can express B* in terms of A* :

|                  Kb    2
|        B*  = --  A*                    (4)
|                  Ku

We can now plug in expression (4) into (3) and then we will have a quadratic equation in terms of A*:

|                  Kb   2
|        A*  + -- A*  = Ao               (5)
|          Ku

whose solution is:

|             _____________
|             |
|             |             Kb
|             |  1 + 4 * --  - 1
|            \|          Ku
|           --------------------         (6)
|                  Kb
|                         2 * --
|                                 Ku

One can now find the stationary concentration of B using equation (4).


HOW TO USE IT
--------------
Choose the values of Ku and Kb with appropriate sliders:
- Kb controls the rate of the forward reaction by which two green turtles turn bimolecularly into a single red turtle.
- Ku controls the rate of the reverse reaction, by which a red turtle turns unimolecularly into two green turtles.

Having chosen appropriate values of the constants, press SETUP to clear the world and create an initial number of green turtles.  Note: we do not create red turtles initially, although this could be done in principle.

Press GO to start the simulation.


THINGS TO NOTICE
----------------
You will see turtles wandering around the world and changing color.  Pay more attention to the plot of the concentrations.  Do the plots soon reach stationary concentrations?


THINGS TO TRY
-------------
How do the stationary concentrations depend on the values of Kb and Ku?   You can change Ku and Kb while the model is running.   See if you can predict what the stationary concentrations will be with various combinations of Kb and Ku.


EXTENDING THE MODEL
------------------
Try to implement the following reaction:

|                 Kb         K2
|        A + A <======> B -------> C
|                 Ku

This reaction underlines a vast number of microbiological processes (e.g. fermentation).  You can read about its kinetics in any book on Biochemistry.  Look up the so-called Michaeles-Menten equation.  Does it check numerically?

Try to implement the following reaction:

|                 Kb         K2
|        A + B <======> C -------> D
|                 Ku


NETLOGO FEATURES
------------------
It is a little tricky to ensure that a reactant never participates in two reactions simultaneously.  The turtle variable REACTING? is used to control this.  In the future, a primitive called GRAB may be added to NetLogo; then REACTING? won't be needed.


CREDITS AND REFERENCES
----------------------
Thanks to Mike Stieff for his work on this model.

To refer to this model in academic publications, please use:  Wilensky, U. (1998).  NetLogo Simple Kinetics 1 model.  http://ccl.northwestern.edu/netlogo/models/SimpleKinetics1.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 1998 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/SimpleKinetics1 for terms of use.
"
Weak Acid,/models/Sample Models/Chemistry & Physics/Chemical Reactions/Acids and Bases,"breed [waters water]            ;; water molecules
breed [hydroniums hydronium]    ;; hydronium ions (green)
breed [hydroxides hydroxide]    ;; base molecules (red)
breed [acids acid]              ;; parent acid molecules (yellow)
breed [conj-bases conj-base]    ;; conjugate base molecules of parent acid (orange)


globals [
  pH
  Ka             ;; variable for acid reactions
  base-added     ;; use to keep track of how much total base has been added
]

to setup
  clear-all
  set-default-shape waters ""molecule2""
  set-default-shape hydroniums ""molecule3""
  set-default-shape hydroxides ""molecule1""
  set-default-shape acids ""molecule2""
  set-default-shape conj-bases ""molecule1""
  set Ka 1.9
  create-acids vol-acid                 ;; adds parent acid molecules
    [ set color yellow ]
  ask acids
    [ if random-float 100.0 < Ka              ;; creates initial dissociated acid
        [ hatch-hydroniums 1
            [ set color green
              fd 3 ]
         set breed conj-bases                 ;; parent turtle turns into a conj-base
         set color orange ] ]
  create-waters (100 - count hydroniums)
    [ set color blue ]
  ask turtles                   ;; randomize position and heading of turtles
    [ setxy random-xcor random-ycor ]
  set base-added 0
  calculate-pH
  plot-pH
end

to go
  ask hydroxides [ react-hydroxide-hydronium ]
  ask hydroxides [ react-hydroxide-acid ]
  ask acids [ react-acid ]
  ask hydroniums [ react-hydronium ]
  ;; move turtles randomly around the world
  ask turtles
    [ fd 1
      rt random 10
      lt random 10 ]
  tick
  calculate-pH
  plot-pH
end

;; adds base molecules to the solution
to add-base
  create-hydroxides vol-base
    [ fd 1
      set color red ]
  set base-added base-added + vol-base
end

;; hydroxide procedure
to react-hydroxide-hydronium
  let partner one-of hydroniums-here     ;; tells hydroxide to recognize hydronium
  if partner != nobody              ;; if you are a hydroxide molecule and you encounter a hydronium
    [ ;; then turn yourself and the hydronium into water molecules
      set breed waters
      set color blue
      ask partner
        [ set breed waters
          set color blue ] ]
end

;; hydroxide procedure
to react-hydroxide-acid
  if random-float 100.0 < Ka                  ;; react with acid molecules according to the acid strength
    [ let partner one-of acids-here
      if partner != nobody              ;; if you are a hydroxide molecule and you encounter an acid molecule
        ;; then turn the hydroxide into a conjugate base molecule
        ;; and turn yourself into a water molecule
        [ set breed waters
          set color blue
          ask partner
            [ set breed conj-bases
              set color orange ] ] ]
end

;; acid procedure
to react-acid
  if random-float 100.0 < Ka                  ;; acid molecules may dissociate to hydronium depending on their Ka
    [ let partner one-of waters-here
      if partner != nobody              ;; if you are an acid molecule and you encounter a water molecule
        ;; then turn the water molecule into a hydronium molecule
        ;; and turn yourself into a conjugate base molecule
        [ set breed conj-bases            
          set color orange
          ask partner
            [ set breed hydroniums 
              set color green ] ] ]
end

;; hydronium procedure
to react-hydronium
  if random-float 100.0 < Ka                  ;; hydronium molecules may recombine with conjugate base to form acid
    [ let partner one-of conj-bases-here
      if partner != nobody              ;; if you are a hydronium molecule and you encounter a conjugate base molecule
      ;; then turn the conjugate base molecule into an acid molecule
      ;; and turn yourself into a water molecule
        [ set breed waters
          set color blue
          ask partner
            [ set breed acids
              set color yellow ] ] ]
end

;; calculates the pH from the amount of the various ions in solution;
;; note that for simplicity the calculations don't take the true molar
;; concentration of water into account, but instead use an arbitrarily
;; chosen factor of 1000 to produce numbers lying in a reasonable range
to calculate-pH
  let volume count turtles
  let concH (count hydroniums / volume)
  let concOH (count hydroxides / volume)
  ifelse (concH = concOH)
    [ set pH 7 ]
    [ ifelse (concH > concOH)
      [ set pH (- log (concH / 1000) 10) ]
      [ let pOH (- log (concOH / 1000) 10)
        set pH 14 - pOH ] ]
end

;; plotting procedures

to plot-pH
  set-current-plot ""pH Curve""
  plot pH
end

to record-pH
  set-current-plot ""Titration Curve""
  plotxy base-added pH
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2001 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2001).  NetLogo Weak Acid model.
; http://ccl.northwestern.edu/netlogo/models/WeakAcid.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2001 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/WeakAcid
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model demonstrates the differences in the calculation of pH when evaluating a weak acid in solution. It is best viewed as the second model in the ACID-BASE package. Unlike a strong acid, a weak acid has a very low Ka (or acid dissociation constant). Consequently, very little of the acid is dissociated into hydronium ions and conjugate base as seen in the following reaction.

|                        1%         +    -
|        H-A  + H O  <========>  H O  + A
|                2                3

Because so little hydronium ion is present, the pH of the solution cannot be calculated directly from the initial concentration of acid. Though the equation for calculating the pH is identical to that for a strong base,

|                           +
|            pH = - log [H O]
|                         3

we must first calculate the amount of hydronium ion present in the solution. This amount is dependent on the Ka of the acid. Each acid has a unique Ka, which indicates the probability that an acid molecule will react with a water molecule to form a hydronium ion and an anion. The anion in such a reaction is known as the conjugate base of the original acid. Though the term conjugate base may seem strange, it makes sense if you look at the chemical equation above. There A- is the conjugate base of H-A because it can take a proton from the hydronium ion to generate the original acid.

This model models the composition of a weakly acidic solution and allows the user to observe how altering the species in solution affects the pH. In the model, the dissociation constant Ka, is much higher than the real Ka for an acid. In fact, the model uses the following formula to convert he real-world Ka into a simulated Ka for the model:

|    Ka for MODEL = 11 - pKa (pKa = - log (real-world Ka)


HOW TO USE IT
--------------
Decide how much acid should be present at the start of the simulation with the VOL-ACID slider and press SETUP. Turtles will distribute randomly across the world. BLUE turtles represent water molecules, GREEN turtles represent hydronium ions, YELLOW turtles are acid molecules, and finally ORANGE turtles are conjugate base molecules. A set amount of water molecules is added each time to the solution. In this model we are using the Ka of acetic, which means that approximately 1% of the original acid molecules are dissociated into 1 conjugate base molecule and 1 hydronium molecule.

Press GO. The turtles will move randomly across the world and the pH of the solution will by plotted over time on the pH Curve and displayed in the pH monitor.

Observe the effect of adding RED base molecules to the solution by setting the volume of base with the VOL-BASE (mL) slider and pressing ADD-BASE.

At any time while go is depressed, RECORD-PH can be pressed to plot the pH versus the amount of base added on the Titration Curve.


THINGS TO NOTICE
----------------
Observe how the pH curve changes over time with the addition of base. How is this curve different from that seen in the strong acid model? Plot a titration curve and compare it with a strong acid.

Does the value of VOL-BASE affect the titration curve in any way? Is this different from the relationship between strong acids and strong bases?

Why are the base molecules not reacting with the water molecules? Does it matter?


THINGS TO TRY
-------------
Notice that the pH of the solution seems to be an average rather than a constant. Can you explain this?

Start the model with various amounts of acid. How does this affect the titration curve? Is there any difference in the endpoint of the reaction?

Keep adding base until the pH rises to about 10. Notice the breeds of turtles present. How does the pH depend on the molecules present?

Notice that in our models acid molecules react with base molecules based on the value of Ka. Make a slider so that you can alter this value. Observe how the system changes with regard to this variable. Is your pH between 0-14?

WARNING: We have established a constant for Ka in the procedures window. You must remove that constant when you replace it with a slider of the same name.


EXTENDING THE MODEL
------------------
Notice that the code requires hydroxide molecules to first react with hydronium molecules on a patch before they react with acid molecules. This is because hydroxide and hydronium react much more rapidly than hydroxide does with a weak acid. Reverse the code and observe the effect on the system.

Alter the code so that base turtles only react with hydronium molecules. What effect is observed? What additional changes do you need to make so that the pH continues to rise with the addition of base?

Increase the dissociation percentage so that more hydronium ions are generated at setup. What does this do to the pH? Can you predict what the Ka of a strong acid might be?

Try using the various pKa values listed below to determine the endpoint of each weak acid.

|    weak acid   Ka              pKa  Ka for model
|    ---------------------------------------------
|    HCN         1.26 x 10^-9    9.1      1.9
|    HOAc        1.8 x 10^-5     4.8      6.2
|    H2CO3       3.16 x 10^-7    6.5      4.5
|    HCO2H       2.0 x 10^-4     3.7      7.3


NETLOGO FEATURES
------------------
Notice the large number of breeds used in this model. Because of the complex interactions between molecules in a weakly acidic solution, it is necessary to separate turtles according to their identity. This allows each breed of turtle to follow unique instructions, which allows the model to simulate the complexity of molecular interactions.


CREDITS AND REFERENCES
----------------------
Thanks to Mike Stieff for his work on this model.

To refer to this model in academic publications, please use:  Wilensky, U. (2001).  NetLogo Weak Acid model.  http://ccl.northwestern.edu/netlogo/models/WeakAcid.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2001 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/WeakAcid for terms of use.
"
Strong Acid,/models/Sample Models/Chemistry & Physics/Chemical Reactions/Acids and Bases,"breed [ waters water ]          ;; water molecules
breed [ hydroxides hydroxide ]  ;; base molecules
breed [ hydroniums hydronium ]  ;; acid molecules

globals [
  pH
  base-added    ;; use to keep track of how much total base has been added
]

to setup
  clear-all
  set-default-shape waters ""molecule2""
  set-default-shape hydroniums ""molecule3""
  set-default-shape hydroxides ""molecule1""
  create-waters 100           ;; creates constant volume of water in which to dilute acid
    [ set color blue ]
  create-hydroniums vol-acid  ;; creates VOL-ACID of hydronium ions
    [ set color green ]
  ask turtles                       ;; randomize position and heading of turtles
    [ setxy random-xcor random-ycor ]
  set base-added 0
  calculate-pH
  plot-pH
end

to go
  ask hydroxides [ react ]
  ask turtles
    [ fd 1                                        ;; move turtles around randomly
      rt random 10
      lt random 10 ]    ;; around the world
  tick
  calculate-pH
  plot-pH
end

;; adds hydroxide molecules to the solution
to add-base
  create-hydroxides vol-base
    [ set color red
      fd 1 ]
  set base-added base-added + vol-base
end

;; hydroxide procedure
to react
  let partner one-of hydroniums-here   ;; see if there are any hydroniums here
  if partner != nobody                 ;; if one is found
    [ set breed waters                 ;; become water
      set color blue
      ask partner
        [ set breed waters             ;; partner becomes water too
          set color blue ] ]
end

;; calculates the pH from the amount of the various ions in solution;
;; note that for simplicity the calculations don't take the true molar
;; concentration of water into account, but instead use an arbitrarily
;; chosen factor of 1000 to produce numbers lying in a reasonable range
to calculate-pH
  let volume count turtles
  let concH (count hydroniums / volume)
  let concOH (count hydroxides / volume)
  ifelse (concH = concOH)
    [ set pH 7 ]
    [ ifelse (concH > concOH)
      [ set pH (- log (concH / 1000) 10) ]
      [ let pOH (- log (concOH / 1000) 10)
        set pH 14 - pOH ] ]
end

;; plotting procedures

to plot-pH
  set-current-plot ""pH Curve""
  plot pH
end

to record-pH
  set-current-plot ""Titration Curve""
  plotxy base-added pH
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2001 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2001).  NetLogo Strong Acid model.
; http://ccl.northwestern.edu/netlogo/models/StrongAcid.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2001 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/StrongAcid
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model demonstrates how chemists and biologists measure the pH of a solution. The value of pH, like many other chemical measurements, emerges from the interactions and relative ratios of the composite molecules within a solution.

Specifically, pH is a measurement of the amount of hydronium ions (H+ or H3O+) that are present in a solution. Hydronium ions are generated when an acid molecule donates a proton to the a water molecule. Bases have the opposite effect on water -- they take a hydrogen from a water molecule and generate hydroxide ions (OH-). These two reactions are listed below. Note the balance of charge and conversion of atoms. H-A denotes a strong acid and B denotes a strong base.

|                          +   -                          -     +
|     H 0 + H-A --------> H O + A     B + H O --------> OH + H-B
|      2                       3                   2

It is important to note that this model simulates a strong acid and a strong base interacting. Acids and bases that are classified as strong dissociate completely in water. That means that all the H-A is converted to hydronium ions and all of the B is protonated, so that concentration of the original acid is equal to the concentration of hydronium ion. pH meters are capable of detecting how many hydronium ions or hydroxide ions are present in a solution. The formula for measuring pH is listed below. One can also calculate the pOH in a similar manner. [] indicates concentration in MOLARITY.

|        pH = -log [H+]                  pOH = -log [OH-]

Hydronium ions and hydroxide ions are oppositely charged and react readily together. When they react, a hydrogen atom is transferred and two water molecules are generated in the process. Chemists often titrate acids and bases together to determine how stable the pH of a particular acid or base is. This experiment is done by taking a known amount of acid and adding various amounts of base to it. The titration curve is generated by plotting the pH against the volume of base added.


HOW TO USE IT
--------------
Decide how much acid should be present at the start of the simulation with the VOL-ACID slider and press SETUP. Turtles will be distributed randomly across the world. BLUE turtles represent water molecules and GREEN turtles represent hydronium ions. A set amount of water molecules is added each time to the solution.

Press GO. The turtles will move randomly across the world and the pH of the solution will be plotted over time and displayed in the pH monitor.

To observe the effect of adding base to the solution, set the volume of base to be added with the VOL-BASE slider and press ADD-BASE to add the red base molecules.

To perform a titration experiment, set the sliders to desired values and press GO. While the model is running, press ADD-BASE. This will add VOL-BASE to the acid in the world. Wait for the pH to stabilize as you would in a real experiment and then press RECORD-PH. A point is then plotted on the curve with each addition of base so that the user can observe how the value of pH is related to the amount of base added to the solution.


THINGS TO NOTICE
----------------
Observe the shape of the titration curve, especially where the slope approaches one. Can you explain this phenomenon?

What are the minimum and maximum values of pH in this model? Can you think of a way to alter their values?

Why are there no acid molecules in the simulation? Similarly, why aren't A and H-B shown in the model?


THINGS TO TRY
-------------
Plot a titration curve using various settings of VOL-BASE. How does this affect the titration curve? Is it more advisable to use large or small amounts of base? Should you use constant amounts of base?

Hit ADD-BASE a few times and observe the pH vs. time plot. Do you feel this is a useful plot for experiments? What does it tell you?

Can you alter the pH of the solution without adding base to the solution?


EXTENDING THE MODEL
-------------------
The code currently generates two water molecules every time a hydronium and hydroxide molecule collide. Alter the code to generate behavior for hydroxide and water collision, according to the chemical equation above. How does this change the model?

What if only one water molecule were generated and the hydroxide molecule were destroyed when the two collided? How would this affect the pH?

Add a button to add more acid to the solution at any point in time, can you use it to adjust the pH to a target value?


NETLOGO FEATURES
----------------
Notice that in the calculate-pH procedure the model makes use of the COUNT primitive and some math to convert the number of turtles in the world into concentrations like those seen in the laboratory.


CREDITS AND REFERENCES
----------------------
Thanks to Mike Stieff for his work on this model.

To refer to this model in academic publications, please use:  Wilensky, U. (2001).  NetLogo Strong Acid model.  http://ccl.northwestern.edu/netlogo/models/StrongAcid.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2001 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/StrongAcid for terms of use.
"
Diprotic Acid,/models/Sample Models/Chemistry & Physics/Chemical Reactions/Acids and Bases/Unverified,"breed [acids acid]           ;; acid molecules (yellow)
breed [hydroxides hydroxide] ;; base molecules (red)
breed [hydroniums hydronium]  ;; hydronium ions (green)
breed [waters water]         ;; water molecules (blue)
breed [con-bases con-base]   ;;first conjugate base molecules (magenta)
breed [con-base2s con-base2] ;;second conjugate base molecules (cyan)

globals
  [
   pH pOH                                         ;;variables for calculating pH
   mmolH mmolOH mmolA mmolA2 mmolHA               ;;variables for calculating amount of molecules
   Hconc OHconc Aconc HAconc A2conc volume        ;;variables for calculating concentrations
  ]

turtles-own [partner]                                  ;;variable to control reactions

to setup
  clear-all
  set-default-shape waters ""water""
  set-default-shape hydroniums ""hydronium""
  set-default-shape hydroxides ""hydroxide""
  set-default-shape acids ""acid""
  set-default-shape con-bases ""conbase""
  set-default-shape con-base2s ""conbase2""
  ;;creates variable amount of acid
  create-acids starting-acid
  ;;initializes the amount of dissociated acid
  ask acids
    [
     if ((random 100) > (99 - Ka1))
      [
       hatch-hydroniums 1 [fd 3]
       set breed con-bases
      ]
    ]
  ;;initializes the amount of dissociated conjugate base
  ask con-bases
    [
     if ((random 100) > (99 - Ka2))
      [
       hatch-hydroniums 1 [fd 3]
       set breed con-base2s
      ]
    ]
  if see-starting-water?
    [ create-waters (100 - (count hydroniums)) ]
  calculate-ions    ;;used to calculate pH
  set-colors    ;;assigns colors
  set mmolOH 0
  ;; calculates overall number of molecules (total volume)
  set volume count turtles
  ;;randomizes position and headings
  ask turtles [setxy random-xcor random-ycor]
  plot-molecules
  plot-ph
end

to go ;;main turtle procedure
  collide
  set-colors
  ask turtles [fd 1]
  calculate-ions
  tick
  if (ticks > 30) [plot-pH plot-molecules]
end


to collide ;;turtle procedure - tells molecules how to find other molecules
  ;; hydroxide molecules will react with all proton donor molecules in the model
  if (count hydroxides > 0)
    [
     ask hydroxides
       [
        if any? hydroniums-here [set partner one-of hydroniums-here react-bases]
        if any? acids-here [set partner one-of acids-here react-bases]
        if any? con-bases-here [set partner one-of con-bases-here react-bases]
       ]
    ]

  ;; acid molecules always have a chance to dissociate to hydroniums depending on their
  if (count acids > 0)
    [
     ask acids
       [
        if ((random 100) > (99 - Ka1))
          [if any? waters-here [set partner one-of waters-here react-acids]]
       ]
    ]

  ;; conjugate base molecules always have a chance to dissociate to hydroniums depending on their Ka
  if count con-bases > 0
    [
      ask con-bases
        [
         if ((random 100) > (99 - Ka2))
           [if any? waters-here [set partner one-of waters-here react-bases]]
        ]
    ]

  ;; hydroniums molecules always have a chance to recombine with conjugate base to form acid
  if count hydroniums > 0
    [
     ask hydroniums
          [
           if ((random 100) > Ka1)
             [if any? con-bases-here [set partner one-of con-bases-here react-acids]]
          ]
    ]

  ;; hydroniums molecules can also recombine with the second conjugate base to form conjugate base
  if count hydroniums > 0
    [
     ask hydroniums
            [
             if ((random 100) > Ka2)
               [if any? con-base2s-here [ set partner one-of con-base2s-here react-acids ]]
            ]
    ]
end

to set-colors ;;turtle procedure to assign graphics
  ask waters [set color blue]
  ask hydroniums [set color green]
  ask acids [set color yellow]
  ask con-bases [set color magenta]
  ask con-base2s [set color cyan]
  ask hydroxides [set color red]
end

to react-bases ;;turtle procedure that tells base molecules how to react

;; all hydroxide molecules will instantly react with hydroniums molecules
  if [breed] of partner = hydroniums
    [set breed waters
     ask partner [ set breed waters ]]

;; hydroxide molecules have a high probability of reacting with acid molecules
  if [breed] of partner = acids
    [if ((random 100) > (99 - Ka1)) [set breed waters
                                     ask partner [set breed con-bases]]]

;; hydroxide molecules have a low probablity of reacting with conjugate base
  if [breed] of partner = con-bases
    [if ((random 100) > (99 - Ka2)) [set breed waters
                                     ask partner [set breed con-base2s]]]

;; conjugate base molecules react with water to form hydroniums and con-base2
  if [breed] of partner = waters
    [set breed con-base2s
     ask partner [set breed hydroniums]]
end


to react-acids ;;turtle procedure that tells acid turtles how to react

;;acid molecules react with water to form hydroniums and con-base
if [breed] of partner = waters
  [set breed con-bases
   ask partner [set breed hydroniums]]

;;hydroniums molecules react with con-base to form acid and water
if [breed] of partner = con-bases
  [set breed waters
   rt random 360 fd 2
   ask partner [set breed acids]]

;;hydroniums molecules react with con-base2 to form con-base and water
if [breed] of partner = con-base2s
  [set breed waters rt random 360 fd 2
   ask partner [set breed con-bases]]
end


;; calculates variables for determining the pH
to calculate-ions
  set mmolH count hydroniums
  set mmolOH count hydroxides
  set mmolA count con-bases
  set mmolHA count acids
  set mmolA2 count con-base2s
  set volume count turtles
  set Hconc (mmolH / volume)
  set OHconc (mmolOH / volume)
  set Aconc (mmolA / volume)
  set A2conc (mmolA2 / volume)
  set HAconc (mmolHA / volume)
  calculate-pH
end


;; calculates the pH from the amount of the various ions in solution;
;; note that for simplicity the calculations don't take the true molar
;; concentration of water into account; instead we simply divide by
;; a factor of 1000 to bring the numbers into a reasonable range.
;; Above the endpoint, the pH is calculated as a strong acid.
to calculate-pH
  let concH 0
  let concOH 0
  set concH (count hydroniums / volume)
  set concOH (count hydroxides / volume)
  ifelse (concH = concOH)
    [ set pH 7 ]
    [ ifelse (concH > concOH)
      [ set pH (- log (concH / 1000) 10) ]
      [ set pOH (- log (concOH / 1000) 10)
        set pH 14 - pOH ] ]
end

;; adds more base to the system
to add-base
  create-hydroxides base-added
    [
     fd 1
    ]
  set-colors
end

;; plotting procedures

to record-pH
  set-current-plot ""Titration Curve""
  set-plot-pen-interval base-added
  ; before next plotting, move along x-axis by magnitude of amount added
  plot pH
end

to plot-pH
  set-current-plot ""pH Curve""
  plot pH
end

to plot-molecules
  set-current-plot ""Molecule Counts""
  set-current-plot-pen ""con-base""
  plot count con-bases
  set-current-plot-pen ""acid""
  plot count acids
  set-current-plot-pen ""hydroxide""
  plot count hydroxides
  set-current-plot-pen ""hydronium""
  plot count hydroniums
  set-current-plot-pen ""water""
  plot count waters
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2005 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2005).  NetLogo Diprotic Acid model.
; http://ccl.northwestern.edu/netlogo/models/DiproticAcid.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2005 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/DiproticAcid
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This is the fourth model of the Acid-Base subsection of  the Connected Chemistry models. It is best explored after the Strong Acid, Weak Acid, and Buffer models. In this model, we have yet another variant on determining the pH of a solution.  This model depicts a diprotic acid, or an acid which can donate two atoms of hydrogen to a base.

The value of pH, like many other chemical measurements, emerges from the interactions and relative ratios of the composite molecules within a solution. Specifically, pH is a measurement of the amount of hydronium ions (H+ or H3O+) that are present in a solution. Hydronium ions are generated when an acid molecule donates a proton to a water molecule. Bases have the opposite effect on water -- they take a hydrogen atom from a water molecule and generate hydroxide ions (OH-). The chemical reaction is shown below (for more detailed explanations about pH and acid-base reactions, please check the three aforementioned models).

|                      Ka1      +      -  Ka2      +    2-
|        H A  +  2H O  -->   H O  + H-A   -->  2H O  + A
|         2        2          3                  3

We can see that the first proton is donated to water to make a hydronium ion. After the initial acid is consumed, the second proton is donated to form a second molecule of hydronium ion. It is important to note that the Ka of the first proton is much greater than the second Ka. This is because the loss of the first proton generates a negatively charged anion. It is very difficult for bases which have a negative charge or a high electron density to come in close proximity to this anion and pull off the second proton. Because of this, the first proton is most often consumed before the second proton can be donated. The pH for the reaction is determined using the Henderson-Hasselbach equation in two separate instances. While the original acid (H2A) is present, the pH is determined by:

|                                    -
|                pH = pK1 + log ([H-A ] / [H A])
|                                           2

Once the weak acid is depleted, the pH is then determined by:

|                                  2-       -
|                pH = pK2 + log ([A ] / [H-A ])

The model uses a short-cut equation to approximate the pH of the solution. The equation, which can be used for each pK value of a polyprotic acid, transforms the above two equations into the following, respectively.

|                pH = 0.5 * (pK1 + log ([HA])
|                pH = 0.5 * (pK2 + log ([A])


HOW TO USE IT
--------------
Decide how much acid should be present at the start of the simulation with the STARTING-ACID slider and press SETUP. Turtles will distribute randomly across the view. BLUE turtles represent water molecules, GREEN turtles represent hydronium ions, YELLOW turtles are acid molecules, and finally MAGENTA turtles are conjugate base molecules. A set amount of water molecules is added each time to the solution. In this model we are using the Ka of acetic acid, which means that approximately 1% of the original acid turtles are dissociated into one conjugate base molecule and one hydronium molecule.

Press GO. The turtles will move randomly across the view and the pH of the solution will be plotted over time on the pH Curve and displayed in the pH monitor. Also, you will see the counts of all the molecules present in the solution in the Molecule Counts plot

Observe the effect of adding base to the solution by setting the volume of base with the BASE-ADDED slider and pressing ADD BASE.

When the pH remains at a steady value, press RECORD-PH, which will plot the pH versus the amount of bases added on the titration curve.


THINGS TO NOTICE
----------------
Run a titration and observe the curve. Is there anything unique about its shape?

Look for light blue (cyan) anions in the solution. How much base does it take before you start seeing them? Is this surprising?

Pay attention to how the molecules interact. Which molecules react with each other?


THINGS TO TRY
-------------
Compare the titration curve of the diprotic acid with that of a buffer. Do you see any similarities? How can you alter the code to test if this diprotic acid acts as a buffer?

Increase the dissociation percentage so that more hydronium ions are generated at setup. What does this do to the pH? Is the Henderson-Hasselbach equation still valid with a large Ka?

Notice that the code requires hydroxide molecules to first react with hydronium molecules on a patch before they react with acid molecules. Can you explain why this is? Reverse the code and observe the effect on the system.

Can you alter the pH of the solution without adding base to the solution?


EXTENDING THE MODEL
------------------
Alter the code so that base turtles only react with hydronium molecules. What effect is observed? What additional changes do you need to make so that the pH continues to rise with the addition of base?

Substitute the short-cut equation for calculating pH with the full equation. Are the values similar?

Try substituting the various pKa values below into the Henderson-Hasselbach equation and observe their effect on the titration curve. What affect does this have on the pH?

|        weak acid       pK1             pK2
|        ---------       ----            ----
|        carbonic        6.5             10.2
|        oxalic          1.27            4.27
|        glycine         2.34            9.60
|        maleic          2.00            6.20


RELATED MODELS
--------------
Strong Acid
Weak Acid
Buffer


NETLOGO FEATURES
----------------
Notice that in the calculate-pH procedure the model makes use of the COUNT primitive to convert the number of turtles in the world into concentrations that are often used in the chemistry laboratory.


CREDITS AND REFERENCES
----------------------
Thanks to Mike Stieff for his work on this model.

To refer to this model in academic publications, please use:  Wilensky, U. (2005).  NetLogo Diprotic Acid model.  http://ccl.northwestern.edu/netlogo/models/DiproticAcid.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2005 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/DiproticAcid for terms of use.
"
Buffer,/models/Sample Models/Chemistry & Physics/Chemical Reactions/Acids and Bases,"breed [waters water]             ;; water molecules
breed [hydroniums hydronium]     ;; hydronium ions (green)
breed [hydroxides hydroxide]     ;; base molecules (red)
breed [acids acid]               ;; parent acid molecules (yellow)
breed [conj-bases conj-base]     ;; conjugate base molecules of parent acid (orange)

globals [
  pH
]

to setup
  clear-all
  set-default-shape waters ""molecule2""
  set-default-shape hydroniums ""molecule3""
  set-default-shape hydroxides ""molecule1""
  set-default-shape acids ""molecule2""
  set-default-shape conj-bases ""molecule1""
  create-acids starting-acid  ;; creates variable amount of acid
    [ set color yellow ]
  ask acids [
    ;; initializes amount of dissociated acid
    if random-float 100 > 98
      [ dissociate ] ]
  if see-starting-water?
    [ create-waters 100    ;; creates constant volume of water
        [ set color blue ] ]
  create-conj-bases starting-conj-base  ;; creates variable amount of conjugate base
    [ set color orange ]
  ask turtles                   ;; randomize position and heading of turtles
    [ setxy random-xcor random-ycor ]
  calculate-pH
  plot-pH
end

;; dissociate an acid molecule into hydronium and conj-base
;; this should only be called by turtles that are acids
to dissociate  ;; turtle procedure
  hatch-hydroniums 1 [ set color green ]
  set breed conj-bases
  set color orange
end

to go
  ask hydroxides [ react-hydroxide ]
  ask hydroniums [ react-hydronium ]
  ;; move turtles randomly around the world
  ask turtles
    [ fd 1
      rt random 10
      lt random 10 ]
  tick
  calculate-pH
  plot-pH
  plot-molecules
end

to react-hydroxide  ;; hydroxide procedure
  let partner one-of hydroniums-here
  ifelse partner != nobody
    [ react partner ]
    [ set partner one-of acids-here
      if partner != nobody
        [ react partner ] ]
end

to react-hydronium  ;; hydronium procedure
  let partner one-of hydroxides-here
  ifelse partner != nobody
    [ react partner ]
    [ set partner one-of conj-bases-here
      if partner != nobody
        [ react partner ] ]
end

to react [ partner ]  ;; turtle procedure
  ;; all hydroxide molecules will instantly react with
  ;; hydronium molecules and form water
  ifelse ([breed] of partner) = hydroniums or ([breed] of partner) = hydroxides
    [ set breed waters
      set color blue
      ask partner
        [ set breed waters
          set color blue ] ]
    [ ;; hydroxide molecules have a high probability of
      ;; reacting with acid molecules
      ifelse ([breed] of partner) = acids
        [ if random-float 100 > 80
          [ set breed waters
            set color blue
            ask partner
              [ set breed conj-bases
                set color orange ] ] ]
        ;; hydronium ions will react with conjugate base to form acid
        [ if ([breed] of partner) = conj-bases
          [ if random-float 100 > 80
            [ set breed waters
              set color blue
              ask partner
                [ set breed acids
                  set color yellow ] ] ] ] ]
end

;; calculates the pH from the amount of the various ions in solution;
;; note that for simplicity the calculations don't take the true molar
;; concentration of water into account; instead we simply divide by
;; a factor of 1000 to bring the numbers into a reasonable range
to calculate-pH
  let volume count turtles
  let concH (count hydroniums / volume)
  let concOH (count hydroxides / volume)
  ifelse (concH = concOH)
    [ set pH 7 ]
    [ ifelse (concH > concOH)
      [ set pH (- log (concH / 1000) 10) ]
      [ let pOH (- log (concOH / 1000) 10)
        set pH 14 - pOH ] ]
end

;; add more base to the system
to add-base
  create-hydroxides added-base
    [ set color red
      fd 1 ]
end

;; add more acid to the system
to add-acid
  create-hydroniums added-acid
    [ set color green
      fd 1 ]
end

;; plotting procedures

to plot-pH
  set-current-plot ""pH Curve""
  plot pH
end

to plot-molecules
  set-current-plot ""Molecule Counts""
  set-current-plot-pen ""conj. base""
  plot count conj-bases
  set-current-plot-pen ""acid""
  plot count acids
  set-current-plot-pen ""hydroxide""
  plot count hydroxides
  set-current-plot-pen ""hydronium""
  plot count hydroniums
  set-current-plot-pen ""water""
  plot count waters
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2001 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2001).  NetLogo Buffer model.
; http://ccl.northwestern.edu/netlogo/models/Buffer.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2001 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Buffer
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model demonstrates the behavior of a buffered solution.  A buffer is a solution that resists change in pH when either acid or base are added into it, within limits.  It is best viewed as the third model in the ACID-BASE package.

Chemists and biologists use the properties of acids and bases to create buffer solutions.  It is often desirable to keep the acidity, or hydronium ion concentration of a solution, as nearly constant as possible.  Examples of such situation would be: measuring the velocity of a reaction, selectively dissolving certain salts, or studying the growth of bacteria or plants.   In our body, the blood has a buffering capacity, keeping the pH at 7.35.  If the pH goes above 7.7 (alkalosis) or below 7.0 (acidosis), the results are fatal.

To accomplish this feat, buffers depend on the presence of both a weak acid and its conjugate base. With both of these species in the solution, additional acids and bases are neutralized according to the following chemical equations. H-A denotes the weak acid and A- denotes its conjugate base.

|           -                      -           -       +
| H-A  +  OH     ----->   H O  +  A           A  +  H O    ------->   H O  +  H-A
|                          2                         3                 2

The pH of a buffer is determined in the same manner that the pH of a weak acid is determined - by counting the number of hydronium and hydroxide ions and calculating their ratio with total number of ions and molecules in the solution.

When there are more hydroniums,  pH = - log ( hydronium concentration )

When there are more hydroxides,  pH = 14 - pOH = 14 - log ( hydroxide concentration )

Buffers are effective only within their unique buffering range. This range is determined by the concentrations of the weak acid and its conjugate base.  Outside of its buffering range, the solution behaves as a strong acid or base.


HOW TO USE IT
--------------
Decide how many acid molecules should be present at the start of the simulation with the STARTING-ACID slider. Set the number of conjugate base molecules with the STARTING-CONJ-BASE slider.

Press SETUP.  The turtles will distribute randomly across the world.

YELLOW turtles are acid molecules (HA)
ORANGE turtles are conjugate base molecules (A-)
GREEN turtles represent hydronium ions (H30+)
RED turtles are hydroxide molecules (OH-)
BLUE turtles represent water molecules (H20)

In this model we are assuming that 2% of the original acid molecules are dissociated into 2 conjugate base molecules and 2 hydronium molecules.  This is true only before the molecules start interacting between themselves.

Press GO. The molecules will move randomly across the world.

When two turtles occupy the same patch, the following rules apply:
1.  When a weak acid and a water molecule collide, the acid molecule dissociates into its conjugate base and the water molecule transforms to a hydronium ion.
2.  When hydroxide and hydronium ions collide, they always form two water molecules.
3.  When a weak acid and hydroxide collide, they have a high probability of transforming into a conjugate base and a water molecule.
4.  When hydronium and conjugate base collide, they have a high probability of transforming into a weak acid molecule and a water molecule.

To observe the effect of adding base or acid to the solution, set the number of acid molecules you want to add with the ADDED-ACID slider and press ADD-ACID (H30+)
Do the same for adding base with the ADDED-BASE slider and ADD-BASE button.

A number of plots and monitors can be observed:
The pH of the solution is plotted over time on the PH plot, and at each time tick on the PH monitor.  pH is calculated using the ratio of the number of hydronium and hydroxide molecules to the total number of turtles.  This is different from the chemistry calculation that relates this number to solution volume.
You can see the number of hydroniums and hydroxides in the solution in their monitors  (# HYDRONIUMS, # HYDROXIDES).
You may follow the number of molecules of each species over time in the MOLECULE COUNTS plot.

You may choose to see the initial water molecules or not with the SEE-STARTING-WATER? switch.


THINGS TO NOTICE
----------------
After you press SETUP, the buffer solution is not yet in equilibrium.  After the model starts running, the molecules react until the system is equilibrated, and the pH doesn't change anymore.

Observe the pH curve.  How are the numbers of hydronium and hydroxide molecules in the monitors below related to the pH?

Examine the shape of the pH curve. Notice how the pH changes with respect to the amount of base or acid added. Does the buffer resist change in pH?

Observe the number of molecules in the plot.   When acid or base is added to the solution, they quickly disappear as they react. Can you determine which molecules react with each other?  What is the relationship between the two plots: pH and number of molecules?

What happens when large amounts of base or acid are added to the system?  Is it the same as adding small amounts?  Does the pH curve reflect this?


THINGS TO TRY
-------------
Add a large amount of acid or base to the solution and observe the effect.  Why does the pH change dramatically outside of the buffering range?  Would it be useful to add large amounts of base all at once to a solution in the laboratory if you were trying to adjust the pH?

Can you relate the idea of a ""buffering range"" to the molecules and their behavior in the model?

Try running the model with different amounts of acid or conjugate base.  The buffering range of the solution should shift.  How is the shift related to the changes you made?  Does changing the proportion between the number of weak acid and conjugate base molecules have an effect on the buffering capacity?

How does changing the amount of buffer molecules influence the buffering capacity?

Try pressing SETUP a number of times with the same initial settings, and observe the number of hydroniums.  Is the number always the same?  Press GO and watch the change in pH.  Why is the same equilibrium reached in each case?


EXTENDING THE MODEL
------------------
Increase the amount of hydronium originally generated upon SETUP by increasing the chance of dissociation in the procedures.  What effect does this have on the initial pH?

Add a button and procedure to add more conjugate base to the reaction.  How could this help a chemist who is trying to keep the pH of a solution at a constant value?

Add a procedure that allows you to plot a titration curve for a buffer.  Is it similar to any other titration curves you have seen?  What additional information can you learn from the titration curve?

Additional interactions could take place in a solution in addition to those stated in the rules.  These were omitted because their probability of occurring is low.  Try including one of these rules to the procedure.  For example, two water molecules could transform into a hydronium and hydroxide ions.  Does it make a change?


CREDITS AND REFERENCES
----------------------
Thanks to Mike Stieff for his work on this model.

To refer to this model in academic publications, please use:  Wilensky, U. (2001).  NetLogo Buffer model.  http://ccl.northwestern.edu/netlogo/models/Buffer.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2001 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Buffer for terms of use.
"
Simple Kinetics 2,/models/Sample Models/Chemistry & Physics/Chemical Reactions,"breed [reactants reactant]     ;; reactant molecules (NO2), shown as green
breed [products product]       ;; product molecules (N2O4), shown as red

globals [
  Kf                 ;; when temp-effect is on, replaces Kb
  Kr                 ;; when temp-effect is on, replaces Ku
  Keq                ;; equilibrium constant
  react-conc         ;; concentration of reactant
  prod-conc          ;; concentration of product
  black-patches      ;; agentset of all the patches inside the reaction container
]

to setup
  clear-all
  set-default-shape reactants ""NO2""
  set-default-shape products ""N2O4""
  draw-box                                 ;; draws the reaction container
  create-reactants 200                     ;; generates reactants
    [ set color green
      move-to one-of black-patches ]       ;; distribute reactants around the world
  update-concentrations
  do-plotting
end

to update-concentrations
  set react-conc (count reactants / count black-patches) * 100
  set prod-conc (count products / count black-patches) * 100
end

to go
  ifelse temp-effect?
    ;; if temp-effect is ON, Kf  replaces Kb and Kr replaces Ku
    ;; Kf and Kr are calculated with the Arrhenius Equation, k = ln A - Ea / RT .
    ;; ln A, Ea, and R are all constants for a reaction. Below, the constants have simulated
    ;; values that were chosen to produce the same qualitative results as the real-world
    ;; reaction. Because the number of molecules in the model is so small, we use simulated
    ;; constants to keep the values of each variable in a useful range for the model.
    ;; The important thing to note is how each K value varies according to the
    ;; temperature of the reaction.
    [ set Kf (5 + (3000 /(8 * (temp + 273))))
      set Kr (15 - (8000 / (8 * (temp + 273)))) ]
    ;; if temp-effect is OFF, set Keq based on concentrations
    [ set Keq (prod-conc / (react-conc ^ 2)) * 100 ]
  ask turtles
    [ bounce                        ;; bounce off walls
      fd 1                          ;; wander aimlessly
      rt random 10
      lt random 10 ]
  ask reactants
    [ react-forward ]
  ask products
    [ react-backward ]
  update-concentrations
  tick
  do-plotting
end

;; see explanations of ""react-forward"" and ""react-backward"" in the info window

to react-forward  ;; turtle procedure
  let chance 0
  ifelse temp-effect?
    [ set chance Kf ]   
    [ set chance Kb ]
  if (any? other reactants-here) and (random-float 10.0 < chance)
    [ ask one-of other reactants-here
        [ set breed products
          set color red ]
      die ]
end

to react-backward  ;; turtle procedure
  let chance Ku
  if temp-effect?
    [ set chance Kr ]
  if random-float 1000.0 < chance
    [ set breed reactants
      set color green
      hatch 1
        [ rt 180 ] ]
end

;; turtle procedure to bounce molecules off the yellow walls
to bounce
  let box-edge edge-size + 1  ;; setting this first makes the calculations a bit simpler
  ; check: hitting top or bottom wall?
  if (patch-at 0 box-edge = nobody     and ((heading > 270) or (heading < 90))) or
     (patch-at 0 (- box-edge) = nobody and ((heading > 90) and (heading < 270)))
    ; if so, reflect heading around y axis
    [ set heading (180 - heading) ]
  ; check: hitting left or right wall?
  if (patch-at box-edge 0 = nobody     and ((heading > 0) and (heading < 180))) or
     (patch-at (- box-edge) 0 = nobody and ((heading > 180)))
    ; if so, reflect heading around x axis
    [ set heading (- heading) ]
end

;;observer procedures to add more molecules to the model
to add-reactant
  create-reactants 20
    [ set color green
      move-to one-of black-patches ]
end

to add-product
  create-products 20
    [ set color red
      move-to one-of black-patches ]
end

;;;; plotting procedures

to do-plotting
  set-current-plot ""Concentrations""
  set-current-plot-pen ""Reactant""
  plot react-conc
  set-current-plot-pen ""Product""
  plot prod-conc
end

to draw-box
  ask patches
    [ ifelse (pxcor > (max-pxcor - edge-size)) or (pxcor < (min-pxcor + edge-size)) or
             (pycor > (max-pycor - edge-size)) or (pycor < (min-pycor + edge-size))
        [ set pcolor yellow ]
        [ set pcolor black ] ]
  set black-patches patches with [pcolor = black]
  ask turtles
  [
    move-to one-of black-patches
    rt random-float 360
  ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2001 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2001).  NetLogo Simple Kinetics 2 model.
; http://ccl.northwestern.edu/netlogo/models/SimpleKinetics2.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2001 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/SimpleKinetics2
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model demonstrates the properties of LeChatelier's Principle. This chemical principle states that if a system that is at equilibrium is perturbed, the system will readjust to establish a new equilibrium. For example, if you add reactants to a reversible reaction that is at equilibrium, the system will shift to generate more products and establish a new equilibrium. The principle can also be described with chemical equations.

Below is a generic equation which depicts two molecules of reactant A combining to form one molecule or product B. The reaction is reversible, meaning that the one molecule of B can break down into two molecules of A.

|                  Kb
|        A + A <=======> B
|                  Ku

An example of such a reaction would be dimerization of the gas nitrous oxide:

|                  Kb
|        2 NO  <=======> N O
|            2     Ku     2 4

This reaction is an example of a complex reaction which consists of two elementary reactions.  The forward bimolecular reaction

|                 Kb
|        A + A --------> B

is characterized by the constant Kb and the reverse unimolecular reaction

|              Ku
|        B ---------> A + A

The equilibrium rate constant for the entire reaction (Keq) is equal to [B] / [A] ^ 2. Each of the rate constants in the equations above has units of s^-1. They are empirically derived constants that when combined with the reaction concentrations tell you how fast the reaction proceeds according to the reaction rate law. The rate law ultimately tells you how many Molar units of a molecule react per second. For the reaction above the forward rate law is RATE = Kb[A]^2 and the reverse rate law is RATE = Ku[B].

Note that because we are simulating the reaction, the values of Kb and Ku in this reaction are not real-world values.  It would be necessary to use several differential equations to calculate the real values of Kb, Ku and Keq, however, several qualitative features of their relationships can be seen using this model. Reaction equilibrium is reached when a system reaches a steady-state. This is not to say that reactions have stopped occurring!  Microscopic changes in equilibrium still take place, but to our eyes and our measurements the system appears stable because the forward and reverse rates are equal.

The rate at which a reaction reaches equilibrium as well as the state of the equilibrium system both depend upon the rate constants, the temperature, the concentration of reactants and products and, when a gas is involved, the volume of the container. When a system has reached equilibrium, changes to any of the variables above result in a change in the system to establish a new equilibrium. This effect is predicted using LeChatelier's Principle. We can use our model to discover the role of each variable (temperature, volume, concentration and rate constant) in LeChatelier's Principle.


HOW TO USE IT
--------------
To start off:

Choose the values of Kb and Ku with appropriate sliders:
- Kb controls the rate of the forward reaction by which two green molecules turn bimolecularly into a single red molecule.
- Ku controls the rate of the reverse reaction, by which a red molecule turns unimolecularly into two green molecules.

Having chosen appropriate values of the constants, press SETUP to clear the world and create an initial number of green molecules.  Note: we do not create red molecules initially, although this can be done in principal.

Press RUN to start the simulation.

Set the size of the yellow box using the EDGE-SIZE slider. (If you would like to change the size while you are running a model. Press RUN to stop the model, adjust the EDGE-SIZE slider and redraw the box using the REDRAW BOX button. Resume the reaction by pressing RUN.)

After viewing the effects of several different rate constant values, use the other sliders and buttons to observe how concentration, volume, and temperature affect the equilibrium.

A note on the temperature variable. Temperature changes have a unique effect on equilibrium compared with the other variables. You can observe this effect by toggling the TEMP-EFFECT button on or off and using the slider to set the temperature of the reaction in centigrade.


THINGS TO NOTICE
----------------
You will see molecules wandering around the world and changing color.  Pay more attention to the plot of the concentrations.  Do the plots soon reach stationary concentrations?

How does changing the concentrations of reactants and products in the system affect the equilibrium? Does it take more or less time to reach a stationary condition under various conditions?

What is the effect of temperature on the equilibrium of the system compared to volume or concentration?  In the Procedures window, note how rate constants are calculated based on the temperature.

Notice how the ratio of products to reactants changes with changes to the system. Does the ratio change much with each factor? Make a window that show the value of Keq to help you determine this.

Why do the traces of each breed eventual balance around a constant average? How come this value is an average and not a constant?


THINGS TO TRY
-------------
How do the stationary concentrations depend on the values of Kb and Ku?   You can change Ku and Kb while the model is running.   See if you can predict what the stationary concentrations will be with various combinations of Kb and Ku.

Without adding additional reactants or products and with the temperature effect in the off position, note that more red product molecules accumulate when the volume decreases.  Can you explain why?

Observe the progress of the reaction at high and low temperatures.  Does this observed trend fit your expectations?

Try adding some molecules to the system that have no ""breed"", as an inert gas. Does this affect the equilibrium? Why or why not?


EXTENDING THE MODEL
------------------
Try altering the code so that when two green molecules collide, they produce two red molecules instead of one. Likewise, alter it so that two red molecules must collide to form two green molecules. Observe the effect of volume on this system. Is the effect as you predicted?

What would the effect of adding a catalyst to the system be?  Add a catalyst breed that accelerates the reaction and observe the trend.  Are you surprised?

Add a monitor that measures the equilibrium constant for the system.  Is it really a constant?


RELATED MODELS
--------------
Simple Kinetics 1, Simple Kinetics 3.  Note that the original StarLogoT version of this model was named ""Le Chatelier 1"".


NETLOGO FEATURES
----------------
Notice the use of breeds in the model.

Notice how we store an agentset of patches in the BLACK-PATCHES variable.  Computing this agentset once ahead of time (at the time the box is drawn) is faster than recomputing it at every iteration.

It is a little tricky to ensure that a reactant never participates in two reactions simultaneously.  The turtle variable REACTING? is used to control this.  In the future, we will add a new primitive to NetLogo to make this easier.


CREDITS AND REFERENCES
----------------------
Thanks to Mike Stieff for his work on this model.

To refer to this model in academic publications, please use:  Wilensky, U. (2001).  NetLogo Simple Kinetics 2 model.  http://ccl.northwestern.edu/netlogo/models/SimpleKinetics2.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2001 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/SimpleKinetics2 for terms of use.
"
Small Worlds,/models/Sample Models/Networks,"turtles-own
[
  node-clustering-coefficient
  distance-from-other-turtles   ;; list of distances of this node from other turtles
]

links-own
[
  rewired?                    ;; keeps track of whether the link has been rewired or not
]

globals
[
  clustering-coefficient               ;; the clustering coefficient of the network; this is the
                                       ;; average of clustering coefficients of all turtles
  average-path-length                  ;; average path length of the network
  clustering-coefficient-of-lattice    ;; the clustering coefficient of the initial lattice
  average-path-length-of-lattice       ;; average path length of the initial lattice
  infinity                             ;; a very large number.
                                         ;; used to denote distance between two turtles which
                                         ;; don't have a connected or unconnected path between them
  highlight-string                     ;; message that appears on the node properties monitor
  number-rewired                       ;; number of edges that have been rewired. used for plots.
  rewire-one?                          ;; these two variables record which button was last pushed
  rewire-all?
]

;;;;;;;;;;;;;;;;;;;;;;;;
;;; Setup Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;

to startup
  set highlight-string """"
end

to setup
  ca
  set infinity 99999  ;; just an arbitrary choice for a large number
  set-default-shape turtles ""circle""
  make-turtles

  ;; set up a variable to determine if we still have a connected network
  ;; (in most cases we will since it starts out fully connected)
  let success? false
  while [not success?] [
    ;; we need to find initial values for lattice
    wire-them
    ;;calculate average path length and clustering coefficient for the lattice
    set success? do-calculations
  ]

  ;; setting the values for the initial lattice
  set clustering-coefficient-of-lattice clustering-coefficient
  set average-path-length-of-lattice average-path-length
  set number-rewired 0
  set highlight-string """"
end

to make-turtles
  crt num-nodes [ set color gray + 2 ]
  ;; arrange them in a circle in order by who number
  layout-circle (sort turtles) max-pxcor - 1
end

;;;;;;;;;;;;;;;;;;;;;;;
;;; Main Procedure ;;;
;;;;;;;;;;;;;;;;;;;;;;;

to rewire-one

  ;; make sure num-turtles is setup correctly else run setup first
  if count turtles != num-nodes [
    setup
  ]

  ;; record which button was pushed
  set rewire-one? true
  set rewire-all? false

  let potential-edges links with [ not rewired? ]
  ifelse any? potential-edges [
    ask one-of potential-edges [
      ;; ""a"" remains the same
      let node1 end1
      ;; if ""a"" is not connected to everybody
      if [ count link-neighbors ] of end1 < (count turtles - 1)
      [
        ;; find a node distinct from node1 and not already a neighbor of node1
        let node2 one-of turtles with [ (self != node1) and (not link-neighbor? node1) ]
        ;; wire the new edge
        ask node1 [ create-link-with node2 [ set color cyan  set rewired? true ] ]

        set number-rewired number-rewired + 1  ;; counter for number of rewirings

        ;; remove the old edge
        die
      ]
    ]
    ;; plot the results
    let connected? do-calculations
    do-plotting
  ]
  [ user-message ""all edges have already been rewired once"" ]
end

to rewire-all

  ;; make sure num-turtles is setup correctly; if not run setup first
  if count turtles != num-nodes [
    setup
  ]

  ;; record which button was pushed
  set rewire-one? false
  set rewire-all? true

  ;; set up a variable to see if the network is connected
  let success? false

  ;; if we end up with a disconnected network, we keep trying, because the APL distance
  ;; isn't meaningful for a disconnected network.
  while [not success?] [
    ;; kill the old lattice, reset neighbors, and create new lattice
    ask links [ die ]
    wire-them
    set number-rewired 0

    ask links [

      ;; whether to rewire it or not?
      if (random-float 1) < rewiring-probability
      [
        ;; ""a"" remains the same
        let node1 end1
        ;; if ""a"" is not connected to everybody
        if [ count link-neighbors ] of end1 < (count turtles - 1)
        [
          ;; find a node distinct from node1 and not already a neighbor of node1
          let node2 one-of turtles with [ (self != node1) and (not link-neighbor? node1) ]
          ;; wire the new edge
          ask node1 [ create-link-with node2 [ set color cyan  set rewired? true ] ]

          set number-rewired number-rewired + 1  ;; counter for number of rewirings
          set rewired? true
        ]
      ]
      ;; remove the old edge
      if (rewired?)
      [
        die
      ]
    ]

    ;; check to see if the new network is connected and calculate path length and clustering
    ;; coefficient at the same time
    set success? do-calculations
  ]

  ;; do the plotting
  do-plotting
end

;; do-calculations reports true if the network is connected,
;;   and reports false if the network is disconnected.
;; (In the disconnected case, the average path length does not make sense,
;;   or perhaps may be considered infinite)
to-report do-calculations

  ;; set up a variable so we can report if the network is disconnected
  let connected? true

  ;; find the path lengths in the network
  find-path-lengths

  let num-connected-pairs sum [length remove infinity (remove 0 distance-from-other-turtles)] of turtles

  ;; In a connected network on N nodes, we should have N(N-1) measurements of distances between pairs,
  ;; and none of those distances should be infinity.
  ;; If there were any ""infinity"" length paths between nodes, then the network is disconnected.
  ;; In that case, calculating the average-path-length doesn't really make sense.
  ifelse ( num-connected-pairs != (count turtles * (count turtles - 1) ))
  [
      set average-path-length infinity
      ;; report that the network is not connected
      set connected? false
  ]
  [
    set average-path-length (sum [sum distance-from-other-turtles] of turtles) / (num-connected-pairs)
  ]
  ;; find the clustering coefficient and add to the aggregate for all iterations
  find-clustering-coefficient

  ;; report whether the network is connected or not
  report connected?
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Clustering computations ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

to-report in-neighborhood? [ hood ]
  report ( member? end1 hood and member? end2 hood )
end


to find-clustering-coefficient
  ifelse all? turtles [count link-neighbors <= 1]
  [
    ;; it is undefined
    ;; what should this be?
    set clustering-coefficient 0
  ]
  [
    let total 0
    ask turtles with [ count link-neighbors <= 1]
      [ set node-clustering-coefficient ""undefined"" ]
    ask turtles with [ count link-neighbors > 1]
    [
      let hood link-neighbors
      set node-clustering-coefficient (2 * count links with [ in-neighborhood? hood ] /
                                         ((count hood) * (count hood - 1)) )
      ;; find the sum for the value at turtles
      set total total + node-clustering-coefficient
    ]
    ;; take the average
    set clustering-coefficient total / count turtles with [count link-neighbors > 1]
  ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Path length computations ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Implements the Floyd Warshall algorithm for All Pairs Shortest Paths
;; It is a dynamic programming algorithm which builds bigger solutions
;; from the solutions of smaller subproblems using memoization that
;; is storing the results.
;; It keeps finding incrementally if there is shorter path through
;; the kth node.
;; Since it iterates over all turtles through k,
;; so at the end we get the shortest possible path for each i and j.

to find-path-lengths
  ;; reset the distance list
  ask turtles
  [
    set distance-from-other-turtles []
  ]

  let i 0
  let j 0
  let k 0
  let node1 one-of turtles
  let node2 one-of turtles
  let node-count count turtles
  ;; initialize the distance lists
  while [i < node-count]
  [
    set j 0
    while [j < node-count]
    [
      set node1 turtle i
      set node2 turtle j
      ;; zero from a node to itself
      ifelse i = j
      [
        ask node1 [
          set distance-from-other-turtles lput 0 distance-from-other-turtles
        ]
      ]
      [
        ;; 1 from a node to it's neighbor
        ifelse [ link-neighbor? node1 ] of node2
        [
          ask node1 [
            set distance-from-other-turtles lput 1 distance-from-other-turtles
          ]
        ]
        ;; infinite to everyone else
        [
          ask node1 [
            set distance-from-other-turtles lput infinity distance-from-other-turtles
          ]
        ]
      ]
      set j j + 1
    ]
    set i i + 1
  ]
  set i 0
  set j 0
  let dummy 0
  while [k < node-count]
  [
    set i 0
    while [i < node-count]
    [
      set j 0
      while [j < node-count]
      [
        ;; alternate path length through kth node
        set dummy ( (item k [distance-from-other-turtles] of turtle i) +
                    (item j [distance-from-other-turtles] of turtle k))
        ;; is the alternate path shorter?
        if dummy < (item j [distance-from-other-turtles] of turtle i)
        [
          ask turtle i [
            set distance-from-other-turtles replace-item j distance-from-other-turtles dummy
          ]
        ]
        set j j + 1
      ]
      set i i + 1
    ]
    set k k + 1
  ]

end

;;;;;;;;;;;;;;;;;;;;;;;
;;; Edge Operations ;;;
;;;;;;;;;;;;;;;;;;;;;;;

;; creates a new lattice
to wire-them
  ;; iterate over the turtles
  let n 0
  while [n < count turtles]
  [
    ;; make edges with the next two neighbors
    ;; this makes a lattice with average degree of 4
    make-edge turtle n
              turtle ((n + 1) mod count turtles)
    make-edge turtle n
              turtle ((n + 2) mod count turtles)
    set n n + 1
  ]
end

;; connects the two turtles
to make-edge [node1 node2]
  ask node1 [ create-link-with node2  [
    set rewired? false
  ] ]
end

;;;;;;;;;;;;;;;;
;;; Graphics ;;;
;;;;;;;;;;;;;;;;

to highlight
  ;; remove any previous highlights
  ask turtles [ set color gray + 2 ]
  ask links [ set color gray + 2 ]
  if mouse-inside? [ do-highlight ]
  display
end

to do-highlight
  ;; getting the node closest to the mouse
  let min-d min [distancexy mouse-xcor mouse-ycor] of turtles
  let node one-of turtles with [count link-neighbors > 0 and distancexy mouse-xcor mouse-ycor = min-d]
  if node != nobody
  [
    ;; highlight the chosen node
    ask node
    [
      set color pink - 1
      let pairs (length remove infinity distance-from-other-turtles)
      let local-val (sum remove infinity distance-from-other-turtles) / pairs
      ;; show node's clustering coefficient
      set highlight-string (word ""clustering coefficient = "" precision node-clustering-coefficient 3
                                 "" and avg path length = "" precision local-val 3
                                 "" (for "" pairs "" turtles )"")
    ]
    let neighbor-nodes [ link-neighbors ] of node
    let direct-links [ my-links ] of node
    ;; highlight neighbors
    ask neighbor-nodes
    [
      set color blue - 1

      ;; highlight edges connecting the chosen node to its neighbors
      ask my-links [
        ifelse (end1 = node or end2 = node)
        [
          set color blue - 1 ;
        ]
        [
          if (member? end1 neighbor-nodes and member? end2 neighbor-nodes)
            [ set color yellow ]
        ]
      ]
    ]
  ]
end

;;;;;;;;;;;;;;;;
;;; Plotting ;;;
;;;;;;;;;;;;;;;;

to do-plotting

   if rewire-one? [
     ;; plot the rewire-one graph
     set-current-plot ""Network Properties Rewire-One""
     set-current-plot-pen ""apl""
     ;; note: dividing by value at initial value to normalize the plot
     plotxy number-rewired / count links
            average-path-length / average-path-length-of-lattice

     set-current-plot-pen ""cc""
     ;; note: dividing by initial value to normalize the plot
     plotxy number-rewired / count links
            clustering-coefficient / clustering-coefficient-of-lattice
   ]

   if rewire-all? [
     ;; plot the rewire-all graph
     set-current-plot ""Network Properties Rewire-All""
     set-current-plot-pen ""apl""
     ;; note: dividing by value at initial value to normalize the plot
     plotxy rewiring-probability
            average-path-length / average-path-length-of-lattice

     set-current-plot-pen ""cc""
     ;; note: dividing by initial value to normalize the plot
     plotxy rewiring-probability
            clustering-coefficient / clustering-coefficient-of-lattice
   ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2005 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2005).  NetLogo Small Worlds model.
; http://ccl.northwestern.edu/netlogo/models/SmallWorlds.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2005 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/SmallWorlds
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model explores the formation of networks that result in the ""small world"" phenomenon -- the idea that a person is only a couple of connections away any other person in the world.

A popular example of the small world phenomenon is the network formed by actors appearing in the same movie (e.g. the ""six degrees of Kevin Bacon"" game), but small worlds are not limited to people-only networks.  Other examples range from power grids to the neural networks of worms.  This model illustrates some general, theoretical conditions under which small world networks between people or things might occur.


HOW IT WORKS
------------
This model is an adaptation of a model proposed by Duncan Watts and Steve Strogatz (1998). It begins with a network where each person (or ""node"") is connected to his or her two neighbors on either side.  The REWIRE-ONCE button picks a random connection (or ""edge"") and rewires it. By rewiring, we mean changing one end of a connected pair of nodes, and keeping the other end the same.

The REWIRE-ALL button creates the network and then visits all edges and tries to rewire them.  The REWIRING-PROBABILITY slider determines the probability that an edge will get rewired.  Running REWIRE-ALL at multiple probabilities produces a range of possible networks with varying average path lengths and clustering coefficients.

To identify small worlds, the ""average path length"" (abbreviated ""apl"") and ""clustering coefficient"" (abbreviated ""cc"") of the network are calculated and plotted after the REWIRE-ONCE or REWIRE-ALL buttons are pressed. These two plots are separated because the x-axis is slightly different.  The REWIRE-ONCE x-axis is the fraction of edges rewired so far, whereas the REWIRE-ALL x-axis is the probability of rewiring.  Networks with short average path lengths and high clustering coefficients are considered small world networks. (Note: The plots for both the clustering coefficient and average path length are normalized by dividing by the values of the initial network. The monitors give the actual values.)

Average Path Length: Average path length is calculated by finding the shortest path between all pairs of nodes, adding them up, and then dividing by the total number of pairs. This shows us, on average, the number of steps it takes to get from one member of the network to another.

Clustering Coefficient:  Another property of small world networks is that from one person's perspective it seems unlikely that they could be only a few steps away from anybody else in the world.  This is because their friends more or less know all the same people they do. The clustering coefficient is a measure of this ""all-my-friends-know-each-other"" property.  This is sometimes described as the friends of my friends are my friends.  More precisely, the clustering coefficient of a node is the ratio of existing links connecting a node's neighbors to each other to the maximum possible number of such links.  You can see this is if you press the HIGHLIGHT button and click a node, that will display all of the neighbors in blue and the edges connecting those neighbors in yellow.  The more yellow links, the higher the clustering coefficient for the node you are examining (the one in pink) will be.  The clustering coefficient for the entire network is the average of the clustering coefficients of all the nodes. A high clustering coefficient for a network is another indication of a small world.



HOW TO USE IT
-------------
The NUM-NODES slider controls the size of the network.  Choose a size and press SETUP.

Pressing the REWIRE-ONCE button picks one edge at random, rewires it, and then plots the resulting network properties. The REWIRE-ONCE button always rewires at least one edge (i.e., it ignores the REWIRING-PROBABILITY).

Pressing the REWIRE-ALL button re-creates the initial network (each node connected to its two neighbors on each side for a total of four neighbors) and rewires all the edges with the current rewiring probability, then plots the resulting network properties on the rewire-all plot. Changing the REWIRING-PROBABILITY slider changes the fraction of links rewired after each run.

When you press HIGHLIGHT and then point to node in the view it color-codes the nodes and edges.  The node itself turns pink. Its neighbors and the edges connecting the node to those neighbors turn blue. Edges connecting the neighbors of the node to each other turn yellow. The amount of yellow between neighbors can gives you an indication of the clustering coefficient for that node.  The NODE-PROPERTIES monitor displays the average path length and clustering coefficient of the highlighted node only.  The AVERAGE-PATH-LENGTH and CLUSTERING-COEFFICIENT monitors display the values for the entire network.


THINGS TO NOTICE
----------------
Note that for certain ranges of the fraction of nodes, the average path length decreases faster than the clustering coefficient.  In fact, there is a range of values for which the average path length is much smaller than clustering coefficient.  (Note that the values for average path length and clustering coefficient have been normalized, so that they are more directly comparable.)  Networks in that range are considered small worlds.


THINGS TO TRY
-------------
Try plotting the values for different rewiring probabilities and observe the trends of the values for average path length and clustering coefficient.  What is the relationship between rewiring probability and fraction of nodes?  In other words, what is the relationship between the rewire-one plot and the rewire-all plot?

Do the trends depend on the number of nodes in the network?

Can you get a small world by repeatedly pressing REWIRE-ONE?

Set NUM-NODES to 80 and then press SETUP. Go to BehaviorSpace and run the VARY-REWIRING-PROBABILITY experiment. Try running the experiment multiple times without clearing the plot (i.e., do not run SETUP again).  What range of rewiring probabilities result in small world networks?


EXTENDING THE MODEL
-------------------
Try to see if you can produce the same results if you start with a different initial network.  Create new BehaviorSpace experiments to compare results.

In a precursor to this model, Watts and Strogatz created an ""alpha"" model where the rewiring was not based on a global rewiring probability.  Instead, the probability that a node got connected to another node depended on how many mutual connections the two nodes had. The extent to which mutual connections mattered was determined by the parameter ""alpha.""  Create the ""alpha"" model and see if it also can result in small world formation.


NETWORK CONCEPTS
----------------
In this model we need to find the shortest paths between all pairs of nodes.  This is accomplished through the use of a standard dynamic programming algorithm called the Floyd Warshall algorithm. You may have noticed that the model runs slowly for large number of nodes.  That is because the time it takes for the Floyd Warshall algorithm (or other ""all-pairs-shortest-path"" algorithm) to run grows polynomially with the number of nodes.  For more information on the Floyd Warshall algorithm please consult:  http://en.wikipedia.org/wiki/Floyd-Warshall_algorithm


NETLOGO FEATURES
----------------

The various network/link features (introduced in NetLogo 4.0) are used extensively in this model.

Lists are used heavily in the procedures that calculates shortest paths.

RELATED MODELS
--------------
See other models in the Networks section of the Models Library, such as Giant Component and Preferential Attachment.


CREDITS AND REFERENCES
----------------------
This model is adapted from:
Duncan J. Watts, Six Degrees: The Science of a Connected Age (W.W. Norton & Company, New York, 2003), pages 83-100.

The work described here was originally published in:
DJ Watts and SH Strogatz. Collective dynamics of 'small-world' networks, Nature,
393:440-442 (1998)

For more information please see Watts' website:  http://smallworld.columbia.edu/index.html

The small worlds idea was first made popular by Stanley Milgram's famous experiment (1967) which found that two random US citizens where on average connected by six acquaintances (giving rise to the popular ""six degrees of separation"" expression):
Stanley Milgram.  The Small World Problem,  Psychology Today,  2: 60-67 (1967).

This experiment was popularized into a game called ""six degrees of Kevin Bacon"" which you can find more information about here:  http://www.cs.virginia.edu/oracle/

To refer to this model in academic publications, please use:  Wilensky, U. (2005).  NetLogo Small Worlds model.  http://ccl.northwestern.edu/netlogo/models/SmallWorlds.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2005 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/SmallWorlds for terms of use.
"
Giant Component,/models/Sample Models/Networks,"turtles-own
[
  ;; this is used to mark turtles we have already visited
  explored?
]

globals
[
  component-size          ;; number of turtles explored so far in the current component
  giant-component-size    ;; number of turtles in the giant component
  giant-start-node        ;; node from where we started exploring the giant component
]

;;;;;;;;;;;;;;;;;;;;;;;;
;;; Setup Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;

to setup
  ca
  set-default-shape turtles ""circle""
  make-turtles
  ;; at this stage, all the components will be of size 1,
  ;; since there are no edges yet
  find-all-components
  color-giant-component
  setup-plot
  do-plotting
end

to make-turtles
  crt num-nodes
  layout-circle turtles max-pxcor - 1
end

to setup-plot
  ;; Draws the transition line.
  set-current-plot-pen ""transition""
  plot-pen-up
  plotxy 1 0
  plot-pen-down
  plotxy 1 1
end

;;;;;;;;;;;;;;;;;;;;;;
;;; Main Procedure ;;;
;;;;;;;;;;;;;;;;;;;;;;

to go
  ;; if the below condition is true then we have a fully connected network and we need to stop
  if ( (2 * count links ) >= ( (count turtles) * (count turtles - 1) ) ) [
    display
    user-message ""Network is fully connected. No more edges can be added.""
    stop
  ]
  add-edge
  find-all-components
  color-giant-component
  ask links [ set color [color] of end1 ]  ;; recolor all edges
  tick
  do-plotting
  layout
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Network Exploration ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; to find all the connected components in the network, their sizes and starting turtles
to find-all-components
  ask turtles [ set explored? false ]
  ;; keep exploring till all turtles get explored
  loop
  [
    ;; pick a node that has not yet been explored
    let start one-of turtles with [ not explored? ]
    if start = nobody [ stop ]
    ;; reset the number of turtles found to 0
    ;; this variable is updated each time we explore an
    ;; unexplored node.
    set component-size 0
    ;; at this stage, we recolor everything to light gray
    ask start [ explore (gray + 2) ]
    ;; the explore procedure updates the component-size variable.
    ;; so check, have we found a new giant component?
    if component-size > giant-component-size
    [
      set giant-component-size component-size
      set giant-start-node start
    ]
  ]
end

;; Finds all turtles reachable from this node (and recolors them)
to explore [new-color]  ;; node procedure
  if explored? [ stop ]
  set explored? true
  set component-size component-size + 1
  ;; color the node
  set color new-color
  ask link-neighbors [ explore new-color ]
end

;; color the giant component red
to color-giant-component
  ask turtles [ set explored? false ]
  ask giant-start-node [ explore red ]
end

;;;;;;;;;;;;;;;;;;;;;;;
;;; Edge Operations ;;;
;;;;;;;;;;;;;;;;;;;;;;;

;; pick a random missing edge and create it
to add-edge
  let node1 one-of turtles
  let node2 one-of turtles
  ask node1 [
    ifelse link-neighbor? node2 or node1 = node2
    ;; if there's already an edge there, then go back
    ;; and pick new turtles
    [ add-edge ]
    ;; else, go ahead and make it
    [ create-link-with node2 ]
  ]

end


to do-plotting ;; plotting procedure
  set-current-plot-pen ""size""
  ;; We multiply by 2 because every edge should be counted twice while calculating,
  ;; the average, since an edge connects two turtles.
  ;; We divide by the node count to normalize the y axis to a 0 to 1 range.
  plotxy (2 * count links / count turtles)
         (giant-component-size / count turtles)
end

;;;;;;;;;;;;;;
;;; Layout ;;;
;;;;;;;;;;;;;;
to layout
  if not layout? [ stop ]
  ;; the number 10 here is arbitrary; more repetitions slows down the
  ;; model, but too few gives poor layouts
  repeat 10 [
    do-layout
    display  ;; so we get smooth animation
  ]
end

to do-layout
  layout-spring (turtles with [any? link-neighbors]) links 0.4 6 1
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2005 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2005).  NetLogo Giant Component model.
; http://ccl.northwestern.edu/netlogo/models/GiantComponent.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2005 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/GiantComponent
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
In a network, a ""component"" is a group of nodes that are all connected to each other, directly or indirectly.  So if a network has a ""giant component"", that means almost every node is reachable from almost every other.  This model shows how quickly a giant component arises if you grow a random network.


HOW IT WORKS
------------
Initially we have nodes but no connections (edges) between them. At each step, we pick two nodes at random which were not directly connected before and add an edge between them.  All possible connections between them have exactly the same probability of occurring.

As the model runs, small chain-like ""components"" are formed, where the members in each component are either directly or indirectly connected to each other.  If an edge is created between nodes from two different components, then those two components merge into one. The component with the most members at any given point in time is the ""giant"" component and it is colored red.  (If there is a tie for largest, we pick a random component to color.)


HOW TO USE IT
-------------
The NUM-NODES slider controls the size of the network.  Choose a size and press SETUP.

Pressing the GO ONCE button adds one new edge to the network.  To repeatedly add edges, press GO.

As the model runs, the nodes and edges try to position themselves in a layout that makes the structure of the network easy to see.  Layout makes the model run slower, though.  To get results faster, turn off the LAYOUT? switch.

The REDO LAYOUT button runs the layout-step procedure continuously to improve the layout of the network.

A monitor shows the current size of the giant component, and the plot shows how the giant component's size changes over time.


THINGS TO NOTICE
----------------
The y-axis of the plot shows the fraction of all nodes that are included in the giant component.  The x-axis shows the average number of connections per node. The vertical line on the plot shows where the average number of connections per node equals 1.  What happens to the rate of growth of the giant component at this point?

The model demonstrates one of the early proofs of random graph theory by the mathematicians Paul Erdos and Alfred Renyi (1959).  They showed that the largest connected component of a network formed by randomly connecting two existing nodes per time step, rapidly grows after the average number of connections per node equals 1. In other words, the average number of connections has a ""critical point"" where the network undergoes a ""phase transition"" from a rather unconnected world of a bunch of small, fragmented components, to a world where most nodes belong to the same connected component.


THINGS TO TRY
-------------
Let the model run until the end.  Does the ""giant component"" live up to its name?

Run the model again, this time slowly, a step at a time.  Watch how the components grow.  What is happening when the plot is steepest?

Run it with a small number of nodes (like 10) and watch the plot.  How does it differ from the plot you get when you run it with a large number of nodes (like 300)?  If you do multiple runs with the same number of nodes, how much does the shape of the plot vary from run to run?  You can turn off the LAYOUT? switch to get results faster.


EXTENDING THE MODEL
-------------------
Right now the probability of any two nodes getting connected to each other is the same. Can you think of ways to make some nodes more attractive to connect to than others?  How would that impact the formation of the giant component?


NETWORK CONCEPTS
----------------
Identification of the connected components is done using a standard search algorithm called ""depth first search.""  ""Depth first"" means that the algorithm first goes deep into a branch of connections, tracing them out all the way to the end.  For a given node it explores its neighbor's neighbors (and then their neighbors, etc) before moving on to its own next neighbor.  The algorithm is recursive so eventually all reachable nodes from a particular starting node will be explored.  Since we need to find every reachable node, and since it doesn't matter what order we find them in, another algorithm such as ""breadth first search"" would have worked equally well.  We chose depth first search because it is the simplest to code.

The position of the nodes is determined by the ""spring"" method, which is further described in the Preferential Attachment model.


NETLOGO FEATURES
----------------
Both nodes and edges are turtles.  Edge turtles have the ""line"" shape.  The edge turtle's SIZE variable is used to make the edge be the right length.

Lists are used heavily in this model.  Each node maintains a list of its neighboring nodes.  Lists are also used in the procedure that identifies the components.


RELATED MODELS
--------------
See other models in the Networks section of the Models Library, such as Preferential Attachment.

See also Network Example, in the Code Examples section.


CREDITS AND REFERENCES
----------------------
This model is adapted from:
Duncan J. Watts. Six Degrees: The Science of a Connected Age (W.W. Norton & Company, New York, 2003), pages 43-47.

Watts' website is available at:  http://smallworld.columbia.edu/

The work Watts describes was originally published in:
P. Erdos and A. Renyi. On random graphs. Publ. Math. Debrecen, 6:290-297, 1959.

This paper has some additional analysis:
S. Janson, D.E. Knuth, T. Luczak, and B. Pittel. The birth of the giant component. Random Structures & Algorithms 4, 3 (1993), pages 233-358.

To refer to this model in academic publications, please use:  Wilensky, U. (2005).  NetLogo Giant Component model.  http://ccl.northwestern.edu/netlogo/models/GiantComponent.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2005 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/GiantComponent for terms of use.
"
Team Assembly,/models/Sample Models/Networks,"globals
[
  newcomer              ;; an agent who has never collaborated
  component-size        ;; current running size of component being explored
  giant-component-size  ;; size of largest connected component
  components            ;; list of connected components
]

turtles-own
[
  incumbent?   ;; true if an agent has collaborated before
  in-team?     ;; true if an agent belongs to the new team being constructed
  downtime     ;; the number of time steps passed since the agent last collaborated
  explored?    ;; used to compute connected components in the graph
]

links-own
[
  new-collaboration?  ;; true if the link represents the first time two agents collaborated
]


;;;;;;;;;;;;;;;;;;;;;;;;
;;; Setup Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;

to make-newcomer
  create-turtles 1
  [
    set color blue + 1
    set size 1.8
    set incumbent? false
    set in-team? false
    set newcomer self
    set downtime 0
    set explored? false
  ]
end


to setup
  clear-all
  set-default-shape turtles ""circle""

  ;; assemble the first team
  repeat team-size [ make-newcomer ]
  ask turtles
  [
    set in-team? true
    set incumbent? true
  ]
  tie-collaborators
  color-collaborations

  ask turtles  ;; arrange turtles in a regular polygon
  [
    set heading (360 / team-size) * who
    fd 1.75
    set in-team? false
  ]
end


;;;;;;;;;;;;;;;;;;;;;;;
;;; Main Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;

to go
  ;; all existing turtles are now considered incumbents
  ask turtles [set incumbent? true set color gray - 1.5 set size 0.9]
  ask links [set new-collaboration? false]

  ;; assemble a new team
  pick-team-members
  tie-collaborators
  color-collaborations

  ;; age turtles
  ask turtles
  [
    ;; agents drop out of the collaboration network when they become inactive for max-downtime steps
    if downtime > max-downtime
      [die]

    set in-team? false
    set downtime downtime + 1
  ]

  if layout? [ layout ]
  if plot? [ do-plot ]
  tick
end


;; choose turtles to be in a new team
to pick-team-members
  let new-team-member nobody
  repeat team-size
  [
    ifelse random-float 100.0 >= p  ;;with a probability P, make a newcomer
    [
      make-newcomer
      set new-team-member newcomer
    ]
    [
      ;; with a probability Q, choose a new team member who was a previous collaborator of an existing team member
      ;; if the current team has at least one previous collaborator.
      ;; otherwise collaborate with a previous incumbent
      ifelse random-float 100.0 < q and any? (turtles with [in-team? and (any? link-neighbors with [not in-team?])])
        [set new-team-member one-of turtles with [not in-team? and (any? link-neighbors with [in-team?])]]
        [set new-team-member one-of turtles with [not in-team?]]
    ]
    ask new-team-member  ;; specify turtle to become a new team member
    [
      set in-team? true
      set downtime 0
      set size 1.8
      set color ifelse-value incumbent? [yellow + 2] [blue + 1]
    ]
  ]
end


;; forms a link between all unconnected turtles with in-team? = true
to tie-collaborators
  ask turtles with [in-team?]
  [
    create-links-with other turtles with [in-team?]
    [
      set new-collaboration? true  ;; specifies newly-formed collaboration between two members
      set thickness 0.3
    ]
  ]
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Visualization Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; color links according to past experience
to color-collaborations
    ask links with [[in-team?] of end1 and [in-team?] of end2]
    [
      ifelse new-collaboration?
      [
        ifelse ([incumbent?] of end1) and ([incumbent?] of end2)
        [
          set color yellow       ;; both members are incumbents
        ]
        [
          ifelse ([incumbent?] of end1) or ([incumbent?] of end2)
            [ set color green ]  ;; one member is an incumbent
            [ set color blue ]   ;; both members are newcomers
        ]
      ]
      [
        set color red            ;; members are previous collaborators
      ]
    ]
end

;; perform spring layout on all turtles and links
to layout
  repeat 12 [
    layout-spring turtles links 0.18 0.01 1.2
    display
  ]
end


to do-plot
  ;; plot stacked histogram of link types
  set-current-plot ""Link counts""
  let total 0
  set-current-plot-pen ""previous collaborators""
  plot-pen-up plotxy ticks total
  set total total + count links with [color = red]
  plot-pen-down plotxy ticks total
  set-current-plot-pen ""incumbent-incumbent""
  plot-pen-up plotxy ticks total
  set total total + count links with [color = yellow]
  plot-pen-down plotxy ticks total
  set-current-plot-pen ""newcomer-incumbent""
  plot-pen-up plotxy ticks total
  set total total + count links with [color = green]
  plot-pen-down plotxy ticks total
  set-current-plot-pen ""newcomer-newcomer""
  plot-pen-up plotxy ticks total
  set total total + count links with [color = blue]
  plot-pen-down plotxy ticks total

  ;; calculate and plot connected component metrics
  find-all-components
  set-current-plot ""% of agents in the giant component""
  plotxy ticks (giant-component-size / (count turtles))
  set-current-plot ""Average component size""
  plotxy ticks (mean components)
end



;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Network Exploration ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; to find all the connected components in the network, their sizes and starting turtles
to find-all-components
  set components []
  set giant-component-size 0

  ask turtles [ set explored? false ]
  ;; keep exploring till all turtles get explored
  loop
  [
    ;; pick a turtle that has not yet been explored
    let start one-of turtles with [ not explored? ]
    if start = nobody [ stop ]
    ;; reset the number of turtles found to 0
    ;; this variable is updated each time we explore an
    ;; unexplored turtle.
    set component-size 0
    ask start [ explore ]
    ;; the explore procedure updates the component-size variable.
    ;; so check, have we found a new giant component?
    if component-size > giant-component-size
    [
      set giant-component-size component-size
    ]
    set components lput component-size components
  ]
end

;; finds all turtles reachable from this turtle
to explore ;; turtle procedure
  if explored? [ stop ]
  set explored? true
  set component-size component-size + 1
  ask link-neighbors [ explore ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2007 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Bakshy, E. and Wilensky, U. (2007). NetLogo Team Assembly model.
; http://ccl.northwestern.edu/netlogo/models/TeamAssembly.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2007 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/TeamAssembly
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model of collaboration networks illustrates how the behavior of individuals in assembling small teams for short-term projects can give rise to a variety of large-scale network structures over time.  It is an adaptation of the team assembly model presented by Guimera et al (2005).  The rules of the model draw upon observations of collaboration networks ranging from Broadway productions to scientific publications in psychology and astronomy.

Many of the general features found in the networks of creative enterprises can be captured by the Team Assembly model with two simple parameters: the proportion of newcomers participating in a team and the propensity for past collaborators to work again with one another.


HOW IT WORKS
------------
At each tick a new team is assembled.  Team members are either inexperienced ""newcomers"" -- people who have not previously participated in any teams -- or are established ""incumbents"" -- experienced people who have previously participated on a team.  Each member is chosen sequentially.  The P slider gives the probability that a new team member will be an incumbent.  If the new member is not a newcomer, then with a probability given by the Q slider, an incumbent will be chosen at random from the pool of previous collaborators of an incumbent already on the team.  Otherwise, a new member will just be randomly chosen from all incumbents.  When a team is created, all members are linked to one another.  If an agent does not participate in a new team for a prolonged period of time, the agent and her links are removed from the network.

Agents in a newly assembled team are colored blue if they are newcomers and yellow if they are incumbents.  Smaller grey circles represent those that are not currently collaborating.  Links indicate members' experience at their most recent time of collaboration.  For example, blue links between agents indicate that two agents collaborated as newcomers.  Green and yellow links correspond to one-time newcomer-incumbent and incumbent-incumbent collaborations, respectively.  Finally, red links indicate that agents have collaborated with one another multiple times.


HOW TO USE IT
-------------
Click the SETUP button to start with a single team.  Click GO ONCE to assemble an additional team.  Click GO to indefinitely assemble new teams.  You may wish to use the GO ONCE button for the first few steps to get a better sense of how the parameters affect the assembly of teams.

Visualization Controls:
- LAYOUT?: controls whether or not the spring layout algorithm runs at each tick.  This procedure attempts to move the nodes around to make the structure of the network easier to see.  Switching off LAYOUT? will significantly increase the speed of the model.
- PLOT?: switches on and off the plots. Again, off speeds up the model.

The REDO LAYOUT button lets you run the layout algorithm without assembling new teams.

Parameters:
- TEAM-SIZE: the number of agents in a newly assembled team.
- MAX-DOWNTIME: the number of steps an agent will remain in the world without collaborating before it retires.
- P: the probability an incumbent is chosen to become a member of a new team
- Q: the probability that the team being assembled will include a previous collaborator of an incumbent on the team, given that the team has at least one incumbent.

Plots:
- LINK COUNTS: plots a stacked histogram of the number of links in the collaboration network over time.  The colors correspond to collaboration ties as follows:
-- Blue: two newcomers
-- Green: a newcomer and an incumbent
-- Yellow: two incumbents that have not previously collaborated with one another
-- Red: Repeat collaborators
-  % OF AGENTS IN THE GIANT COMPONENT: plots the percentage of agents belonging to the largest connected component network over time.
- AVERAGE COMPONENT SIZE: plots the average size of isolated collaboration networks as a fraction of the total number of agents

Using the plots, one can observe important features of the network, like the distribution of link types or the connectivity of the network vary over time.


THINGS TO NOTICE
----------------
The model captures two basic features of collaboration networks that can influence or stifle innovation in creative enterprises by varying the values of P and Q.  First is the distribution of the type of the connection between collaborators, which can be seen in the LINK COUNTS plot. An overabundance of newcomer-newcomer (blue) links might indicate that a field is not taking advantage of experienced members. On the other hand, a multitude of repeat collaborations (red) and incumbent-incumbent (yellow) links may indicate a lack of in diversity of ideas or experiences.

Second is the overall connectivity of the collaboration network.  For example, many academic fields are said to be comprised of an ""invisible college"" of loosely connected academic communities.  By contrast, patent networks tend to consist of isolated clusters or chains of inventors.  You can see one measure of this on the % OF AGENTS IN THE GIANT COMPONENT plot -- the giant component being the size of the largest connected chain of collaborators.

You can also see the different emergent topologies in the display.   New collaborations or synergy among teams naturally tend to the center of the display. Teams or clusters of teams with few connections to new collaborations naturally ""float"" to the edges of the world. Newcomers always start in the center of the world. Incumbents, which are chosen at random, may be located in any part of the screen. Thus, collaborations amongst newcomers and or distant team components tend toward the center, and disconnected clusters are repelled from the centered.

Finally, note that the structure of collaboration networks in the model can change dramatically over time. Initially, only new teams are generated; the collaborative field has not existed long enough for members to retire. However, after a period of time (MAX-DOWNTIME), inactive agents begin to retire, and the number of agents becomes relatively stable -- the emergent effects of P and Q become more apparent in this equilibrium stage.  Note also that the end of the growth stage is often marked by a drop in the connectivity of the network.


THINGS TO TRY
-------------
Keeping Q fixed at 40%, how does the structure of collaboration networks vary with P?  For example, which values of P produce isolated clusters of agents?  As P increases, how do these clusters combine to form more complex structures?  Over which values of P does the transition from a disconnected network to a fully connected network occur?

Set P to 40% and Q to 100%, so that all incumbents choose to work with past collaborators.  Press SETUP, then GO, and let the model run for about 100 steps after the number of agents in the network stops growing.  What happens to the connectivity of the collaboration network?  Keeping P fixed, continue to lower Q in decrements of 5-10%.

Try keeping P and Q constant and varying TEAM-SIZE.  How does the global structure of the network change with larger or smaller team sizes?  Under which ranges of P and Q does this relation hold?


EXTENDING THE MODEL
-------------------
What happens when the size of new teams are not constant?  Try changing the rules so that team sizes vary randomly from a distribution or increase over time.

How do P and Q relate to the global clustering coefficient of the network?  You may wish to use code from the Small Worlds model in the Networks section of Sample Models.

Can you modify the model so that agents are more likely to collaborate with collaborators of collaborators?

Collaboration networks can alternatively be thought of as a network consisting of individuals linked to projects.  For example, one can represent a scientific journal with two types of nodes, scientists and publications.  Ties between scientists and publications represent authorship.  Thus, links between a publication multiple scientists specify co-authorship.  More generally, a collaborative project may be represented one type of node, and participants another type.  Can you modify the model to assemble teams using bipartite networks?


RELATED MODELS
--------------
Preferential Attachment - gives a generative explanation of how general principles of attachment can give rise to a network structure common to many technological and biological systems.

Giant Component - shows how critical points exist in which a network can transition from a rather disconnected topology to a fully connected topology


CREDITS AND REFERENCES
----------------------
This model is based on:
R Guimera, B Uzzi, J Spiro, L Amaral; Team Assembly Mechanisms Determine Collaboration Network Structure and Team Performance. Science 2005, V308, N5722, p697-702
http://amaral.northwestern.edu/Publications/Papers/Guimera-2005-Science-308-697.pdf


To refer to this model in academic publications, please use:  Bakshy, E. and Wilensky, U. (2007).  NetLogo Team Assembly model.  http://ccl.northwestern.edu/netlogo/models/TeamAssembly.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2007 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/TeamAssembly for terms of use.
"
Preferential Attachment,/models/Sample Models/Networks,";;;;;;;;;;;;;;;;;;;;;;;;
;;; Setup Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;

to setup
  clear-all
  set-default-shape turtles ""circle""
  ;; make the initial network of two turtles and an edge
  make-node nobody        ;; first node, unattached
  make-node turtle 0      ;; second node, attached to first node
end

;;;;;;;;;;;;;;;;;;;;;;;
;;; Main Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;

to go
  ;; new edge is green, old edges are gray
  ask links [ set color gray ]
  make-node find-partner         ;; find partner & use it as attachment
                                 ;; point for new node
  tick
  if layout? [ layout ]
  if plot? [ do-plotting ]
end

;; used for creating a new node
to make-node [old-node]
  crt 1
  [
    set color red
    if old-node != nobody
      [ create-link-with old-node [ set color green ]
        ;; position the new node near its partner
        move-to old-node
        fd 8
      ]
  ]
end

;; This code is borrowed from Lottery Example (in the Code Examples
;; section of the Models Library).
;; The idea behind the code is a bit tricky to understand.
;; Basically we take the sum of the degrees (number of connections)
;; of the turtles, and that's how many ""tickets"" we have in our lottery.
;; Then we pick a random ""ticket"" (a random number).  Then we step
;; through the turtles to figure out which node holds the winning ticket.
to-report find-partner
  let total random-float sum [count link-neighbors] of turtles
  let partner nobody
  ask turtles
  [
    let nc count link-neighbors
    ;; if there's no winner yet...
    if partner = nobody
    [
      ifelse nc > total
        [ set partner self ]
        [ set total total - nc ]
    ]
  ]
  report partner
end

;;;;;;;;;;;;;;;;
;;; Plotting ;;;
;;;;;;;;;;;;;;;;

to do-plotting ;; plotting procedure
  let max-degree max [count link-neighbors] of turtles

  set-current-plot ""Degree Distribution""
  plot-pen-reset  ;; erase what we plotted before
  set-plot-x-range 1 (max-degree + 1)  ;; + 1 to make room for the width of the last bar
  histogram [count link-neighbors] of turtles

  ;; for this plot, the axes are logarithmic, so we can't
  ;; use ""histogram-from""; we have to plot the points
  ;; ourselves one at a time
  set-current-plot ""Degree Distribution (log-log)""
  plot-pen-reset  ;; erase what we plotted before
  ;; the way we create the network there is never a zero degree node,
  ;; so start plotting at degree one
  let degree 1
  while [degree <= max-degree]
  [
    let matches turtles with [count link-neighbors = degree]
    if any? matches
      [ plotxy log degree 10
               log (count matches) 10 ]
    set degree degree + 1
  ]
end

;;;;;;;;;;;;;;
;;; Layout ;;;
;;;;;;;;;;;;;;

;; resize-nodes, change back and forth from size based on degree to a size of 1
to resize-nodes
  ifelse all? turtles [size <= 1]
  [
    ;; a node is a circle with diameter determined by
    ;; the SIZE variable; using SQRT makes the circle's
    ;; area proportional to its degree
    ask turtles [ set size sqrt count link-neighbors ]
  ]
  [
    ask turtles [ set size 1 ]
  ]
end

to layout
  ;; the number 3 here is arbitrary; more repetitions slows down the
  ;; model, but too few gives poor layouts
  repeat 3 [
    ;; the more turtles we have to fit into the same amount of space,
    ;; the smaller the inputs to layout-spring we'll need to use
    let factor sqrt count turtles
    ;; numbers here are arbitrarily chosen for pleasing appearance
    layout-spring turtles links (1 / factor) (7 / factor) (1 / factor)
    display  ;; for smooth animation
  ]
  ;; don't bump the edges of the world
  let x-offset max [xcor] of turtles + min [xcor] of turtles
  let y-offset max [ycor] of turtles + min [ycor] of turtles
  ;; big jumps look funny, so only adjust a little each time
  set x-offset limit-magnitude x-offset 0.1
  set y-offset limit-magnitude y-offset 0.1
  ask turtles [ setxy (xcor - x-offset / 2) (ycor - y-offset / 2) ]
end

to-report limit-magnitude [number limit]
  if number > limit [ report limit ]
  if number < (- limit) [ report (- limit) ]
  report number
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2005 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2005).  NetLogo Preferential Attachment model.
; http://ccl.northwestern.edu/netlogo/models/PreferentialAttachment.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2005 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/PreferentialAttachment
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
In some networks, a few ""hubs"" have lots of connections, while everybody else only has a few.  This model shows one way such networks can arise.

Such networks can be found in a surprisingly large range of real world situations, ranging from the connections between websites to the collaborations between actors.

This model generates these networks by a process of ""preferential attachment"", in which new network members prefer to make a connection to the more popular existing members.


HOW IT WORKS
------------
The model starts with two nodes connected by an edge.

At each step, a new node is added.  A new node picks an existing node to connect to randomly, but with some bias.  More specifically, a node's chance of being selected is directly proportional to the number of connections it already has, or its ""degree."" This is the mechanism which is called ""preferential attachment.""


HOW TO USE IT
-------------
Pressing the GO ONCE button adds one new node.  To continuously add nodes, press GO.

The LAYOUT? switch controls whether or not the layout procedure is run.  This procedure attempts to move the nodes around to make the structure of the network easier to see.

The PLOT? switch turns off the plots which speeds up the model.

The RESIZE-NODES button will make all of the nodes take on a size representative of their degree distribution.  If you press it again the nodes will return to equal size.

If you want the model to run faster, you can turn off the LAYOUT? and PLOT? switches and/or freeze the view (using the on/off button in the control strip over the view). The LAYOUT? switch has the greatest effect on the speed of the model.

If you have LAYOUT? switched off, and then want the network to have a more appealing layout, press the REDO-LAYOUT button which will run the layout-step procedure until you press the button again. You can press REDO-LAYOUT at any time even if you had LAYOUT? switched on and it will try to make the network easier to see.

THINGS TO NOTICE
----------------
The networks that result from running this model are often called ""scale-free"" or ""power law"" networks. These are networks in which the distribution of the number of connections of each node is not a normal distribution -- instead it follows what is a called a power law distribution.  Power law distributions are different from normal distributions in that they do not have a peak at the average, and they are more likely to contain extreme values (see Barabasi 2002 for a further description of the frequency and significance of scale-free networks).  Barabasi originally described this mechanism for creating networks, but there are other mechanisms of creating scale-free networks and so the networks created by the mechanism implemented in this model are referred to as Barabasi scale-free networks.

You can see the degree distribution of the network in this model by looking at the plots. The top plot is a histogram of the degree of each node.  The bottom plot shows the same data, but both axes are on a logarithmic scale.  When degree distribution follows a power law, it appears as a straight line on the log-log plot.  One simple way to think about power laws is that if there is one node with a degree distribution of 1000, then there will be ten nodes with a degree distribution of 100, and 100 nodes with a degree distribution of 10.


THINGS TO TRY
-------------
Let the model run a little while.  How many nodes are ""hubs"", that is, have many connections?  How many have only a few?  Does some low degree node ever become a hub?  How often?

Turn off the LAYOUT? switch and freeze the view to speed up the model, then allow a large network to form.  What is the shape of the histogram in the top plot?  What do you see in log-log plot? Notice that the log-log plot is only a straight line for a limited range of values.  Why is this?  Does the degree to which the log-log plot resembles a straight line grow as you add more node to the network?


EXTENDING THE MODEL
-------------------
Assign an additional attribute to each node.  Make the probability of attachment depend on this new attribute as well as on degree.  (A bias slider could control how much the attribute influences the decision.)

Can the layout algorithm be improved?  Perhaps nodes from different hubs could repel each other more strongly than nodes from the same hub, in order to encourage the hubs to be physically separate in the layout.


NETWORK CONCEPTS
----------------
There are many ways to graphically display networks.  This model uses a common ""spring"" method where the movement of a node at each time step is the net result of ""spring"" forces that pulls connected nodes together and repulsion forces that push all the nodes away from each other.  This code is in the layout-step procedure. You can force this code to execute any time by pressing the REDO LAYOUT button, and pressing it again when you are happy with the layout.


NETLOGO FEATURES
----------------
Both nodes and edges are turtles.  Edge turtles have the ""line"" shape.  The edge turtle's SIZE variable is used to make the edge be the right length.

Lists are used heavily in this model.  Each node maintains a list of its neighboring nodes.


RELATED MODELS
--------------
See other models in the Networks section of the Models Library, such as Giant Component.

See also Network Example, in the Code Examples section.


CREDITS AND REFERENCES
----------------------
This model is based on:
Albert-Laszlo Barabasi. Linked: The New Science of Networks, Perseus Publishing, Cambridge, Massachusetts, pages 79-92.

For a more technical treatment, see:
Albert-Laszlo Barabasi & Reka Albert. Emergence of Scaling in Random Networks, Science, Vol 286, Issue 5439, 15 October 1999, pages 509-512.

Barabasi's webpage has additional information at: http://www.nd.edu/~alb/

The layout algorithm is based on the Fruchterman-Reingold layout algorithm.  More information about this algorithm can be obtained at: http://citeseer.ist.psu.edu/fruchterman91graph.html.

For a model similar to the one described in the first extension, please consult:
W. Brian Arthur, ""Urban Systems and Historical Path-Dependence"", Chapt. 4 in Urban systems and Infrastructure, J. Ausubel and R. Herman (eds.), National Academy of Sciences, Washington, D.C., 1988.

To refer to this model in academic publications, please use:  Wilensky, U. (2005).  NetLogo Preferential Attachment model.  http://ccl.northwestern.edu/netlogo/models/PreferentialAttachment.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2005 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/PreferentialAttachment for terms of use.
"
Lunar Lander,/models/Sample Models/Games,"globals [
  platform     ;; the x coordinate of the center of the platform
]

turtles-own [
  xvel yvel    ;; x and y components of the lander's velocity
]

to setup
  clear-all
  setup-terrain
  crt 1 [
    set shape ""lander""
    set color red
    set size 10
    setxy (platform + max-pxcor)
          (max-pycor - size / 2)
    set heading 0
  ]
end

to setup-terrain
  let terrain-color gray
  set platform platform-width
               + random (world-width - 2 * platform-width)
               + min-pxcor
  ;; first use a turtle to draw the surface of the moon
  ;; including the landing platform
  crt 1 [
    set color gray
    setxy min-pxcor
          floor (min-pycor / 2)
    set heading 90
    repeat world-width [
      set pcolor color
      fd 1
      ;; draw the platform in blue
      if pxcor = platform - (platform-width / 2) [
        set heading 90
        set color blue
      ]
      ;; everything else is moon surface and should be gray
      if pxcor = platform + (platform-width / 2) [
        set color gray
      ]
      ;; and if it isn't the platform it should also be
      ;; jagged so vary ycor by the terrain-bumpiness
      if color != blue [
        ;; random-poisson usually gives small variations, occasionally
        ;; larger ones
        let y ( ycor + one-of [1 -1] * random-poisson ( terrain-bumpiness ) )
        ;; prevent the drawing turtle from wrapping vertically
        ;; while contouring the terrain
          if patch-at 0 (y - ycor) != nobody
          [ set ycor y ]
      ]
    ]
    die
  ]

  ;; then use more turtles to make solid gray below the gray line
  ask patches with [pcolor != black] [
    sprout 1 [
      set heading 180
      ;; if the drawing turtle is already at the bottom it should not continue
      if not can-move? 1 [ die ]
      fd 1
      set pcolor gray
      fd 1
      while [ can-move? 1 ]
      [
        set pcolor gray
        fd 1
      ]
      set pcolor gray
      die
    ]
  ]
end

to go
  if (not any? turtles) or ([color] of one-of turtles != red)
    [ stop ]
  every 0.015 [
    ask turtles [
      ;; if the module is about to wrap vertically
      ;; stop its ascent
      ifelse ycor + yvel > max-pycor
      [ set xcor (xcor + xvel)
        set yvel 0 ]
      [ setxy (xcor + xvel) (ycor + yvel) ]
      ;; exert the force of gravity
      set yvel yvel - 0.001
      ;; detect crashes and insufficiently soft landings
      if [pcolor] of patch-at 0 -2 != black [
        ifelse (abs yvel > 0.08) or
               (abs xvel > 0.04) or
               (heading != 0) or
               ((pxcor - platform) >= platform-width / 2)
        [ game-over ]
        [ set color green - 1 ]
      ]
      ;; switch back to the shape without the thrusters on
      if shape = ""lander2"" and timer > 0.3
        [ set shape ""lander"" ]
    ]
    tick
  ]
end

to game-over  ;; turtle procedure
  set shape ""skull""
  set color white
  set heading 0
end

to rotate-left  ;; turtle procedure
  if shape = ""lander"" [
    lt 5
  ]
end

to rotate-right  ;; turtle procedure
  if shape = ""lander"" [
    rt 5
  ]
end

to thrust  ;; turtle procedure
  if shape = ""lander"" [
    set xvel xvel + thrust-amount * dx
    set yvel yvel + thrust-amount * dy
    ;; lander2 has a visual indication that the thrusters are on
    set shape ""lander2""
    reset-timer
  ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2005 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2005).  NetLogo Lunar Lander model.
; http://ccl.northwestern.edu/netlogo/models/LunarLander.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2005 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/LunarLander
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model is based on the arcade game, Lunar Lander.  The object of the game is to land the red lunar module on the blue landing pad on the surface of the moon without crashing or breaking the module.

The lunar module is fragile, so you have to be moving extremely slowly to prevent damage when you touch down. You have one thruster that exerts a force depending on the tilt of the module.  You have the ability to tilt right and left.


HOW TO USE IT
-------------
Buttons:
SETUP starts the game over by creating a new surface for you to navigate and poising your module above that surface, ready for descent.
GO starts the game.  Be ready; the module will start descending fairly quickly.
LEFT and RIGHT tilt the module back and forth
THRUST fires your rockets according to your current tilt.

Sliders:
PLATFORM-WIDTH controls the width of the blue landing pad created at setup, a wider landing pad makes an easier target.
TERRAIN-BUMPINESS controls the variation in the elevation of the lunar surface.  More bumpiness may mean you will have large obstacles to maneuver around.
THRUST-AMOUNT controls the magnitude of the force of your rockets.


THINGS TO NOTICE
----------------
When terrain-bumpiness is very high some of the randomly generated surfaces are not navigable.


THINGS TO TRY
-------------
Try to land the module with the fewest adjustments.

Increase the THRUST-AMOUNT to make the game harder.


EXTENDING THE MODEL
-------------------
Currently, collisions with the edges of the module are not detected, so you can graze the side of a peak with the edge of the module without crashing.  It would be more realistic if these crashes were detected.

Add levels to the game by continually making the terrain bumpier, the platform smaller, or by some other method of making the game more difficult, perhaps alien spaceships.

Try to write a robot pilot that will automatically land the module safely.


NETLOGO FEATURES
----------------
This model uses the RANDOM-POISSON reporter to create the terrain.  See its entry in the NetLogo Dictionary, and also http://mathworld.wolfram.com/PoissonDistribution.html.

As in many NetLogo games the EVERY command is used to control the speed of the game.


RELATED MODELS
--------------
Gravitation


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (2005).  NetLogo Lunar Lander model.  http://ccl.northwestern.edu/netlogo/models/LunarLander.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2005 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/LunarLander for terms of use.
"
Frogger,/models/Sample Models/Games,"extensions [ sound ]

breed [ trucks truck ]
breed [ cars car ]
breed [ logs a-log ]
breed [ river-turtles river-turtle ]
breed [ pads pad ]
breed [ frogs frog ] ;; These are all the game pieces.

;;;;;;;;;;;;;;;
;; Variables ;;
;;;;;;;;;;;;;;;

globals [
  action            ;; Last button pressed. Prevent the player from moving the frog until the
                    ;; the game is running.  Checks the status of this button every loop.
  dead?             ;; True when no frog lives are left - used to stop the game
  lives             ;; Remaining lives
  level             ;; Current level
  jumps             ;; Current number of jumps
  time-left         ;; Time remaining
  pads-done         ;; Number of frogs that have successfully reached the pads
]

;; In NetLogo, all the breeds are ""turtles"".  This can be confusing because
;; there are also ""turtles"" in the game of Frogger -- they swim in the river.
;; To avoid confusion, we call those turtles ""river-turtles"".

turtles-own [
  speed            ;; The 'time' variable will be initialized to the value of 'speed' after the turtle moves
  time             ;; This keeps track of how many time loops have occurred since the turtle last moved.
                   ;; It actually counts down from 'speed' to zero.  Once it reaches zero, the turtle
                   ;; moves forward one space
]

river-turtles-own [
  dive?            ;; True when the turtle dives
]

;;;;;;;;;;;;;;;;;;;;;;;;
;;; Setup Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;

to startup            ;; Setup is the 'New Game' button, this will setup the game.
  setup
end

to setup              ;; Initializes the game
  ca
  set action 0
  set dead? false
  set lives start-lives
  set-default-shape frogs ""frog""
  set-default-shape cars ""car""
  set-default-shape logs ""log""
  set-default-shape river-turtles ""turtle""
  set level start-level
  next-level
end

to next-level        ;; This will call the appropriate level procedure, where the level is created
  draw-map
  if ( level = 1 )
    [ level-1 ]
  if ( level = 2 )
    [ level-2 ]
  if ( level = 3 )
    [ level-3 ]
  if ( level = 4 )
    [ level-4 ]
  if ( level = 5 )
    [ level-5 ]
  if ( level = 6 )
    [ user-message ""Actually, that was the last level.\nPerhaps you should program some more :-)""
      set dead? true]
end

;; This will color the patches to make the grass, road, and river, and creates the frog.
;; The second line causes the grass to be various similar shades of green so it looks
;; more like real grass.

to draw-map
  cp ct
  ask patches
    [ set pcolor scale-color green ((random 500) + 5000) 0 9000 ]
  setup-pads
  ask patches with [pycor <= max-pycor and pycor >= 3]
    [ set pcolor blue ]
  ask patches with [pycor <= -1 and pycor >= -5]
    [ set pcolor gray ]
  set pads-done 0
  create-frogs 1
    [ set color 53
      reset-frog
    ]
end

;; Initializes the frog by setting it to the right patch and facing the right direction

to reset-frog
  setxy 0 min-pycor
  set heading 0
  set jumps 0
  set time-left start-time
end

;; Creates the five pads equally spaced at the top of the board.
;; The second line uses the modulus operation to determine which x-cor
;; is divisible by three.  This is an easy way to have a pad created every
;; three patches.

to setup-pads
  set-default-shape pads ""pad""
  ask patches with [pycor = max-pycor and pxcor mod 3 = 0]
    [ sprout-pads 1 ]
end

to create-truck [ x y direction quickness ]   ;; Creates and initializes a truck
  let truckColor (random 13 + 1) * 10 + 3
  ask patches with [(pxcor = x or pxcor = (x + 1)) and pycor = y]
    [ sprout-trucks 1
        [ set color truckColor
          set heading direction
          set speed quickness
          set time speed
          ifelse ((pxcor = x) xor (direction = 90))
            [ set shape ""truck"" ]
            [ set shape ""truck rear"" ]
        ]
    ]
end

to create-car [x y direction quickness]     ;; Creates and initializes a car
  create-cars 1
    [ set color (random 13 + 1) * 10 + 3
      setxy x y
      set heading direction
      set speed quickness
      set time speed
    ]
end

;; Creates and initializes a log.

to create-log [x y leng quickness]
  ask patches with [pycor = y and pxcor >= x and pxcor < (x + leng)]
    [ sprout-logs 1
        [ set color brown
          set heading 90
          set speed quickness
          set time speed
        ]
    ]
end

to create-river-turtle [x y leng quickness]    ;; Creates and initializes a river-turtle
  ask patches with [pycor = y and pxcor >= x and pxcor < (x + leng)]
    [ sprout-river-turtles 1
        [ set heading 270
          set speed quickness
          set time speed
          set color 54
          set dive? false
        ]
    ]
end

to make-river-turtle-dive [num]    ;; Causes a random river-turtle(s) to dive underwater.
  repeat num
    [ ask one-of river-turtles with [not dive?]
        [ set dive? true ]
    ]
end


;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Runtime Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;


to go            ;; The main procedure
  if dead?
    [ stop ]
  move
end

;; This is the time loop: every 0.1 seconds it decrements every turtle's 'time'
;; variable and check to see if it should move (when it reaches zero).  It then will
;; reset the 'time' if it is zero.  The logs and river-turtles need their own special
;; procedure to move since they ""carry"" the frog with them.

to move
  move-frog
  every 0.1
    [ ask turtles
        [ decrement-time ]
      ask turtles with [time = 0.0 and breed != frogs]
        [ set time speed
          ifelse (breed = logs)
            [ move-log ]
            [ ifelse (breed = river-turtles)
                [ move-river-turtle ]
                [ fd 1 ]
            ]
        ]
      check-frog
    ]
  display
end

;; This will decrement the 'time' for all non-frogs and it will decrement the 'time-left'
;; global variable.  The precision function is needed to verify there is only one decimal
;; place on the time variables.

to decrement-time
  ifelse (breed = frogs)
    [ set time-left precision (time-left - 0.1) 1 ]
    [ set time precision (time - 0.1) 1 ]
end

;;  Every time loop, we need to see what the frog's status is (dead, on a pad, etc..)
;;  First it will need to see if it is on a pad and make sure there are no other frogs there
;;  (by checking the shape of the the pad).  Then you need to check to see if the frog is in
;;  a space where he should die.  Finally, it checks to see if the level is complete.

to check-frog
  ask frogs
    [ if any? pads-here with [shape = ""pad""]
        [ sound:play-drum ""CRASH CYMBAL 2"" 97
          ask pads-here
            [ set shape ""frog""
              set heading 0
              set color 54
              set pads-done (pads-done + 1)
            ]
          reset-frog
        ]
      if ((any? trucks-here) or (any? cars-here) or (time-left <= 0) or
         ((pcolor = blue) and
          (count pads-here = 0) and
          (count logs-here = 0) and
          (count river-turtles-here with [not hidden?] = 0)))
        [ kill-frog ]
    ]
  if ( pads-done = 5 )
    [ set level (level + 1)
      set pads-done 0
      user-message (word ""Congrats, all your frogs are safe!\nOn to level "" level ""..."")
      next-level
    ]
end

to kill-frog        ;; This is called when the frog dies, checks if the game is over
  set lives (lives - 1)
  ifelse (lives = 0)
    [ user-message ""Your frog died!\nYou have no more frogs!\nGAME OVER!""
      set dead? true
      die
    ]
    [ user-message (word ""Your frog died!\nYou have "" lives "" frogs left."")
      reset-frog
    ]
end

;; This is a special procedure to move a log.  It needs to move any frogs that
;; are on top of it.

to move-log
  ask frogs-here
    [ if (pxcor != max-pxcor)
        [ set xcor xcor + 1 ]
    ]
  fd 1
end

;; This is a special procedure to move the river-turtles.  It needs to move any frogs that
;; are on top of it.

to move-river-turtle
  fd 1
  ask frogs-at 1 0
    [ set xcor xcor - 1
      if (xcor = max-pxcor)
        [ set xcor xcor + 1 ]
    ]
  dive-river-turtle
end

;; If a river-turtle has been instructed to dive, this procedure will implement that.
;; It will also cause it to splash and rise back up.  It uses a random numbers to
;; determine when it should dive and rise back up.  Theoritically, it will dive about
;; every eighth move and stay down for about five moves, but this isn't always the case
;; (the randomness is added for increasing the challenge of the game)

to dive-river-turtle
  if dive?
    [ ifelse (hidden? and random 5 = 1)
        [ show-turtle ]
        [ if ( shape = ""splash"" )
            [ set shape ""turtle""
              hide-turtle
            ]
          if (shape = ""turtle"" and random 8 = 1)
            [ set shape ""splash"" ]
        ]
    ]
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Interface Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;

to move-frog
  if (action != 0)
    [ if (action = 1)
        [ move-left ]
      if (action = 2)
        [ move-right ]
      if (action = 3)
        [ move-down ]
      if (action = 4)
        [ move-up ]
      sound:play-drum ""LONG GUIRO"" 50
      set action 0
    ]
end

to move-left
  ask frogs with [xcor != min-pxcor]
    [ set heading 270
      fd 1
      set jumps ( jumps + 1 )
    ]
  check-frog
end

to move-right
  ask frogs with [xcor != max-pxcor]
    [ set heading 90
      fd 1
      set jumps ( jumps + 1 )
    ]
  check-frog
end

to move-up
  ask frogs with [ycor != max-pycor]
    [ set heading 0
      fd 1
      set jumps ( jumps + 1 )
    ]
  check-frog
end

to move-down
  ask frogs with [ycor != min-pycor]
    [ set heading 180
      fd 1
      set jumps ( jumps + 1 )
    ]
  check-frog
end


;;;;;;;;;;;;;;
;;; Levels ;;;
;;;;;;;;;;;;;;

to level-1
  create-truck 5 -5 270 .9
  create-truck 0 -5 270 .9
  create-truck -8 -4 90 .9
  create-truck -5 -4 90 .9
  create-truck 2 -4 90 .9
  create-truck -3 -3 270 .8
  create-truck 6 -3 270 .8
  create-car 0 -2 90 .4
  create-car -4 -2 90 .4
  create-car 8 -1 270 .2
  create-car 3 -1 270 .2
  create-log 4 3 3 .6
  create-log -8 3 5 .6
  create-log 4 5 2 .7
  create-log -4 5 3 .7
  create-log 1 7 4 .3
  create-log -6 7 4 .3
  create-river-turtle 2 4 2 .4
  create-river-turtle -4 4 4 .4
  create-river-turtle 5 4 4 .4
  create-river-turtle -3 6 4 .5
  create-river-turtle 7 6 3 .5
end

to level-2
  create-truck 4 -5 270 .8
  create-truck -3 -5 270 .8
  create-truck 0 -4 90 .9
  create-truck -4 -4 90 .9
  create-truck -1 -3 270 .8
  create-truck 4 -3 270 .8
  create-truck -5 -3 270 .8
  create-car 0 -2 90 .2
  create-car -4 -2 90 .2
  create-car 8 -2 90 .2
  create-car 6 -1 270 .4
  create-car 2 -1 270 .4
  create-car -3 -1 270 .4
  create-car -6 -1 270 .4
  create-log 6 3 3 .6
  create-log -4 3 4 .6
  create-log 0 5 3 .3
  create-log -6 5 3 .3
  create-log 1 7 4 .5
  create-log 6 7 4 .5
  create-river-turtle 0 4 4 .3
  create-river-turtle 6 4 4 .3
  create-river-turtle 0 6 4 .4
  create-river-turtle 6 6 3 .4
  make-river-turtle-dive 1
end

to level-3
  create-truck -8 -5 270 .7
  create-truck -4 -5 270 .7
  create-truck 0 -5 270 .7
  create-truck -2 -4 90 .7
  create-truck 2 -4 90 .7
  create-truck -6 -4 90 .7
  create-truck -4 -3 270 .7
  create-truck 0 -3 270 .7
  create-truck 4 -3 270 .7
  create-car -3 -2 90 .2
  create-car -5 -2 90 .2
  create-car 5 -2 90 .2
  create-car 1 -2 90 .2
  create-car 0 -1 270 .3
  create-car 5 -1 270 .3
  create-car -7 -1 270 .3
  create-car -3 -1 270 .3
  create-log -6 3 4 .4
  create-log -2 5 3 .4
  create-log 5 5 3 .4
  create-log -4 7 2 .2
  create-log 0 7 2 .2
  create-log 4 7 2 .2
  create-river-turtle -4 4 4 .3
  create-river-turtle 5 4 4 .3
  create-river-turtle -1 6 3 .4
  create-river-turtle -8 6 3 .4
  make-river-turtle-dive 3
end

to level-4
  create-truck -8 -5 270 .5
  create-truck -2 -5 270 .5
  create-truck 6 -5 270 .5
  create-truck 4 -4 90 .6
  create-truck -1 -4 90 .6
  create-truck -6 -4 90 .6
  create-car -4 -3 270 .3
  create-car 0 -3 270 .3
  create-car 4 -3 270 .3
  create-car 7 -3 270 .3
  create-car -3 -2 90 .2
  create-car -5 -2 90 .2
  create-car 5 -2 90 .2
  create-car 1 -2 90 .2
  create-car 0 -1 270 .3
  create-car 5 -1 270 .3
  create-car -7 -1 270 .3
  create-car -3 -1 270 .3
  create-log -3 3 3 .3
  create-log -3 5 3 .3
  create-log -3 7 3 .3
  create-river-turtle -4 4 4 .3
  create-river-turtle 4 4 4 .3
  create-river-turtle -7 4 1 .3
  create-river-turtle -1 6 3 .4
  create-river-turtle -8 6 3 .4
  create-river-turtle 3 6 2 .4
  make-river-turtle-dive 4
end

to level-5
  create-car -4 -5 270 .3
  create-car 0 -5 270 .3
  create-car 4 -5 270 .3
  create-car 7 -5 270 .3
  create-car -3 -4 90 .2
  create-car -5 -4 90 .2
  create-car 5 -4 90 .2
  create-car 1 -4 90 .2
  create-car 8 -4 90 .2
  create-car -4 -3 270 .3
  create-car 0 -3 270 .3
  create-car 4 -3 270 .3
  create-car 7 -3 270 .3
  create-car -3 -2 90 .2
  create-car -5 -2 90 .2
  create-car 4 -2 90 .2
  create-car 1 -2 90 .2
  create-car 7 -2 90 .2
  create-car 0 -1 270 .3
  create-car 5 -1 270 .3
  create-car -7 -1 270 .3
  create-car -3 -1 270 .3
  create-log -5 3 2 .2
  create-log 0 5 2 .1
  create-log -5 7 2 .2
  create-river-turtle -4 4 2 .3
  create-river-turtle 4 4 3 .3
  create-river-turtle -7 4 2 .3
  create-river-turtle -1 6 2 .3
  create-river-turtle -8 6 2 .3
  create-river-turtle 3 6 3 .3
  make-river-turtle-dive 5
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2002 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2002).  NetLogo Frogger model.
; http://ccl.northwestern.edu/netlogo/models/Frogger.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2002 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Frogger
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This model is based on the classic arcade game, Frogger.  The object of the game is to get the frog, found at the bottom of the view, across the traffic and river to a safe lily pad on the other side.


HOW IT WORKS
------------
There are two main obstacles to overcome, the road and the river.  The road has cars and trucks moving at various speeds that are liable to run over the frog.  Once you have crossed the road safely, you must overcome the danger lurking in the river.  Unfortunately, you will die if you jump in the river, so you must keep moving towards the lily pads by jumping on the logs or sets of turtles moving back and forth in the river's current.

You must also avoid getting pushed off the edge by a log or turtle.  In addition, in the later levels, some of the turtles will dive under water -- if you happen to be standing on them you will drown!  Finally, you must also get across the board before the allotted amount of time runs out.


HOW TO USE IT
-------------
Buttons:
- NEW-GAME resets the game
- START starts the game
- The direction buttons (UP, DOWN, LEFT, RIGHT) will move your frog in that direction

Monitors
- FROGS LEFT tells you how many remaining lives you have
- LEVEL monitors the current level you are playing
- TIME LEFT shows you how much time remains
- FROG JUMPS tells you how many jumps you has taken

Sliders
- START-LIVES will determine how many lives you will start with
- START-TIME sets how much time you start out with
- START-LEVEL is used to determine which level you will start on

Cast of characters:
- Green Frog:      This is you.
- Truck:           This is a truck.  Avoid at all costs.  They are usually pretty slow.
- Car:             This is a car.  Avoid at all costs.  They are usually fast.
- Brown Squares:   This is a log.  You need to jump onto these to get across the river.
- Turtle:          This is a turtle.  You need to jump onto these.  Avoid ones that dive.
- Green Circles:   This is the lily pad.  You want to get on these to win the level.
- Blue Squares:    This is the river.  You can't land on this.
- Gray Squares:    This is the road.  You can jump on this, but watch out for vehicles.
- Green Patches:   This is grass.  You are pretty safe here.


THINGS TO TRY
-------------
See if you can get through all of the levels.

Try to beat your previous time.

Try to make as few jumps as possible in the time allotted.

Try to use as few lives as possible.


THINGS TO NOTICE
----------------
Determine how many jumps it would take to get across the board without obstacles.

Determine how many jumps it would take to get across the board with obstacles.

How does each of the two questions above relate to the time it takes you to complete a level?

If you take just as many jumps with obstacles as without, why does it take different durations of time to get across?


EXTENDING THE MODEL
-------------------
Write your own levels by altering the code in the Procedures tab.

Add some bonuses or additional hazards.

Implement a scoring system.

Write a robot script that will move your frog automatically.


NETLOGO FEATURES
-----------------
This model uses breeds to implement the different moving game pieces.

The EVERY command is used to control the speed of the game.

The USER-MESSAGE command presents messages to the user.

MOUSE-DOWN?, MOUSE-XCOR, and MOUSE-YCOR are used to detect and handle mouse clicks.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (2002).  NetLogo Frogger model.  http://ccl.northwestern.edu/netlogo/models/Frogger.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2002 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Frogger for terms of use.
"
Minesweeper,/models/Sample Models/Games,"globals [
  clock             ;; how many seconds the game has lasted so far
  game-started?     ;; initially false, becomes true when player first presses GO
  game-over?        ;; initially false, becomes true if the player loses
]

breed [ grass-squares grass-square ]    ;; these are the green squares the player hasn't tested yet
breed [ mines mine ]             ;; the mines (initially invisible)
breed [ markers marker ]          ;; show where the player thinks mines are

to setup
  clear-all
  set clock 0
  set game-started? false
  set game-over? false
  set-default-shape grass-squares ""grass patch""
  set-default-shape mines ""bomb""
  set-default-shape markers ""bomb""
  ask patches [
    sprout-grass-squares 1 [ set color green ]
    set pcolor gray
  ]
  ;; make the number of mines determined by the mine-count slider
  ask n-of mine-count patches [
    sprout-mines 1 [
      set color black
      hide-turtle
    ]
  ]
end

to go
  if game-over? [
    ask markers with [any? mines-here] [ die ]
    ask markers [ set color gray  - 2 ]
    ask mines [ show-turtle ]
    set game-over? true
    ask patches [ set pcolor red ]
    stop
  ]
  if not game-started? [
    ;; this must be the first time through GO, so start the clock
    reset-timer
    set game-started? true
  ]
  set clock timer
  if all? grass-squares [any? mines-here] [
    ;; you win!!!
    ask mines [ show-turtle ]
    ask patches [ set pcolor blue ]
    stop
  ]
  if mouse-down? [
    ask patch (round mouse-xcor) (round mouse-ycor) [
      ifelse any? mines-here
        [ set game-over? true ]   ;; aiggghhhh!
        [ clear ]                 ;; whew!
    ]
  ]
  tick
end

to clear  ;; patch procedure
  ask grass-squares-here [ die ]
  ask markers-here [ die ]
  let total count neighbors with [any? mines-here]
  ifelse total > 0
    [ set plabel total ]
    ;; if none of our neighbors have mines on them, then they can
    ;; be cleared too, to save the user from extra clicking
    [ ask neighbors with [any? grass-squares-here]
      [ clear ] ]
end

to mark/unmark
  if not mouse-inside? [ stop ]
  ask patch round mouse-xcor round mouse-ycor [
    if any? grass-squares-here [
      ifelse any? markers-here
        [ ask markers-here [ die ] ]
        [ sprout-markers 1 [ set color black ] ]
    ]
  ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2005 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2005).  NetLogo Minesweeper model.
; http://ccl.northwestern.edu/netlogo/models/Minesweeper.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2005 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Minesweeper
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This is game of strategy.  There are land mines hidden beneath the green landscape.  Your job is to locate all of the mines without exploding any of them.


HOW IT WORKS
------------
If you click on a patch of grass without a mine, a number appears. The number tells you how many adjacent mines there are.

If you click on a mine, the mine explodes, and you lose the game.

You win the game by uncovering every square that doesn't have a mine.

If you lose, the land turns red.  If you win, it turns blue.


HOW TO USE IT
-------------
Press SETUP to set up the board, then press GO to play the game.

While GO is pressed, click on green squares to check them for mines.

To help you remember where where you think the mines are, you can mark a square by pointing at it and pressing the M key.  (Note the M in the corner of the MARK/UNMARK button.  If the M is grayed out, hide the command center.)

You can make the game easier or harder by adjusting the MINE-COUNT slider before pressing SETUP.


THINGS TO NOTICE
----------------
Use the numbers to deduce where it is safe to click and where it isn't.

Can you always know where it is safe to click, or do you have to guess sometimes?

Note that when you click in an empty region, the model saves you time by automatically clearing all the surrounding empty cells for you.  This keeps the game from being tedious.


THINGS TO TRY
-------------
Try to win the game as fast as possible.  Your time appears in the CLOCK monitor.

Try playing with a bigger or smaller board by editing the view and adjusting min-p(x/y)cor and max-p(x/y)cor.


EXTENDING THE MODEL
-------------------
Write out a file to disk containing the best times players have achieved so far for a given board size.  Update the file when someone beats a previous time.

Write a computer player that can play the game automatically.  What strategy should it use?

Modify the game to use a hexagonal grid instead of a square one.  (See Hex Cells Example, in Code Examples, to see how to make a hexagonal grid.)


NETLOGO FEATURES
----------------
The NEIGHBORS primitive is used to find neighboring squares.


RELATED MODELS
--------------
Some of the models in Cellular Automata section, under Computer Science, also have rules based on how many neighboring cells are occupied.


CREDITS AND REFERENCES
----------------------
According to http://en.wikipedia.org/wiki/Minesweeper_%28computer_game%29 , Minesweeper was invented by Robert Donner in 1989.  A version of the game is included with the Windows operating system.

Landmines are a real problem that kills people every day. To learn more about the campaign to ban landmines, see http://www.icbl.org .

To refer to this model in academic publications, please use:  Wilensky, U. (2005).  NetLogo Minesweeper model.  http://ccl.northwestern.edu/netlogo/models/Minesweeper.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2005 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Minesweeper for terms of use.
"
Pac-Man Level Editor,/models/Sample Models/Games/Unverified,"breed       [ pacmans pacman ]
breed       [ ghosts ghost ]
breed       [ pellets pellet ]
breed       [ bonuses bonus ]
turtles-own [ home-pos ]
ghosts-own  [ eaten? ]
pellets-own [ powerup? ]
bonuses-own [ value countdown ]

patches-own [ pellet-grid? ]

globals [
  difficulty    ;; Slider in Pac-Man.nlogo
  level         ;; Current Level
  score         ;; Your Score
  lives         ;; Remaining Lives
  extra-lives   ;; Total Number of Extra Lives you've won
  scared        ;; Time until Ghosts aren't scared (0 means not scared)
  level-over?   ;; True when a level is complete
  dead?         ;; True when pacman is loses a life
  next-bonus-in ;; Time until next bonus is created
  tool          ;; The currently selected tool
]


;;;;;;;;;;;;;;;;;;;;;;
;; Setup Procedures ;;
;;;;;;;;;;;;;;;;;;;;;;

;; Setup a new level
to new
  if user-yes-or-no? ""Do you really want to clear the level?""
  [
    ca
    set difficulty 0
    set level 0
    set score 0
    set lives 3
    set extra-lives 0
    set scared 0
    set level-over? false
    set dead? false
    set next-bonus-in 0
    set tool ""Eraser""

    create-pacmans 1
    [
      set color yellow
      set shape ""pacman""
      setxy 10 10
    ]

    create-ghosts 4
    [
      set shape ""ghost""
      setxy 0 3
      set heading 0
      set eaten? false
    ]

    ; set ghost colors and initial position
    ask turtle 1 [ set color 15  setxy 10 9 ]
    ask turtle 2 [ set color 26  setxy 10 8 ]
    ask turtle 3 [ set color 127 setxy 10 7 ]
    ask turtle 4 [ set color 85  setxy 10 6 ]

    ask turtles
    [ set home-pos list xcor ycor ]

    ask patches
    [ set pellet-grid? false ]
  ]
end


;;;;;;;;;;;;;;;;;;;;;;;;
;; Runtime Procedures ;;
;;;;;;;;;;;;;;;;;;;;;;;;

;; If the mouse is down, use the Current Tool on the patch the mouse is over
to draw
  if mouse-down?
  [
    ;; Eraser Tool - Clears Walls/Gates, Removes Pellets
    if tool = ""Eraser""
    [ erase ]
    ;; Wall Tool - Draws a Wall - Neither Pac-Man nor Ghosts can move through walls
    if tool = ""Draw Wall""
    [ draw-boundary blue ]
    ;; Gate Tool - Draws a Gate - Only Ghosts can move through Gates
    ;;             Gates also heal ghosts which have been eaten.
    if tool = ""Draw Ghost Gate""
    [ draw-boundary gray ]
    ;; Pellet Tool - Places a pellet on the grid
    if tool = ""Place Pellet""
    [ place-pellet ]
    ;; Power Pellet Toggle Tool - Changes a Pellet into a Power Pellet and vice versa.
    if tool = ""Toggle Power Pellet""
    [ toggle-power-pellet ]
    ;; Pac-Man Tool - Changes Pac-Man's starting position
    if tool = ""Place Pac-Man""
    [ place-pacman ]
    ;; Ghost Tool - Changes the starting position of the Ghost chosen by the WHICH-GHOST slider
    if tool = ""Place Ghost""
    [ place-ghost ]
  ]
end

;;;;;;;;;;;;;;;;;;;;;
;; Tool Procedures ;;
;;;;;;;;;;;;;;;;;;;;;

;; Clears Walls/Gates, Removes Pellets from the patch the mouse is over
to erase
  ask patch (round mouse-xcor) (round mouse-ycor)
  [
    set pcolor black
    set pellet-grid? false
    ask pellets-here
    [ die ]
  ]
end

;; Draws a Wall or a Gate if there are not any pellets, or Ghosts, or Pac-Man on the patch the mouse is over
to draw-boundary [ boundary-color ]
  ask patch (round mouse-xcor) (round mouse-ycor)
  [
    ifelse not any? turtles-here
    [ set pcolor boundary-color ]
    [
      ifelse boundary-color = gray
      [
        ifelse any? pacmans-here or any? pellets-here
        [ user-message ""You cannot place a gate on top of pacman or a pellet."" ]
        [ set pcolor boundary-color ]
      ]
      [ user-message ""You cannot place a wall on top of pacman, a ghost, or a pellet."" ]
    ]
  ]
end

;; Place a pellet on a patch if the patch is not already a Wall or a Gate
to place-pellet
  ask patch (round mouse-xcor) (round mouse-ycor)
  [
    ifelse pcolor != black
    [ user-message ""You cannot place a pellet on top of a wall or a gate."" ]
    [
      if not any? turtles-here
      [
        sprout-pellets 1
        [
          set color white
          set powerup? false
          set shape ""pellet""
        ]
        set pellet-grid? true
        set pcolor black
      ]
    ]
  ]
end

;; Changes a Pellet into a Power Pellet and vice versa.
to toggle-power-pellet
  if any? pellets-on patch mouse-xcor mouse-ycor
  [
    ask one-of pellets-on patch mouse-xcor mouse-ycor
    [
      set powerup? not powerup?
      ifelse powerup?
      [ set shape ""circle"" ]
      [ set shape ""pellet"" ]
      wait 0.1
    ]
  ]
end

;; Changes Pac-Man's starting position
to place-pacman
  ifelse [pcolor] of patch round mouse-xcor mouse-ycor != black
  [ user-message ""You must place pacman on a corridor space, not a wall or a gate."" ]
  [
    ask pacmans
    [ setxy (round mouse-xcor) (round mouse-ycor) ]
  ]
end

;; Changes the starting position of the Ghost chosen by the WHICH-GHOST slider
to place-ghost
  ifelse [pcolor] of patch mouse-xcor mouse-ycor = blue
  [ user-message ""You must place a ghost on a corridor space or a gate, not a wall."" ]
  [
    ask turtle which-ghost
    [ setxy (round mouse-xcor) (round mouse-ycor) ]
  ]
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Saving and Loading Procedures ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Change the Level
to set-level
  if level > 0
  [
    if not user-yes-or-no? ""Are you sure you want to change the level number of this map?""
    [ stop ]
  ]
  let temp 0
  while[ temp <= 0 ]
  [
    set temp read-from-string user-input ""Input New Level Number:""
    if temp <= 0
    [ user-message ""The level must be a positive number."" ]
  ]
  set level temp
end

;; If there are pellets and the level has been set, save the file
to save-level
  if not any? pellets
  [
    user-message ""You must have at least 1 pellet in a level.""
    stop
  ]
  if level <= 0
  [
    user-message ""You must choose a positive level number before saving.""
    set-level
  ]
  let filepath (word ""../pacmap"" level "".csv"")
  ifelse user-yes-or-no? (word ""File will be saved at: "" filepath
     ""\nIf this file already exists, it will be overwritten.\nAre you sure you want to save?"")
  [
    export-world filepath
    user-message ""File Saved.""
  ]
  [ user-message ""Save Canceled. File not saved."" ]
end

;; Load a level
to load-level
  let choice 0
  while[ choice <= 0 ]
  [
    set choice read-from-string user-input ""Load What Level? (1 or greater)""
    if choice <= 0
    [ user-message ""You must choose a positive level number to load."" ]
  ]
  let filepath (word ""../pacmap"" choice "".csv"")
  ifelse user-yes-or-no? (word ""Load File: "" filepath
         ""\nThis will clear your current level and replace it with the level loaded.""
         ""\nAre you sure you want to Load?"")
  [
    import-world filepath
    set tool ""Eraser""
    user-message ""File Loaded.""
  ]
  [ user-message ""Load Canceled. File not loaded."" ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2003 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2003).  NetLogo Pac-Man Level Editor model.
; http://ccl.northwestern.edu/netlogo/models/Pac-ManLevelEditor.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2003 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Pac-ManLevelEditor
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This is a level editor for the Pac-Man model.  It can be used to edit the included levels and to create new levels that can be played in the Pac-Man model.  Familiarity with the Pac-Man model will be very helpful before attempting to create or edit levels.


HOW IT WORKS
------------
Use the various tools to construct a level for the Pac-Man model.


HOW TO USE IT
-------------
The following are for setup, loading, and saving:

NEW LEVEL - Clears the level and sets it up to start making a new level from scratch.
LOAD LEVEL - Prompts for a level number to load for editing.  The file opened will be the file ""pacmap#.csv"" (where # is the input level number), and the file must be in the Games folder in the Sample Models section of the Models Library.  (Files will not be visible in the Models Library Browser.)
-- With both NEW LEVEL and LOAD LEVEL, any unsaved changes to a level will be lost (you will be reminded of this and prompted to continue when using these buttons).
SAVE LEVEL - Prompts to save the current level to a file usable by the Pac-Man model.  The file will be saved in the Games folder in the Sample Models section of the Models Library with the Pac-Man model with the file name ""pacmap#.csv"" (where # is the currently set level number).  Saving a level with the same level number as a previously created level will overwrite the old level (it is not be possible to recover overwritten levels).
SET LEVEL - Sets the current value of 'level' which determines the filename of the level when it is saved with SAVE LEVEL.
LEVEL - This monitor shows the current value of level.

The following are the tools for actually editing levels:

USE TOOL - Allows you to use the current tool on a patch by clicking on it with the mouse.
CURRENT TOOL - Shows what the currently selected tool is.
WHICH-GHOST - This slider determines which Ghost will be moved by the PLACE GHOST tool.

-- The following buttons set the current tool to do different actions.
ERASER - This tool allows you to clear a patch of walls, gates, and pellets.
DRAW WALL - This tool allows you to draw a wall (blue) on the current patch.
DRAW GATE - This tool allows you to draw a gate (gray) on the current patch.
PLACE PELLET - This tool allows you to place a pellet on the grid.
TOGGLE POWER PELLET - This tool allows you to change a Pellet into a Power Pellet and vice versa.
PLACE PAC-MAN - This tool allows you to change Pac-Man's starting position.
PLACE GHOST - This tool allows you to change the starting position of the Ghost chosen by WHICH-GHOST.


THINGS TO NOTICE
----------------
If Pac-Man goes off the edge of the maze he will wrap around to the other side.

Identifying Things in the Maze:
-- Yellow Circle with a mouth:  This is Pac-Man - The protagonist.
-- Small White Circles:         These are Pellets - Pac-Man will have to collect all of these (including the Power-Pellets) to move on to the next level.
-- Large White Circles:         These are Power-Pellets - They allow Pac-Man to eat the Ghosts for a limited amount of time.
-- Blue Squares:                These are the walls of the maze - Neither Pac-Man nor the Ghosts can move through the walls.
-- Gray Squares:                These are the Ghost Gates - Only Ghosts can move through them, and if they do so after having been eaten they will be healed.
-- Colorful Ghost with Eyes:    These are the Ghosts - The antagonists.


THINGS TO TRY
-------------
Make a maze by strategically placing gates that has corridors that only Ghosts can travel down, but Pac-Man has to circum-navigate.


EXTENDING THE MODEL
-------------------
The Pac-Man model suggests adding new features.  Add tools to this model to allow you to construct these new features in a level.

Add the ability to have a variable number of ghosts in a level (including more than four).


NETLOGO FEATURES
-----------------
This model makes use of breeds, create-<breed>, user-message, user-input, user-yes-or-no?, read-from-string, as well as the mouse primitives and import-world and export-world for loading and saving levels.


RELATED MODELS
--------------
Pac-Man


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (2003).  NetLogo Pac-Man Level Editor model.  http://ccl.northwestern.edu/netlogo/models/Pac-ManLevelEditor.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2003 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Pac-ManLevelEditor for terms of use.
"
Planarity,/models/Sample Models/Games,"globals [
  level    ;; determines how many nodes you have to untangle;
           ;; the formula is below
]

to setup
  clear-all
  set-default-shape turtles ""circle""
  ask patches [ set pcolor white ]      ;; plain white background
  set level starting-level
  setup-level
end

to setup-level
  reset-ticks  ;; use tick counter as a move counter
  clear-turtles  ;; when the turtles die, the links connecting them die too
  ;; create nodes and position them randomly
  create-turtles 4 + level [
    set color blue
    setxy random-xcor random-ycor
  ]
  ;; Now we need to make some links.  We have to be careful that
  ;; the resulting graph has a solution.  Probably there are lots
  ;; of ways this could be done, but this was the simplest way we
  ;; could think of.
  ;; First make a bunch of links at random.
  while [count links < count turtles] [
    ask one-of turtles [
      ask one-of other turtles [ attempt-link ]
    ]
  ]
  ;; Then fill in all remaining allowable links.
  ask turtles [
    ask other turtles [ attempt-link ]
  ]
  ;; Now we have a graph which we know is solvable,
  ;; because the current layout is a solution.
  ;; Time to scramble the nodes around!
  while [solved?] [ scramble ]
  display
end

to attempt-link  ;; link procedure
  ;; note that if the link already exists, nothing happens
  create-link-with myself [
    if any-intersections? [ die ]
  ]
end

to scramble
  ;; The turtles agentset is always in random order,
  ;; so this makes a random layout.
  layout-circle turtles (world-width / 2 - 1)
end

;; This procedure lets us find the next turtle,
;; or the turtle two over, and so on.
to-report turtle-plus [n]  ;; turtle procedure
  report turtle ((who + n) mod count turtles)
end

to go
  if mouse-down? [
    ;; find the closest node
    let grabbed min-one-of turtles [distancexy mouse-xcor mouse-ycor]
    ;; loop until the mouse button is released
    while [mouse-down?] [
      ask grabbed [ setxy mouse-xcor mouse-ycor ]
      display
    ]
    ;; use tick counter as a move counter
    tick
    ;; check if the level is solved
    if solved? [
      user-message ""You rock. Now try this...""
      set level level + 1
      setup-level
    ]
  ]
end

to-report solved?
  report all? links [not any-intersections?]
end

to-report any-intersections?  ;; link procedure
  report any? other links with [crossed? self myself]
end

to-report crossed? [link-a link-b]
  ;; store nodes in variables for easy access
  let a1 [end1] of link-a
  let a2 [end2] of link-a
  let b1 [end1] of link-b
  let b2 [end2] of link-b
  let nodes (turtle-set a1 a2 b1 b2)
  ;; if the links share a node, they don't cross
  if 4 > count nodes [ report false ]
  ;; but if two nodes are on top of each other, we will say
  ;; the links do cross (so you can't cheat that way)
  if 4 > length remove-duplicates [list xcor ycor] of nodes
    [ report true ]
  ;; if the ends of link-a are on opposite sides of link-b,
  ;; and the ends of link-b are on opposite sides of link-a,
  ;; then the links cross
  report [subtract-headings towards a2 towards b1 < 0 xor
          subtract-headings towards a2 towards b2 < 0] of a1
     and [subtract-headings towards b2 towards a1 < 0 xor
          subtract-headings towards b2 towards a2 < 0] of b1
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; Copyright 2007 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2007).  NetLogo Planarity model.
; http://ccl.northwestern.edu/netlogo/models/Planarity.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2007 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Planarity
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This is a puzzle game where you try to untangle a graph. (A graph is a collection of nodes connected by lines.) Try to reposition the nodes so that no two lines cross. The more nodes, the harder it gets!


HOW IT WORKS
------------
The game knows how to generate solvable graphs, and it also knows how to detect whether any lines intersect. The details are in the Procedures tab.


HOW TO USE IT
-------------
Use the STARTING-LEVEL slider to choose the initial difficulty level.  If you're a beginner, start at 1.  Press SETUP to set up a new board, then press GO to play.  Once the GO button is pressed, you can use your mouse to drag the nodes around.

Every level is solvable. One you find a solution, you will automatically be taken to the next level.


THINGS TO NOTICE
----------------
The game only gives you solvable graphs. How might the game be able to guarantee this?  (One answer is in the Procedures tab.)

Can you draw an example of an unsolvable graph on a piece of paper?  How many nodes are in the smallest unsolvable graph?

On early levels, you can usually untangle the nodes without too much thought.  On later levels, you'll probably need to develop some conscious strategies.  What strategies do you find most effective?  When your friends play, do they use the same strategies you do?


THINGS TO TRY
-------------
See how high a level you can solve.

Try to solve each level in the fewest number of moves. (The tick counter shows you how many moves you've made.)


EXTENDING THE MODEL
-------------------
Are there any other ways of generating solvable graphs besides the SETUP-LEVEL?  Does it matter what method is used? The more links you can make, the harder the level will be, but if you make too many links, the level might not be solvable at all!

Wherever two links intersect, add a small, brightly colored turtle to mark the intersection.  (You'll need two breeds of turtle, one for the nodes, one for the markers.  Intersecting Links Example has code for locating the intersection points.)

Make it possible to select multiple nodes and move them together.


NETLOGO FEATURES
----------------
The nodes are turtles; the lines connecting them are links.  The code does not make use of patches (other than to make a plain white background).

NetLogo does not have a primitive which detects whether two links intersect.  To do the detection, the code uses the SUBTRACT-HEADINGS primitive and some math.


RELATED MODELS
--------------
Intersecting Links Example -- has sample code for finding the point where two links intersect (unlike this model, which only determines whether that point exists or not)


CREDITS AND REFERENCES
----------------------
Thanks to Josh Unterman and Seth Tisue for their work on this model and to Jim Lyons for coding advice.

Original version created by John Tantalo, from an original concept by Mary Radcliffe. Tantalo's site is here: http://www.planarity.net/.

Solvable graphs are called ""planar graphs"" by mathematicians.  See http://en.wikipedia.org/wiki/Planar_graph.

To refer to this model in academic publications, please use:  Wilensky, U. (2007).  NetLogo Planarity model.  http://ccl.northwestern.edu/netlogo/models/Planarity.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2007 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Planarity for terms of use.
"
Pac-Man,/models/Sample Models/Games,"turtles-own [ home-pos ]
patches-own [ pellet-grid? ]  ;; true/false: is a pellet here initially?

breed [ pellets pellet ]
pellets-own [ powerup? ]

breed [ bonuses bonus ]
bonuses-own [ value countdown ]

breed [ pacmans pacman ]
pacmans-own  [ new-heading ]

breed [ ghosts ghost ]
ghosts-own  [ eaten? ]

globals [
  level         ;; current level
  score         ;; your score
  lives         ;; remaining lives
  extra-lives   ;; total number of extra lives you've won
  scared        ;; time until ghosts aren't scared (0 means not scared)
  level-over?   ;; true when a level is complete
  dead?         ;; true when Pac-Man is loses a life
  next-bonus-in ;; time until next bonus is created
  tool which-ghost ;; variables needed to properly load levels 4 and above.
]

;;;;;;;;;;;;;;;;;;;;;;;;
;;; Setup Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;

to new  ;; Observer Button
  clear-all
  set level 1
  load-map
  set score 0
  set lives 3
  set extra-lives 0
  set scared 0
  set level-over? false
end

to load-map  ;; Observer Procedure
  ;; Filenames of Level Files
  let maps [""pacmap1.csv"" ""pacmap2.csv"" ""pacmap3.csv""
            ""pacmap4.csv"" ""pacmap5.csv""]
  let current-score score
  let current-lives lives
  let current-extra-lives extra-lives
  let current-difficulty difficulty

  ifelse ((level - 1) < length maps)
  [ import-world item (level - 1) maps
    set score current-score
    set lives current-lives
    set extra-lives current-extra-lives
    set difficulty current-difficulty
    set dead? false
    ask pacmans
    [ set home-pos list xcor ycor ]
    ask ghosts
    [ set home-pos list xcor ycor ]
  ]
  [ set level 1
    load-map ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Runtime Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

to play  ;; Observer Forever Button
  ;; Only true at this point if you died and are trying to continue
  if dead?
  [ stop ]
  every (1 - difficulty / 10)
  [ move-pacman ]
  every 0.25
  [ update-bonuses ]
  if floor (score / 35000) > extra-lives
  [ set lives lives + 1
    set extra-lives extra-lives + 1 ]
  if dead?
  [ ifelse lives = 0
    [ user-message word ""Game Over!\nScore: "" score ]
    [ set lives lives - 1
      ifelse lives = 0
      [ user-message ""You died!\nNo lives left."" ]
      [ ifelse lives = 1
        [ user-message ""You died!\nOnly 1 life left."" ]
        [ user-message (word ""You died!\nOnly "" lives "" lives left."") ]
      ]
      ask pacmans
      [ setxy (item 0 home-pos) (item 1 home-pos)
        set heading 0
      ]
      ask ghosts
      [ setxy (item 0 home-pos) (item 1 home-pos)
        set heading 0
        set shape ""ghost""
      ]
      set dead? false
    ]
    stop
  ]
  if level-over?
  [ user-message word ""Level Complete!\nScore: "" score  ;; \n means start a new line
    set level level + 1
    load-map
    set level-over? false
    stop ]
  every 1.6 * (1 - difficulty / 10)
  [ move-ghosts ]
  every next-bonus-in
  [ make-bonus ]
  display
end

to move-pacman  ;; Observer Procedure
  ask pacmans
  [ ;; move forward unless blocked by wall
    let old-heading heading
    set heading new-heading
    if [pcolor] of patch-ahead 1 != black
    [ set heading old-heading ]
    if [pcolor] of patch-ahead 1 = black
    [ fd 1 ]
    consume
    ;; Level ends when all pellets are eaten
    if not any? pellets
    [ set level-over? true ]
    ;; Animation
    ifelse shape = ""pacman""
    [ set shape ""pacman open"" ]
    [ set shape ""pacman"" ]
  ]
end

to consume  ;; Pacman Procedure
  ;; Consume Bonuses
  if any? bonuses-here
  [ set score score + sum [value] of bonuses-here
    ask bonuses-here [ die ] ]

  ;; Consume Pellets
  if any? pellets-here
  [ ifelse [powerup?] of one-of pellets-here
    [ set score score + 500
      set scared 40
      ask ghosts
      [ if not eaten?
        [ set shape ""scared"" ] ]
    ]
    [ set score score + 100 ]
    ask pellets-here [ die ] ]

  ;; Ghosts
  if any? ghosts-here with [not eaten?]
  [ ifelse scared = 0
    [ set dead? true ]
    [ ask ghosts-here with [not eaten?]
      [ set eaten? true
        set shape ""eyes""
        set score score + 500 ]
    ]
  ]
end

to update-bonuses  ;; Observer Procedure
  ask bonuses
  [ set heading heading + 13
    set countdown countdown - 1
    if countdown = 0
    [ die ] ]
end

to move-ghosts  ;; Observer Procedure
  ask ghosts
  [ ifelse eaten?
    [ if [pcolor] of patch-at 0 1 = gray
      [ set eaten? false
        set shape ""ghost"" ]
      return-home
    ]
    [ choose-heading ]
    fd 1
  ]
  if scared > 0
  [ set scared scared - 1
    ifelse scared < 10 and scared mod 2 = 0
    [ ask ghosts with [not eaten?]
      [ set shape ""ghost"" ] ]
    [ ask ghosts with [not eaten?]
      [ set shape ""scared"" ] ]
    if scared = 0
    [ ask ghosts with [not eaten?]
      [ set shape ""ghost"" ]
    ]
  ]
end

to return-home  ;; Ghosts Procedure
  let dirs clear-headings
  let new-dirs remove opposite heading dirs
  let home-dir 0
  if pcolor != gray
    [ set home-dir towards one-of patches with [pcolor = gray] ]
  let home-path 90 * round (home-dir / 90)

  if length new-dirs = 1
  [ set heading item 0 new-dirs ]
  if length new-dirs > 1
  [ ifelse position home-path new-dirs != false
    [ set heading home-path ]
    [ set heading one-of new-dirs ]
  ]
end

to choose-heading  ;; Ghosts Procedure
  let dirs clear-headings
  let new-dirs remove opposite heading dirs
  let pacman-dir false

  if length dirs = 1
  [ set heading item 0 dirs ]
  if length dirs = 2
  [ ifelse see-pacman item 0 dirs
    [ set pacman-dir item 0 dirs ]
    [ ifelse see-pacman item 1 dirs
      [ set pacman-dir item 1 dirs ]
      [ set heading one-of new-dirs ]
    ]
  ]
  if length dirs = 3
  [ ifelse see-pacman item 0 dirs
    [ set pacman-dir item 0 dirs ]
    [ ifelse see-pacman item 1 dirs
      [ set pacman-dir item 1 dirs ]
      [ ifelse see-pacman item 2 dirs
        [ set pacman-dir item 2 dirs ]
        [ set heading one-of new-dirs ]
      ]
    ]
  ]
  if length dirs = 4
  [ ifelse see-pacman item 0 dirs
    [ set pacman-dir item 0 dirs ]
    [ ifelse see-pacman item 1 dirs
      [ set pacman-dir item 1 dirs ]
      [ ifelse see-pacman item 2 dirs
        [ set pacman-dir item 2 dirs ]
        [ ifelse see-pacman item 3 dirs
          [ set pacman-dir item 3 dirs ]
          [ set heading one-of new-dirs ]
        ]
      ]
    ]
  ]
  if pacman-dir != false
  [ ifelse scared = 0
    [ set heading pacman-dir ]
    [ set dirs remove pacman-dir dirs
      set heading one-of dirs
    ]
  ]
end

to-report clear-headings ;; ghosts procedure
  let dirs []
  if [pcolor] of patch-at 0 1 != blue
  [ set dirs lput 0 dirs ]
  if [pcolor] of patch-at 1 0 != blue
  [ set dirs lput 90 dirs ]
  if [pcolor] of patch-at 0 -1 != blue
  [ set dirs lput 180 dirs ]
  if [pcolor] of patch-at -1 0 != blue
  [ set dirs lput 270 dirs ]
  report dirs
end

to-report opposite [dir]
  ifelse dir < 180
  [ report dir + 180 ]
  [ report dir - 180 ]
end

to-report see-pacman [dir] ;; ghosts procedure
  let saw-pacman? false
  let p patch-here
  while [[pcolor] of p = black]
  [ ask p
    [ if any? pacmans-here
      [ set saw-pacman? true ]
      set p patch-at sin dir cos dir ;; next patch in direction dir
    ]
    ;; stop looking if you loop around the whole world
    if p = patch-here [ report saw-pacman? ]
  ]
  report saw-pacman?
end

to make-bonus ;; Observer Procedure
  ifelse next-bonus-in = 0
  [ set next-bonus-in 10 ]
  [ let bonus-patch one-of patches with [pellet-grid? and
                                                not any? bonuses-here and
                                                not any? pellets-here]
    if bonus-patch != nobody
    [ ask bonus-patch
      [ sprout-bonuses 1
        [ set shape ""star""
          set heading 0
          set color random 14 * 10 + 5
          set value (random 10 + 1) * 100
          set countdown random 200 + 50 ] ]
      set next-bonus-in 5 + random 10 ] ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Interface Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;

to move-up
  ask pacmans [ set new-heading 0 ]
end

to move-right
  ask pacmans [ set new-heading 90 ]
end

to move-down
  ask pacmans [ set new-heading 180 ]
end

to move-left
  ask pacmans [ set new-heading 270 ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2001 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2001).  NetLogo Pac-Man model.
; http://ccl.northwestern.edu/netlogo/models/Pac-Man.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2001 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Pac-Man
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This is the classic arcade game, Pac-Man.  The game involves navigating Pac-Man through a maze.  Your objective is that Pac-Man eat all of the pellets (white circles), while avoiding the ghosts that pursue him.

If a ghost ever catches Pac-Man then Pac-Man is defeated.  If this occurs, the level will reset, but this will happen only if Pac-Man still has some lives remaining. (The pellets already collected on the level remain collected.)

However, when Pac-Man eats a Power-Pellet (large white circle) he can turn the tide, and the ghosts will turn scared and flee from him, for with the power of the Power-Pellet, Pac-Man can eat the ghosts!  Once a ghost is eaten it will return to its base, where it is born again, immune to the Power-Pellet until Pac-Man can find a new one to consume.  Pac-Man had better do just that, because unfortunately, the power of the Power-Pellet does not last forever, and will begin to wear off over time. (You will see the ghosts start to flash back to their normal appearance during the last few seconds of the Power-Pellet's effectiveness.)

Finally, occasionally a bonus (rotating star) will appear in the maze.  This bonus gives Pac-Man extra points if he eats it, but it will disappear if Pac-Man doesn't get it within a limited amount of time.


HOW TO USE IT
-------------
Monitors
-- SCORE shows your current score.  You get points for collecting pellets, eating ghosts, and collecting bonuses.  You will get an extra life after every 35,000 points.
-- LEVEL shows your current level.  Each level has a different map, if you complete all the maps, it will loop back to the first map and continue.
-- LIVES shows how many extra lives you have remaining.  If you are defeated by a ghost when this is at 0, the game is over.

Sliders
-- DIFFICULTY controls the speed of the game.  Lower numbers make both the ghosts and Pac-Man move slowly, giving you more time to react as you play.

Buttons
-- NEW sets up a new game on level 1, with 3 lives, and a score of 0.
-- PLAY begins the game.  The game will pause after each level, so you will need to hit PLAY again after each level to continue.

Controls
-- UP, DOWN, LEFT, RIGHT control the direction Pac-Man moves.


THINGS TO NOTICE
----------------
If you go off the edge of the maze you will wrap around to the other side.

Identifying Things in the Maze:
-- Yellow Circle with a mouth:  This is Pac-Man - you.
-- White Circles:               These are Pellets - Collect all of these (including the Power-Pellets) to move on to the next level.
-- Large White Circles:         These are Power-Pellets - They allow you to eat the Ghosts for a limited ammount of time.
-- Blue Squares:                These are the walls of the maze - Neither Pac-Man nor the Ghosts can move through the walls.
-- Gray Squares:                These are the Ghost Gates - Only Ghosts can move through them, and if they do so after having been eaten they will be healed.
-- Rotating Colored Stars:      These are Bonus Stars - They give you extra points when you eat them.
-- Colorful Ghost with Eyes:    These are the active Ghosts - Watch out for them!
-- Blue Ghost Shape:            These are the scared Ghosts - Eat them for Extra Points!
-- Two Small Eyes:              These are the Ghosts after they've been eaten - They will not affect you, and you can't eat them again, so just ignore them, but try not to be near its base when it gets back there.

Scoring System
-- Eat a Pellet:       100 Points
-- Eat a Power-Pellet: 500 Points
-- Eat a Scared Ghost: 500 Points
-- Eat a Bonus Star:   100-1000 Points (varies)


THINGS TO TRY
-------------
Beat your Highest Score.

Can you write an automated program for Pac-Man that will get him safely through the maze and collect all the pellets?


EXTENDING THE MODEL
-------------------
Think of other power-ups or bonuses that might be fun to have and make them appear randomly in the maze.

Add new enemies that behave differently from the ghosts.


NETLOGO FEATURES
-----------------
This model makes use of breeds, create-<breed>, every, and user-message.

The ""import-world"" command is used to read in the different maze configurations (levels).


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (2001).  NetLogo Pac-Man model.  http://ccl.northwestern.edu/netlogo/models/Pac-Man.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2001 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Pac-Man for terms of use.
"
Tetris,/models/Sample Models/Games,"globals [
  score
  level
  lines
  next-shape   ;; we number the different piece shapes 0 through 6
  game-over?
]
breed [ pieces piece ]   ;; pieces fall through the air...
breed [ blocks block ]   ;; ...and when they land, they become blocks

pieces-own [
  x y      ;; these are the piece's offsets relative to turtle 0
]
blocks-own [
  line     ;; the bottom line is line 0, above it is line 1, and so on
]

;;;;;;;;;;;;;
;;; Notes ;;;
;;;;;;;;;;;;;

;  It's a little tricky to make it so that the four turtles that make
;  up each piece always move together.  There are various possible ways
;  that you could arrange this, but here's how we chose to make it work.
;  We only ever make four turtles of the ""pieces"" breed, and we reuse
;  those same four turtles to make up each successive piece that falls.
;  Since they are the first four turtles created, we know that their
;  ""who"" numbers will be 0, 1, 2, and 3.  turtle 0 is special; it's
;  the turtle around which the others rotate when the user rotates
;  the piece.  The breed variables ""x"" and ""y"" hold each turtle's
;  offsets from turtle 0.

;;;;;;;;;;;;;;;;;;;;;;;;
;;; Setup Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;
to new
  clear-all
  set-default-shape turtles ""square big""
  set score 0
  set level starting-level
  set lines 0
  set next-shape random 7
  set game-over? false
  ;; make the piece turtles first so they get who numbers of 0 through 3
  create-pieces 4
  [ set heading 180 ]
  ;; draw the board
  ask patches
  [ ifelse (pxcor = -9) or (pxcor > 3) or (pycor = min-pycor)
    [ set pcolor gray ]
    [ ;; make debris
      if ((pycor + max-pycor) <= debris-level and
          (pycor + max-pycor) > 0 and
          (random 2 = 0))
      [ sprout-blocks 1
        [ set line (pycor + max-pycor)
          set heading 180
          set color blue ]
      ]
    ]
  ]
  ;; make the ""Next Piece"" area
  ask patch 6 10 [ set plabel ""Next"" ]
  ask patches with [((pxcor > 4) and (pxcor < 9) and
                     (pycor > 5) and (pycor < 11))]
  [ set pcolor black ]
  ;; setup the new piece
  new-piece
end

;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Interface Buttons ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
to rotate-right
  if rotate-right-clear? and not game-over?
    [ ask pieces [ rotate-me-right ] ]
end

to rotate-me-right  ;; Piece Procedure
  let oldx x
  let oldy y
  set x oldy
  set y (- oldx)
  set xcor ([xcor] of turtle 0) + x
  set ycor ([ycor] of turtle 0) + y
end

to rotate-left
  if rotate-left-clear? and not game-over?
    [ ask pieces [ rotate-me-left ] ]
end

to rotate-me-left  ;; Piece Procedure
  let oldx x
  let oldy y
  set x (- oldy)
  set y oldx
  set xcor ([xcor] of turtle 0) + x
  set ycor ([ycor] of turtle 0) + y
end

to shift-right
  if (clear-at? 1 0) and not game-over?
    [ ask pieces [ set xcor xcor + 1 ] ]
end

to shift-left
  if (clear-at? -1 0) and not game-over?
    [ ask pieces [ set xcor xcor - 1 ] ]
end

to shift-down
  ifelse (clear-at? 0 -1) and not game-over?
    [ ask pieces [ fd 1 ] ]
    [ place-piece ]
end

to drop-down
  while [(clear-at? 0 -1) and not game-over?]
    [ ask pieces [ fd 1 ] display ]
  place-piece
end

;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Runtime Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;
to play
  if game-over? [ stop ]
  every (0.01 + 0.12 * (10 - level))
    [ shift-down
      check-lines ]
  display
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Overlap prevention Reporters ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to-report clear? [p]  ;; p is a patch
  if p = nobody [ report false ]
  report (not any? blocks-on p) and ([pcolor] of p != gray)
end

to-report clear-at? [xoff yoff]
  report all? pieces [clear? patch-at xoff yoff]
end

to-report rotate-left-clear?
  report all? pieces [clear? patch-at (- y) x]
end

to-report rotate-right-clear?
  report all? pieces [clear? patch-at y (- x)]
end

;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Blocks Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
to check-lines
  let n 1
  let line-count 0
  repeat (2 * max-pycor)
  [ ifelse (count blocks with [line = n] = 12)
    [ delete-line n
      set line-count line-count + 1 ]
    [ set n n + 1 ]
  ]
  score-lines line-count
  set lines lines + line-count
  if (floor (lines / 10) > level)
  [ set level floor (lines / 10) ]
end

to delete-line [n]
  ask blocks with [line = n] [ die ]
  ask blocks with [line > n]
  [ fd 1
    set line (pycor + max-pycor) ]
end

to score-lines [n]
  let bonus 0
  if n = 1 [ set bonus 50   * (level + 1) ]
  if n = 2 [ set bonus 150  * (level + 1) ]
  if n = 3 [ set bonus 350  * (level + 1) ]
  if n = 4 [ set bonus 1000 * (level + 1) ]
  if (not any? blocks) and (n > 0)
  [ set bonus bonus + 2000 * (level + 1) ]
  set score score + bonus
end

;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Pieces Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
to place-piece
  ask pieces
  [ hatch-blocks 1
    [ set line (pycor + max-pycor) ]
  ]
  set score score + 10 * (level + 1)
  new-piece
end

to new-piece
  let new-shape next-shape
  set next-shape random 7
  if (show-next?) [ show-next-piece ]
  ask turtle 0 [ setxy -3 12 ]
  ask pieces
  [ setup-piece new-shape ]
  if any? pieces with [any? other turtles-here]
  [ user-message ""Game Over""
    set game-over? true ]
end

to show-next-piece
  ask patches with [(pxcor > 4) and (pxcor < 9) and (pycor > 5) and (pycor < 11)]
  [ set pcolor black ]
  ask turtle 0 [ setxy 6 8 ]
  ask pieces
  [ setup-piece next-shape
    set pcolor color ]
end

to setup-piece [s]  ;; Piece Procedure
  if (s = 0) [ setupO  set color blue   ]
  if (s = 1) [ setupL  set color red    ]
  if (s = 2) [ setupJ  set color yellow ]
  if (s = 3) [ setupT  set color green  ]
  if (s = 4) [ setupS  set color orange ]
  if (s = 5) [ setupZ  set color sky    ]
  if (s = 6) [ setupI  set color violet ]
  setxy ([xcor] of turtle 0) + x
        ([ycor] of turtle 0) + y
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Pieces Setup Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; The numbers 0123 show the relative positions of turtles
;; 0, 1, 2, and 3 within the overall shape.

;; O-Block
;; 01
;; 23
to setupO ;;Piece Procedure
  if (who = 1) [ set x 1 set y  0 ]
  if (who = 2) [ set x 0 set y -1 ]
  if (who = 3) [ set x 1 set y -1 ]
end

;; L-Block
;; 201
;; 3
to setupL ;;Piece Procedure
  if (who = 1) [ set x  1 set y  0 ]
  if (who = 2) [ set x -1 set y  0 ]
  if (who = 3) [ set x -1 set y -1 ]
end

;; J-Block
;; 102
;;   3
to setupJ ;;Piece Procedure
  if (who = 1) [ set x -1 set y  0 ]
  if (who = 2) [ set x  1 set y  0 ]
  if (who = 3) [ set x  1 set y -1 ]
end

;; T-Block
;; 201
;;  3
to setupT ;;Piece Procedure
  if (who = 1) [ set x  1 set y  0 ]
  if (who = 2) [ set x -1 set y  0 ]
  if (who = 3) [ set x  0 set y -1 ]
end

;; S-Block
;;  01
;; 23
to setupS ;;Piece Procedure
  if (who = 1) [ set x  1 set y  0 ]
  if (who = 2) [ set x -1 set y -1 ]
  if (who = 3) [ set x  0 set y -1 ]
end

;; Z-block
;; 10
;;  32
to setupZ ;;Piece Procedure
  if (who = 1) [ set x -1 set y  0 ]
  if (who = 2) [ set x  1 set y -1 ]
  if (who = 3) [ set x  0 set y -1 ]
end

;; I-Block
;; 1023
to setupI ;;Piece Procedure
  if (who = 1) [ set x -1 set y 0 ]
  if (who = 2) [ set x  1 set y 0 ]
  if (who = 3) [ set x  2 set y 0 ]
end


; *** NetLogo 4.0beta7 Model Copyright Notice ***
;
; This model was created as part of the projects:
; PARTICIPATORY SIMULATIONS: NETWORK-BASED DESIGN FOR SYSTEMS LEARNING IN
; CLASSROOMS and/or INTEGRATED SIMULATION AND MODELING ENVIRONMENT.
; The project gratefully acknowledges the support of the
; National Science Foundation (REPP & ROLE programs) --
; grant numbers REC #9814682 and REC-0126227.
;
; Copyright 2001 by Uri Wilensky.  All rights reserved.
;
; Permission to use, modify or redistribute this model is hereby granted,
; provided that both of the following requirements are followed:
; a) this copyright notice is included.
; b) this model will not be redistributed for profit without permission
;    from Uri Wilensky.
; Contact Uri Wilensky for appropriate licenses for redistribution for
; profit.
;
; To refer to this model in academic publications, please use:
; Wilensky, U. (2001).  NetLogo Tetris model.
; http://ccl.northwestern.edu/netlogo/models/Tetris.
; Center for Connected Learning and Computer-Based Modeling,
; Northwestern University, Evanston, IL.
;
; In other publications, please use:
; Copyright 2001 Uri Wilensky.  All rights reserved.
; See http://ccl.northwestern.edu/netlogo/models/Tetris
; for terms of use.
;
; *** End of NetLogo 4.0beta7 Model Copyright Notice ***
","WHAT IS IT?
-----------
This is the classic puzzle game, Tetris.  The game involves falling pieces composed of four blocks in different configurations.  The object of the game is to complete horizontal rows of blocks in the well.

Any time a row is completed it disappears and the blocks above it fall down.  The more rows you clear with the placement of a single piece, the more points you receive.  If you clear enough rows, you move on to the next level.  The higher the level, the more points you receive for everything, but the pieces fall faster as well, increasing the challenge.


HOW TO USE IT
-------------
Monitors:
-- SCORE shows your current score.
-- LINES shows the number of lines you have cleared.
-- LEVEL shows your current level.

Sliders:
-- STARTING-LEVEL selects the beginning level for the game.  Choosing a higher level to begin allows you to get more points faster and increase the initial falling speed.  Your level will not increase until your number of lines is 10*(level+1). (i.e. starting-level=3, level will stay 3 until 40 lines are cleared.)
-- DEBRIS-LEVEL sets how many lines of random blocks will be created at the bottom of the well at the beginning of the game.

Buttons:
-- NEW sets up a new game with the initial settings.
-- PLAY begins the game.

Controls:
-- ROTLEFT rotates the current piece 90 degrees to the left.
-- ROTRIGHT rotates the current piece 90 degrees the right.
-- LEFT moves the current piece one space left.
-- DROP causes the current piece to drop to the bottom of the well immediately.
-- RIGHT moves the current piece one space right.
-- DOWN moves the current piece one space down.

Options (Switches)
-- SHOW-NEXT-PIECE? toggles the option which causes the piece which will appear in the well after you place the current one to be shown in a small box to the right of the well.


THINGS TO NOTICE
----------------
There are seven types of pieces.  These are all the shapes that can be made by four blocks stuck together.

|   [][]      Square-Block - good filler in flat areas,
|   [][]         hard to place in jagged areas
|
|   [][][]    L-Block - fits well into deep holes
|   []
|
|     [][]    S-Block - good filler in jagged areas,
|   [][]         hard to place in flat areas
|
|   [][][]    T-Block - good average piece, can fit
|     []         almost anywhere well
|
|   [][]      Reverse S-Block (Or Z-Block) - good
|     [][]       filler in jagged areas, hard to
|                place in flat areas
|
|   [][][]    Reverse L-Block - fits well into
|       []       deep holes
|
|   [][][][]  I-Bar - Only piece that allows you to
|                clear 4 lines at once (aka a Tetris)

Scoring System:
Note: Points are scored using level + 1 so that points are still scored at level 0.
-- 1 Line  = 50*(level + 1) points
-- 2 Lines = 150*(level + 1) points
-- 3 Lines = 350*(level + 1) points
-- 4 Lines = 1000*(level + 1) points (aka a Tetris)
-- Clear the board = 2000*(level + 1)
-- Every piece = 10*(level + 1) points


THINGS TO TRY
-------------
Beat your highest score.


EXTENDING THE MODEL
-------------------
Add options for changing the width and depth of the well.

Add the option of including pieces composed of more than four blocks, or fewer.


NETLOGO FEATURES
----------------
This model makes use of turtle breeds.


CREDITS AND REFERENCES
----------------------
To refer to this model in academic publications, please use:  Wilensky, U. (2001).  NetLogo Tetris model.  http://ccl.northwestern.edu/netlogo/models/Tetris.  Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.

In other publications, please use:  Copyright 2001 Uri Wilensky.  All rights reserved.  See http://ccl.northwestern.edu/netlogo/models/Tetris for terms of use.
"
